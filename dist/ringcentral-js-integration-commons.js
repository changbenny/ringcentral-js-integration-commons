(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RcPhone"] = factory();
	else
		root["RcPhone"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _slicedToArray2 = __webpack_require__(45);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _addModule = __webpack_require__(119);
	
	var _addModule2 = _interopRequireDefault(_addModule);
	
	var _ringcentral = __webpack_require__(120);
	
	var _ringcentral2 = _interopRequireDefault(_ringcentral);
	
	var _ringcentralClient = __webpack_require__(132);
	
	var _ringcentralClient2 = _interopRequireDefault(_ringcentralClient);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _settings = __webpack_require__(152);
	
	var _settings2 = _interopRequireDefault(_settings);
	
	var _brand = __webpack_require__(166);
	
	var _brand2 = _interopRequireDefault(_brand);
	
	var _auth = __webpack_require__(169);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _subscription = __webpack_require__(192);
	
	var _subscription2 = _interopRequireDefault(_subscription);
	
	var _user = __webpack_require__(199);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _webphone = __webpack_require__(203);
	
	var _webphone2 = _interopRequireDefault(_webphone);
	
	var _redux = __webpack_require__(153);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var REDUCER = (0, _symbol2.default)();
	
	function getStoreRegisterAndResolver() {
	  var handlers = new _set2.default();
	  return [function (fn) {
	    return handlers.add(fn);
	  }, function (store) {
	    return handlers.forEach(function (fn) {
	      return fn(store);
	    });
	  }];
	}
	
	var RcPhone = function (_RcModule) {
	  (0, _inherits3.default)(RcPhone, _RcModule);
	
	  function RcPhone(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var getStore = _ref.getStore;
	    var _stateMapper = _ref.stateMapper;
	    var _ref$prefix = _ref.prefix;
	    var prefix = _ref$prefix === undefined ? 'rc' : _ref$prefix;
	    var sdkSettings = _ref.sdkSettings;
	    var defaultBrand = _ref.defaultBrand;
	    (0, _classCallCheck3.default)(this, RcPhone);
	
	    var register = registerStoreHandler;
	    var resolve = void 0;
	    if (!register) {
	      var _getStoreRegisterAndR = getStoreRegisterAndResolver();
	
	      var _getStoreRegisterAndR2 = (0, _slicedToArray3.default)(_getStoreRegisterAndR, 2);
	
	      register = _getStoreRegisterAndR2[0];
	      resolve = _getStoreRegisterAndR2[1];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RcPhone).call(this, {
	      registerStoreHandler: register,
	      stateMapper: _stateMapper
	    }));
	
	    _addModule2.default.call(_this, 'sdk', new _ringcentral2.default((0, _extends3.default)({
	
	      cachePrefix: prefix + '-'
	    }, sdkSettings)));
	
	    _addModule2.default.call(_this, 'platform', _this.sdk.platform());
	
	    _addModule2.default.call(_this, 'api', new _ringcentralClient2.default(_this.sdk));
	
	    _addModule2.default.call(_this, 'auth', new _auth2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).auth;
	      },
	      prefix: prefix,
	      platform: _this.platform
	    }));
	
	    _addModule2.default.call(_this, 'settings', new _settings2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).settings;
	      }
	    }));
	
	    _addModule2.default.call(_this, 'defaultBrand', new _brand2.default((0, _extends3.default)({
	      registerStoreHandler: register,
	      prefix: prefix + '-default',
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).defaultBrand;
	      }
	    }, defaultBrand)));
	
	    _addModule2.default.call(_this, 'subscription', new _subscription2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).subscription;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      sdk: _this.sdk,
	      auth: _this.auth
	    }));
	
	    _addModule2.default.call(_this, 'user', new _user2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).user;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    _addModule2.default.call(_this, 'webphone', new _webphone2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).webphone;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings,
	      auth: _this.auth
	    }));
	
	    // combine reducers
	    _this[REDUCER] = (0, _redux.combineReducers)({
	      auth: _this.auth.reducer,
	      defaultBrand: _this.defaultBrand.reducer,
	      subscription: _this.subscription.reducer,
	      user: _this.user.reducer,
	      webphone: _this.webphone.reducer,
	      settings: _this.settings.reducer
	    });
	
	    if (resolve) {
	      resolve(getStore(_this.reducer));
	      // resolve(createStore(this.reducer));
	    }
	    return _this;
	  }
	
	  (0, _createClass3.default)(RcPhone, [{
	    key: 'reducer',
	    get: function get() {
	      return this[REDUCER];
	    }
	  }]);
	  return RcPhone;
	}(_rcModule2.default);
	
	exports.default = RcPhone;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(4), __esModule: true };

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = __webpack_require__(8).Object.assign;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(21)});

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , core      = __webpack_require__(8)
	  , ctx       = __webpack_require__(9)
	  , hide      = __webpack_require__(11)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 7 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(10);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12)
	  , createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(16) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , toPrimitive    = __webpack_require__(19)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function(){
	  return Object.defineProperty(__webpack_require__(18)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(17)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , document = __webpack_require__(7).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(22)
	  , gOPS     = __webpack_require__(37)
	  , pIE      = __webpack_require__(38)
	  , toObject = __webpack_require__(39)
	  , IObject  = __webpack_require__(26)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(17)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(23)
	  , enumBugKeys = __webpack_require__(36);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(24)
	  , toIObject    = __webpack_require__(25)
	  , arrayIndexOf = __webpack_require__(29)(false)
	  , IE_PROTO     = __webpack_require__(33)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(26)
	  , defined = __webpack_require__(28);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(27);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(25)
	  , toLength  = __webpack_require__(30)
	  , toIndex   = __webpack_require__(32);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(31)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(34)('keys')
	  , uid    = __webpack_require__(35);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 37 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(28);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(41), __esModule: true };

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	module.exports = __webpack_require__(8).Object.getPrototypeOf;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(39)
	  , $getPrototypeOf = __webpack_require__(43);
	
	__webpack_require__(44)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(24)
	  , toObject    = __webpack_require__(39)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(6)
	  , core    = __webpack_require__(8)
	  , fails   = __webpack_require__(17);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(46);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(47), __esModule: true };

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(64);

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	var global        = __webpack_require__(7)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(52)
	  , TO_STRING_TAG = __webpack_require__(61)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(50)
	  , step             = __webpack_require__(51)
	  , Iterators        = __webpack_require__(52)
	  , toIObject        = __webpack_require__(25);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(53)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(54)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(24)
	  , Iterators      = __webpack_require__(52)
	  , $iterCreate    = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(60)
	  , getPrototypeOf = __webpack_require__(43)
	  , ITERATOR       = __webpack_require__(61)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(57)
	  , descriptor     = __webpack_require__(20)
	  , setToStringTag = __webpack_require__(60)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(61)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(58)
	  , enumBugKeys = __webpack_require__(36)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(18)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(59).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(12)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(22);
	
	module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(7).document && document.documentElement;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f
	  , has = __webpack_require__(24)
	  , TAG = __webpack_require__(61)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(34)('wks')
	  , uid        = __webpack_require__(35)
	  , Symbol     = __webpack_require__(7).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(63)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(53)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , defined   = __webpack_require__(28);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(27)
	  , TAG = __webpack_require__(61)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(67), __esModule: true };

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(68);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13)
	  , get      = __webpack_require__(69);
	module.exports = __webpack_require__(8).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(73), __esModule: true };

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74);
	var $Object = __webpack_require__(8).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(16), 'Object', {defineProperty: __webpack_require__(12).f});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(77);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(48);
	module.exports = __webpack_require__(79).f('iterator');

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(61);

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(81), __esModule: true };

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(82);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	module.exports = __webpack_require__(8).Symbol;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(7)
	  , has            = __webpack_require__(24)
	  , DESCRIPTORS    = __webpack_require__(16)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , META           = __webpack_require__(83).KEY
	  , $fails         = __webpack_require__(17)
	  , shared         = __webpack_require__(34)
	  , setToStringTag = __webpack_require__(60)
	  , uid            = __webpack_require__(35)
	  , wks            = __webpack_require__(61)
	  , wksExt         = __webpack_require__(79)
	  , wksDefine      = __webpack_require__(84)
	  , keyOf          = __webpack_require__(85)
	  , enumKeys       = __webpack_require__(86)
	  , isArray        = __webpack_require__(87)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , createDesc     = __webpack_require__(20)
	  , _create        = __webpack_require__(57)
	  , gOPNExt        = __webpack_require__(88)
	  , $GOPD          = __webpack_require__(90)
	  , $DP            = __webpack_require__(12)
	  , $keys          = __webpack_require__(22)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(89).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(38).f  = $propertyIsEnumerable;
	  __webpack_require__(37).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(54)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(35)('meta')
	  , isObject = __webpack_require__(14)
	  , has      = __webpack_require__(24)
	  , setDesc  = __webpack_require__(12).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(17)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(7)
	  , core           = __webpack_require__(8)
	  , LIBRARY        = __webpack_require__(54)
	  , wksExt         = __webpack_require__(79)
	  , defineProperty = __webpack_require__(12).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(22)
	  , toIObject = __webpack_require__(25);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(22)
	  , gOPS    = __webpack_require__(37)
	  , pIE     = __webpack_require__(38);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(27);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(25)
	  , gOPN      = __webpack_require__(89).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(23)
	  , hiddenKeys = __webpack_require__(36).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(38)
	  , createDesc     = __webpack_require__(20)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , has            = __webpack_require__(24)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 91 */
/***/ function(module, exports) {



/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('asyncIterator');

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('observable');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(95);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(99);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	module.exports = __webpack_require__(8).Object.setPrototypeOf;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(98).set});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(9)(Function.call, __webpack_require__(90).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(101);
	var $Object = __webpack_require__(8).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(57)});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(104);
	__webpack_require__(116);
	module.exports = __webpack_require__(8).Set;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(105);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(112)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(12).f
	  , create      = __webpack_require__(57)
	  , hide        = __webpack_require__(11)
	  , redefineAll = __webpack_require__(106)
	  , ctx         = __webpack_require__(9)
	  , anInstance  = __webpack_require__(107)
	  , defined     = __webpack_require__(28)
	  , forOf       = __webpack_require__(108)
	  , $iterDefine = __webpack_require__(53)
	  , step        = __webpack_require__(51)
	  , setSpecies  = __webpack_require__(111)
	  , DESCRIPTORS = __webpack_require__(16)
	  , fastKey     = __webpack_require__(83).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(9)
	  , call        = __webpack_require__(109)
	  , isArrayIter = __webpack_require__(110)
	  , anObject    = __webpack_require__(13)
	  , toLength    = __webpack_require__(30)
	  , getIterFn   = __webpack_require__(69)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(52)
	  , ITERATOR   = __webpack_require__(61)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(7)
	  , core        = __webpack_require__(8)
	  , dP          = __webpack_require__(12)
	  , DESCRIPTORS = __webpack_require__(16)
	  , SPECIES     = __webpack_require__(61)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(7)
	  , $export        = __webpack_require__(6)
	  , meta           = __webpack_require__(83)
	  , fails          = __webpack_require__(17)
	  , hide           = __webpack_require__(11)
	  , redefineAll    = __webpack_require__(106)
	  , forOf          = __webpack_require__(108)
	  , anInstance     = __webpack_require__(107)
	  , isObject       = __webpack_require__(14)
	  , setToStringTag = __webpack_require__(60)
	  , dP             = __webpack_require__(12).f
	  , each           = __webpack_require__(113)(0)
	  , DESCRIPTORS    = __webpack_require__(16);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(9)
	  , IObject  = __webpack_require__(26)
	  , toObject = __webpack_require__(39)
	  , toLength = __webpack_require__(30)
	  , asc      = __webpack_require__(114);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(115);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , isArray  = __webpack_require__(87)
	  , SPECIES  = __webpack_require__(61)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(117)('Set')});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(65)
	  , from    = __webpack_require__(118);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(108);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	exports.default = addModule;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function addModule(name, module) {
	  if (Object.prototype.hasOwnProperty.call(this, name)) {
	    throw new Error("module '" + name + "' already exists...");
	  }
	
	  (0, _defineProperty2.default)(this, name, {
	    get: function get() {
	      return module;
	    },
	
	    enumerable: true
	  });
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(126), __webpack_require__(130), __webpack_require__(131));
		else if(typeof define === 'function' && define.amd)
			define([, , "pubnub"], factory);
		else if(typeof exports === 'object')
			exports["SDK"] = factory(require("es6-promise"), require("node-fetch"), require("pubnub"));
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["SDK"] = factory(root[undefined], root[undefined], root[undefined]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/build/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	__webpack_require__(2);
	
	var _Utils = __webpack_require__(3);
	
	var Utils = _interopRequireWildcard(_Utils);
	
	var _Cache = __webpack_require__(8);
	
	var _Cache2 = _interopRequireDefault(_Cache);
	
	var _Externals = __webpack_require__(4);
	
	var Externals = _interopRequireWildcard(_Externals);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _ClientMock = __webpack_require__(12);
	
	var _ClientMock2 = _interopRequireDefault(_ClientMock);
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Platform = __webpack_require__(15);
	
	var _Platform2 = _interopRequireDefault(_Platform);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _PubnubFactory = __webpack_require__(17);
	
	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);
	
	var _Subscription = __webpack_require__(19);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _CachedSubscription = __webpack_require__(20);
	
	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SDK = function () {
	
	    /**
	     * @namespace RingCentral
	     * @constructor
	     * @param {object} [options]
	     * @param {string} [options.server]
	     * @param {string} [options.cachePrefix]
	     * @param {string} [options.appSecret]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.pubnubFactory]
	     * @param {string} [options.client]
	     */
	
	    function SDK(options) {
	        _classCallCheck(this, SDK);
	
	        options = options || {};
	
	        if (!Externals.fetch) {
	            throw new Error('Native Fetch is missing, set RingCentral.SDK.core.Externals.fetch to your favorite alternative');
	        }
	
	        if (!Externals.Promise) {
	            throw new Error('Native Promise is missing, set RingCentral.SDK.core.Externals.Promise to your favorite alternative');
	        }
	
	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);
	
	        this._client = options.client || new _Client2.default();
	
	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);
	
	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;
	    }
	
	    /**
	     * @return {Platform}
	     */
	
	
	    SDK.prototype.platform = function platform() {
	        return this._platform;
	    };
	
	    /**
	     * @return {Subscription}
	     */
	
	
	    SDK.prototype.createSubscription = function createSubscription() {
	        return new _Subscription2.default(this._pubnubFactory, this._platform);
	    };
	
	    /**
	     * @return {CachedSubscription}
	     */
	
	
	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {
	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);
	    };
	
	    /**
	     * @return {Cache}
	     */
	
	
	    SDK.prototype.cache = function cache() {
	        return this._cache;
	    };
	
	    SDK.handleLoginRedirect = function handleLoginRedirect(origin) {
	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);
	    };
	
	    return SDK;
	}();
	
	SDK.version =  true ? ("3.0.0-rc1") : 'x.x.x';
	SDK.server = {
	    sandbox: 'https://platform.devtest.ringcentral.com',
	    production: 'https://platform.ringcentral.com'
	};
	SDK.core = {
	    Cache: _Cache2.default,
	    EventEmitter: _events2.default,
	    Utils: Utils,
	    Externals: Externals
	};
	SDK.http = {
	    Client: _Client2.default,
	    ApiResponse: _ApiResponse2.default
	};
	SDK.platform = {
	    Auth: _Auth2.default,
	    Platform: _Platform2.default
	};
	SDK.subscription = {
	    Subscription: _Subscription2.default
	};
	SDK.mocks = {
	    Client: _ClientMock2.default,
	    Registry: _Registry2.default,
	    Mock: _Mock2.default
	};
	SDK.pubnub = {
	    PubnubMockFactory: _PubnubFactory2.default
	};
	
	
	module.exports = SDK;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.queryStringify = queryStringify;
	exports.parseQueryString = parseQueryString;
	exports.isFunction = isFunction;
	exports.isArray = isArray;
	exports.isObject = isObject;
	exports.isObjectObject = isObjectObject;
	exports.isPlainObject = isPlainObject;
	exports.isNodeJS = isNodeJS;
	exports.isBrowser = isBrowser;
	exports.delay = delay;
	
	var _Externals = __webpack_require__(4);
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {object} parameters
	 * @returns {string}
	 */
	function queryStringify(parameters) {
	
	    var array = [];
	
	    parameters = parameters || {};
	
	    Object.keys(parameters).forEach(function (k) {
	
	        var v = parameters[k];
	
	        if (isArray(v)) {
	            v.forEach(function (vv) {
	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));
	            });
	        } else {
	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
	        }
	    });
	
	    return array.join('&');
	}
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {string} queryString
	 * @returns {object}
	 */
	function parseQueryString(queryString) {
	
	    var argsParsed = {};
	
	    queryString.split('&').forEach(function (arg) {
	
	        arg = decodeURIComponent(arg);
	
	        if (arg.indexOf('=') == -1) {
	
	            argsParsed[arg.trim()] = true;
	        } else {
	
	            var pair = arg.split('='),
	                key = pair[0].trim(),
	                value = pair[1].trim();
	
	            if (key in argsParsed) {
	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];
	                argsParsed[key].push(value);
	            } else {
	                argsParsed[key] = value;
	            }
	        }
	    });
	
	    return argsParsed;
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isFunction(obj) {
	    return typeof obj === "function";
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isArray(obj) {
	    return Array.isArray ? Array.isArray(obj) : typeof obj === "array";
	}
	
	function isObject(o) {
	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);
	}
	
	function isObjectObject(o) {
	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
	}
	
	function isPlainObject(o) {
	    var ctor, prot;
	
	    if (isObjectObject(o) === false) return false;
	
	    // If has modified constructor
	    ctor = o.constructor;
	    if (typeof ctor !== 'function') return false;
	
	    // If has modified prototype
	    prot = ctor.prototype;
	    if (isObjectObject(prot) === false) return false;
	
	    // If constructor does not have an Object-specific method
	    if (prot.hasOwnProperty('isPrototypeOf') === false) {
	        return false;
	    }
	
	    // Most likely a plain Object
	    return true;
	}
	
	function isNodeJS() {
	    return typeof process !== 'undefined';
	}
	
	function isBrowser() {
	    return typeof window !== 'undefined';
	}
	
	function delay(timeout) {
	    return new _Externals.Promise(function (resolve, reject) {
	        setTimeout(function () {
	            resolve(null);
	        }, timeout);
	    });
	}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	exports.__esModule = true;
	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;
	
	var _es6Promise = __webpack_require__(5);
	
	var _es6Promise2 = _interopRequireDefault(_es6Promise);
	
	var _nodeFetch = __webpack_require__(6);
	
	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);
	
	var _pubnub = __webpack_require__(7);
	
	var _pubnub2 = _interopRequireDefault(_pubnub);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var root = typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function("return this;")();
	
	var Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;
	
	var fetch = _nodeFetch2.default && typeof _nodeFetch2.default == 'function' ? _nodeFetch2.default : root.fetch;
	var Request = fetch.Request || root.Request;
	var Response = fetch.Response || root.Response;
	var Headers = fetch.Headers || root.Headers;
	
	var PUBNUB = _pubnub2.default || root.PUBNUB;
	
	var localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};
	
	exports.Promise = Promise;
	exports.fetch = fetch;
	exports.Request = Request;
	exports.Response = Response;
	exports.Headers = Headers;
	exports.PUBNUB = PUBNUB;
	exports.localStorage = localStorage;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Cache = function () {
	    function Cache(storage, prefix) {
	        _classCallCheck(this, Cache);
	
	        this.setPrefix(prefix);
	        this._storage = storage;
	    }
	
	    Cache.prototype.setPrefix = function setPrefix(prefix) {
	        this._prefix = prefix || Cache.defaultPrefix;
	        return this;
	    };
	
	    Cache.prototype.setItem = function setItem(key, data) {
	        this._storage[this._prefixKey(key)] = JSON.stringify(data);
	        return this;
	    };
	
	    Cache.prototype.removeItem = function removeItem(key) {
	        delete this._storage[this._prefixKey(key)];
	        return this;
	    };
	
	    Cache.prototype.getItem = function getItem(key) {
	        var item = this._storage[this._prefixKey(key)];
	        if (!item) return null;
	        return JSON.parse(item);
	    };
	
	    Cache.prototype.clean = function clean() {
	
	        for (var key in this._storage) {
	
	            if (!this._storage.hasOwnProperty(key)) continue;
	
	            if (key.indexOf(this._prefix) === 0) {
	                delete this._storage[key];
	            }
	        }
	
	        return this;
	    };
	
	    Cache.prototype._prefixKey = function _prefixKey(key) {
	        return this._prefix + key;
	    };
	
	    return Cache;
	}();
	
	Cache.defaultPrefix = 'rc-';
	exports.default = Cache;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	exports.findHeaderName = findHeaderName;
	
	var _Externals = __webpack_require__(4);
	
	var _Utils = __webpack_require__(3);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_EventEmitter) {
	    _inherits(Client, _EventEmitter);
	
	    function Client() {
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Client);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _EventEmitter.call.apply(_EventEmitter, [this].concat(args))), _this), _this.events = {
	            beforeRequest: 'beforeRequest',
	            requestSuccess: 'requestSuccess',
	            requestError: 'requestError'
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    /**
	     * @param {Request} request
	     * @return {Promise<ApiResponse>}
	     */
	
	    Client.prototype.sendRequest = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var apiResponse;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            apiResponse = new _ApiResponse2.default(request);
	                            _context.prev = 1;
	
	
	                            //TODO Stop request if listeners return false
	                            this.emit(this.events.beforeRequest, apiResponse);
	
	                            _context.next = 5;
	                            return this._loadResponse(request);
	
	                        case 5:
	                            apiResponse._response = _context.sent;
	                            _context.next = 8;
	                            return apiResponse._init();
	
	                        case 8:
	                            if (apiResponse.ok()) {
	                                _context.next = 10;
	                                break;
	                            }
	
	                            throw new Error('Response has unsuccessful status');
	
	                        case 10:
	
	                            this.emit(this.events.requestSuccess, apiResponse);
	
	                            return _context.abrupt("return", apiResponse);
	
	                        case 14:
	                            _context.prev = 14;
	                            _context.t0 = _context["catch"](1);
	
	
	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);
	
	                            this.emit(this.events.requestError, _context.t0);
	
	                            throw _context.t0;
	
	                        case 19:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[1, 14]]);
	        }));
	
	        function sendRequest(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @return {Promise<Response>}
	     * @private
	     */
	
	
	    Client.prototype._loadResponse = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return _Externals.fetch.call(null, request);
	
	                        case 2:
	                            return _context2.abrupt("return", _context2.sent);
	
	                        case 3:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this);
	        }));
	
	        function _loadResponse(_x2) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    /**
	     * Wraps the JS Error object with transaction information
	     * @param {Error|IApiError} e
	     * @param {ApiResponse} apiResponse
	     * @return {IApiError}
	     */
	
	
	    Client.prototype.makeError = function makeError(e, apiResponse) {
	
	        // Wrap only if regular error
	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {
	
	            e.apiResponse = apiResponse;
	            e.originalMessage = e.message;
	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;
	        }
	
	        return e;
	    };
	
	    /**
	     *
	     * @param {object} init
	     * @param {object} [init.url]
	     * @param {object} [init.body]
	     * @param {string} [init.method]
	     * @param {object} [init.query]
	     * @param {object} [init.headers]
	     * @return {Request}
	     */
	
	
	    Client.prototype.createRequest = function createRequest(init) {
	
	        init = init || {};
	        init.headers = init.headers || {};
	
	        // Sanity checks
	        if (!init.url) throw new Error('Url is not defined');
	        if (!init.method) init.method = 'GET';
	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {
	            throw new Error('Method has wrong value: ' + init.method);
	        }
	
	        // Defaults
	        init.credentials = init.credentials || 'include';
	        init.mode = init.mode || 'cors';
	
	        // Append Query String
	        if (init.query) {
	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);
	        }
	
	        if (!findHeaderName('Accept', init.headers)) {
	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;
	        }
	
	        // Serialize body
	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {
	
	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);
	
	            if (!contentTypeHeaderName) {
	                contentTypeHeaderName = _ApiResponse2.default._contentType;
	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;
	            }
	
	            var contentType = init.headers[contentTypeHeaderName];
	
	            // Assign a new encoded body
	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {
	                init.body = JSON.stringify(init.body);
	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {
	                init.body = (0, _Utils.queryStringify)(init.body);
	            }
	        }
	
	        // Create a request with encoded body
	        var req = new _Externals.Request(init.url, init);
	
	        // Keep the original body accessible directly (for mocks)
	        req.originalBody = init.body;
	
	        return req;
	    };
	
	    return Client;
	}(_events2.default);
	
	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];
	exports.default = Client;
	function findHeaderName(name, headers) {
	    name = name.toLowerCase();
	    return Object.keys(headers).reduce(function (res, key) {
	        if (res) return res;
	        if (name == key.toLowerCase()) return key;
	        return res;
	    }, null);
	}
	
	/**
	 * @name IApiError
	 * @property {string} stack
	 * @property {string} originalMessage
	 * @property {ApiResponse} apiResponse
	 */
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ApiResponse = function () {
	
	    /**
	     * @param {Request} request
	     * @param {Response} response
	     * @param {string} responseText
	     */
	
	    function ApiResponse(request, response, responseText) {
	        _classCallCheck(this, ApiResponse);
	
	        /** @type {Request} */
	        this._request = request;
	
	        /** @type {Response} */
	        this._response = response;
	
	        this._text = responseText;
	        this._json = null;
	        this._multipart = [];
	    }
	
	    ApiResponse.prototype._init = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(this._isMultipart() || this._isJson())) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.response().text();
	
	                        case 3:
	                            this._text = _context.sent;
	
	                        case 4:
	                            return _context.abrupt('return', this);
	
	                        case 5:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _init() {
	            return _ref.apply(this, arguments);
	        }
	
	        return _init;
	    }();
	
	    /**
	     * @return {Response}
	     */
	
	
	    ApiResponse.prototype.response = function response() {
	        return this._response;
	    };
	
	    /**
	     * @return {Request}
	     */
	
	
	    ApiResponse.prototype.request = function request() {
	        return this._request;
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    ApiResponse.prototype.ok = function ok() {
	        return this._response && this._response.ok;
	    };
	
	    /**
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.text = function text() {
	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');
	        return this._text;
	    };
	
	    /**
	     * @return {object}
	     */
	
	
	    ApiResponse.prototype.json = function json() {
	        if (!this._isJson()) throw new Error('Response is not JSON');
	        if (!this._json) {
	            this._json = this._text ? JSON.parse(this._text) : null;
	        }
	        return this._json;
	    };
	
	    /**
	     * @param [skipOKCheck]
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.error = function error(skipOKCheck) {
	
	        if (this.ok() && !skipOKCheck) return null;
	
	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');
	
	        try {
	
	            if (this.json().message) message = this.json().message;
	            if (this.json().error_description) message = this.json().error_description;
	            if (this.json().description) message = this.json().description;
	        } catch (e) {}
	
	        return message;
	    };
	
	    /**
	     * @return {ApiResponse[]}
	     */
	
	
	    ApiResponse.prototype.multipart = function multipart() {
	
	        if (!this._isMultipart()) throw new Error('Response is not multipart');
	
	        if (!this._multipart.length) {
	
	            // Step 1. Split multipart response
	
	            var text = this.text();
	
	            if (!text) throw new Error('No response body');
	
	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];
	
	            if (!boundary) throw new Error('Cannot find boundary');
	
	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);
	
	            if (parts[0].trim() === '') parts.shift();
	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();
	
	            if (parts.length < 1) throw new Error('No parts in body');
	
	            // Step 2. Parse status info
	
	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();
	
	            // Step 3. Parse all other parts
	
	            this._multipart = parts.map(function (part, i) {
	
	                var status = statusInfo.response[i].status;
	
	                return ApiResponse.create(part, status);
	            });
	        }
	
	        return this._multipart;
	    };
	
	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {
	        return this._getContentType().indexOf(contentType) > -1;
	    };
	
	    ApiResponse.prototype._getContentType = function _getContentType() {
	        return this._response.headers.get(ApiResponse._contentType) || '';
	    };
	
	    ApiResponse.prototype._isMultipart = function _isMultipart() {
	        return this._isContentType(ApiResponse._multipartContentType);
	    };
	
	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {
	        return this._isContentType(ApiResponse._urlencodedContentType);
	    };
	
	    ApiResponse.prototype._isJson = function _isJson() {
	        return this._isContentType(ApiResponse._jsonContentType);
	    };
	
	    /**
	     * Method is used to create ApiResponse object from string parts of multipart/mixed response
	     * @param {string} [text]
	     * @param {number} [status]
	     * @param {string} [statusText]
	     * @return {ApiResponse}
	     */
	
	
	    ApiResponse.create = function create(text, status, statusText) {
	
	        text = text || '';
	        status = status || 200;
	        statusText = statusText || 'OK';
	
	        text = text.replace(/\r/g, '');
	
	        var headers = new _Externals.Headers(),
	            headersAndBody = text.split(ApiResponse._bodySeparator),
	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';
	
	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;
	
	        (headersText || '').split('\n').forEach(function (header) {
	
	            var split = header.trim().split(ApiResponse._headerSeparator),
	                key = split.shift().trim(),
	                value = split.join(ApiResponse._headerSeparator).trim();
	
	            if (key) headers.append(key, value);
	        });
	
	        return new ApiResponse(null, new _Externals.Response(text ? text : undefined, {
	            headers: headers,
	            status: status,
	            statusText: statusText
	        }), text);
	    };
	
	    return ApiResponse;
	}();
	
	ApiResponse._contentType = 'Content-Type';
	ApiResponse._jsonContentType = 'application/json';
	ApiResponse._multipartContentType = 'multipart/mixed';
	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';
	ApiResponse._headerSeparator = ':';
	ApiResponse._bodySeparator = '\n\n';
	ApiResponse._boundarySeparator = '--';
	exports.default = ApiResponse;
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_HttpClient) {
	    _inherits(Client, _HttpClient);
	
	    function Client() {
	        _classCallCheck(this, Client);
	
	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));
	
	        _this._registry = new _Registry2.default();
	        return _this;
	    }
	
	    Client.prototype.registry = function registry() {
	        return this._registry;
	    };
	
	    Client.prototype._loadResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var mock;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            mock = this._registry.find(request);
	                            _context.next = 3;
	                            return mock.getResponse(request);
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 4:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _loadResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    return Client;
	}(_Client2.default);
	
	exports.default = Client;
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Registry = function () {
	    function Registry() {
	        _classCallCheck(this, Registry);
	
	        this._mocks = [];
	    }
	
	    Registry.prototype.add = function add(mock) {
	        this._mocks.push(mock);
	        return this;
	    };
	
	    Registry.prototype.clear = function clear() {
	        this._mocks = [];
	        return this;
	    };
	
	    Registry.prototype.find = function find(request) {
	
	        //console.log('Registry is looking for', request);
	
	        var mock = this._mocks.shift();
	
	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);
	
	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());
	
	        return mock;
	    };
	
	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText, delay) {
	
	        this.add(new _Mock2.default(method, path, response, status, statusText, delay));
	
	        return this;
	    };
	
	    Registry.prototype.authentication = function authentication() {
	
	        this.apiCall('POST', '/restapi/oauth/token', {
	            'access_token': 'ACCESS_TOKEN',
	            'token_type': 'bearer',
	            'expires_in': 3600,
	            'refresh_token': 'REFRESH_TOKEN',
	            'refresh_token_expires_in': 60480,
	            'scope': 'SMS RCM Foo Boo',
	            'expireTime': new Date().getTime() + 3600000
	        });
	
	        return this;
	    };
	
	    Registry.prototype.logout = function logout() {
	
	        this.apiCall('POST', '/restapi/oauth/revoke', {});
	
	        return this;
	    };
	
	    Registry.prototype.presenceLoad = function presenceLoad(id) {
	
	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {
	            "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id + "/presence",
	            "extension": {
	                "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id,
	                "id": id,
	                "extensionNumber": "101"
	            },
	            "activeCalls": [],
	            "presenceStatus": "Available",
	            "telephonyStatus": "Ringing",
	            "userStatus": "Available",
	            "dndStatus": "TakeAllCalls",
	            "extensionId": id
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {
	
	        expiresIn = expiresIn || 15 * 60 * 60;
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],
	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),
	            'expiresIn': expiresIn,
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': false,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar'
	            },
	            'id': 'foo-bar-baz',
	            'creationTime': date.toISOString(),
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {
	
	        id = id || '1';
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],
	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': true,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar',
	                'encryptionAlgorithm': 'AES',
	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='
	            },
	            'creationTime': date.toISOString(),
	            'id': 'foo-bar-baz',
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {
	
	        if (!failure) {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
	                'token_type': 'bearer',
	                'expires_in': 3600,
	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
	                'refresh_token_expires_in': 60480,
	                'scope': 'SMS RCM Foo Boo'
	            });
	        } else {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'message': 'Wrong token',
	                'error_description': 'Wrong token',
	                'description': 'Wrong token'
	            }, 400);
	        }
	
	        return this;
	    };
	
	    return Registry;
	}();
	
	exports.default = Registry;
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Mock = function () {
	    function Mock(method, path, json, status, statusText, delay) {
	        _classCallCheck(this, Mock);
	
	        this._method = method.toUpperCase();
	        this._path = path;
	        this._json = json || {};
	        this._delay = delay || 10;
	        this._status = status || 200;
	        this._statusText = statusText || 'OK';
	    }
	
	    Mock.prototype.path = function path() {
	        return this._path;
	    };
	
	    Mock.prototype.method = function method() {
	        return this._method;
	    };
	
	    Mock.prototype.test = function test(request) {
	
	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;
	    };
	
	    Mock.prototype.getResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return (0, _Utils.delay)(this._delay);
	
	                        case 2:
	                            return _context.abrupt('return', this.createResponse(this._json));
	
	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function getResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return getResponse;
	    }();
	
	    Mock.prototype.createResponse = function createResponse(json, init) {
	
	        init = init || {};
	
	        init.status = init.status || this._status;
	        init.statusText = init.statusText || this._statusText;
	
	        var str = JSON.stringify(json),
	            res = new _Externals.Response(str, init);
	
	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);
	
	        return res;
	    };
	
	    return Mock;
	}();
	
	exports.default = Mock;
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Platform = function (_EventEmitter) {
	    _inherits(Platform, _EventEmitter);
	
	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {
	        _classCallCheck(this, Platform);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            beforeLogin: 'beforeLogin',
	            loginSuccess: 'loginSuccess',
	            loginError: 'loginError',
	            beforeRefresh: 'beforeRefresh',
	            refreshSuccess: 'refreshSuccess',
	            refreshError: 'refreshError',
	            beforeLogout: 'beforeLogout',
	            logoutSuccess: 'logoutSuccess',
	            logoutError: 'logoutError'
	        };
	
	
	        _this._server = server;
	        _this._appKey = appKey;
	        _this._appSecret = appSecret;
	
	        /** @type {Cache} */
	        _this._cache = cache;
	
	        /** @type {Client} */
	        _this._client = client;
	
	        /** @type {Promise<ApiResponse>} */
	        _this._refreshPromise = null;
	
	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);
	
	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;
	
	        return _this;
	    }
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Platform.prototype.auth = function auth() {
	        return this._auth;
	    };
	
	    /**
	     * @return {Client}
	     */
	
	
	    Platform.prototype.client = function client() {
	        return this._client;
	    };
	
	    /**
	     * @param {string} path
	     * @param {object} [options]
	     * @param {boolean} [options.addServer]
	     * @param {string} [options.addMethod]
	     * @param {boolean} [options.addToken]
	     * @return {string}
	     */
	
	
	    Platform.prototype.createUrl = function createUrl(path, options) {
	
	        path = path || '';
	        options = options || {};
	
	        var builtUrl = '',
	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;
	
	        if (options.addServer && !hasHttp) builtUrl += this._server;
	
	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;
	
	        builtUrl += path;
	
	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';
	
	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;
	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();
	
	        return builtUrl;
	    };
	
	    /**
	     * @param {string} options.redirectUri
	     * @param {string} options.state
	     * @param {string} options.brandId
	     * @param {string} options.display
	     * @param {string} options.prompt
	     * @param {object} [options]
	     * @return {string}
	     */
	
	
	    Platform.prototype.loginUrl = function loginUrl(options) {
	
	        options = options || {};
	
	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({
	            'response_type': 'code',
	            'redirect_uri': options.redirectUri || '',
	            'client_id': this._appKey,
	            'state': options.state || '',
	            'brand_id': options.brandId || '',
	            'display': options.display || '',
	            'prompt': options.prompt || ''
	        }), { addServer: true });
	    };
	
	    /**
	     * @param {string} url
	     * @return {Object}
	     */
	
	
	    Platform.prototype.parseLoginRedirectUrl = function parseLoginRedirectUrl(url) {
	
	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),
	            error = qs.error_description || qs.error;
	
	        if (error) {
	            var e = new Error(error);
	            e.error = qs.error;
	            throw e;
	        }
	
	        return qs;
	    };
	
	    /**
	     * Convenience method to handle 3-legged OAuth
	     *
	     * Attention! This is an experimental method and it's signature and behavior may change without notice.
	     *
	     * @experimental
	     * @param {number} [options.width]
	     * @param {number} [options.height]
	     * @param {object} [options.login] additional options for login()
	     * @param {string} [options.origin]
	     * @param {string} [options.property] name of window.postMessage's event data property
	     * @param {string} [options.target] target for window.open()
	     * @param {string} options.url
	     * @return {Promise}
	     */
	
	
	    Platform.prototype.loginWindow = function loginWindow(options) {
	        var _this2 = this;
	
	        return new _Externals.Promise(function (resolve, reject) {
	
	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');
	
	            if (!options.url) throw new Error('Missing mandatory URL parameter');
	
	            options = options || {};
	            options.url = options.url || 400;
	            options.width = options.width || 400;
	            options.height = options.height || 600;
	            options.origin = options.origin || window.location.origin;
	            options.property = options.property || 'RCAuthorizationCode';
	            options.target = options.target || '_blank';
	
	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
	
	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
	
	            var left = width / 2 - options.width / 2 + dualScreenLeft;
	            var top = height / 2 - options.height / 2 + dualScreenTop;
	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');
	
	            if (window.focus) win.focus();
	
	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';
	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';
	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';
	
	            var eventListener = function eventListener(e) {
	
	                if (e.origin != options.origin) return;
	                if (!e.data || !e.data[options.property]) return; // keep waiting
	
	                win.close();
	                window[eventRemoveMethod](messageEvent, eventListener);
	
	                try {
	
	                    var loginOptions = _this2.parseLoginRedirectUrl(e.data[options.property]);
	
	                    if (!loginOptions.code) throw new Error('No authorization code');
	
	                    resolve(loginOptions);
	                } catch (e) {
	                    reject(e);
	                }
	            };
	
	            window[eventMethod](messageEvent, eventListener, false);
	        });
	    };
	
	    /**
	     * @return {Promise<boolean>}
	     */
	
	
	    Platform.prototype.loggedIn = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.prev = 0;
	                            _context.next = 3;
	                            return this.ensureLoggedIn();
	
	                        case 3:
	                            return _context.abrupt("return", true);
	
	                        case 6:
	                            _context.prev = 6;
	                            _context.t0 = _context["catch"](0);
	                            return _context.abrupt("return", false);
	
	                        case 9:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[0, 6]]);
	        }));
	
	        function loggedIn() {
	            return _ref.apply(this, arguments);
	        }
	
	        return loggedIn;
	    }();
	
	    /**
	     * @param {string} options.username
	     * @param {string} options.password
	     * @param {string} options.extension
	     * @param {string} options.code
	     * @param {string} options.redirectUri
	     * @param {string} options.endpointId
	     * @param {string} options.remember
	     * @param {string} options.accessTokenTtl
	     * @param {string} options.refreshTokenTtl
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.login = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {
	            var body, apiResponse, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            options = options || {};
	
	                            this.emit(this.events.beforeLogin);
	
	                            body = {};
	
	
	                            if (!options.code) {
	
	                                body.grant_type = 'password';
	                                body.username = options.username;
	                                body.password = options.password;
	                                body.extension = options.extension || '';
	                            } else if (options.code) {
	
	                                body.grant_type = 'authorization_code';
	                                body.code = options.code;
	                                body.redirect_uri = options.redirectUri;
	                                //body.client_id = this.getCredentials().key; // not needed
	                            }
	
	                            if (options.endpointId) body.endpoint_id = options.endpointId;
	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;
	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;
	
	                            _context2.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, body);
	
	                        case 10:
	                            apiResponse = _context2.sent;
	                            json = apiResponse.json();
	
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.loginSuccess, apiResponse);
	
	                            return _context2.abrupt("return", apiResponse);
	
	                        case 17:
	                            _context2.prev = 17;
	                            _context2.t0 = _context2["catch"](0);
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.loginError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 22:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 17]]);
	        }));
	
	        function login(_x) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return login;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     * @private
	     */
	
	
	    Platform.prototype._refresh = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var res, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this.emit(this.events.beforeRefresh);
	
	                            _context3.next = 4;
	                            return (0, _Utils.delay)(Platform._refreshDelayMs);
	
	                        case 4:
	                            if (this._auth.refreshToken()) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Refresh token is missing');
	
	                        case 6:
	                            if (this._auth.refreshTokenValid()) {
	                                _context3.next = 8;
	                                break;
	                            }
	
	                            throw new Error('Refresh token has expired');
	
	                        case 8:
	                            _context3.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, {
	                                "grant_type": "refresh_token",
	                                "refresh_token": this._auth.refreshToken(),
	                                "access_token_ttl": this._auth.data().expires_in + 1,
	                                "refresh_token_ttl": this._auth.data().refresh_token_expires_in + 1
	                            });
	
	                        case 10:
	                            res = _context3.sent;
	                            json = res.json();
	
	                            if (json.access_token) {
	                                _context3.next = 14;
	                                break;
	                            }
	
	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);
	
	                        case 14:
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.refreshSuccess, res);
	
	                            return _context3.abrupt("return", res);
	
	                        case 19:
	                            _context3.prev = 19;
	                            _context3.t0 = _context3["catch"](0);
	
	
	                            _context3.t0 = this._client.makeError(_context3.t0);
	
	                            if (Platform._clearCacheOnRefreshError) {
	                                this._cache.clean();
	                            }
	
	                            this.emit(this.events.refreshError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 25:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 19]]);
	        }));
	
	        function _refresh() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return _refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.refresh = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var _this3 = this;
	
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (!this._refreshPromise) {
	                                _context4.next = 2;
	                                break;
	                            }
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 2:
	                            _context4.prev = 2;
	
	
	                            this._refreshPromise = this._refresh().then(function (res) {
	                                _this3._refreshPromise = null;
	                                return res;
	                            });
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 7:
	                            _context4.prev = 7;
	                            _context4.t0 = _context4["catch"](2);
	
	
	                            this._refreshPromise = null;
	                            throw _context4.t0;
	
	                        case 11:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[2, 7]]);
	        }));
	
	        function refresh() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.logout = function () {
	        var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	            var res;
	            return regeneratorRuntime.wrap(function _callee5$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.prev = 0;
	
	
	                            this.emit(this.events.beforeLogout);
	
	                            _context5.next = 4;
	                            return this._tokenRequest(Platform._revokeEndpoint, {
	                                token: this._auth.accessToken()
	                            });
	
	                        case 4:
	                            res = _context5.sent;
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.logoutSuccess, res);
	
	                            return _context5.abrupt("return", res);
	
	                        case 10:
	                            _context5.prev = 10;
	                            _context5.t0 = _context5["catch"](0);
	
	
	                            this.emit(this.events.logoutError, _context5.t0);
	
	                            throw _context5.t0;
	
	                        case 14:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, _callee5, this, [[0, 10]]);
	        }));
	
	        function logout() {
	            return _ref5.apply(this, arguments);
	        }
	
	        return logout;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<Request>}
	     */
	
	
	    Platform.prototype.inflateRequest = function () {
	        var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {
	            return regeneratorRuntime.wrap(function _callee6$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	
	                            options = options || {};
	
	                            if (!options.skipAuthCheck) {
	                                _context6.next = 3;
	                                break;
	                            }
	
	                            return _context6.abrupt("return", request);
	
	                        case 3:
	                            _context6.next = 5;
	                            return this.ensureLoggedIn();
	
	                        case 5:
	
	                            request.headers.set('X-User-Agent', this._userAgent);
	                            request.headers.set('Client-Id', this._appKey);
	                            request.headers.set('Authorization', this._authHeader());
	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...
	
	                            return _context6.abrupt("return", request);
	
	                        case 9:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, _callee6, this);
	        }));
	
	        function inflateRequest(_x2, _x3) {
	            return _ref6.apply(this, arguments);
	        }
	
	        return inflateRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.sendRequest = function () {
	        var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(request, options) {
	            return regeneratorRuntime.wrap(function _callee7$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.prev = 0;
	                            _context7.next = 3;
	                            return this.inflateRequest(request, options);
	
	                        case 3:
	                            request = _context7.sent;
	                            _context7.next = 6;
	                            return this._client.sendRequest(request);
	
	                        case 6:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 9:
	                            _context7.prev = 9;
	                            _context7.t0 = _context7["catch"](0);
	
	                            if (!(!_context7.t0.apiResponse || !_context7.t0.apiResponse.response() || _context7.t0.apiResponse.response().status != 401)) {
	                                _context7.next = 13;
	                                break;
	                            }
	
	                            throw _context7.t0;
	
	                        case 13:
	
	                            this._auth.cancelAccessToken();
	
	                            _context7.next = 16;
	                            return this.sendRequest(request, options);
	
	                        case 16:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 17:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, _callee7, this, [[0, 9]]);
	        }));
	
	        function sendRequest(_x4, _x5) {
	            return _ref7.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * General purpose function to send anything to server
	     * @param {string} options.url
	     * @param {object} [options.body]
	     * @param {string} [options.method]
	     * @param {object} [options.query]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.send = function () {
	        var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            return regeneratorRuntime.wrap(function _callee8$(_context8) {
	                while (1) {
	                    switch (_context8.prev = _context8.next) {
	                        case 0:
	
	                            //FIXME https://github.com/bitinn/node-fetch/issues/43
	                            options.url = this.createUrl(options.url, { addServer: true });
	
	                            _context8.next = 3;
	                            return this.sendRequest(this._client.createRequest(options), options);
	
	                        case 3:
	                            return _context8.abrupt("return", _context8.sent);
	
	                        case 4:
	                        case "end":
	                            return _context8.stop();
	                    }
	                }
	            }, _callee8, this);
	        }));
	
	        function send(_x6) {
	            return _ref8.apply(this, arguments);
	        }
	
	        return send;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.get = function () {
	        var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee9$(_context9) {
	                while (1) {
	                    switch (_context9.prev = _context9.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'GET';
	                            options.url = url;
	                            options.query = query;
	                            _context9.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context9.abrupt("return", _context9.sent);
	
	                        case 7:
	                        case "end":
	                            return _context9.stop();
	                    }
	                }
	            }, _callee9, this);
	        }));
	
	        function get(_x8, _x9, _x10) {
	            return _ref9.apply(this, arguments);
	        }
	
	        return get;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} body
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.post = function () {
	        var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee10$(_context10) {
	                while (1) {
	                    switch (_context10.prev = _context10.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'POST';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context10.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context10.abrupt("return", _context10.sent);
	
	                        case 8:
	                        case "end":
	                            return _context10.stop();
	                    }
	                }
	            }, _callee10, this);
	        }));
	
	        function post(_x11, _x12, _x13, _x14) {
	            return _ref10.apply(this, arguments);
	        }
	
	        return post;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [body]
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.put = function () {
	        var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee11$(_context11) {
	                while (1) {
	                    switch (_context11.prev = _context11.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'PUT';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context11.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context11.abrupt("return", _context11.sent);
	
	                        case 8:
	                        case "end":
	                            return _context11.stop();
	                    }
	                }
	            }, _callee11, this);
	        }));
	
	        function put(_x15, _x16, _x17, _x18) {
	            return _ref11.apply(this, arguments);
	        }
	
	        return put;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {string} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype['delete'] = function () {
	        var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee12$(_context12) {
	                while (1) {
	                    switch (_context12.prev = _context12.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'DELETE';
	                            options.url = url;
	                            options.query = query;
	                            _context12.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context12.abrupt("return", _context12.sent);
	
	                        case 7:
	                        case "end":
	                            return _context12.stop();
	                    }
	                }
	            }, _callee12, this);
	        }));
	
	        function _delete(_x19, _x20, _x21) {
	            return _ref12.apply(this, arguments);
	        }
	
	        return _delete;
	    }();
	
	    Platform.prototype._tokenRequest = function () {
	        var _ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(path, body) {
	            return regeneratorRuntime.wrap(function _callee13$(_context13) {
	                while (1) {
	                    switch (_context13.prev = _context13.next) {
	                        case 0:
	                            _context13.next = 2;
	                            return this.send({
	                                url: path,
	                                skipAuthCheck: true,
	                                body: body,
	                                method: 'POST',
	                                headers: {
	                                    'Authorization': 'Basic ' + this._apiKey(),
	                                    'Content-Type': 'application/x-www-form-urlencoded'
	                                }
	                            });
	
	                        case 2:
	                            return _context13.abrupt("return", _context13.sent);
	
	                        case 3:
	                        case "end":
	                            return _context13.stop();
	                    }
	                }
	            }, _callee13, this);
	        }));
	
	        function _tokenRequest(_x22, _x23) {
	            return _ref13.apply(this, arguments);
	        }
	
	        return _tokenRequest;
	    }();
	
	    Platform.prototype.ensureLoggedIn = function () {
	        var _ref14 = _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
	            return regeneratorRuntime.wrap(function _callee14$(_context14) {
	                while (1) {
	                    switch (_context14.prev = _context14.next) {
	                        case 0:
	                            if (!this._isAccessTokenValid()) {
	                                _context14.next = 2;
	                                break;
	                            }
	
	                            return _context14.abrupt("return", null);
	
	                        case 2:
	                            _context14.next = 4;
	                            return this.refresh();
	
	                        case 4:
	                            return _context14.abrupt("return", _context14.sent);
	
	                        case 5:
	                        case "end":
	                            return _context14.stop();
	                    }
	                }
	            }, _callee14, this);
	        }));
	
	        function ensureLoggedIn() {
	            return _ref14.apply(this, arguments);
	        }
	
	        return ensureLoggedIn;
	    }();
	
	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {
	        return this._auth.accessTokenValid();
	    };
	
	    Platform.prototype._apiKey = function _apiKey() {
	        var apiKey = this._appKey + ':' + this._appSecret;
	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');
	    };
	
	    Platform.prototype._authHeader = function _authHeader() {
	        var token = this._auth.accessToken();
	        return this._auth.tokenType() + (token ? ' ' + token : '');
	    };
	
	    return Platform;
	}(_events2.default);
	
	Platform._urlPrefix = '/restapi';
	Platform._apiVersion = 'v1.0';
	Platform._tokenEndpoint = '/restapi/oauth/token';
	Platform._revokeEndpoint = '/restapi/oauth/revoke';
	Platform._authorizeEndpoint = '/restapi/oauth/authorize';
	Platform._refreshDelayMs = 100;
	Platform._cacheId = 'platform';
	Platform._clearCacheOnRefreshError = false;
	exports.default = Platform;
	
	/***/ },
	/* 16 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Auth = function () {
	    function Auth(cache, cacheId) {
	        _classCallCheck(this, Auth);
	
	        /** @type {Cache} */
	        this._cache = cache;
	        this._cacheId = cacheId;
	    } // 1 minute
	
	
	    Auth.prototype.accessToken = function accessToken() {
	        return this.data().access_token;
	    };
	
	    Auth.prototype.refreshToken = function refreshToken() {
	        return this.data().refresh_token;
	    };
	
	    Auth.prototype.tokenType = function tokenType() {
	        return this.data().token_type;
	    };
	
	    /**
	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}
	     */
	
	
	    Auth.prototype.data = function data() {
	
	        return this._cache.getItem(this._cacheId) || {
	            token_type: '',
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        };
	    };
	
	    /**
	     * @param {object} newData
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.setData = function setData(newData) {
	
	        newData = newData || {};
	
	        var data = this.data();
	
	        Object.keys(newData).forEach(function (key) {
	            data[key] = newData[key];
	        });
	
	        data.expire_time = Date.now() + data.expires_in * 1000;
	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;
	
	        this._cache.setItem(this._cacheId, data);
	
	        return this;
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.accessTokenValid = function accessTokenValid() {
	
	        var authData = this.data();
	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {
	
	        return this.data().refresh_token_expire_time > Date.now();
	    };
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {
	
	        return this.setData({
	            access_token: '',
	            expires_in: 0
	        });
	    };
	
	    /**
	     * This method sets a special authentication mode used in Service Web
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.forceAuthentication = function forceAuthentication() {
	
	        this.setData({
	            token_type: Auth.forcedTokenType,
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        });
	
	        return this;
	    };
	
	    return Auth;
	}();
	
	//export interface IAuthData {
	//    remember?:boolean;
	//    token_type?:string;
	//    access_token?:string;
	//    expires_in?:number; // actually it's string
	//    expire_time?:number;
	//    refresh_token?:string;
	//    refresh_token_expires_in?:number; // actually it's string
	//    refresh_token_expire_time?:number;
	//    scope?:string;
	//}
	
	
	Auth.refreshHandicapMs = 60 * 1000;
	Auth.forcedTokenType = 'forced';
	exports.default = Auth;
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _PubnubMock = __webpack_require__(18);
	
	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PubnubMockFactory = function () {
	    function PubnubMockFactory() {
	        _classCallCheck(this, PubnubMockFactory);
	
	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	    }
	
	    PubnubMockFactory.prototype.init = function init(options) {
	        return new _PubnubMock2.default(options);
	    };
	
	    return PubnubMockFactory;
	}();
	
	exports.default = PubnubMockFactory;
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PubnubMock = function (_EventEmitter) {
	    _inherits(PubnubMock, _EventEmitter);
	
	    function PubnubMock(options) {
	        _classCallCheck(this, PubnubMock);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.options = options;
	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	        return _this;
	    }
	
	    PubnubMock.prototype.init = function init(options) {
	        this.options = options;
	    };
	
	    PubnubMock.prototype.ready = function ready() {};
	
	    PubnubMock.prototype.subscribe = function subscribe(options) {
	        this.on('message-' + options.channel, options.message);
	    };
	
	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {
	        this.removeAllListeners('message-' + options.channel);
	    };
	
	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {
	        this.emit('message-' + channel, msg, 'env', channel);
	    };
	
	    return PubnubMock;
	}(_events2.default);
	
	exports.default = PubnubMock;
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Subscription = function (_EventEmitter) {
	    _inherits(Subscription, _EventEmitter);
	
	    function Subscription(pubnubFactory, platform) {
	        _classCallCheck(this, Subscription);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            notification: 'notification',
	            removeSuccess: 'removeSuccess',
	            removeError: 'removeError',
	            renewSuccess: 'renewSuccess',
	            renewError: 'renewError',
	            subscribeSuccess: 'subscribeSuccess',
	            subscribeError: 'subscribeError'
	        };
	
	
	        _this._pubnubFactory = pubnubFactory;
	        _this._platform = platform;
	        _this._pubnub = null;
	        _this._pubnubLastChannel = null;
	        _this._timeout = null;
	        _this._subscription = null;
	
	        return _this;
	    }
	
	    Subscription.prototype.subscribed = function subscribed() {
	
	        var subscription = this.subscription();
	
	        return !!(subscription.id && subscription.deliveryMode && subscription.deliveryMode.subscriberKey && subscription.deliveryMode.address);
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.alive = function alive() {
	        return this.subscribed() && Date.now() < this.expirationTime();
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.expired = function expired() {
	        if (!this.subscribed()) return true;
	        return !this.subscribed() || Date.now() > this.subscription().expirationTime;
	    };
	
	    Subscription.prototype.expirationTime = function expirationTime() {
	        return new Date(this.subscription().expirationTime || 0).getTime() - Subscription._renewHandicapMs;
	    };
	
	    Subscription.prototype.setSubscription = function setSubscription(subscription) {
	
	        subscription = subscription || {};
	
	        this._clearTimeout();
	        this._setSubscription(subscription);
	        this._subscribeAtPubnub();
	        this._setTimeout();
	
	        return this;
	    };
	
	    Subscription.prototype.subscription = function subscription() {
	        return this._subscription || {};
	    };
	
	    /**
	     * Creates or updates subscription if there is an active one
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.register = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!this.alive()) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.renew();
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 6:
	                            _context.next = 8;
	                            return this.subscribe();
	
	                        case 8:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 9:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function register() {
	            return _ref.apply(this, arguments);
	        }
	
	        return register;
	    }();
	
	    Subscription.prototype.eventFilters = function eventFilters() {
	        return this.subscription().eventFilters || [];
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.addEventFilters = function addEventFilters(events) {
	        this.setEventFilters(this.eventFilters().concat(events));
	        return this;
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.setEventFilters = function setEventFilters(events) {
	        var subscription = this.subscription();
	        subscription.eventFilters = events;
	        this._setSubscription(subscription);
	        return this;
	    };
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.subscribe = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.eventFilters().length) {
	                                _context2.next = 4;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 4:
	                            _context2.next = 6;
	                            return this._platform.post('/subscription', {
	                                eventFilters: this._getFullEventFilters(),
	                                deliveryMode: {
	                                    transportType: 'PubNub'
	                                }
	                            });
	
	                        case 6:
	                            response = _context2.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);
	
	                            return _context2.abrupt('return', response);
	
	                        case 12:
	                            _context2.prev = 12;
	                            _context2.t0 = _context2['catch'](0);
	
	
	                            _context2.t0 = this._platform.client().makeError(_context2.t0);
	
	                            this.reset().emit(this.events.subscribeError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 17:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 12]]);
	        }));
	
	        function subscribe() {
	            return _ref2.apply(this, arguments);
	        }
	
	        return subscribe;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.renew = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.subscribed()) {
	                                _context3.next = 4;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 4:
	                            if (this.eventFilters().length) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 6:
	                            _context3.next = 8;
	                            return this._platform.put('/subscription/' + this.subscription().id, {
	                                eventFilters: this._getFullEventFilters()
	                            });
	
	                        case 8:
	                            response = _context3.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.renewSuccess, response);
	
	                            return _context3.abrupt('return', response);
	
	                        case 14:
	                            _context3.prev = 14;
	                            _context3.t0 = _context3['catch'](0);
	
	
	                            _context3.t0 = this._platform.client().makeError(_context3.t0);
	
	                            this.reset().emit(this.events.renewError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 19:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 14]]);
	        }));
	
	        function renew() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return renew;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.remove = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var response;
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            _context4.prev = 0;
	
	                            if (this.subscribed()) {
	                                _context4.next = 3;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 3:
	                            _context4.next = 5;
	                            return this._platform.delete('/subscription/' + this.subscription().id);
	
	                        case 5:
	                            response = _context4.sent;
	
	
	                            this.reset().emit(this.events.removeSuccess, response);
	
	                            return _context4.abrupt('return', response);
	
	                        case 10:
	                            _context4.prev = 10;
	                            _context4.t0 = _context4['catch'](0);
	
	
	                            _context4.t0 = this._platform.client().makeError(_context4.t0);
	
	                            this.emit(this.events.removeError, _context4.t0);
	
	                            throw _context4.t0;
	
	                        case 15:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[0, 10]]);
	        }));
	
	        function remove() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return remove;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.resubscribe = function resubscribe() {
	        var filters = this.eventFilters();
	        return this.reset().setEventFilters(filters).subscribe();
	    };
	
	    /**
	     * Remove subscription and disconnect from PUBNUB
	     * This method resets subscription at client side but backend is not notified
	     */
	
	
	    Subscription.prototype.reset = function reset() {
	        this._clearTimeout();
	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this.subscription().deliveryMode.address });
	        this._setSubscription(null);
	        return this;
	    };
	
	    Subscription.prototype._setSubscription = function _setSubscription(subscription) {
	        this._subscription = subscription;
	    };
	
	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {
	        var _this2 = this;
	
	        return this.eventFilters().map(function (event) {
	            return _this2._platform.createUrl(event);
	        });
	    };
	
	    Subscription.prototype._setTimeout = function _setTimeout() {
	        var _this3 = this;
	
	        this._clearTimeout();
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        this._timeout = setInterval(function () {
	
	            if (_this3.alive()) return;
	
	            if (_this3.expired()) {
	                _this3.subscribe();
	            } else {
	                _this3.renew();
	            }
	        }, Subscription._pollInterval);
	
	        return this;
	    };
	
	    Subscription.prototype._clearTimeout = function _clearTimeout() {
	        clearInterval(this._timeout);
	        return this;
	    };
	
	    Subscription.prototype._decrypt = function _decrypt(message) {
	
	        if (!this.subscribed()) throw new Error('No subscription');
	
	        if (this.subscription().deliveryMode.encryptionKey) {
	
	            message = this._pubnubFactory.crypto_obj.decrypt(message, this.subscription().deliveryMode.encryptionKey, {
	                encryptKey: false,
	                keyEncoding: 'base64',
	                keyLength: 128,
	                mode: 'ecb'
	            });
	        }
	
	        return message;
	    };
	
	    Subscription.prototype._notify = function _notify(message) {
	        this.emit(this.events.notification, this._decrypt(message));
	        return this;
	    };
	
	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        var deliveryMode = this.subscription().deliveryMode;
	
	        if (this._pubnub) {
	
	            if (this._pubnubLastChannel == deliveryMode.address) {
	                // Nothing to update, keep listening to same channel
	                return this;
	            } else if (this._pubnubLastChannel) {
	                // Need to subscribe to new channel
	                this._pubnub.unsubscribe({ channel: this._pubnubLastChannel });
	            }
	
	            // Re-init for new data
	            this._pubnub = this._pubnub.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	        } else {
	
	            // Init from scratch
	            this._pubnub = this._pubnubFactory.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	
	            this._pubnub.ready(); //TODO This may be not needed anymore
	        }
	
	        this._pubnubLastChannel = deliveryMode.address;
	
	        this._pubnub.subscribe({
	            channel: deliveryMode.address,
	            message: this._notify.bind(this),
	            connect: function connect() {}
	        });
	
	        return this;
	    };
	
	    return Subscription;
	}(_events2.default);
	
	//export interface ISubscription {
	//    id?:string;
	//    uri?: string;
	//    eventFilters?:string[];
	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z
	//    expiresIn?:number;
	//    deliveryMode?: {
	//        transportType?:string;
	//        encryption?:boolean;
	//        address?:string;
	//        subscriberKey?:string;
	//        encryptionKey?:string;
	//        secretKey?:string;
	//    };
	//    creationTime?:string; // 2014-03-12T19:54:35.613Z
	//    status?:string; // Active
	//}
	
	
	Subscription._renewHandicapMs = 2 * 60 * 1000;
	Subscription._pollInterval = 10 * 1000;
	exports.default = Subscription;
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Subscription2 = __webpack_require__(19);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CachedSubscription = function (_Subscription) {
	    _inherits(CachedSubscription, _Subscription);
	
	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {
	        _classCallCheck(this, CachedSubscription);
	
	        /** @type {Cache} */
	
	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));
	
	        _this._cache = cache;
	        _this._cacheKey = cacheKey;
	
	        return _this;
	    }
	
	    CachedSubscription.prototype.subscription = function subscription() {
	        return this._cache.getItem(this._cacheKey) || {};
	    };
	
	    CachedSubscription.prototype._setSubscription = function _setSubscription(subscription) {
	        return this._cache.setItem(this._cacheKey, subscription);
	    };
	
	    /**
	     * This function checks whether there are any pre-defined eventFilters in cache and if not -- uses provided as defaults
	     * @param {string[]} events
	     * @return {CachedSubscription}
	     */
	
	
	    CachedSubscription.prototype.restore = function restore(events) {
	
	        if (!this.eventFilters().length) {
	            this.setEventFilters(events);
	        }
	
	        return this;
	    };
	
	    return CachedSubscription;
	}(_Subscription3.default);
	
	exports.default = CachedSubscription;
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), __webpack_require__(122).Buffer))

/***/ },
/* 121 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(123)
	var ieee754 = __webpack_require__(124)
	var isArray = __webpack_require__(125)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(122).Buffer, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 124 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(128);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(129)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), (function() { return this; }()), __webpack_require__(127)(module)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 128 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 130 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*! 3.15.2 / modern */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["PUBNUB"] = factory();
		else
			root["PUBNUB"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* globals 'Modern' */
		/* eslint curly: 0, camelcase: 0, dot-notation: 0 */
	
		var packageJSON = __webpack_require__(1);
		var pubNubCore = __webpack_require__(2);
		var crypto_obj = __webpack_require__(5);
		var CryptoJS = __webpack_require__(6);
		var WS = __webpack_require__(7);
	
		/**
		 * UTIL LOCALS
		 */
		var PNSDK = 'PubNub-JS-' + 'Modern' + '/' + packageJSON.version;
	
		/**
		 * LOCAL STORAGE
		 */
		var db = (function () {
		  var ls = typeof localStorage !== 'undefined' && localStorage;
		  return {
		    get: function (key) {
		      try {
		        if (ls) return ls.getItem(key);
		        if (document.cookie.indexOf(key) === -1) return null;
		        return ((document.cookie || '').match(
		            RegExp(key + '=([^;]+)')
		          ) || [])[1] || null;
		      } catch (e) {
		        return;
		      }
		    },
		    set: function (key, value) {
		      try {
		        if (ls) return ls.setItem(key, value) && 0;
		        document.cookie = key + '=' + value +
		          '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';
		      } catch (e) {
		        return;
		      }
		    }
		  };
		})();
	
	
		/**
		 * CORS XHR Request
		 * ================
		 *  xdr({
		 *     url     : ['http://www.blah.com/url'],
		 *     success : function(response) {},
		 *     fail    : function() {}
		 *  });
		 */
		function xdr(setup) {
		  var xhr;
		  var timer;
		  var complete = 0;
		  var loaded = 0;
		  var async = true; /* do not allow sync operations in modern builds */
		  var xhrtme = setup.timeout || pubNubCore.DEF_TIMEOUT;
		  var data = setup.data || {};
		  var fail = setup.fail || function () {};
		  var success = setup.success || function () {};
	
		  var done = function (failed, response) {
		    if (complete) return;
		    complete = 1;
	
		    clearTimeout(timer);
	
		    if (xhr) {
		      xhr.onerror = xhr.onload = null;
		      if (xhr.abort) xhr.abort();
		      xhr = null;
		    }
	
		    if (failed) fail(response);
		  };
	
		  var finished = function () {
		    if (loaded) return;
		    var response;
		    loaded = 1;
	
		    clearTimeout(timer);
	
		    try {
		      response = JSON.parse(xhr.responseText);
		    } catch (r) {
		      return done(1);
		    }
	
		    success(response);
		  };
	
		  timer = pubNubCore.timeout(function () {
		    done(1);
		  }, xhrtme);
	
		  // Send
		  try {
		    xhr = typeof XDomainRequest !== 'undefined' &&
		      new XDomainRequest() ||
		      new XMLHttpRequest();
	
		    xhr.onerror = xhr.onabort = function () {
		      done(1, xhr.responseText || { error: 'Network Connection Error' });
		    };
		    xhr.onload = xhr.onloadend = finished;
	
		    data.pnsdk = PNSDK;
		    var url = pubNubCore.build_url(setup.url, data);
		    xhr.open('GET', url, async);
		    if (async) xhr.timeout = xhrtme;
		    xhr.send();
		  } catch (eee) {
		    done(1, { error: 'XHR Failed', stacktrace: eee });
		  }
	
		  // Return 'done'
		  return done;
		}
	
		/**
		 * BIND
		 * ====
		 * bind( 'keydown', search('a')[0], function(element) {
		 *     ...
		 * } );
		 */
		function bind(type, el, fun) {
		  pubNubCore.each(type.split(','), function (etype) {
		    var rapfun = function (e) {
		      if (!e) e = window.event;
		      if (!fun(e)) {
		        e.cancelBubble = true;
		        e.returnValue = false;
		        if (e.preventDefault) e.preventDefault();
		        if (e.stopPropagation) e.stopPropagation();
		      }
		    };
	
		    if (el.addEventListener) el.addEventListener(etype, rapfun, false);
		    else if (el.attachEvent) el.attachEvent('on' + etype, rapfun);
		    else el['on' + etype] = rapfun;
		  });
		}
	
		/**
		 * ERROR
		 * ===
		 * error('message');
		 */
		function error(message) {
		  console.error(message); // eslint-disable-line no-console
		}
	
		/**
		 * EVENTS
		 * ======
		 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {
		 *     // Do Stuff with message
		 * } );
		 *
		 * PUBNUB.events.fire( 'you-stepped-on-flower', "message-data" );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:"data"} );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );
		 *
		 */
		var events = {
		  list: {},
		  unbind: function (name) {
		    events.list[name] = [];
		  },
		  bind: function (name, fun) {
		    (events.list[name] = events.list[name] || []).push(fun);
		  },
		  fire: function (name, data) {
		    pubNubCore.each(
		      events.list[name] || [],
		      function (fun) {
		        fun(data);
		      }
		    );
		  }
		};
	
		/**
		 * ATTR
		 * ====
		 * var attribute = attr( node, 'attribute' );
		 */
		function attr(node, attribute, value) {
		  if (value) node.setAttribute(attribute, value);
		  else return node && node.getAttribute && node.getAttribute(attribute);
		}
	
		/**
		 * $
		 * =
		 * var div = $('divid');
		 */
		function $(id) {
		  return document.getElementById(id);
		}
	
	
		/**
		 * SEARCH
		 * ======
		 * var elements = search('a div span');
		 */
		function search(elements, start) {
		  var list = [];
		  pubNubCore.each(elements.split(/\s+/), function (el) {
		    pubNubCore.each((start || document).getElementsByTagName(el), function (node) {
		      list.push(node);
		    });
		  });
		  return list;
		}
	
		/**
		 * CSS
		 * ===
		 * var obj = create('div');
		 */
		function css(element, styles) {
		  for (var style in styles) if (styles.hasOwnProperty(style))
		    try {
		      element.style[style] = styles[style] + (
		          '|width|height|top|left|'.indexOf(style) > 0 &&
		          typeof styles[style] === 'number'
		            ? 'px' : ''
		        );
		    } catch (e) {
		      return;
		    }
		}
	
		/**
		 * CREATE
		 * ======
		 * var obj = create('div');
		 */
		function create(element) {
		  return document.createElement(element);
		}
	
	
		function get_hmac_SHA256(data, key) {
		  var hash = CryptoJS['HmacSHA256'](data, key);
		  return hash.toString(CryptoJS['enc']['Base64']);
		}
	
		/* =-====================================================================-= */
		/* =-====================================================================-= */
		/* =-=========================     PUBNUB     ===========================-= */
		/* =-====================================================================-= */
		/* =-====================================================================-= */
	
		function CREATE_PUBNUB(setup) {
		  setup.db = db;
		  setup.xdr = xdr;
		  setup.error = setup.error || error;
		  setup.hmac_SHA256 = get_hmac_SHA256;
		  setup.crypto_obj = crypto_obj();
		  setup.WS = WS;
		  setup.params = { pnsdk: PNSDK };
	
		  var SELF = function (setup) {
		    return CREATE_PUBNUB(setup);
		  };
	
		  var PN = pubNubCore.PN_API(setup);
		  for (var prop in PN) {
		    if (PN.hasOwnProperty(prop)) {
		      SELF[prop] = PN[prop];
		    }
		  }
	
		  SELF.init = SELF;
		  SELF.$ = $;
		  SELF.attr = attr;
		  SELF.search = search;
		  SELF.bind = bind;
		  SELF.css = css;
		  SELF.create = create;
		  SELF.crypto_obj = crypto_obj();
		  SELF.WS = WS;
		  SELF.PNmessage = pubNubCore.PNmessage;
		  SELF.supplant = pubNubCore.supplant;
	
		  if (typeof(window) !== 'undefined') {
		    bind('beforeunload', window, function () {
		      SELF['each-channel'](function (ch) {
		        SELF['LEAVE'](ch.name, 1);
		      });
		      return true;
		    });
		  }
	
		  SELF.ready();
	
		  // Return without Testing
		  if (setup.notest) return SELF;
	
		  if (typeof(window) !== 'undefined') {
		    bind('offline', window, SELF['offline']);
		  }
	
		  if (typeof(document) !== 'undefined') {
		    bind('offline', document, SELF['offline']);
		  }
	
		  return SELF;
		}
	
		CREATE_PUBNUB.init = CREATE_PUBNUB;
		CREATE_PUBNUB.secure = CREATE_PUBNUB;
		CREATE_PUBNUB.crypto_obj = crypto_obj();
		CREATE_PUBNUB.WS = WS;
		CREATE_PUBNUB.db = db;
		CREATE_PUBNUB.PNmessage = pubNubCore.PNmessage;
		CREATE_PUBNUB.uuid = pubNubCore.uuid;
	
		CREATE_PUBNUB.css = css;
		CREATE_PUBNUB.$ = $;
		CREATE_PUBNUB.create = $;
		CREATE_PUBNUB.bind = bind;
		CREATE_PUBNUB.search = search;
		CREATE_PUBNUB.attr = attr;
		CREATE_PUBNUB.events = events;
	
		CREATE_PUBNUB.map = pubNubCore.map;
		CREATE_PUBNUB.each = pubNubCore.each;
		CREATE_PUBNUB.grep = pubNubCore.grep;
		CREATE_PUBNUB.supplant = pubNubCore.supplant;
		CREATE_PUBNUB.now = pubNubCore.now;
		CREATE_PUBNUB.unique = pubNubCore.unique;
		CREATE_PUBNUB.updater = pubNubCore.updater;
	
		module.exports = CREATE_PUBNUB;
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		module.exports = {
			"name": "pubnub",
			"preferGlobal": false,
			"version": "3.15.2",
			"author": "PubNub <support@pubnub.com>",
			"description": "Publish & Subscribe Real-time Messaging with PubNub",
			"contributors": [
				{
					"name": "Stephen Blum",
					"email": "stephen@pubnub.com"
				}
			],
			"bin": {},
			"scripts": {
				"test": "grunt test --force"
			},
			"main": "./node.js/pubnub.js",
			"browser": "./modern/dist/pubnub.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/pubnub/javascript.git"
			},
			"keywords": [
				"cloud",
				"publish",
				"subscribe",
				"websockets",
				"comet",
				"bosh",
				"xmpp",
				"real-time",
				"messaging"
			],
			"dependencies": {
				"agentkeepalive": "~0.2",
				"lodash": "^4.1.0"
			},
			"noAnalyze": false,
			"devDependencies": {
				"chai": "^3.5.0",
				"eslint": "2.4.0",
				"eslint-config-airbnb": "^6.0.2",
				"eslint-plugin-flowtype": "^2.1.0",
				"eslint-plugin-mocha": "^2.0.0",
				"eslint-plugin-react": "^4.1.0",
				"flow-bin": "^0.22.0",
				"grunt": "^0.4.5",
				"grunt-contrib-clean": "^1.0.0",
				"grunt-contrib-copy": "^0.8.2",
				"grunt-contrib-uglify": "^0.11.1",
				"grunt-env": "^0.4.4",
				"grunt-eslint": "^18.0.0",
				"grunt-flow": "^1.0.3",
				"grunt-karma": "^0.12.1",
				"grunt-mocha-istanbul": "^3.0.1",
				"grunt-text-replace": "^0.4.0",
				"grunt-webpack": "^1.0.11",
				"imports-loader": "^0.6.5",
				"isparta": "^4.0.0",
				"json-loader": "^0.5.4",
				"karma": "^0.13.21",
				"karma-chai": "^0.1.0",
				"karma-mocha": "^0.2.1",
				"karma-phantomjs-launcher": "^1.0.0",
				"karma-spec-reporter": "0.0.24",
				"load-grunt-tasks": "^3.4.0",
				"mocha": "^2.4.5",
				"nock": "^1.1.0",
				"node-uuid": "^1.4.7",
				"nodeunit": "^0.9.0",
				"phantomjs-prebuilt": "^2.1.4",
				"proxyquire": "^1.7.4",
				"sinon": "^1.17.2",
				"uglify-js": "^2.6.1",
				"underscore": "^1.7.0",
				"webpack": "^1.12.13",
				"webpack-dev-server": "^1.14.1"
			},
			"bundleDependencies": [],
			"license": "MIT",
			"engine": {
				"node": ">=0.8"
			},
			"files": [
				"core",
				"node.js",
				"modern",
				"CHANGELOG",
				"FUTURE.md",
				"LICENSE",
				"README.md"
			]
		};
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0, no-use-before-define: 0, no-unused-expressions: 0  */
		/* eslint eqeqeq: 0, one-var: 0 */
		/* eslint no-redeclare: 0 */
		/* eslint guard-for-in: 0 */
		/* eslint block-scoped-var: 0 space-return-throw-case: 0, no-unused-vars: 0 */
	
		var packageJSON = __webpack_require__(1);
		var defaultConfiguration = __webpack_require__(3);
		var utils = __webpack_require__(4);
	
		var NOW = 1;
		var READY = false;
		var READY_BUFFER = [];
		var PRESENCE_SUFFIX = '-pnpres';
		var DEF_WINDOWING = 10; // MILLISECONDS.
		var DEF_TIMEOUT = 15000; // MILLISECONDS.
		var DEF_SUB_TIMEOUT = 310; // SECONDS.
		var DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).
		var SECOND = 1000; // A THOUSAND MILLISECONDS.
		var PRESENCE_HB_THRESHOLD = 5;
		var PRESENCE_HB_DEFAULT = 30;
		var SDK_VER = packageJSON.version;
	
		/**
		 * UTILITIES
		 */
		function unique() {
		  return 'x' + ++NOW + '' + (+new Date);
		}
	
		/**
		 * NEXTORIGIN
		 * ==========
		 * var next_origin = nextorigin();
		 */
		var nextorigin = (function () {
		  var max = 20;
		  var ori = Math.floor(Math.random() * max);
		  return function (origin, failover) {
		    return origin.indexOf('pubsub.') > 0
		      && origin.replace(
		        'pubsub', 'ps' + (
		          failover ? utils.generateUUID().split('-')[0] :
		            (++ori < max ? ori : ori = 1)
		        )) || origin;
		  };
		})();
	
	
		/**
		 * Generate Subscription Channel List
		 * ==================================
		 * generate_channel_list(channels_object);
		 */
		function generate_channel_list(channels, nopresence) {
		  var list = [];
		  utils.each(channels, function (channel, status) {
		    if (nopresence) {
		      if (channel.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel);
		      }
		    } else {
		      if (status.subscribed) list.push(channel);
		    }
		  });
		  return list.sort();
		}
	
		/**
		 * Generate Subscription Channel Groups List
		 * ==================================
		 * generate_channel_group_list(channels_groups object);
		 */
		function generate_channel_group_list(channel_groups, nopresence) {
		  var list = [];
		  utils.each(channel_groups, function (channel_group, status) {
		    if (nopresence) {
		      if (channel_group.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel_group);
		      }
		    } else {
		      if (status.subscribed) list.push(channel_group);
		    }
		  });
		  return list.sort();
		}
	
		// PUBNUB READY TO CONNECT
		function ready() {
		  if (READY) return;
		  READY = 1;
		  utils.each(READY_BUFFER, function (connect) {
		    connect();
		  });
		}
	
		function PNmessage(args) {
		  var msg = args || { apns: {} };
	
		  msg['getPubnubMessage'] = function () {
		    var m = {};
	
		    if (Object.keys(msg['apns']).length) {
		      m['pn_apns'] = {
		        aps: {
		          alert: msg['apns']['alert'],
		          badge: msg['apns']['badge']
		        }
		      };
		      for (var k in msg['apns']) {
		        m['pn_apns'][k] = msg['apns'][k];
		      }
		      var exclude1 = ['badge', 'alert'];
		      for (var k in exclude1) {
		        delete m['pn_apns'][exclude1[k]];
		      }
		    }
	
		    if (msg['gcm']) {
		      m['pn_gcm'] = {
		        data: msg['gcm']
		      };
		    }
	
		    for (var k in msg) {
		      m[k] = msg[k];
		    }
		    var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];
		    for (var k in exclude) {
		      delete m[exclude[k]];
		    }
	
		    return m;
		  };
		  msg['publish'] = function () {
		    var m = msg.getPubnubMessage();
	
		    if (msg['pubnub'] && msg['channel']) {
		      msg['pubnub'].publish({
		        message: m,
		        channel: msg['channel'],
		        callback: msg['callback'],
		        error: msg['error']
		      });
		    }
		  };
		  return msg;
		}
	
		function PN_API(setup) {
		  var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING;
		  var SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND;
		  var KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND;
		  var TIME_CHECK = setup['timecheck'] || 0;
		  var NOLEAVE = setup['noleave'] || 0;
		  var PUBLISH_KEY = setup['publish_key'];
		  var SUBSCRIBE_KEY = setup['subscribe_key'];
		  var AUTH_KEY = setup['auth_key'] || '';
		  var SECRET_KEY = setup['secret_key'] || '';
		  var hmac_SHA256 = setup['hmac_SHA256'];
		  var SSL = setup['ssl'] ? 's' : '';
		  var ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com');
		  var STD_ORIGIN = nextorigin(ORIGIN);
		  var SUB_ORIGIN = nextorigin(ORIGIN);
		  var CONNECT = function () {
		  };
		  var PUB_QUEUE = [];
		  var CLOAK = true;
		  var TIME_DRIFT = 0;
		  var SUB_CALLBACK = 0;
		  var SUB_CHANNEL = 0;
		  var SUB_RECEIVER = 0;
		  var SUB_RESTORE = setup['restore'] || 0;
		  var SUB_BUFF_WAIT = 0;
		  var TIMETOKEN = 0;
		  var RESUMED = false;
		  var CHANNELS = {};
		  var CHANNEL_GROUPS = {};
		  var SUB_ERROR = function () {
		  };
		  var STATE = {};
		  var PRESENCE_HB_TIMEOUT = null;
		  var PRESENCE_HB = validate_presence_heartbeat(
		    setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']
		  );
		  var PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) - 1;
		  var PRESENCE_HB_RUNNING = false;
		  var NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'];
		  var COMPATIBLE_35 = setup['compatible_3.5'] || false;
		  var xdr = setup['xdr'];
		  var params = setup['params'] || {};
		  var error = setup['error'] || function () {};
		  var _is_online = setup['_is_online'] || function () { return 1;};
		  var jsonp_cb = setup['jsonp_cb'] || function () { return 0; };
		  var db = setup['db'] || { get: function () {}, set: function () {} };
		  var CIPHER_KEY = setup['cipher_key'];
		  var UUID = setup['uuid'] || (!setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '');
		  var USE_INSTANCEID = setup['instance_id'] || false;
		  var INSTANCEID = '';
		  var shutdown = setup['shutdown'];
		  var use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined') ? setup['use_send_beacon'] : true;
		  var sendBeacon = (use_send_beacon) ? setup['sendBeacon'] : null;
		  var _poll_timer;
		  var _poll_timer2;
	
		  if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;
	
		  var crypto_obj = setup['crypto_obj'] || {
		    encrypt: function (a, key) {
		      return a;
		    },
		    decrypt: function (b, key) {
		      return b;
		    }
		  };
	
		  function _get_url_params(data) {
		    if (!data) data = {};
		    utils.each(params, function (key, value) {
		      if (!(key in data)) data[key] = value;
		    });
		    return data;
		  }
	
		  function _object_to_key_list(o) {
		    var l = [];
		    utils.each(o, function (key, value) {
		      l.push(key);
		    });
		    return l;
		  }
	
		  function _object_to_key_list_sorted(o) {
		    return _object_to_key_list(o).sort();
		  }
	
		  function _get_pam_sign_input_from_params(params) {
		    var si = '';
		    var l = _object_to_key_list_sorted(params);
	
		    for (var i in l) {
		      var k = l[i];
		      si += k + '=' + utils.pamEncode(params[k]);
		      if (i != l.length - 1) si += '&';
		    }
		    return si;
		  }
	
		  function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {
		    var err = false;
	
		    if (typeof heartbeat === 'undefined') {
		      return cur_heartbeat;
		    }
	
		    if (typeof heartbeat === 'number') {
		      if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) {
		        err = false;
		      } else {
		        err = true;
		      }
		    } else if (typeof heartbeat === 'boolean') {
		      if (!heartbeat) {
		        return 0;
		      } else {
		        return PRESENCE_HB_DEFAULT;
		      }
		    } else {
		      err = true;
		    }
	
		    if (err) {
		      error && error('Presence Heartbeat value invalid. Valid range ( x > ' + PRESENCE_HB_THRESHOLD + ' or x = 0). Current Value : ' + (cur_heartbeat || PRESENCE_HB_THRESHOLD));
		      return cur_heartbeat || PRESENCE_HB_THRESHOLD;
		    } else return heartbeat;
		  }
	
		  function encrypt(input, key) {
		    return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;
		  }
	
		  function decrypt(input, key) {
		    return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||
		      crypto_obj['decrypt'](input, CIPHER_KEY) ||
		      input;
		  }
	
		  function error_common(message, callback) {
		    callback && callback({ error: message || 'error occurred' });
		    error && error(message);
		  }
	
		  function _presence_heartbeat() {
		    clearTimeout(PRESENCE_HB_TIMEOUT);
	
		    if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||
		      PRESENCE_HB_INTERVAL < 1 ||
		      (!generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length)) {
		      PRESENCE_HB_RUNNING = false;
		      return;
		    }
	
		    PRESENCE_HB_RUNNING = true;
		    SELF['presence_heartbeat']({
		      callback: function (r) {
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      },
		      error: function (e) {
		        error && error('Presence Heartbeat unable to reach Pubnub servers.' + JSON.stringify(e));
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      }
		    });
		  }
	
		  function start_presence_heartbeat() {
		    !PRESENCE_HB_RUNNING && _presence_heartbeat();
		  }
	
		  function publish(next) {
		    if (NO_WAIT_FOR_PENDING) {
		      if (!PUB_QUEUE.length) return;
		    } else {
		      if (next) PUB_QUEUE.sending = 0;
		      if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;
		      PUB_QUEUE.sending = 1;
		    }
	
		    xdr(PUB_QUEUE.shift());
		  }
	
		  function each_channel_group(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {
		      var chang = CHANNEL_GROUPS[channel_group];
	
		      if (!chang) return;
	
		      count++;
		      (callback || function () {
		      })(chang);
		    });
	
		    return count;
		  }
	
		  function each_channel(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_list(CHANNELS), function (channel) {
		      var chan = CHANNELS[channel];
	
		      if (!chan) return;
	
		      count++;
		      (callback || function () {
		      })(chan);
		    });
	
		    return count;
		  }
	
		  function _invoke_callback(response, callback, err) {
		    if (typeof response == 'object') {
		      if (response['error']) {
		        var callback_data = {};
	
		        if (response['message']) {
		          callback_data['message'] = response['message'];
		        }
	
		        if (response['payload']) {
		          callback_data['payload'] = response['payload'];
		        }
	
		        err && err(callback_data);
		        return;
		      }
		      if (response['payload']) {
		        if (response['next_page']) {
		          callback && callback(response['payload'], response['next_page']);
		        } else {
		          callback && callback(response['payload']);
		        }
		        return;
		      }
		    }
		    callback && callback(response);
		  }
	
		  function _invoke_error(response, err) {
		    if (typeof response == 'object' && response['error']) {
		      var callback_data = {};
	
		      if (response['message']) {
		        callback_data['message'] = response['message'];
		      }
	
		      if (response['payload']) {
		        callback_data['payload'] = response['payload'];
		      }
	
		      err && err(callback_data);
		      return;
		    } else {
		      err && err(response);
		    }
		  }
	
		  function CR(args, callback, url1, data) {
		    var callback = args['callback'] || callback;
		    var err = args['error'] || error;
		    var jsonp = jsonp_cb();
	
		    data = data || {};
	
		    if (!data['auth']) {
		      data['auth'] = args['auth_key'] || AUTH_KEY;
		    }
	
		    var url = [
		      STD_ORIGIN, 'v1', 'channel-registration',
		      'sub-key', SUBSCRIBE_KEY
		    ];
	
		    url.push.apply(url, url1);
	
		    if (jsonp) data['callback'] = jsonp;
	
		    xdr({
		      callback: jsonp,
		      data: _get_url_params(data),
		      success: function (response) {
		        _invoke_callback(response, callback, err);
		      },
		      fail: function (response) {
		        _invoke_error(response, err);
		      },
		      url: url
		    });
		  }
	
		  // Announce Leave Event
		  var SELF = {
		    LEAVE: function (channel, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var url;
		      var params;
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel
		      if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(channel), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    LEAVE_GROUP: function (channel_group, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var url;
		      var params;
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel Group
		      if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(','), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    set_resumed: function (resumed) {
		      RESUMED = resumed;
		    },
	
		    get_cipher_key: function () {
		      return CIPHER_KEY;
		    },
	
		    set_cipher_key: function (key) {
		      CIPHER_KEY = key;
		    },
	
		    raw_encrypt: function (input, key) {
		      return encrypt(input, key);
		    },
	
		    raw_decrypt: function (input, key) {
		      return decrypt(input, key);
		    },
	
		    get_heartbeat: function () {
		      return PRESENCE_HB;
		    },
	
		    set_heartbeat: function (heartbeat, heartbeat_interval) {
		      PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);
		      PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;
		      if (PRESENCE_HB == 2) {
		        PRESENCE_HB_INTERVAL = 1;
		      }
		      CONNECT();
		      _presence_heartbeat();
		    },
	
		    get_heartbeat_interval: function () {
		      return PRESENCE_HB_INTERVAL;
		    },
	
		    set_heartbeat_interval: function (heartbeat_interval) {
		      PRESENCE_HB_INTERVAL = heartbeat_interval;
		      _presence_heartbeat();
		    },
	
		    get_version: function () {
		      return SDK_VER;
		    },
	
		    getGcmMessageObject: function (obj) {
		      return {
		        data: obj
		      };
		    },
	
		    getApnsMessageObject: function (obj) {
		      var x = {
		        aps: { badge: 1, alert: '' }
		      };
		      for (var k in obj) {
		        k[x] = obj[k];
		      }
		      return x;
		    },
	
		    _add_param: function (key, val) {
		      params[key] = val;
		    },
	
		    channel_group: function (args, callback) {
		      var ns_ch = args['channel_group'];
		      var callback = callback || args['callback'];
		      var channels = args['channels'] || args['channel'];
		      var cloak = args['cloak'];
		      var namespace;
		      var channel_group;
		      var url = [];
		      var data = {};
		      var mode = args['mode'] || 'add';
	
	
		      if (ns_ch) {
		        var ns_ch_a = ns_ch.split(':');
	
		        if (ns_ch_a.length > 1) {
		          namespace = (ns_ch_a[0] === '*') ? null : ns_ch_a[0];
	
		          channel_group = ns_ch_a[1];
		        } else {
		          channel_group = ns_ch_a[0];
		        }
		      }
	
		      namespace && url.push('namespace') && url.push(utils.encode(namespace));
	
		      url.push('channel-group');
	
		      if (channel_group && channel_group !== '*') {
		        url.push(channel_group);
		      }
	
		      if (channels) {
		        if (utils.isArray(channels)) {
		          channels = channels.join(',');
		        }
		        data[mode] = channels;
		        data['cloak'] = (CLOAK) ? 'true' : 'false';
		      } else {
		        if (mode === 'remove') url.push('remove');
		      }
	
		      if (typeof cloak != 'undefined') data['cloak'] = (cloak) ? 'true' : 'false';
	
		      CR(args, callback, url, data);
		    },
	
		    channel_group_list_groups: function (args, callback) {
		      var namespace;
	
		      namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;
		      if (namespace) {
		        args['channel_group'] = namespace + ':*';
		      }
	
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_channels: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_group: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_add_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_cloak: function (args, callback) {
		      if (typeof args['cloak'] == 'undefined') {
		        callback(CLOAK);
		        return;
		      }
		      CLOAK = args['cloak'];
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_namespaces: function (args, callback) {
		      var url = ['namespace'];
		      CR(args, callback, url);
		    },
	
		    channel_group_remove_namespace: function (args, callback) {
		      var url = ['namespace', args['namespace'], 'remove'];
		      CR(args, callback, url);
		    },
	
		    /*
		     PUBNUB.history({
		     channel  : 'my_chat_channel',
		     limit    : 100,
		     callback : function(history) { }
		     });
		     */
		    history: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var count = args['count'] || args['limit'] || 100;
		      var reverse = args['reverse'] || 'false';
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var start = args['start'];
		      var end = args['end'];
		      var include_token = args['include_token'];
		      var string_msg_token = args['string_message_token'] || false;
		      var params = {};
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) return error('Missing Channel');
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      params['stringtoken'] = 'true';
		      params['count'] = count;
		      params['reverse'] = reverse;
		      params['auth'] = auth_key;
	
		      if (channel_group) {
		        params['channel-group'] = channel_group;
		        if (!channel) {
		          channel = ',';
		        }
		      }
		      if (jsonp) params['callback'] = jsonp;
		      if (start) params['start'] = start;
		      if (end) params['end'] = end;
		      if (include_token) params['include_token'] = 'true';
		      if (string_msg_token) params['string_message_token'] = 'true';
	
		      // Send Message
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(params),
		        success: function (response) {
		          if (typeof response == 'object' && response['error']) {
		            err({ message: response['message'], payload: response['payload'] });
		            return;
		          }
		          var messages = response[0];
		          var decrypted_messages = [];
		          for (var a = 0; a < messages.length; a++) {
		            if (include_token) {
		              var new_message = decrypt(messages[a]['message'], cipher_key);
		              var timetoken = messages[a]['timetoken'];
		              try {
		                decrypted_messages['push']({ message: JSON['parse'](new_message), timetoken: timetoken });
		              } catch (e) {
		                decrypted_messages['push'](({ message: new_message, timetoken: timetoken }));
		              }
		            } else {
		              var new_message = decrypt(messages[a], cipher_key);
		              try {
		                decrypted_messages['push'](JSON['parse'](new_message));
		              } catch (e) {
		                decrypted_messages['push']((new_message));
		              }
		            }
		          }
		          callback([decrypted_messages, response[1], response[2]]);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'history', 'sub-key',
		          SUBSCRIBE_KEY, 'channel', utils.encode(channel)
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.replay({
		     source      : 'my_channel',
		     destination : 'new_channel'
		     });
		     */
		    replay: function (args, callback) {
		      var callback = callback || args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var source = args['source'];
		      var destination = args['destination'];
		      var err = args['error'] || args['error'] || function () {};
		      var stop = args['stop'];
		      var start = args['start'];
		      var end = args['end'];
		      var reverse = args['reverse'];
		      var limit = args['limit'];
		      var jsonp = jsonp_cb();
		      var data = {};
		      var url;
	
		      // Check User Input
		      if (!source) return error('Missing Source Channel');
		      if (!destination) return error('Missing Destination Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Setup URL Params
		      if (jsonp != '0') data['callback'] = jsonp;
		      if (stop) data['stop'] = 'all';
		      if (reverse) data['reverse'] = 'true';
		      if (start) data['start'] = start;
		      if (end) data['end'] = end;
		      if (limit) data['count'] = limit;
	
		      data['auth'] = auth_key;
	
		      // Compose URL Parts
		      url = [
		        STD_ORIGIN, 'v1', 'replay',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        source, destination
		      ];
	
		      // Start (or Stop) Replay!
		      xdr({
		        callback: jsonp,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function () {
		          callback([0, 'Disconnected']);
		        },
		        url: url,
		        data: _get_url_params(data)
		      });
		    },
	
		    /*
		     PUBNUB.auth('AJFLKAJSDKLA');
		     */
		    auth: function (auth) {
		      AUTH_KEY = auth;
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.time(function(time){ });
		     */
		    time: function (callback) {
		      var jsonp = jsonp_cb();
	
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [STD_ORIGIN, 'time', jsonp],
		        success: function (response) {
		          callback(response[0]);
		        },
		        fail: function () {
		          callback(0);
		        }
		      });
		    },
	
		    /*
		     PUBNUB.publish({
		     channel : 'my_chat_channel',
		     message : 'hello!'
		     });
		     */
		    publish: function (args, callback) {
		      var msg = args['message'];
		      if (!msg) return error('Missing Message');
	
		      var callback = callback || args['callback'] || msg['callback'] || args['success'] || function () {};
		      var channel = args['channel'] || msg['channel'];
		      var meta = args['meta'] || args['metadata'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var err = args['error'] || msg['error'] || function () {};
		      var post = args['post'] || false;
		      var store = ('store_in_history' in args) ? args['store_in_history'] : true;
		      var replicate = ('replicate' in args) ? args['replicate'] : true;
		      var jsonp = jsonp_cb();
		      var add_msg = 'push';
		      var params;
		      var url;
	
		      if (args['prepend']) add_msg = 'unshift';
	
		      if (!channel) return error('Missing Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (msg['getPubnubMessage']) {
		        msg = msg['getPubnubMessage']();
		      }
	
		      // If trying to send Object
		      msg = JSON['stringify'](encrypt(msg, cipher_key));
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'publish',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        0, utils.encode(channel),
		        jsonp, utils.encode(msg)
		      ];
	
		      params = { uuid: UUID, auth: auth_key };
	
		      if (meta && typeof meta === 'object') {
		        params['meta'] = JSON.stringify(meta);
		      }
	
		      if (!store) params['store'] = '0';
		      if (!replicate) params['norep'] = 'true';
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      // Queue Message Send
		      PUB_QUEUE[add_msg]({
		        callback: jsonp,
		        url: url,
		        data: _get_url_params(params),
		        fail: function (response) {
		          _invoke_error(response, err);
		          publish(1);
		        },
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		          publish(1);
		        },
		        mode: (post) ? 'POST' : 'GET'
		      });
	
		      // Send Message
		      publish();
		    },
	
		    fire: function (args, callback) {
		      args.store_in_history = false;
		      args.replicate = false;
		      SELF['publish'](args, callback);
		    },
	
		    /*
		     PUBNUB.unsubscribe({ channel : 'my_chat' });
		     */
		    unsubscribe: function (args, callback) {
		      var channelArg = args['channel'];
		      var channelGroupArg = args['channel_group'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var callback = callback || args['callback'] || function () {};
		      var err = args['error'] || function () {};
	
		      if (!channelArg && !channelGroupArg) return error('Missing Channel or Channel Group');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (channelArg) {
		        var channels = utils.isArray(channelArg) ? channelArg : ('' + channelArg).split(',');
		        var existingChannels = [];
		        var presenceChannels = [];
	
		        utils.each(channels, function (channel) {
		          if (CHANNELS[channel]) existingChannels.push(channel);
		        });
	
		        // if we do not have any channels to unsubscribe from, trigger a callback.
		        if (existingChannels.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannels, function (channel) {
		          presenceChannels.push(channel + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannels.concat(presenceChannels), function (channel) {
		          if (channel in CHANNELS) delete CHANNELS[channel];
		          if (channel in STATE) delete STATE[channel];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE'](existingChannels.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      if (channelGroupArg) {
		        var channelGroups = utils.isArray(channelGroupArg) ? channelGroupArg : ('' + channelGroupArg).split(',');
		        var existingChannelGroups = [];
		        var presenceChannelGroups = [];
	
		        utils.each(channelGroups, function (channelGroup) {
		          if (CHANNEL_GROUPS[channelGroup]) existingChannelGroups.push(channelGroup);
		        });
	
		        // if we do not have any channel groups to unsubscribe from, trigger a callback.
		        if (existingChannelGroups.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannelGroups, function (channelGroup) {
		          presenceChannelGroups.push(channelGroup + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannelGroups.concat(presenceChannelGroups), function (channelGroup) {
		          if (channelGroup in CHANNEL_GROUPS) delete CHANNEL_GROUPS[channelGroup];
		          if (channelGroup in STATE) delete STATE[channelGroup];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE_GROUP'](existingChannelGroups.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      // Reset Connection if Count Less
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.subscribe({
		     channel  : 'my_chat'
		     callback : function(message) { }
		     });
		     */
		    subscribe: function (args, callback) {
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var callback = callback || args['callback'];
		      var callback = callback || args['message'];
		      var connect = args['connect'] || function () {};
		      var reconnect = args['reconnect'] || function () {};
		      var disconnect = args['disconnect'] || function () {};
		      var SUB_ERROR = args['error'] || SUB_ERROR || function () {};
		      var idlecb = args['idle'] || function () {};
		      var presence = args['presence'] || 0;
		      var noheresync = args['noheresync'] || 0;
		      var backfill = args['backfill'] || 0;
		      var timetoken = args['timetoken'] || 0;
		      var sub_timeout = args['timeout'] || SUB_TIMEOUT;
		      var windowing = args['windowing'] || SUB_WINDOWING;
		      var state = args['state'];
		      var heartbeat = args['heartbeat'] || args['pnexpires'];
		      var heartbeat_interval = args['heartbeat_interval'];
		      var restore = args['restore'] || SUB_RESTORE;
	
		      AUTH_KEY = args['auth_key'] || AUTH_KEY;
	
		      // Restore Enabled?
		      SUB_RESTORE = restore;
	
		      // Always Reset the TT
		      TIMETOKEN = timetoken;
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) {
		        return error('Missing Channel');
		      }
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {
		        SELF['set_heartbeat'](heartbeat, heartbeat_interval);
		      }
	
		      // Setup Channel(s)
		      if (channel) {
		        utils.each((channel.join ? channel.join(',') : '' + channel).split(','),
		          function (channel) {
		            var settings = CHANNELS[channel] || {};
	
		            // Store Channel State
		            CHANNELS[SUB_CHANNEL = channel] = {
		              name: channel,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            if (state) {
		              if (channel in state) {
		                STATE[channel] = state[channel];
		              } else {
		                STATE[channel] = state;
		              }
		            }
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel: channel + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel: channel,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel);
		                });
		              }
		            });
		          });
		      }
	
		      // Setup Channel Groups
		      if (channel_group) {
		        utils.each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','),
		          function (channel_group) {
		            var settings = CHANNEL_GROUPS[channel_group] || {};
	
		            CHANNEL_GROUPS[channel_group] = {
		              name: channel_group,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel_group: channel_group + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore,
		              auth_key: AUTH_KEY
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel_group: channel_group,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel_group);
		                });
		              }
		            });
		          });
		      }
	
	
		      // Test Network Connection
		      function _test_connection(success) {
		        if (success) {
		          // Begin Next Socket Connection
		          utils.timeout(CONNECT, windowing);
		        } else {
		          // New Origin on Failed Connection
		          STD_ORIGIN = nextorigin(ORIGIN, 1);
		          SUB_ORIGIN = nextorigin(ORIGIN, 1);
	
		          // Re-test Connection
		          utils.timeout(function () {
		            SELF['time'](_test_connection);
		          }, SECOND);
		        }
	
		        // Disconnect & Reconnect
		        each_channel(function (channel) {
		          // Reconnect
		          if (success && channel.disconnected) {
		            channel.disconnected = 0;
		            return channel.reconnect(channel.name);
		          }
	
		          // Disconnect
		          if (!success && !channel.disconnected) {
		            channel.disconnected = 1;
		            channel.disconnect(channel.name);
		          }
		        });
	
		        // Disconnect & Reconnect for channel groups
		        each_channel_group(function (channel_group) {
		          // Reconnect
		          if (success && channel_group.disconnected) {
		            channel_group.disconnected = 0;
		            return channel_group.reconnect(channel_group.name);
		          }
	
		          // Disconnect
		          if (!success && !channel_group.disconnected) {
		            channel_group.disconnected = 1;
		            channel_group.disconnect(channel_group.name);
		          }
		        });
		      }
	
		      // Evented Subscribe
		      function _connect() {
		        var jsonp = jsonp_cb();
		        var channels = generate_channel_list(CHANNELS).join(',');
		        var channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');
	
		        // Stop Connection
		        if (!channels && !channel_groups) return;
	
		        if (!channels) channels = ',';
	
		        // Connect to PubNub Subscribe Servers
		        _reset_offline();
	
		        var data = _get_url_params({ uuid: UUID, auth: AUTH_KEY });
	
		        if (channel_groups) {
		          data['channel-group'] = channel_groups;
		        }
	
	
		        var st = JSON.stringify(STATE);
		        if (st.length > 2) data['state'] = JSON.stringify(STATE);
	
		        if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;
	
		        if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		        start_presence_heartbeat();
		        SUB_RECEIVER = xdr({
		          timeout: sub_timeout,
		          callback: jsonp,
		          fail: function (response) {
		            if (response && response['error'] && response['service']) {
		              _invoke_error(response, SUB_ERROR);
		              _test_connection(false);
		            } else {
		              SELF['time'](function (success) {
		                !success && (_invoke_error(response, SUB_ERROR));
		                _test_connection(success);
		              });
		            }
		          },
		          data: _get_url_params(data),
		          url: [
		            SUB_ORIGIN, 'subscribe',
		            SUBSCRIBE_KEY, utils.encode(channels),
		            jsonp, TIMETOKEN
		          ],
		          success: function (messages) {
		            // Check for Errors
		            if (!messages || (typeof messages == 'object' && 'error' in messages && messages['error'])) {
		              SUB_ERROR(messages);
		              return utils.timeout(CONNECT, SECOND);
		            }
	
		            // User Idle Callback
		            idlecb(messages[1]);
	
		            // Restore Previous Connection Point if Needed
		            TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];
	
		            /*
		             // Connect
		             each_channel_registry(function(registry){
		             if (registry.connected) return;
		             registry.connected = 1;
		             registry.connect(channel.name);
		             });
		             */
	
		            // Connect
		            each_channel(function (channel) {
		              if (channel.connected) return;
		              channel.connected = 1;
		              channel.connect(channel.name);
		            });
	
		            // Connect for channel groups
		            each_channel_group(function (channel_group) {
		              if (channel_group.connected) return;
		              channel_group.connected = 1;
		              channel_group.connect(channel_group.name);
		            });
	
		            if (RESUMED && !SUB_RESTORE) {
		              TIMETOKEN = 0;
		              RESUMED = false;
		              // Update Saved Timetoken
		              db['set'](SUBSCRIBE_KEY, 0);
		              utils.timeout(_connect, windowing);
		              return;
		            }
	
		            // Invoke Memory Catchup and Receive Up to 100
		            // Previous Messages from the Queue.
		            if (backfill) {
		              TIMETOKEN = 10000;
		              backfill = 0;
		            }
	
		            // Update Saved Timetoken
		            db['set'](SUBSCRIBE_KEY, messages[1]);
	
		            // Route Channel <---> Callback for Message
		            var next_callback = (function () {
		              var channels = '';
		              var channels2 = '';
	
		              if (messages.length > 3) {
		                channels = messages[3];
		                channels2 = messages[2];
		              } else if (messages.length > 2) {
		                channels = messages[2];
		              } else {
		                channels = utils.map(
		                  generate_channel_list(CHANNELS), function (chan) {
		                    return utils.map(
		                      Array(messages[0].length)
		                        .join(',').split(','),
		                      function () {
		                        return chan;
		                      }
		                    );
		                  }).join(',');
		              }
	
		              var list = channels.split(',');
		              var list2 = (channels2) ? channels2.split(',') : [];
	
		              return function () {
		                var channel = list.shift() || SUB_CHANNEL;
		                var channel2 = list2.shift();
	
		                var chobj = {};
	
		                if (channel2) {
		                  if (channel && channel.indexOf('-pnpres') >= 0
		                    && channel2.indexOf('-pnpres') < 0) {
		                    channel2 += '-pnpres';
		                  }
		                  chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { callback: function () {} };
		                } else {
		                  chobj = CHANNELS[channel];
		                }
	
		                var r = [
		                  chobj
		                    .callback || SUB_CALLBACK,
		                  channel.split(PRESENCE_SUFFIX)[0]
		                ];
		                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);
		                return r;
		              };
		            })();
	
		            var latency = detect_latency(+messages[1]);
		            utils.each(messages[0], function (msg) {
		              var next = next_callback();
		              var decrypted_msg = decrypt(msg,
		                (CHANNELS[next[1]]) ? CHANNELS[next[1]]['cipher_key'] : null);
		              next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);
		            });
	
		            utils.timeout(_connect, windowing);
		          }
		        });
		      }
	
		      CONNECT = function () {
		        _reset_offline();
		        utils.timeout(_connect, windowing);
		      };
	
		      // Reduce Status Flicker
		      if (!READY) return READY_BUFFER.push(CONNECT);
	
		      // Connect Now
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.here_now({ channel : 'my_chat', callback : fun });
		     */
		    here_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var debug = args['debug'];
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var uuids = ('uuids' in args) ? args['uuids'] : true;
		      var state = args['state'];
		      var data = { uuid: UUID, auth: auth_key };
	
		      if (!uuids) data['disable_uuids'] = 1;
		      if (state) data['state'] = 1;
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      var url = [
		        STD_ORIGIN, 'v2', 'presence',
		        'sub_key', SUBSCRIBE_KEY
		      ];
	
		      channel && url.push('channel') && url.push(utils.encode(channel));
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (channel_group) {
		        data['channel-group'] = channel_group;
		        !channel && url.push('channel') && url.push(',');
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        debug: debug,
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });
		     */
		    where_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var uuid = args['uuid'] || UUID;
		      var data = { auth: auth_key };
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub_key', SUBSCRIBE_KEY,
		          'uuid', utils.encode(uuid)
		        ]
		      });
		    },
	
		    state: function (args, callback) {
		      var callback = args['callback'] || callback || function (r) {};
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var state = args['state'];
		      var uuid = args['uuid'] || UUID;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var url;
		      var data = _get_url_params({ auth: auth_key });
	
		      // Make sure we have a Channel
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!uuid) return error('Missing UUID');
		      if (!channel && !channel_group) return error('Missing Channel');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (typeof channel != 'undefined'
		        && CHANNELS[channel] && CHANNELS[channel].subscribed) {
		        if (state) STATE[channel] = state;
		      }
	
		      if (typeof channel_group != 'undefined'
		        && CHANNEL_GROUPS[channel_group]
		        && CHANNEL_GROUPS[channel_group].subscribed
		      ) {
		        if (state) STATE[channel_group] = state;
		        data['channel-group'] = channel_group;
	
		        if (!channel) {
		          channel = ',';
		        }
		      }
	
		      data['state'] = JSON.stringify(state);
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      if (state) {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', uuid, 'data'
		        ];
		      } else {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', utils.encode(uuid)
		        ];
		      }
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
	
		      });
		    },
	
		    /*
		     PUBNUB.grant({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     ttl      : 24 * 60, // Minutes
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    grant: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'] || args['channels'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var ttl = args['ttl'];
		      var r = (args['read']) ? '1' : '0';
		      var w = (args['write']) ? '1' : '0';
		      var m = (args['manage']) ? '1' : '0';
		      var auth_key = args['auth_key'] || args['auth_keys'];
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'grant' + '\n';
	
		      var data = { w: w, r: r, timestamp: timestamp };
	
		      if (args['manage']) {
		        data['m'] = m;
		      }
		      if (utils.isArray(channel)) {
		        channel = channel['join'](',');
		      }
		      if (utils.isArray(auth_key)) {
		        auth_key = auth_key['join'](',');
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (ttl || ttl === 0) data['ttl'] = ttl;
	
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
	
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'grant',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.mobile_gw_provision ({
		     device_id: 'A655FBA9931AB',
		     op       : 'add' | 'remove',
		     gw_type  : 'apns' | 'gcm',
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     });
		     */
	
		    mobile_gw_provision: function (args) {
		      var callback = args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var channel = args['channel'];
		      var op = args['op'];
		      var gw_type = args['gw_type'];
		      var device_id = args['device_id'];
		      var params;
		      var url;
	
		      if (!device_id) return error('Missing Device ID (device_id)');
		      if (!gw_type) return error('Missing GW Type (gw_type: gcm or apns)');
		      if (!op) return error('Missing GW Operation (op: add or remove)');
		      if (!channel) return error('Missing gw destination Channel (channel)');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'v1/push/sub-key',
		        SUBSCRIBE_KEY, 'devices', device_id
		      ];
	
		      params = { uuid: UUID, auth: auth_key, type: gw_type };
	
		      if (op == 'add') {
		        params['add'] = channel;
		      } else if (op == 'remove') {
		        params['remove'] = channel;
		      }
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.audit({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    audit: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var auth_key = args['auth_key'];
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'audit' + '\n';
	
		      var data = { timestamp: timestamp };
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'audit',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.revoke({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    revoke: function (args, callback) {
		      args['read'] = false;
		      args['write'] = false;
		      SELF['grant'](args, callback);
		    },
	
		    set_uuid: function (uuid) {
		      UUID = uuid;
		      CONNECT();
		    },
	
		    get_uuid: function () {
		      return UUID;
		    },
	
		    isArray: function (arg) {
		      return utils.isArray(arg);
		    },
	
		    get_subscribed_channels: function () {
		      return generate_channel_list(CHANNELS, true);
		    },
	
		    presence_heartbeat: function (args) {
		      var callback = args['callback'] || function () {};
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      var st = JSON['stringify'](STATE);
		      if (st.length > 2) data['state'] = JSON['stringify'](STATE);
	
		      if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      var channels = utils.encode(generate_channel_list(CHANNELS, true)['join'](','));
		      var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');
	
		      if (!channels) channels = ',';
		      if (channel_groups) data['channel-group'] = channel_groups;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channels,
		          'heartbeat'
		        ],
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        }
		      });
		    },
	
		    stop_timers: function () {
		      clearTimeout(_poll_timer);
		      clearTimeout(_poll_timer2);
		      clearTimeout(PRESENCE_HB_TIMEOUT);
		    },
	
		    shutdown: function () {
		      SELF['stop_timers']();
		      shutdown && shutdown();
		    },
	
		    // Expose PUBNUB Functions
		    xdr: xdr,
		    ready: ready,
		    db: db,
		    uuid: utils.generateUUID,
		    map: utils.map,
		    each: utils.each,
		    'each-channel': each_channel,
		    grep: utils.grep,
		    offline: function () {
		      _reset_offline(1, { message: 'Offline. Please check your network settings.' });
		    },
		    supplant: utils.supplant,
		    now: utils.rnow,
		    unique: unique,
		    updater: utils.updater
		  };
	
		  function _poll_online() {
		    _is_online() || _reset_offline(1, { error: 'Offline. Please check your network settings.' });
		    _poll_timer && clearTimeout(_poll_timer);
		    _poll_timer = utils.timeout(_poll_online, SECOND);
		  }
	
		  function _poll_online2() {
		    if (!TIME_CHECK) return;
		    SELF['time'](function (success) {
		      detect_time_detla(function () {
		      }, success);
		      success || _reset_offline(1, {
		        error: 'Heartbeat failed to connect to Pubnub Servers.' +
		        'Please check your network settings.'
		      });
		      _poll_timer2 && clearTimeout(_poll_timer2);
		      _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		    });
		  }
	
		  function _reset_offline(err, msg) {
		    SUB_RECEIVER && SUB_RECEIVER(err, msg);
		    SUB_RECEIVER = null;
	
		    clearTimeout(_poll_timer);
		    clearTimeout(_poll_timer2);
		  }
	
		  if (!UUID) UUID = SELF['uuid']();
		  if (!INSTANCEID) INSTANCEID = SELF['uuid']();
		  db['set'](SUBSCRIBE_KEY + 'uuid', UUID);
	
		  _poll_timer = utils.timeout(_poll_online, SECOND);
		  _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		  PRESENCE_HB_TIMEOUT = utils.timeout(
		    start_presence_heartbeat,
		    (PRESENCE_HB_INTERVAL - 3) * SECOND
		  );
	
		  // Detect Age of Message
		  function detect_latency(tt) {
		    var adjusted_time = utils.rnow() - TIME_DRIFT;
		    return adjusted_time - tt / 10000;
		  }
	
		  detect_time_detla();
		  function detect_time_detla(cb, time) {
		    var stime = utils.rnow();
	
		    time && calculate(time) || SELF['time'](calculate);
	
		    function calculate(time) {
		      if (!time) return;
		      var ptime = time / 10000;
		      var latency = (utils.rnow() - stime) / 2;
		      TIME_DRIFT = utils.rnow() - (ptime + latency);
		      cb && cb(TIME_DRIFT);
		    }
		  }
	
		  return SELF;
		}
	
		module.exports = {
		  PN_API: PN_API,
		  unique: unique,
		  PNmessage: PNmessage,
		  DEF_TIMEOUT: DEF_TIMEOUT,
		  timeout: utils.timeout,
		  build_url: utils.buildURL,
		  each: utils.each,
		  uuid: utils.generateUUID,
		  URLBIT: defaultConfiguration.URLBIT,
		  grep: utils.grep,
		  supplant: utils.supplant,
		  now: utils.rnow,
		  updater: utils.updater,
		  map: utils.map
		};
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		module.exports = {
			"PARAMSBIT": "&",
			"URLBIT": "/"
		};
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint no-unused-expressions: 0, block-scoped-var: 0, no-redeclare: 0, guard-for-in: 0 */
	
		var defaultConfiguration = __webpack_require__(3);
		var REPL = /{([\w\-]+)}/g;
	
		function rnow() {
		  return +new Date;
		}
	
		function isArray(arg) {
		  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === 'number');
		  // return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === "number")
		}
	
		/**
		 * EACH
		 * ====
		 * each( [1,2,3], function(item) { } )
		 */
		function each(o, f) {
		  if (!o || !f) {
		    return;
		  }
	
		  if (isArray(o)) {
		    for (var i = 0, l = o.length; i < l;) {
		      f.call(o[i], o[i], i++);
		    }
		  } else {
		    for (var i in o) {
		      o.hasOwnProperty &&
		      o.hasOwnProperty(i) &&
		      f.call(o[i], i, o[i]);
		    }
		  }
		}
	
		/**
		 * ENCODE
		 * ======
		 * var encoded_data = encode('path');
		 */
		function encode(path) { return encodeURIComponent(path); }
	
		/**
		 * Build Url
		 * =======
		 *
		 */
		function buildURL(urlComponents, urlParams) {
		  var url = urlComponents.join(defaultConfiguration.URLBIT);
		  var params = [];
	
		  if (!urlParams) return url;
	
		  each(urlParams, function (key, value) {
		    var valueStr = (typeof value === 'object') ? JSON['stringify'](value) : value;
		    (typeof value !== 'undefined' &&
		      value !== null && encode(valueStr).length > 0
		    ) && params.push(key + '=' + encode(valueStr));
		  });
	
		  url += '?' + params.join(defaultConfiguration.PARAMSBIT);
		  return url;
		}
	
		/**
		 * UPDATER
		 * =======
		 * var timestamp = unique();
		 */
		function updater(fun, rate) {
		  var timeout;
		  var last = 0;
		  var runnit = function () {
		    if (last + rate > rnow()) {
		      clearTimeout(timeout);
		      timeout = setTimeout(runnit, rate);
		    } else {
		      last = rnow();
		      fun();
		    }
		  };
	
		  return runnit;
		}
	
		/**
		 * GREP
		 * ====
		 * var list = grep( [1,2,3], function(item) { return item % 2 } )
		 */
		function grep(list, fun) {
		  var fin = [];
		  each(list || [], function (l) {
		    fun(l) && fin.push(l);
		  });
		  return fin;
		}
	
		/**
		 * SUPPLANT
		 * ========
		 * var text = supplant( 'Hello {name}!', { name : 'John' } )
		 */
		function supplant(str, values) {
		  return str.replace(REPL, function (_, match) {
		    return values[match] || _;
		  });
		}
	
		/**
		 * timeout
		 * =======
		 * timeout( function(){}, 100 );
		 */
		function timeout(fun, wait) {
		  if (typeof setTimeout === 'undefined') {
		    return;
		  }
	
		  return setTimeout(fun, wait);
		}
	
		/**
		 * uuid
		 * ====
		 * var my_uuid = generateUUID();
		 */
		function generateUUID(callback) {
		  var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		    function (c) {
		      var r = Math.random() * 16 | 0;
		      var v = c === 'x' ? r : (r & 0x3 | 0x8);
		      return v.toString(16);
		    });
		  if (callback) callback(u);
		  return u;
		}
	
		/**
		 * MAP
		 * ===
		 * var list = map( [1,2,3], function(item) { return item + 1 } )
		 */
		function map(list, fun) {
		  var fin = [];
		  each(list || [], function (k, v) {
		    fin.push(fun(k, v));
		  });
		  return fin;
		}
	
	
		function pamEncode(str) {
		  return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {
		    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		  });
		}
	
	
		module.exports = {
		  buildURL: buildURL,
		  encode: encode,
		  each: each,
		  updater: updater,
		  rnow: rnow,
		  isArray: isArray,
		  map: map,
		  pamEncode: pamEncode,
		  generateUUID: generateUUID,
		  timeout: timeout,
		  supplant: supplant,
		  grep: grep
		};
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0 eqeqeq: 0 */
	
		var CryptoJS = __webpack_require__(6);
	
		function crypto_obj() {
		  function SHA256(s) {
		    return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);
		  }
	
		  var iv = '0123456789012345';
	
		  var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];
		  var allowedKeyLengths = [128, 256];
		  var allowedModes = ['ecb', 'cbc'];
	
		  var defaultOptions = {
		    encryptKey: true,
		    keyEncoding: 'utf8',
		    keyLength: 256,
		    mode: 'cbc'
		  };
	
		  function parse_options(options) {
		    // Defaults
		    options = options || {};
		    if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];
		    if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];
		    if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];
	
		    // Validation
		    if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];
		    if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];
	
		    return options;
		  }
	
		  function decode_key(key, options) {
		    if (options['keyEncoding'] === 'base64') {
		      return CryptoJS['enc']['Base64']['parse'](key);
		    } else if (options['keyEncoding'] === 'hex') {
		      return CryptoJS['enc']['Hex']['parse'](key);
		    } else {
		      return key;
		    }
		  }
	
		  function get_padded_key(key, options) {
		    key = decode_key(key, options);
		    if (options['encryptKey']) {
		      return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));
		    } else {
		      return key;
		    }
		  }
	
		  function get_mode(options) {
		    if (options['mode'] === 'ecb') {
		      return CryptoJS['mode']['ECB'];
		    } else {
		      return CryptoJS['mode']['CBC'];
		    }
		  }
	
		  function get_iv(options) {
		    return (options['mode'] === 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;
		  }
	
		  return {
		    encrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      var hex_message = JSON['stringify'](data);
		      var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, { iv: iv, mode: mode })['ciphertext'];
		      var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);
		      return base_64_encrypted || data;
		    },
	
		    decrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      try {
		        var binary_enc = CryptoJS['enc']['Base64']['parse'](data);
		        var json_plain = CryptoJS['AES']['decrypt']({ ciphertext: binary_enc }, cipher_key, { iv: iv, mode: mode })['toString'](CryptoJS['enc']['Utf8']);
		        var plaintext = JSON['parse'](json_plain);
		        return plaintext;
		      } catch (e) {
		        return undefined;
		      }
		    }
		  };
		}
	
		module.exports = crypto_obj;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/*
		 CryptoJS v3.1.2
		 code.google.com/p/crypto-js
		 (c) 2009-2013 by Jeff Mott. All rights reserved.
		 code.google.com/p/crypto-js/wiki/License
		 */
		var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
		    r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
		      32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
		        2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
		    u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
		      a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
		    d)).finalize(c)}}});var t=f.algo={};return f}(Math);
	
		// SHA256
		(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
		  c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
		  d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
	
		// HMAC SHA256
		(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
		  this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();
	
		// Base64
		(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
		l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
	
		// BlockCipher
		(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
		  _doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
		    f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
		      m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
		      E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
		    4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
		(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
		  l)}})();
	
		// Cipher
		CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
		  finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
		  c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
		  e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
		  this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
		  1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
		  decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
		  b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
	
		// AES
		(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
		  16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
		8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
		  d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
	
		// Mode ECB
		CryptoJS.mode.ECB = (function () {
		  var ECB = CryptoJS.lib.BlockCipherMode.extend();
	
		  ECB.Encryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.encryptBlock(words, offset);
		    }
		  });
	
		  ECB.Decryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.decryptBlock(words, offset);
		    }
		  });
	
		  return ECB;
		}());
	
		module.exports = CryptoJS;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET INTERFACE
		// ---------------------------------------------------------------------------
		var WS = function( url, protocols ) {
		  if (!(this instanceof WS)) return new WS( url, protocols );
	
		  var self     = this
		    ,   url      = self.url      = url || ''
		    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'
		    ,   bits     = url.split('/')
		    ,   setup    = {
		    'ssl'           : bits[0] === 'wss:'
		    ,'origin'        : bits[2]
		    ,'publish_key'   : bits[3]
		    ,'subscribe_key' : bits[4]
		    ,'channel'       : bits[5]
		  };
	
		  // READY STATES
		  self['CONNECTING'] = 0; // The connection is not yet open.
		  self['OPEN']       = 1; // The connection is open and ready to communicate.
		  self['CLOSING']    = 2; // The connection is in the process of closing.
		  self['CLOSED']     = 3; // The connection is closed or couldn't be opened.
	
		  // CLOSE STATES
		  self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.
		  self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.
		  self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.
		  self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.
		  self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.
		  self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.
		  self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.
	
		  // Events Default
		  self['onclose']   = self['onerror'] =
		    self['onmessage'] = self['onopen']  =
		      self['onsend']    =  function(){};
	
		  // Attributes
		  self['binaryType']     = '';
		  self['extensions']     = '';
		  self['bufferedAmount'] = 0;
		  self['trasnmitting']   = false;
		  self['buffer']         = [];
		  self['readyState']     = self['CONNECTING'];
	
		  // Close if no setup.
		  if (!url) {
		    self['readyState'] = self['CLOSED'];
		    self['onclose']({
		      'code'     : self['CLOSE_ABNORMAL'],
		      'reason'   : 'Missing URL',
		      'wasClean' : true
		    });
		    return self;
		  }
	
		  // PubNub WebSocket Emulation
		  self.pubnub       = PUBNUB['init'](setup);
		  self.pubnub.setup = setup;
		  self.setup        = setup;
	
		  self.pubnub['subscribe']({
		    'restore'    : false,
		    'channel'    : setup['channel'],
		    'disconnect' : self['onerror'],
		    'reconnect'  : self['onopen'],
		    'error'      : function() {
		      self['onclose']({
		        'code'     : self['CLOSE_ABNORMAL'],
		        'reason'   : 'Missing URL',
		        'wasClean' : false
		      });
		    },
		    'callback'   : function(message) {
		      self['onmessage']({ 'data' : message });
		    },
		    'connect'    : function() {
		      self['readyState'] = self['OPEN'];
		      self['onopen']();
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET SEND
		// ---------------------------------------------------------------------------
		WS.prototype.send = function(data) {
		  var self = this;
		  self.pubnub['publish']({
		    'channel'  : self.pubnub.setup['channel'],
		    'message'  : data,
		    'callback' : function(response) {
		      self['onsend']({ 'data' : response });
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET CLOSE
		// ---------------------------------------------------------------------------
		WS.prototype.close = function() {
		  var self = this;
		  self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });
		  self['readyState'] = self['CLOSED'];
		  self['onclose']({});
		};
	
		module.exports = WS;
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Client"] = factory();
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["Client"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="./externals.d.ts" />
	"use strict";
	var accountClient = __webpack_require__(2);
	var callLogClient = __webpack_require__(40);
	var dictionaryClient = __webpack_require__(55);
	var extensionClient = __webpack_require__(70);
	var messagesClient = __webpack_require__(77);
	var notificationsClient = __webpack_require__(84);
	var presenceClient = __webpack_require__(87);
	var ringoutClient = __webpack_require__(93);
	var forwardingNumbersClient = __webpack_require__(96);
	var blockedNumbersClient = __webpack_require__(99);
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	        this._account = new accountClient.Account(sdk);
	        this._callLog = new callLogClient.CallLog(sdk);
	        this._dictionary = new dictionaryClient.Dictionary(sdk);
	        this._extension = new extensionClient.Extension(sdk);
	        this._messages = new messagesClient.Messages(sdk);
	        this._notifications = new notificationsClient.NotificationsSubscriptionAPI(sdk);
	        this._presence = new presenceClient.Presence(sdk);
	        this._ringout = new ringoutClient.RingOut(sdk);
	        this._forwardingNumbers = new forwardingNumbersClient.ForwardingNumbers(sdk);
	        this._blockedNumbers = new blockedNumbersClient.BlockedNumbers(sdk);
	    }
	    Client.prototype.account = function () { return this._account; };
	    Client.prototype.callLog = function () { return this._callLog; };
	    Client.prototype.dictionary = function () { return this._dictionary; };
	    Client.prototype.extension = function () { return this._extension; };
	    Client.prototype.messages = function () { return this._messages; };
	    Client.prototype.notifications = function () { return this._notifications; };
	    Client.prototype.presence = function () { return this._presence; };
	    Client.prototype.ringout = function () { return this._ringout; };
	    Client.prototype.forwardingNumbers = function () { return this._forwardingNumbers; };
	    Client.prototype.blockedNumbers = function () { return this._blockedNumbers; };
	    Client.version = '0.1.0';
	    return Client;
	}());
	module.exports = Client;
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountinfo = __webpack_require__(4);
	var accountbusinessaddress = __webpack_require__(28);
	var dialingplaninfo = __webpack_require__(30);
	var phonenumberinfo = __webpack_require__(34);
	var accountphonenumbers = __webpack_require__(36);
	var accountserviceinfo = __webpack_require__(37);
	var Account = (function (_super) {
	    __extends(Account, _super);
	    function Account() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Account
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Creates the account in Initial state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Accounts</td>
	     *             <td>Managing accounts: creating new accounts, viewing and updating account information, deleting existing accounts</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.createAccount = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account', options, exports.createAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccount = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}', options, exports.loadAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/business-address', options, exports.loadAccountBusinessAddressOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Update Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.updateAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/business-address', options, exports.updateAccountBusinessAddressOptions), accountbusinessaddress.AccountBusinessAddress);
	    };
	    /**
	     * Get Account Dialing Plan
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns list of countries which can be selected for a dialing plan (to call short numbers and special services).</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listDialingPlans = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/dialing-plan', options, exports.listDialingPlansOptions), dialingplaninfo.DialingPlanInfo);
	    };
	    /**
	     * Provision Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.11 (Release 6.3)</p>
	     * <p>Provisions a phone number.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.provisionPhoneNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.provisionPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers assigned to the RingCentral customer account. Both company-level and extension-level numbers are returned.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listAccountPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.listAccountPhoneNumbersOptions), accountphonenumbers.AccountPhoneNumbers);
	    };
	    /**
	     * Get Phone Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountPhoneNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number/{phoneNumberId}', options, exports.loadAccountPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Service Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the information about service plan, available features and limitations for a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadServiceInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/service-info', options, exports.loadServiceInfoOptions), accountserviceinfo.AccountServiceInfo);
	    };
	    return Account;
	}(client.Client));
	exports.Account = Account;
	/**
	 * Definition of options for createAccount operation
	 */
	exports.createAccountOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createaccountrequest.CreateAccountRequest"
	    }
	];
	/**
	 * Definition of options for loadAccount operation
	 */
	exports.loadAccountOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadAccountBusinessAddress operation
	 */
	exports.loadAccountBusinessAddressOptions = [];
	/**
	 * Definition of options for updateAccountBusinessAddress operation
	 */
	exports.updateAccountBusinessAddressOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "modifyaccountbusinessaddressrequest.ModifyAccountBusinessAddressRequest"
	    }
	];
	/**
	 * Definition of options for listDialingPlans operation
	 */
	exports.listDialingPlansOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for provisionPhoneNumber operation
	 */
	exports.provisionPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "provisionphonenumbers.ProvisionPhoneNumbers"
	    }
	];
	/**
	 * Definition of options for listAccountPhoneNumbers operation
	 */
	exports.listAccountPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "usageType",
	        "type": "IListAccountPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountPhoneNumber operation
	 */
	exports.loadAccountPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "phoneNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadServiceInfo operation
	 */
	exports.loadServiceInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	(function (IListAccountPhoneNumbersUsageType) {
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListAccountPhoneNumbersUsageType || (exports.IListAccountPhoneNumbersUsageType = {}));
	var IListAccountPhoneNumbersUsageType = exports.IListAccountPhoneNumbersUsageType;
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	    }
	    Client.prototype.parseOptions = function (method, url, options, operationParameters) {
	        options = options || {};
	        var request = {
	            url: url,
	            method: method,
	            query: {},
	            body: undefined
	        };
	        operationParameters.forEach(function (param) {
	            if (param.required && !param.default && !options.hasOwnProperty(param.name)) {
	                throw new Error('Required parameter "' + param.name + '" not found');
	            }
	            if (param.default && !options.hasOwnProperty(param.name)) {
	                options[param.name] = param.default;
	            }
	            if (param.in == 'path') {
	                request.url = request.url.replace('{' + param.name + '}', options[param.name]);
	            }
	            if (param.in == 'query' && options.hasOwnProperty(param.name)) {
	                request.query[param.name] = options[param.name];
	            }
	            if (param.in == 'body') {
	                request.body = options[param.name];
	            }
	        });
	        return request;
	    };
	    Client.prototype.send = function (apiOptions, Class) {
	        var _this = this;
	        return this._sdk.platform()
	            .send(apiOptions)
	            .then(function (res) {
	            //TODO Support multipart
	            //TODO Think how to pass headers&stuff to outside
	            if (Class && !res._isMultipart())
	                return new Class(_this._sdk, res.json());
	            return res;
	        });
	    };
	    return Client;
	}());
	exports.Client = Client;
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var serviceinfo = __webpack_require__(22);
	var accountstatusinfo = __webpack_require__(27);
	var AccountInfo = (function (_super) {
	    __extends(AccountInfo, _super);
	    function AccountInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'mainNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'operator', Class: extensioninfo.ExtensionInfo, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceInfo', Class: serviceinfo.ServiceInfo, isArray: false, isRequired: false },
	            { property: 'setupWizardState', Class: AccountInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: AccountInfoStatus, isArray: false, isRequired: false },
	            { property: 'statusInfo', Class: accountstatusinfo.AccountStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountInfo.prototype.getClassName = function () {
	        return 'AccountInfo';
	    };
	    return AccountInfo;
	}(model.Model));
	exports.AccountInfo = AccountInfo;
	(function (AccountInfoSetupWizardState) {
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.AccountInfoSetupWizardState || (exports.AccountInfoSetupWizardState = {}));
	var AccountInfoSetupWizardState = exports.AccountInfoSetupWizardState;
	(function (AccountInfoStatus) {
	    AccountInfoStatus[AccountInfoStatus["Confirmed"] = 'Confirmed'] = "Confirmed";
	    AccountInfoStatus[AccountInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	})(exports.AccountInfoStatus || (exports.AccountInfoStatus = {}));
	var AccountInfoStatus = exports.AccountInfoStatus;
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Model = (function () {
	    function Model(sdk, data) {
	        var _this = this;
	        this._sdk = sdk;
	        data = data || {};
	        this.getPropertyMappings().forEach(function (mapping) {
	            var Class = mapping.Class, prop = mapping.property;
	            if (!data.hasOwnProperty(prop)) {
	                if (mapping.isRequired)
	                    console.warn('Required property "' + prop + '" not defined');
	                return;
	            }
	            var processProperty = function (dataPart) {
	                if (!Class || typeof Class !== 'function') {
	                    return dataPart;
	                }
	                else {
	                    return new Class(_this._sdk, dataPart);
	                }
	            };
	            if (mapping.isArray) {
	                _this[prop] = data[prop].map(processProperty);
	            }
	            else {
	                _this[prop] = processProperty(data[prop]);
	            }
	        });
	    }
	    Model.prototype.getPropertyMappings = function () {
	        return [];
	    };
	    Model.prototype.getClassName = function () {
	        return 'Model';
	    };
	    Model.prototype.getId = function () {
	        return this['id'];
	    };
	    return Model;
	}());
	exports.Model = Model;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactinfo = __webpack_require__(7);
	var departmentinfo = __webpack_require__(9);
	var extensionpermissions = __webpack_require__(10);
	var profileimageinfo = __webpack_require__(12);
	var referenceinfo = __webpack_require__(13);
	var regionalsettings = __webpack_require__(14);
	var extensionservicefeatureinfo = __webpack_require__(20);
	var extensionstatusinfo = __webpack_require__(21);
	var ExtensionInfo = (function (_super) {
	    __extends(ExtensionInfo, _super);
	    function ExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'contact', Class: contactinfo.ContactInfo, isArray: false, isRequired: false },
	            { property: 'departments', Class: departmentinfo.DepartmentInfo, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'permissions', Class: extensionpermissions.ExtensionPermissions, isArray: false, isRequired: false },
	            { property: 'profileImage', Class: profileimageinfo.ProfileImageInfo, isArray: false, isRequired: true },
	            { property: 'references', Class: referenceinfo.ReferenceInfo, isArray: true, isRequired: false },
	            { property: 'regionalSettings', Class: regionalsettings.RegionalSettings, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: extensionservicefeatureinfo.ExtensionServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'setupWizardState', Class: ExtensionInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: ExtensionInfoStatus, isArray: false, isRequired: true },
	            { property: 'statusInfo', Class: extensionstatusinfo.ExtensionStatusInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoType, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionInfo.prototype.getClassName = function () {
	        return 'ExtensionInfo';
	    };
	    return ExtensionInfo;
	}(model.Model));
	exports.ExtensionInfo = ExtensionInfo;
	(function (ExtensionInfoSetupWizardState) {
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.ExtensionInfoSetupWizardState || (exports.ExtensionInfoSetupWizardState = {}));
	var ExtensionInfoSetupWizardState = exports.ExtensionInfoSetupWizardState;
	(function (ExtensionInfoStatus) {
	    ExtensionInfoStatus[ExtensionInfoStatus["Enabled"] = 'Enabled'] = "Enabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    ExtensionInfoStatus[ExtensionInfoStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.ExtensionInfoStatus || (exports.ExtensionInfoStatus = {}));
	var ExtensionInfoStatus = exports.ExtensionInfoStatus;
	(function (ExtensionInfoType) {
	    ExtensionInfoType[ExtensionInfoType["User"] = 'User'] = "User";
	    ExtensionInfoType[ExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    ExtensionInfoType[ExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoType[ExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoType[ExtensionInfoType["Department"] = 'Department'] = "Department";
	    ExtensionInfoType[ExtensionInfoType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoType[ExtensionInfoType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoType[ExtensionInfoType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoType[ExtensionInfoType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    ExtensionInfoType[ExtensionInfoType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoType[ExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoType[ExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.ExtensionInfoType || (exports.ExtensionInfoType = {}));
	var ExtensionInfoType = exports.ExtensionInfoType;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactaddressinfo = __webpack_require__(8);
	var ContactInfo = (function (_super) {
	    __extends(ContactInfo, _super);
	    function ContactInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessPhone', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: contactaddressinfo.ContactAddressInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ContactInfo.prototype.getClassName = function () {
	        return 'ContactInfo';
	    };
	    return ContactInfo;
	}(model.Model));
	exports.ContactInfo = ContactInfo;
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ContactAddressInfo = (function (_super) {
	    __extends(ContactAddressInfo, _super);
	    function ContactAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ContactAddressInfo.prototype.getClassName = function () {
	        return 'ContactAddressInfo';
	    };
	    return ContactAddressInfo;
	}(model.Model));
	exports.ContactAddressInfo = ContactAddressInfo;
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DepartmentInfo = (function (_super) {
	    __extends(DepartmentInfo, _super);
	    function DepartmentInfo() {
	        _super.apply(this, arguments);
	    }
	    DepartmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DepartmentInfo.prototype.getClassName = function () {
	        return 'DepartmentInfo';
	    };
	    return DepartmentInfo;
	}(model.Model));
	exports.DepartmentInfo = DepartmentInfo;
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var permissioninfo = __webpack_require__(11);
	var ExtensionPermissions = (function (_super) {
	    __extends(ExtensionPermissions, _super);
	    function ExtensionPermissions() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPermissions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'admin', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false },
	            { property: 'internationalCalling', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionPermissions.prototype.getClassName = function () {
	        return 'ExtensionPermissions';
	    };
	    return ExtensionPermissions;
	}(model.Model));
	exports.ExtensionPermissions = ExtensionPermissions;
	
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PermissionInfo = (function (_super) {
	    __extends(PermissionInfo, _super);
	    function PermissionInfo() {
	        _super.apply(this, arguments);
	    }
	    PermissionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    PermissionInfo.prototype.getClassName = function () {
	        return 'PermissionInfo';
	    };
	    return PermissionInfo;
	}(model.Model));
	exports.PermissionInfo = PermissionInfo;
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ProfileImageInfo = (function (_super) {
	    __extends(ProfileImageInfo, _super);
	    function ProfileImageInfo() {
	        _super.apply(this, arguments);
	    }
	    ProfileImageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'etag', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastModified', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'scales', Class: null /* string[] */, isArray: true, isRequired: false }
	        ];
	    };
	    ProfileImageInfo.prototype.getClassName = function () {
	        return 'ProfileImageInfo';
	    };
	    return ProfileImageInfo;
	}(model.Model));
	exports.ProfileImageInfo = ProfileImageInfo;
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ReferenceInfo = (function (_super) {
	    __extends(ReferenceInfo, _super);
	    function ReferenceInfo() {
	        _super.apply(this, arguments);
	    }
	    ReferenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'ref', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ReferenceInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    ReferenceInfo.prototype.getClassName = function () {
	        return 'ReferenceInfo';
	    };
	    return ReferenceInfo;
	}(model.Model));
	exports.ReferenceInfo = ReferenceInfo;
	(function (ReferenceInfoType) {
	    ReferenceInfoType[ReferenceInfoType["PartnerId"] = 'PartnerId'] = "PartnerId";
	    ReferenceInfoType[ReferenceInfoType["CustomerDirectoryId"] = 'CustomerDirectoryId'] = "CustomerDirectoryId";
	})(exports.ReferenceInfoType || (exports.ReferenceInfoType = {}));
	var ReferenceInfoType = exports.ReferenceInfoType;
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var timezoneinfo = __webpack_require__(16);
	var languageinfo = __webpack_require__(17);
	var greetinglanguageinfo = __webpack_require__(18);
	var formattinglocaleinfo = __webpack_require__(19);
	var RegionalSettings = (function (_super) {
	    __extends(RegionalSettings, _super);
	    function RegionalSettings() {
	        _super.apply(this, arguments);
	    }
	    RegionalSettings.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'timezone', Class: timezoneinfo.TimezoneInfo, isArray: false, isRequired: false },
	            { property: 'language', Class: languageinfo.LanguageInfo, isArray: false, isRequired: false },
	            { property: 'greetingLanguage', Class: greetinglanguageinfo.GreetingLanguageInfo, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: formattinglocaleinfo.FormattingLocaleInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RegionalSettings.prototype.getClassName = function () {
	        return 'RegionalSettings';
	    };
	    return RegionalSettings;
	}(model.Model));
	exports.RegionalSettings = RegionalSettings;
	
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CountryInfo = (function (_super) {
	    __extends(CountryInfo, _super);
	    function CountryInfo() {
	        _super.apply(this, arguments);
	    }
	    CountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CountryInfo.prototype.getClassName = function () {
	        return 'CountryInfo';
	    };
	    return CountryInfo;
	}(model.Model));
	exports.CountryInfo = CountryInfo;
	
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TimezoneInfo = (function (_super) {
	    __extends(TimezoneInfo, _super);
	    function TimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    TimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TimezoneInfo.prototype.getClassName = function () {
	        return 'TimezoneInfo';
	    };
	    return TimezoneInfo;
	}(model.Model));
	exports.TimezoneInfo = TimezoneInfo;
	
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LanguageInfo = (function (_super) {
	    __extends(LanguageInfo, _super);
	    function LanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    LanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'greeting', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'ui', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    LanguageInfo.prototype.getClassName = function () {
	        return 'LanguageInfo';
	    };
	    return LanguageInfo;
	}(model.Model));
	exports.LanguageInfo = LanguageInfo;
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var GreetingLanguageInfo = (function (_super) {
	    __extends(GreetingLanguageInfo, _super);
	    function GreetingLanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    GreetingLanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    GreetingLanguageInfo.prototype.getClassName = function () {
	        return 'GreetingLanguageInfo';
	    };
	    return GreetingLanguageInfo;
	}(model.Model));
	exports.GreetingLanguageInfo = GreetingLanguageInfo;
	
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var FormattingLocaleInfo = (function (_super) {
	    __extends(FormattingLocaleInfo, _super);
	    function FormattingLocaleInfo() {
	        _super.apply(this, arguments);
	    }
	    FormattingLocaleInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    FormattingLocaleInfo.prototype.getClassName = function () {
	        return 'FormattingLocaleInfo';
	    };
	    return FormattingLocaleInfo;
	}(model.Model));
	exports.FormattingLocaleInfo = FormattingLocaleInfo;
	
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionServiceFeatureInfo = (function (_super) {
	    __extends(ExtensionServiceFeatureInfo, _super);
	    function ExtensionServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ExtensionServiceFeatureInfo';
	    };
	    return ExtensionServiceFeatureInfo;
	}(model.Model));
	exports.ExtensionServiceFeatureInfo = ExtensionServiceFeatureInfo;
	
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionStatusInfo = (function (_super) {
	    __extends(ExtensionStatusInfo, _super);
	    function ExtensionStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: ExtensionStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionStatusInfo.prototype.getClassName = function () {
	        return 'ExtensionStatusInfo';
	    };
	    return ExtensionStatusInfo;
	}(model.Model));
	exports.ExtensionStatusInfo = ExtensionStatusInfo;
	(function (ExtensionStatusInfoReason) {
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.ExtensionStatusInfoReason || (exports.ExtensionStatusInfoReason = {}));
	var ExtensionStatusInfoReason = exports.ExtensionStatusInfoReason;
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var billingplaninfo = __webpack_require__(23);
	var brandinfo = __webpack_require__(24);
	var serviceplaninfo = __webpack_require__(25);
	var targetserviceplaninfo = __webpack_require__(26);
	var ServiceInfo = (function (_super) {
	    __extends(ServiceInfo, _super);
	    function ServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'billingPlan', Class: billingplaninfo.BillingPlanInfo, isArray: false, isRequired: false },
	            { property: 'brand', Class: brandinfo.BrandInfo, isArray: false, isRequired: false },
	            { property: 'servicePlan', Class: serviceplaninfo.ServicePlanInfo, isArray: false, isRequired: false },
	            { property: 'targetServicePlan', Class: targetserviceplaninfo.TargetServicePlanInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceInfo.prototype.getClassName = function () {
	        return 'ServiceInfo';
	    };
	    return ServiceInfo;
	}(model.Model));
	exports.ServiceInfo = ServiceInfo;
	
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BillingPlanInfo = (function (_super) {
	    __extends(BillingPlanInfo, _super);
	    function BillingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    BillingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'durationUnit', Class: BillingPlanInfoDurationUnit, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: BillingPlanInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    BillingPlanInfo.prototype.getClassName = function () {
	        return 'BillingPlanInfo';
	    };
	    return BillingPlanInfo;
	}(model.Model));
	exports.BillingPlanInfo = BillingPlanInfo;
	(function (BillingPlanInfoDurationUnit) {
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Month"] = 'Month'] = "Month";
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Day"] = 'Day'] = "Day";
	})(exports.BillingPlanInfoDurationUnit || (exports.BillingPlanInfoDurationUnit = {}));
	var BillingPlanInfoDurationUnit = exports.BillingPlanInfoDurationUnit;
	(function (BillingPlanInfoType) {
	    BillingPlanInfoType[BillingPlanInfoType["Initial"] = 'Initial'] = "Initial";
	    BillingPlanInfoType[BillingPlanInfoType["Regular"] = 'Regular'] = "Regular";
	    BillingPlanInfoType[BillingPlanInfoType["Suspended"] = 'Suspended'] = "Suspended";
	    BillingPlanInfoType[BillingPlanInfoType["Trial"] = 'Trial'] = "Trial";
	    BillingPlanInfoType[BillingPlanInfoType["TrialNoCC"] = 'TrialNoCC'] = "TrialNoCC";
	    BillingPlanInfoType[BillingPlanInfoType["Free"] = 'Free'] = "Free";
	})(exports.BillingPlanInfoType || (exports.BillingPlanInfoType = {}));
	var BillingPlanInfoType = exports.BillingPlanInfoType;
	
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var BrandInfo = (function (_super) {
	    __extends(BrandInfo, _super);
	    function BrandInfo() {
	        _super.apply(this, arguments);
	    }
	    BrandInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false }
	        ];
	    };
	    BrandInfo.prototype.getClassName = function () {
	        return 'BrandInfo';
	    };
	    return BrandInfo;
	}(model.Model));
	exports.BrandInfo = BrandInfo;
	
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServicePlanInfo = (function (_super) {
	    __extends(ServicePlanInfo, _super);
	    function ServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    ServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'edition', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ServicePlanInfo.prototype.getClassName = function () {
	        return 'ServicePlanInfo';
	    };
	    return ServicePlanInfo;
	}(model.Model));
	exports.ServicePlanInfo = ServicePlanInfo;
	
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TargetServicePlanInfo = (function (_super) {
	    __extends(TargetServicePlanInfo, _super);
	    function TargetServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    TargetServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TargetServicePlanInfo.prototype.getClassName = function () {
	        return 'TargetServicePlanInfo';
	    };
	    return TargetServicePlanInfo;
	}(model.Model));
	exports.TargetServicePlanInfo = TargetServicePlanInfo;
	
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountStatusInfo = (function (_super) {
	    __extends(AccountStatusInfo, _super);
	    function AccountStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: AccountStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    AccountStatusInfo.prototype.getClassName = function () {
	        return 'AccountStatusInfo';
	    };
	    return AccountStatusInfo;
	}(model.Model));
	exports.AccountStatusInfo = AccountStatusInfo;
	(function (AccountStatusInfoReason) {
	    AccountStatusInfoReason[AccountStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    AccountStatusInfoReason[AccountStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.AccountStatusInfoReason || (exports.AccountStatusInfoReason = {}));
	var AccountStatusInfoReason = exports.AccountStatusInfoReason;
	
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var businessaddressinfo = __webpack_require__(29);
	var AccountBusinessAddress = (function (_super) {
	    __extends(AccountBusinessAddress, _super);
	    function AccountBusinessAddress() {
	        _super.apply(this, arguments);
	    }
	    AccountBusinessAddress.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: businessaddressinfo.BusinessAddressInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountBusinessAddress.prototype.getClassName = function () {
	        return 'AccountBusinessAddress';
	    };
	    return AccountBusinessAddress;
	}(model.Model));
	exports.AccountBusinessAddress = AccountBusinessAddress;
	
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BusinessAddressInfo = (function (_super) {
	    __extends(BusinessAddressInfo, _super);
	    function BusinessAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    BusinessAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BusinessAddressInfo.prototype.getClassName = function () {
	        return 'BusinessAddressInfo';
	    };
	    return BusinessAddressInfo;
	}(model.Model));
	exports.BusinessAddressInfo = BusinessAddressInfo;
	
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dialingplancountryinfo = __webpack_require__(31);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var DialingPlanInfo = (function (_super) {
	    __extends(DialingPlanInfo, _super);
	    function DialingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dialingplancountryinfo.DialingPlanCountryInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DialingPlanInfo.prototype.getClassName = function () {
	        return 'DialingPlanInfo';
	    };
	    return DialingPlanInfo;
	}(model.Model));
	exports.DialingPlanInfo = DialingPlanInfo;
	
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DialingPlanCountryInfo = (function (_super) {
	    __extends(DialingPlanCountryInfo, _super);
	    function DialingPlanCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DialingPlanCountryInfo.prototype.getClassName = function () {
	        return 'DialingPlanCountryInfo';
	    };
	    return DialingPlanCountryInfo;
	}(model.Model));
	exports.DialingPlanCountryInfo = DialingPlanCountryInfo;
	
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PagingInfo = (function (_super) {
	    __extends(PagingInfo, _super);
	    function PagingInfo() {
	        _super.apply(this, arguments);
	    }
	    PagingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'page', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'perPage', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageStart', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageEnd', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalPages', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalElements', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    PagingInfo.prototype.getClassName = function () {
	        return 'PagingInfo';
	    };
	    return PagingInfo;
	}(model.Model));
	exports.PagingInfo = PagingInfo;
	
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NavigationInfo = (function (_super) {
	    __extends(NavigationInfo, _super);
	    function NavigationInfo() {
	        _super.apply(this, arguments);
	    }
	    NavigationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nextPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'previousPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastPage', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NavigationInfo.prototype.getClassName = function () {
	        return 'NavigationInfo';
	    };
	    return NavigationInfo;
	}(model.Model));
	exports.NavigationInfo = NavigationInfo;
	
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var phonenumbersextensioninfo = __webpack_require__(35);
	var PhoneNumberInfo = (function (_super) {
	    __extends(PhoneNumberInfo, _super);
	    function PhoneNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'country', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'extension', Class: phonenumbersextensioninfo.PhoneNumbersExtensionInfo, isArray: false, isRequired: false },
	            { property: 'features', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'paymentType', Class: PhoneNumberInfoPaymentType, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: PhoneNumberInfoType, isArray: false, isRequired: false },
	            { property: 'usageType', Class: PhoneNumberInfoUsageType, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumberInfo.prototype.getClassName = function () {
	        return 'PhoneNumberInfo';
	    };
	    return PhoneNumberInfo;
	}(model.Model));
	exports.PhoneNumberInfo = PhoneNumberInfo;
	(function (PhoneNumberInfoPaymentType) {
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["External"] = 'External'] = "External";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["TollFree"] = 'TollFree'] = "TollFree";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["Local"] = 'Local'] = "Local";
	})(exports.PhoneNumberInfoPaymentType || (exports.PhoneNumberInfoPaymentType = {}));
	var PhoneNumberInfoPaymentType = exports.PhoneNumberInfoPaymentType;
	(function (PhoneNumberInfoType) {
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceFax"] = 'VoiceFax'] = "VoiceFax";
	    PhoneNumberInfoType[PhoneNumberInfoType["FaxOnly"] = 'FaxOnly'] = "FaxOnly";
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceOnly"] = 'VoiceOnly'] = "VoiceOnly";
	})(exports.PhoneNumberInfoType || (exports.PhoneNumberInfoType = {}));
	var PhoneNumberInfoType = exports.PhoneNumberInfoType;
	(function (PhoneNumberInfoUsageType) {
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.PhoneNumberInfoUsageType || (exports.PhoneNumberInfoUsageType = {}));
	var PhoneNumberInfoUsageType = exports.PhoneNumberInfoUsageType;
	
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PhoneNumbersExtensionInfo = (function (_super) {
	    __extends(PhoneNumbersExtensionInfo, _super);
	    function PhoneNumbersExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumbersExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumbersExtensionInfo.prototype.getClassName = function () {
	        return 'PhoneNumbersExtensionInfo';
	    };
	    return PhoneNumbersExtensionInfo;
	}(model.Model));
	exports.PhoneNumbersExtensionInfo = PhoneNumbersExtensionInfo;
	
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var AccountPhoneNumbers = (function (_super) {
	    __extends(AccountPhoneNumbers, _super);
	    function AccountPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    AccountPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountPhoneNumbers.prototype.getClassName = function () {
	        return 'AccountPhoneNumbers';
	    };
	    return AccountPhoneNumbers;
	}(model.Model));
	exports.AccountPhoneNumbers = AccountPhoneNumbers;
	
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var servicefeatureinfo = __webpack_require__(38);
	var accountlimits = __webpack_require__(39);
	var AccountServiceInfo = (function (_super) {
	    __extends(AccountServiceInfo, _super);
	    function AccountServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'servicePlanName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: servicefeatureinfo.ServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'limits', Class: accountlimits.AccountLimits, isArray: true, isRequired: false }
	        ];
	    };
	    AccountServiceInfo.prototype.getClassName = function () {
	        return 'AccountServiceInfo';
	    };
	    return AccountServiceInfo;
	}(model.Model));
	exports.AccountServiceInfo = AccountServiceInfo;
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServiceFeatureInfo = (function (_super) {
	    __extends(ServiceFeatureInfo, _super);
	    function ServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'enabled', Class: ServiceFeatureInfoEnabled, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ServiceFeatureInfo';
	    };
	    return ServiceFeatureInfo;
	}(model.Model));
	exports.ServiceFeatureInfo = ServiceFeatureInfo;
	(function (ServiceFeatureInfoEnabled) {
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["True"] = 'True'] = "True";
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["False"] = 'False'] = "False";
	})(exports.ServiceFeatureInfoEnabled || (exports.ServiceFeatureInfoEnabled = {}));
	var ServiceFeatureInfoEnabled = exports.ServiceFeatureInfoEnabled;
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountLimits = (function (_super) {
	    __extends(AccountLimits, _super);
	    function AccountLimits() {
	        _super.apply(this, arguments);
	    }
	    AccountLimits.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'freeSoftPhoneLinesPerExtension', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'meetingSize', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'maxMonitoredExtensionsPerUser', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    AccountLimits.prototype.getClassName = function () {
	        return 'AccountLimits';
	    };
	    return AccountLimits;
	}(model.Model));
	exports.AccountLimits = AccountLimits;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountactivecalls = __webpack_require__(41);
	var accountcalllog = __webpack_require__(47);
	var accountcalllogrecord = __webpack_require__(48);
	var extensionactivecalls = __webpack_require__(49);
	var extensioncalllog = __webpack_require__(50);
	var extensioncalllogrecord = __webpack_require__(51);
	var calllogsync = __webpack_require__(52);
	var callrecording = __webpack_require__(54);
	var CallLog = (function (_super) {
	    __extends(CallLog, _super);
	    function CallLog() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Account Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listAccountActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/active-calls', options, exports.listAccountActiveCallsOptions), accountactivecalls.AccountActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log', options, exports.loadAccountCallLogOptions), accountcalllog.AccountCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteAccountCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/call-log', options, exports.deleteAccountCallLogOptions), null);
	    };
	    /**
	     * Get Account Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns individual call log record(s) by ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log/{callRecordId}', options, exports.loadAccountCallLogRecordOptions), accountcalllogrecord.AccountCallLogRecord);
	    };
	    /**
	     * Get Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all extension calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listExtensionActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/active-calls', options, exports.listExtensionActiveCallsOptions), extensionactivecalls.ExtensionActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.loadExtensionCallLogOptions), extensioncalllog.ExtensionCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.deleteExtensionCallLogOptions), null);
	    };
	    /**
	     * Get Extension Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log record(s) by their ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log/{callRecordId}', options, exports.loadExtensionCallLogRecordOptions), extensioncalllogrecord.ExtensionCallLogRecord);
	    };
	    /**
	     * Call Log Synchronization
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.syncExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log-sync', options, exports.syncExtensionCallLogOptions), calllogsync.CallLogSync);
	    };
	    /**
	     * Get Call Recording
	     *
	     * <p style='font-style:italic;'>Since 1.0.18</p>
	     * <p>Returns call recording metadata.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingMetadata = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}', options, exports.loadCallRecordingMetadataOptions), callrecording.CallRecording);
	    };
	    /**
	     * Get Call Recording Data
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingContent = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}/content', options, exports.loadCallRecordingContentOptions), null);
	    };
	    return CallLog;
	}(client.Client));
	exports.CallLog = CallLog;
	/**
	 * Definition of options for listAccountActiveCalls operation
	 */
	exports.listAccountActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListAccountActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListAccountActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLog operation
	 */
	exports.loadAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadAccountCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadAccountCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadAccountCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteAccountCallLog operation
	 */
	exports.deleteAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLogRecord operation
	 */
	exports.loadAccountCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listExtensionActiveCalls operation
	 */
	exports.listExtensionActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListExtensionActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLog operation
	 */
	exports.loadExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadExtensionCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadExtensionCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadExtensionCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteExtensionCallLog operation
	 */
	exports.deleteExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLogRecord operation
	 */
	exports.loadExtensionCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncExtensionCallLog operation
	 */
	exports.syncExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncExtensionCallLogSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "statusGroup",
	        "type": "ISyncExtensionCallLogStatusGroup",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Missed",
	            "All"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCallRecordingMetadata operation
	 */
	exports.loadCallRecordingMetadataOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadCallRecordingContent operation
	 */
	exports.loadCallRecordingContentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	(function (IListAccountActiveCallsDirection) {
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListAccountActiveCallsDirection || (exports.IListAccountActiveCallsDirection = {}));
	var IListAccountActiveCallsDirection = exports.IListAccountActiveCallsDirection;
	(function (IListAccountActiveCallsType) {
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListAccountActiveCallsType || (exports.IListAccountActiveCallsType = {}));
	var IListAccountActiveCallsType = exports.IListAccountActiveCallsType;
	(function (ILoadAccountCallLogDirection) {
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadAccountCallLogDirection || (exports.ILoadAccountCallLogDirection = {}));
	var ILoadAccountCallLogDirection = exports.ILoadAccountCallLogDirection;
	(function (ILoadAccountCallLogType) {
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadAccountCallLogType || (exports.ILoadAccountCallLogType = {}));
	var ILoadAccountCallLogType = exports.ILoadAccountCallLogType;
	(function (ILoadAccountCallLogView) {
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadAccountCallLogView || (exports.ILoadAccountCallLogView = {}));
	var ILoadAccountCallLogView = exports.ILoadAccountCallLogView;
	(function (IListExtensionActiveCallsDirection) {
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListExtensionActiveCallsDirection || (exports.IListExtensionActiveCallsDirection = {}));
	var IListExtensionActiveCallsDirection = exports.IListExtensionActiveCallsDirection;
	(function (IListExtensionActiveCallsType) {
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListExtensionActiveCallsType || (exports.IListExtensionActiveCallsType = {}));
	var IListExtensionActiveCallsType = exports.IListExtensionActiveCallsType;
	(function (ILoadExtensionCallLogDirection) {
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadExtensionCallLogDirection || (exports.ILoadExtensionCallLogDirection = {}));
	var ILoadExtensionCallLogDirection = exports.ILoadExtensionCallLogDirection;
	(function (ILoadExtensionCallLogType) {
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadExtensionCallLogType || (exports.ILoadExtensionCallLogType = {}));
	var ILoadExtensionCallLogType = exports.ILoadExtensionCallLogType;
	(function (ILoadExtensionCallLogView) {
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadExtensionCallLogView || (exports.ILoadExtensionCallLogView = {}));
	var ILoadExtensionCallLogView = exports.ILoadExtensionCallLogView;
	(function (ISyncExtensionCallLogSyncType) {
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncExtensionCallLogSyncType || (exports.ISyncExtensionCallLogSyncType = {}));
	var ISyncExtensionCallLogSyncType = exports.ISyncExtensionCallLogSyncType;
	(function (ISyncExtensionCallLogStatusGroup) {
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["Missed"] = 'Missed'] = "Missed";
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["All"] = 'All'] = "All";
	})(exports.ISyncExtensionCallLogStatusGroup || (exports.ISyncExtensionCallLogStatusGroup = {}));
	var ISyncExtensionCallLogStatusGroup = exports.ISyncExtensionCallLogStatusGroup;
	
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountActiveCalls = (function (_super) {
	    __extends(AccountActiveCalls, _super);
	    function AccountActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    AccountActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountActiveCalls.prototype.getClassName = function () {
	        return 'AccountActiveCalls';
	    };
	    return AccountActiveCalls;
	}(model.Model));
	exports.AccountActiveCalls = AccountActiveCalls;
	
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var calllogrecordleginfo = __webpack_require__(45);
	var CallLogRecord = (function (_super) {
	    __extends(CallLogRecord, _super);
	    function CallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: CallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordTransport, isArray: false, isRequired: false },
	            { property: 'legs', Class: calllogrecordleginfo.CallLogRecordLegInfo, isArray: true, isRequired: true }
	        ];
	    };
	    CallLogRecord.prototype.getClassName = function () {
	        return 'CallLogRecord';
	    };
	    return CallLogRecord;
	}(model.Model));
	exports.CallLogRecord = CallLogRecord;
	(function (CallLogRecordType) {
	    CallLogRecordType[CallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordType[CallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordType || (exports.CallLogRecordType = {}));
	var CallLogRecordType = exports.CallLogRecordType;
	(function (CallLogRecordDirection) {
	    CallLogRecordDirection[CallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordDirection[CallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordDirection || (exports.CallLogRecordDirection = {}));
	var CallLogRecordDirection = exports.CallLogRecordDirection;
	(function (CallLogRecordAction) {
	    CallLogRecordAction[CallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordAction[CallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordAction[CallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordAction[CallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordAction[CallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordAction[CallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordAction[CallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordAction[CallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordAction[CallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordAction[CallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordAction[CallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordAction[CallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordAction[CallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordAction[CallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordAction[CallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordAction[CallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordAction[CallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordAction[CallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordAction[CallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordAction[CallLogRecordAction["Support"] = 'Support'] = "Support";
	    CallLogRecordAction[CallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordAction || (exports.CallLogRecordAction = {}));
	var CallLogRecordAction = exports.CallLogRecordAction;
	(function (CallLogRecordResult) {
	    CallLogRecordResult[CallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordResult[CallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordResult[CallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordResult[CallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordResult[CallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordResult[CallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordResult[CallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordResult[CallLogRecordResult["Received"] = 'Received'] = "Received";
	    CallLogRecordResult[CallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordResult[CallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordResult[CallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordResult[CallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordResult[CallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordResult[CallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordResult[CallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordResult[CallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordResult[CallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordResult[CallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordResult[CallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordResult[CallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordResult[CallLogRecordResult["Account"] = 'Account'] = "Account";
	    CallLogRecordResult[CallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordResult[CallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordResult[CallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordResult[CallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordResult[CallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordResult[CallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordResult[CallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordResult[CallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordResult[CallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordResult[CallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordResult[CallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordResult[CallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordResult[CallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordResult[CallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordResult[CallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordResult[CallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordResult || (exports.CallLogRecordResult = {}));
	var CallLogRecordResult = exports.CallLogRecordResult;
	(function (CallLogRecordTransport) {
	    CallLogRecordTransport[CallLogRecordTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordTransport[CallLogRecordTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordTransport || (exports.CallLogRecordTransport = {}));
	var CallLogRecordTransport = exports.CallLogRecordTransport;
	
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallLogCallerInfo = (function (_super) {
	    __extends(CallLogCallerInfo, _super);
	    function CallLogCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogCallerInfo.prototype.getClassName = function () {
	        return 'CallLogCallerInfo';
	    };
	    return CallLogCallerInfo;
	}(model.Model));
	exports.CallLogCallerInfo = CallLogCallerInfo;
	
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RecordingInfo = (function (_super) {
	    __extends(RecordingInfo, _super);
	    function RecordingInfo() {
	        _super.apply(this, arguments);
	    }
	    RecordingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: RecordingInfoType, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    RecordingInfo.prototype.getClassName = function () {
	        return 'RecordingInfo';
	    };
	    return RecordingInfo;
	}(model.Model));
	exports.RecordingInfo = RecordingInfo;
	(function (RecordingInfoType) {
	    RecordingInfoType[RecordingInfoType["Automatic"] = 'Automatic'] = "Automatic";
	    RecordingInfoType[RecordingInfoType["OnDemand"] = 'OnDemand'] = "OnDemand";
	})(exports.RecordingInfoType || (exports.RecordingInfoType = {}));
	var RecordingInfoType = exports.RecordingInfoType;
	
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfocalllog = __webpack_require__(46);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var CallLogRecordLegInfo = (function (_super) {
	    __extends(CallLogRecordLegInfo, _super);
	    function CallLogRecordLegInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecordLegInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'action', Class: CallLogRecordLegInfoAction, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordLegInfoDirection, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfocalllog.ExtensionInfoCallLog, isArray: false, isRequired: false },
	            { property: 'legType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordLegInfoType, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordLegInfoResult, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordLegInfoTransport, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogRecordLegInfo.prototype.getClassName = function () {
	        return 'CallLogRecordLegInfo';
	    };
	    return CallLogRecordLegInfo;
	}(model.Model));
	exports.CallLogRecordLegInfo = CallLogRecordLegInfo;
	(function (CallLogRecordLegInfoAction) {
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Support"] = 'Support'] = "Support";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordLegInfoAction || (exports.CallLogRecordLegInfoAction = {}));
	var CallLogRecordLegInfoAction = exports.CallLogRecordLegInfoAction;
	(function (CallLogRecordLegInfoDirection) {
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordLegInfoDirection || (exports.CallLogRecordLegInfoDirection = {}));
	var CallLogRecordLegInfoDirection = exports.CallLogRecordLegInfoDirection;
	(function (CallLogRecordLegInfoType) {
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordLegInfoType || (exports.CallLogRecordLegInfoType = {}));
	var CallLogRecordLegInfoType = exports.CallLogRecordLegInfoType;
	(function (CallLogRecordLegInfoResult) {
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Received"] = 'Received'] = "Received";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Account"] = 'Account'] = "Account";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordLegInfoResult || (exports.CallLogRecordLegInfoResult = {}));
	var CallLogRecordLegInfoResult = exports.CallLogRecordLegInfoResult;
	(function (CallLogRecordLegInfoTransport) {
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordLegInfoTransport || (exports.CallLogRecordLegInfoTransport = {}));
	var CallLogRecordLegInfoTransport = exports.CallLogRecordLegInfoTransport;
	
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoCallLog = (function (_super) {
	    __extends(ExtensionInfoCallLog, _super);
	    function ExtensionInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoCallLog.prototype.getClassName = function () {
	        return 'ExtensionInfoCallLog';
	    };
	    return ExtensionInfoCallLog;
	}(model.Model));
	exports.ExtensionInfoCallLog = ExtensionInfoCallLog;
	
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountCallLog = (function (_super) {
	    __extends(AccountCallLog, _super);
	    function AccountCallLog() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountCallLog.prototype.getClassName = function () {
	        return 'AccountCallLog';
	    };
	    return AccountCallLog;
	}(model.Model));
	exports.AccountCallLog = AccountCallLog;
	
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var AccountCallLogRecord = (function (_super) {
	    __extends(AccountCallLogRecord, _super);
	    function AccountCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: AccountCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: AccountCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: AccountCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: AccountCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountCallLogRecord.prototype.getClassName = function () {
	        return 'AccountCallLogRecord';
	    };
	    return AccountCallLogRecord;
	}(model.Model));
	exports.AccountCallLogRecord = AccountCallLogRecord;
	(function (AccountCallLogRecordType) {
	    AccountCallLogRecordType[AccountCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    AccountCallLogRecordType[AccountCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.AccountCallLogRecordType || (exports.AccountCallLogRecordType = {}));
	var AccountCallLogRecordType = exports.AccountCallLogRecordType;
	(function (AccountCallLogRecordDirection) {
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.AccountCallLogRecordDirection || (exports.AccountCallLogRecordDirection = {}));
	var AccountCallLogRecordDirection = exports.AccountCallLogRecordDirection;
	(function (AccountCallLogRecordAction) {
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Support"] = 'Support'] = "Support";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.AccountCallLogRecordAction || (exports.AccountCallLogRecordAction = {}));
	var AccountCallLogRecordAction = exports.AccountCallLogRecordAction;
	(function (AccountCallLogRecordResult) {
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Received"] = 'Received'] = "Received";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Account"] = 'Account'] = "Account";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.AccountCallLogRecordResult || (exports.AccountCallLogRecordResult = {}));
	var AccountCallLogRecordResult = exports.AccountCallLogRecordResult;
	
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionActiveCalls = (function (_super) {
	    __extends(ExtensionActiveCalls, _super);
	    function ExtensionActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    ExtensionActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionActiveCalls.prototype.getClassName = function () {
	        return 'ExtensionActiveCalls';
	    };
	    return ExtensionActiveCalls;
	}(model.Model));
	exports.ExtensionActiveCalls = ExtensionActiveCalls;
	
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionCallLog = (function (_super) {
	    __extends(ExtensionCallLog, _super);
	    function ExtensionCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionCallLog.prototype.getClassName = function () {
	        return 'ExtensionCallLog';
	    };
	    return ExtensionCallLog;
	}(model.Model));
	exports.ExtensionCallLog = ExtensionCallLog;
	
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var ExtensionCallLogRecord = (function (_super) {
	    __extends(ExtensionCallLogRecord, _super);
	    function ExtensionCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: ExtensionCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: ExtensionCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: ExtensionCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionCallLogRecord.prototype.getClassName = function () {
	        return 'ExtensionCallLogRecord';
	    };
	    return ExtensionCallLogRecord;
	}(model.Model));
	exports.ExtensionCallLogRecord = ExtensionCallLogRecord;
	(function (ExtensionCallLogRecordType) {
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.ExtensionCallLogRecordType || (exports.ExtensionCallLogRecordType = {}));
	var ExtensionCallLogRecordType = exports.ExtensionCallLogRecordType;
	(function (ExtensionCallLogRecordDirection) {
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ExtensionCallLogRecordDirection || (exports.ExtensionCallLogRecordDirection = {}));
	var ExtensionCallLogRecordDirection = exports.ExtensionCallLogRecordDirection;
	(function (ExtensionCallLogRecordAction) {
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Support"] = 'Support'] = "Support";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.ExtensionCallLogRecordAction || (exports.ExtensionCallLogRecordAction = {}));
	var ExtensionCallLogRecordAction = exports.ExtensionCallLogRecordAction;
	(function (ExtensionCallLogRecordResult) {
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Received"] = 'Received'] = "Received";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Account"] = 'Account'] = "Account";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.ExtensionCallLogRecordResult || (exports.ExtensionCallLogRecordResult = {}));
	var ExtensionCallLogRecordResult = exports.ExtensionCallLogRecordResult;
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var syncinfocalllog = __webpack_require__(53);
	var CallLogSync = (function (_super) {
	    __extends(CallLogSync, _super);
	    function CallLogSync() {
	        _super.apply(this, arguments);
	    }
	    CallLogSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: syncinfocalllog.SyncInfoCallLog, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogSync.prototype.getClassName = function () {
	        return 'CallLogSync';
	    };
	    return CallLogSync;
	}(model.Model));
	exports.CallLogSync = CallLogSync;
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SyncInfoCallLog = (function (_super) {
	    __extends(SyncInfoCallLog, _super);
	    function SyncInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    SyncInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: SyncInfoCallLogSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    SyncInfoCallLog.prototype.getClassName = function () {
	        return 'SyncInfoCallLog';
	    };
	    return SyncInfoCallLog;
	}(model.Model));
	exports.SyncInfoCallLog = SyncInfoCallLog;
	(function (SyncInfoCallLogSyncType) {
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.SyncInfoCallLogSyncType || (exports.SyncInfoCallLogSyncType = {}));
	var SyncInfoCallLogSyncType = exports.SyncInfoCallLogSyncType;
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallRecording = (function (_super) {
	    __extends(CallRecording, _super);
	    function CallRecording() {
	        _super.apply(this, arguments);
	    }
	    CallRecording.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    CallRecording.prototype.getClassName = function () {
	        return 'CallRecording';
	    };
	    return CallRecording;
	}(model.Model));
	exports.CallRecording = CallRecording;
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var countrylist = __webpack_require__(56);
	var dictionarycountryinfo = __webpack_require__(57);
	var languagelist = __webpack_require__(58);
	var languageinfo = __webpack_require__(17);
	var dictionarylocationlist = __webpack_require__(59);
	var dictionarysecretquestionlist = __webpack_require__(61);
	var secretquestioninfo = __webpack_require__(62);
	var dictionaryshippingoptions = __webpack_require__(63);
	var dictionarystatelist = __webpack_require__(65);
	var dictionarystateinfo = __webpack_require__(66);
	var dictionarytimezonelist = __webpack_require__(68);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var Dictionary = (function (_super) {
	    __extends(Dictionary, _super);
	    function Dictionary() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Country List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the countries available for calling.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listCountries = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country', options, exports.listCountriesOptions), countrylist.CountryList);
	    };
	    /**
	     * Get Country
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadCountry = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country/{countryId}', options, exports.loadCountryOptions), dictionarycountryinfo.DictionaryCountryInfo);
	    };
	    /**
	     * Get Language List
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns the information about supported languages.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLanguages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language', options, exports.listLanguagesOptions), languagelist.LanguageList);
	    };
	    /**
	     * Get Language
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns language by its respective ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadLanguage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language/{languageId}', options, exports.loadLanguageOptions), languageinfo.LanguageInfo);
	    };
	    /**
	     * Get Location List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the available locations for the certain state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLocations = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/location', options, exports.listLocationsOptions), dictionarylocationlist.DictionaryLocationList);
	    };
	    /**
	     * Get Secret Question List
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns the list of secret questions for a specific language.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listSecretQuestions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question', options, exports.listSecretQuestionsOptions), dictionarysecretquestionlist.DictionarySecretQuestionList);
	    };
	    /**
	     * Get Secret Question
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns a particular secret question in specific language by question ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadSecretQuestion = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question/questionId', options, exports.loadSecretQuestionOptions), secretquestioninfo.SecretQuestionInfo);
	    };
	    /**
	     * Get Shipping Options
	     *
	     * <p style='font-style:italic;'>Since 1.0.16 (Release 7.1)</p>
	     * <p>Returns the list of device shipping options with their prices, according to brand, tier, number of ordered devices.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listShippingOptions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/shipping-options', options, exports.listShippingOptionsOptions), dictionaryshippingoptions.DictionaryShippingOptions);
	    };
	    /**
	     * Get State List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the states for a certain country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadlistStates = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state', options, exports.loadlistStatesOptions), dictionarystatelist.DictionaryStateList);
	    };
	    /**
	     * Get State
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadState = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state/{stateId}', options, exports.loadStateOptions), dictionarystateinfo.DictionaryStateInfo);
	    };
	    /**
	     * Get Timezone List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all available timezones.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listTimezones = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone', options, exports.listTimezonesOptions), dictionarytimezonelist.DictionaryTimezoneList);
	    };
	    /**
	     * Get Timezone
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on a certain timezone.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadTimezone = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone/{timezoneId}', options, exports.loadTimezoneOptions), dictionarytimezoneinfo.DictionaryTimezoneInfo);
	    };
	    return Dictionary;
	}(client.Client));
	exports.Dictionary = Dictionary;
	/**
	 * Definition of options for listCountries operation
	 */
	exports.listCountriesOptions = [
	    {
	        "name": "loginAllowed",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "numberSelling",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCountry operation
	 */
	exports.loadCountryOptions = [
	    {
	        "name": "countryId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLanguages operation
	 */
	exports.listLanguagesOptions = [];
	/**
	 * Definition of options for loadLanguage operation
	 */
	exports.loadLanguageOptions = [
	    {
	        "name": "languageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLocations operation
	 */
	exports.listLocationsOptions = [
	    {
	        "name": "orderBy",
	        "type": "IListLocationsOrderBy",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Npa",
	            "City"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withNxx",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listSecretQuestions operation
	 */
	exports.listSecretQuestionsOptions = [];
	/**
	 * Definition of options for loadSecretQuestion operation
	 */
	exports.loadSecretQuestionOptions = [
	    {
	        "name": "questionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listShippingOptions operation
	 */
	exports.listShippingOptionsOptions = [];
	/**
	 * Definition of options for loadlistStates operation
	 */
	exports.loadlistStatesOptions = [
	    {
	        "name": "countryId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withPhoneNumbers",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadState operation
	 */
	exports.loadStateOptions = [
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listTimezones operation
	 */
	exports.listTimezonesOptions = [
	    {
	        "name": "page",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadTimezone operation
	 */
	exports.loadTimezoneOptions = [
	    {
	        "name": "timezoneId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListLocationsOrderBy) {
	    IListLocationsOrderBy[IListLocationsOrderBy["Npa"] = 'Npa'] = "Npa";
	    IListLocationsOrderBy[IListLocationsOrderBy["City"] = 'City'] = "City";
	})(exports.IListLocationsOrderBy || (exports.IListLocationsOrderBy = {}));
	var IListLocationsOrderBy = exports.IListLocationsOrderBy;
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarycountryinfo = __webpack_require__(57);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var CountryList = (function (_super) {
	    __extends(CountryList, _super);
	    function CountryList() {
	        _super.apply(this, arguments);
	    }
	    CountryList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarycountryinfo.DictionaryCountryInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    CountryList.prototype.getClassName = function () {
	        return 'CountryList';
	    };
	    return CountryList;
	}(model.Model));
	exports.CountryList = CountryList;
	
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryCountryInfo = (function (_super) {
	    __extends(DictionaryCountryInfo, _super);
	    function DictionaryCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'emergencyCalling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'numberSelling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'loginAllowed', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryCountryInfo.prototype.getClassName = function () {
	        return 'DictionaryCountryInfo';
	    };
	    return DictionaryCountryInfo;
	}(model.Model));
	exports.DictionaryCountryInfo = DictionaryCountryInfo;
	
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var languageinfo = __webpack_require__(17);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var LanguageList = (function (_super) {
	    __extends(LanguageList, _super);
	    function LanguageList() {
	        _super.apply(this, arguments);
	    }
	    LanguageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'records', Class: languageinfo.LanguageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    LanguageList.prototype.getClassName = function () {
	        return 'LanguageList';
	    };
	    return LanguageList;
	}(model.Model));
	exports.LanguageList = LanguageList;
	
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var locationinfo = __webpack_require__(60);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryLocationList = (function (_super) {
	    __extends(DictionaryLocationList, _super);
	    function DictionaryLocationList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryLocationList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: locationinfo.LocationInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryLocationList.prototype.getClassName = function () {
	        return 'DictionaryLocationList';
	    };
	    return DictionaryLocationList;
	}(model.Model));
	exports.DictionaryLocationList = DictionaryLocationList;
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LocationInfo = (function (_super) {
	    __extends(LocationInfo, _super);
	    function LocationInfo() {
	        _super.apply(this, arguments);
	    }
	    LocationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'areaCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'npa', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nxx', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    LocationInfo.prototype.getClassName = function () {
	        return 'LocationInfo';
	    };
	    return LocationInfo;
	}(model.Model));
	exports.LocationInfo = LocationInfo;
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var secretquestioninfo = __webpack_require__(62);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionarySecretQuestionList = (function (_super) {
	    __extends(DictionarySecretQuestionList, _super);
	    function DictionarySecretQuestionList() {
	        _super.apply(this, arguments);
	    }
	    DictionarySecretQuestionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: secretquestioninfo.SecretQuestionInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    DictionarySecretQuestionList.prototype.getClassName = function () {
	        return 'DictionarySecretQuestionList';
	    };
	    return DictionarySecretQuestionList;
	}(model.Model));
	exports.DictionarySecretQuestionList = DictionarySecretQuestionList;
	
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SecretQuestionInfo = (function (_super) {
	    __extends(SecretQuestionInfo, _super);
	    function SecretQuestionInfo() {
	        _super.apply(this, arguments);
	    }
	    SecretQuestionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionType', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'languageId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionText', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'showInSignUp', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    SecretQuestionInfo.prototype.getClassName = function () {
	        return 'SecretQuestionInfo';
	    };
	    return SecretQuestionInfo;
	}(model.Model));
	exports.SecretQuestionInfo = SecretQuestionInfo;
	
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var shippingmethodinfo = __webpack_require__(64);
	var DictionaryShippingOptions = (function (_super) {
	    __extends(DictionaryShippingOptions, _super);
	    function DictionaryShippingOptions() {
	        _super.apply(this, arguments);
	    }
	    DictionaryShippingOptions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'quantity', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'price', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'method', Class: shippingmethodinfo.ShippingMethodInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryShippingOptions.prototype.getClassName = function () {
	        return 'DictionaryShippingOptions';
	    };
	    return DictionaryShippingOptions;
	}(model.Model));
	exports.DictionaryShippingOptions = DictionaryShippingOptions;
	
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ShippingMethodInfo = (function (_super) {
	    __extends(ShippingMethodInfo, _super);
	    function ShippingMethodInfo() {
	        _super.apply(this, arguments);
	    }
	    ShippingMethodInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ShippingMethodInfo.prototype.getClassName = function () {
	        return 'ShippingMethodInfo';
	    };
	    return ShippingMethodInfo;
	}(model.Model));
	exports.ShippingMethodInfo = ShippingMethodInfo;
	
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarystateinfo = __webpack_require__(66);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryStateList = (function (_super) {
	    __extends(DictionaryStateList, _super);
	    function DictionaryStateList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarystateinfo.DictionaryStateInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryStateList.prototype.getClassName = function () {
	        return 'DictionaryStateList';
	    };
	    return DictionaryStateList;
	}(model.Model));
	exports.DictionaryStateList = DictionaryStateList;
	
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var statecountryinfo = __webpack_require__(67);
	var DictionaryStateInfo = (function (_super) {
	    __extends(DictionaryStateInfo, _super);
	    function DictionaryStateInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'country', Class: statecountryinfo.StateCountryInfo, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryStateInfo.prototype.getClassName = function () {
	        return 'DictionaryStateInfo';
	    };
	    return DictionaryStateInfo;
	}(model.Model));
	exports.DictionaryStateInfo = DictionaryStateInfo;
	
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var StateCountryInfo = (function (_super) {
	    __extends(StateCountryInfo, _super);
	    function StateCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    StateCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    StateCountryInfo.prototype.getClassName = function () {
	        return 'StateCountryInfo';
	    };
	    return StateCountryInfo;
	}(model.Model));
	exports.StateCountryInfo = StateCountryInfo;
	
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryTimezoneList = (function (_super) {
	    __extends(DictionaryTimezoneList, _super);
	    function DictionaryTimezoneList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarytimezoneinfo.DictionaryTimezoneInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryTimezoneList.prototype.getClassName = function () {
	        return 'DictionaryTimezoneList';
	    };
	    return DictionaryTimezoneList;
	}(model.Model));
	exports.DictionaryTimezoneList = DictionaryTimezoneList;
	
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryTimezoneInfo = (function (_super) {
	    __extends(DictionaryTimezoneInfo, _super);
	    function DictionaryTimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryTimezoneInfo.prototype.getClassName = function () {
	        return 'DictionaryTimezoneInfo';
	    };
	    return DictionaryTimezoneInfo;
	}(model.Model));
	exports.DictionaryTimezoneInfo = DictionaryTimezoneInfo;
	
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionlist = __webpack_require__(71);
	var extensioninfo = __webpack_require__(6);
	var extensionphonenumbers = __webpack_require__(72);
	var extensiongrantlist = __webpack_require__(73);
	var departmentmembers = __webpack_require__(76);
	var Extension = (function (_super) {
	    __extends(Extension, _super);
	    function Extension() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension List
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the list of extensions created for a particular account. All types of extensions are included in this list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.listExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension', options, exports.listExtensionsOptions), extensionlist.ExtensionList);
	    };
	    /**
	     * Get Extension Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular extension of an account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.loadExtensionInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}', options, exports.loadExtensionInfoOptions), extensioninfo.ExtensionInfo);
	    };
	    /**
	     * Get Extension Phone Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers that are used by a particular extension, and can be filtered by the phone number type. The returned list contains all numbers which are directly mapped to a given extension plus the features and also company-level numbers
	     *     which may be used when performing different operations on behalf of this extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/phone-number', options, exports.listExtensionPhoneNumbersOptions), extensionphonenumbers.ExtensionPhoneNumbers);
	    };
	    /**
	     * Get Extension Grant List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the list of extension grants.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionGrants = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/grant', options, exports.listExtensionGrantsOptions), extensiongrantlist.ExtensionGrantList);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.loadExtensionProfileImageOptions), null);
	    };
	    /**
	     * Create Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.createExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.createExtensionProfileImageOptions), null);
	    };
	    /**
	     * Update Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Updates the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.updateExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.updateExtensionProfileImageOptions), null);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the scaled profile image of an extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionScaledProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image/{scaleSize}', options, exports.loadExtensionScaledProfileImageOptions), null);
	    };
	    /**
	     * Get Department Member List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listDepartmentMembers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/department/{departmentId}/members', options, exports.listDepartmentMembersOptions), departmentmembers.DepartmentMembers);
	    };
	    return Extension;
	}(client.Client));
	exports.Extension = Extension;
	/**
	 * Definition of options for listExtensions operation
	 */
	exports.listExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "status",
	        "type": "IListExtensionsStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Enabled",
	            "Disabled",
	            "NotActivated",
	            "Unassigned"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "User",
	            "FaxUser",
	            "VirtualUser",
	            "DigitalUser",
	            "Department",
	            "Announcement",
	            "Voicemail",
	            "SharedLinesGroup",
	            "PagingOnlyGroup",
	            "IvrMenu",
	            "ApplicationExtension",
	            "ParkLocation"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionInfo operation
	 */
	exports.loadExtensionInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listExtensionPhoneNumbers operation
	 */
	exports.listExtensionPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "usageType",
	        "type": "IListExtensionPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listExtensionGrants operation
	 */
	exports.listExtensionGrantsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionProfileImage operation
	 */
	exports.loadExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for createExtensionProfileImage operation
	 */
	exports.createExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for updateExtensionProfileImage operation
	 */
	exports.updateExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadExtensionScaledProfileImage operation
	 */
	exports.loadExtensionScaledProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "scaleSize",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listDepartmentMembers operation
	 */
	exports.listDepartmentMembersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "departmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListExtensionsStatus) {
	    IListExtensionsStatus[IListExtensionsStatus["Enabled"] = 'Enabled'] = "Enabled";
	    IListExtensionsStatus[IListExtensionsStatus["Disabled"] = 'Disabled'] = "Disabled";
	    IListExtensionsStatus[IListExtensionsStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    IListExtensionsStatus[IListExtensionsStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.IListExtensionsStatus || (exports.IListExtensionsStatus = {}));
	var IListExtensionsStatus = exports.IListExtensionsStatus;
	(function (IListExtensionsType) {
	    IListExtensionsType[IListExtensionsType["User"] = 'User'] = "User";
	    IListExtensionsType[IListExtensionsType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    IListExtensionsType[IListExtensionsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    IListExtensionsType[IListExtensionsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    IListExtensionsType[IListExtensionsType["Department"] = 'Department'] = "Department";
	    IListExtensionsType[IListExtensionsType["Announcement"] = 'Announcement'] = "Announcement";
	    IListExtensionsType[IListExtensionsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    IListExtensionsType[IListExtensionsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    IListExtensionsType[IListExtensionsType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    IListExtensionsType[IListExtensionsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    IListExtensionsType[IListExtensionsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    IListExtensionsType[IListExtensionsType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.IListExtensionsType || (exports.IListExtensionsType = {}));
	var IListExtensionsType = exports.IListExtensionsType;
	(function (IListExtensionPhoneNumbersUsageType) {
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListExtensionPhoneNumbersUsageType || (exports.IListExtensionPhoneNumbersUsageType = {}));
	var IListExtensionPhoneNumbersUsageType = exports.IListExtensionPhoneNumbersUsageType;
	
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionList = (function (_super) {
	    __extends(ExtensionList, _super);
	    function ExtensionList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionList.prototype.getClassName = function () {
	        return 'ExtensionList';
	    };
	    return ExtensionList;
	}(model.Model));
	exports.ExtensionList = ExtensionList;
	
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionPhoneNumbers = (function (_super) {
	    __extends(ExtensionPhoneNumbers, _super);
	    function ExtensionPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionPhoneNumbers.prototype.getClassName = function () {
	        return 'ExtensionPhoneNumbers';
	    };
	    return ExtensionPhoneNumbers;
	}(model.Model));
	exports.ExtensionPhoneNumbers = ExtensionPhoneNumbers;
	
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var grantinfo = __webpack_require__(74);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionGrantList = (function (_super) {
	    __extends(ExtensionGrantList, _super);
	    function ExtensionGrantList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionGrantList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: grantinfo.GrantInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionGrantList.prototype.getClassName = function () {
	        return 'ExtensionGrantList';
	    };
	    return ExtensionGrantList;
	}(model.Model));
	exports.ExtensionGrantList = ExtensionGrantList;
	
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfogrants = __webpack_require__(75);
	var GrantInfo = (function (_super) {
	    __extends(GrantInfo, _super);
	    function GrantInfo() {
	        _super.apply(this, arguments);
	    }
	    GrantInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfogrants.ExtensionInfoGrants, isArray: false, isRequired: false },
	            { property: 'callPickup', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'callMonitoring', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    GrantInfo.prototype.getClassName = function () {
	        return 'GrantInfo';
	    };
	    return GrantInfo;
	}(model.Model));
	exports.GrantInfo = GrantInfo;
	
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoGrants = (function (_super) {
	    __extends(ExtensionInfoGrants, _super);
	    function ExtensionInfoGrants() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoGrants.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoGrantsType, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoGrants.prototype.getClassName = function () {
	        return 'ExtensionInfoGrants';
	    };
	    return ExtensionInfoGrants;
	}(model.Model));
	exports.ExtensionInfoGrants = ExtensionInfoGrants;
	(function (ExtensionInfoGrantsType) {
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["User"] = 'User'] = "User";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["FaxUser"] = 'Fax User'] = "FaxUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Department"] = 'Department'] = "Department";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["PagingOnly"] = 'PagingOnly'] = "PagingOnly";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ParkLocation"] = 'Park Location'] = "ParkLocation";
	})(exports.ExtensionInfoGrantsType || (exports.ExtensionInfoGrantsType = {}));
	var ExtensionInfoGrantsType = exports.ExtensionInfoGrantsType;
	
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DepartmentMembers = (function (_super) {
	    __extends(DepartmentMembers, _super);
	    function DepartmentMembers() {
	        _super.apply(this, arguments);
	    }
	    DepartmentMembers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DepartmentMembers.prototype.getClassName = function () {
	        return 'DepartmentMembers';
	    };
	    return DepartmentMembers;
	}(model.Model));
	exports.DepartmentMembers = DepartmentMembers;
	
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var messageinfo = __webpack_require__(78);
	var messagelist = __webpack_require__(81);
	var messagesync = __webpack_require__(82);
	var Messages = (function (_super) {
	    __extends(Messages, _super);
	    function Messages() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Pager Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends a pager message.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>InternalMessages</td>
	     *             <td>Sending and receiving intra-company text messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendInternalMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/company-pager', options, exports.sendInternalMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create Fax Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends/resends new fax message. Resend can be done if sending failed.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Faxes</td>
	     *             <td>Sending and receiving faxes</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Messages.prototype.sendFaxMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/fax', options, exports.sendFaxMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create SMS Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends new SMS message. Sending SMS messages simultaneously to different recipients is limited up to 50 requests per minute; relevant for all client applications.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>SMS</td>
	     *             <td>Sending and receiving SMS (text) messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendSMS = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/sms', options, exports.sendSMSOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Get Message List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of messages from an extension mailbox.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.listMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store', options, exports.listMessagesOptions), messagelist.MessageList);
	    };
	    /**
	     * Get Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns individual message record(s) by the given message ID(s). The length of inbound messages is unlimited. Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.loadMessage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.loadMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Update Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Updates message(s) by ID(s). Batch request is supported, see Batch Requests for details. Currently, only the message read status updating is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.updateMessage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.updateMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Delete Message(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Deletes message(s) by the given message ID(s). The first call of this method transfers the message to the 'Delete' status. The second call transfers the deleted message to the 'Purged' status. If it is required to make the message 'Purged' immediately
	     *     (from the first call), then set the query parameter purge to 'True'. Batch request is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.deleteMessage = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.deleteMessageOptions), null);
	    };
	    /**
	     * Get Message Attachment
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Returns particular message attachment data as a media stream.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.loadMessageAttachment = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}/content/{attachmentId}', options, exports.loadMessageAttachmentOptions), null);
	    };
	    /**
	     * Get Message Sync
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Provides facilities to synchronize mailbox content stored externally with server state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.syncMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-sync', options, exports.syncMessagesOptions), messagesync.MessageSync);
	    };
	    return Messages;
	}(client.Client));
	exports.Messages = Messages;
	/**
	 * Definition of options for sendInternalMessage operation
	 */
	exports.sendInternalMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createpagermessagerequest.CreatePagerMessageRequest"
	    }
	];
	/**
	 * Definition of options for sendFaxMessage operation
	 */
	exports.sendFaxMessageOptions = [
	    {
	        "name": "accountId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "extensionId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "Content-Type",
	        "in": "header",
	        "default": "multipart/mixed; boundary=Boundary_1_14413901_1361871080888",
	        "type": "string"
	    },
	    {
	        "name": "Content-Length",
	        "in": "header",
	        "default": "",
	        "type": "string"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "consumes": [
	            "multipart/mixed; boundary=Boundary_1_14413901_1361871080888"
	        ],
	        "default": "--Boundary_1_14413901_1361871080888\nContent-Type: application/json\n\n{\n  \"to\":[{\"phoneNumber\":\"18005630003\"}],\n  \"faxResolution\":\"High\",\n  \"sendTime\":\"2013-02-26T09:31:20.882Z\"\n}\n\n--Boundary_1_14413901_1361871080888\nContent-Type: text/plain\n\nHello, World!\n\n--Boundary_1_14413901_1361871080888--",
	        "type": "string"
	    }
	];
	/**
	 * Definition of options for sendSMS operation
	 */
	exports.sendSMSOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createsmsmessage.CreateSMSMessage"
	    }
	];
	/**
	 * Definition of options for listMessages operation
	 */
	exports.listMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "availability",
	        "type": "IListMessagesAvailability",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Alive",
	            "Deleted",
	            "Purged"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "IListMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "IListMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "readStatus",
	        "type": "IListMessagesReadStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Read",
	            "Unread"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessage operation
	 */
	exports.loadMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateMessage operation
	 */
	exports.updateMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updatemessagerequest.UpdateMessageRequest"
	    }
	];
	/**
	 * Definition of options for deleteMessage operation
	 */
	exports.deleteMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "purge",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessageAttachment operation
	 */
	exports.loadMessageAttachmentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "attachmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncMessages operation
	 */
	exports.syncMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ISyncMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "ISyncMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncMessagesSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListMessagesAvailability) {
	    IListMessagesAvailability[IListMessagesAvailability["Alive"] = 'Alive'] = "Alive";
	    IListMessagesAvailability[IListMessagesAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    IListMessagesAvailability[IListMessagesAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.IListMessagesAvailability || (exports.IListMessagesAvailability = {}));
	var IListMessagesAvailability = exports.IListMessagesAvailability;
	(function (IListMessagesDirection) {
	    IListMessagesDirection[IListMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListMessagesDirection[IListMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListMessagesDirection || (exports.IListMessagesDirection = {}));
	var IListMessagesDirection = exports.IListMessagesDirection;
	(function (IListMessagesMessageType) {
	    IListMessagesMessageType[IListMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    IListMessagesMessageType[IListMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    IListMessagesMessageType[IListMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    IListMessagesMessageType[IListMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    IListMessagesMessageType[IListMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.IListMessagesMessageType || (exports.IListMessagesMessageType = {}));
	var IListMessagesMessageType = exports.IListMessagesMessageType;
	(function (IListMessagesReadStatus) {
	    IListMessagesReadStatus[IListMessagesReadStatus["Read"] = 'Read'] = "Read";
	    IListMessagesReadStatus[IListMessagesReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.IListMessagesReadStatus || (exports.IListMessagesReadStatus = {}));
	var IListMessagesReadStatus = exports.IListMessagesReadStatus;
	(function (ISyncMessagesDirection) {
	    ISyncMessagesDirection[ISyncMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ISyncMessagesDirection[ISyncMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ISyncMessagesDirection || (exports.ISyncMessagesDirection = {}));
	var ISyncMessagesDirection = exports.ISyncMessagesDirection;
	(function (ISyncMessagesMessageType) {
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.ISyncMessagesMessageType || (exports.ISyncMessagesMessageType = {}));
	var ISyncMessagesMessageType = exports.ISyncMessagesMessageType;
	(function (ISyncMessagesSyncType) {
	    ISyncMessagesSyncType[ISyncMessagesSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncMessagesSyncType[ISyncMessagesSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncMessagesSyncType || (exports.ISyncMessagesSyncType = {}));
	var ISyncMessagesSyncType = exports.ISyncMessagesSyncType;
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageattachmentinfo = __webpack_require__(79);
	var messagestorecallerinfo = __webpack_require__(80);
	var MessageInfo = (function (_super) {
	    __extends(MessageInfo, _super);
	    function MessageInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'attachments', Class: messageattachmentinfo.MessageAttachmentInfo, isArray: true, isRequired: false },
	            { property: 'availability', Class: MessageInfoAvailability, isArray: false, isRequired: false },
	            { property: 'conversationId', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryErrorCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'direction', Class: MessageInfoDirection, isArray: false, isRequired: false },
	            { property: 'faxPageCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'faxResolution', Class: MessageInfoFaxResolution, isArray: false, isRequired: false },
	            { property: 'from', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'pgToDepartment', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'priority', Class: MessageInfoPriority, isArray: false, isRequired: false },
	            { property: 'readStatus', Class: MessageInfoReadStatus, isArray: false, isRequired: false },
	            { property: 'smsDeliveryTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'smsSendingAttemptsCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'subject', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'to', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: true, isRequired: false },
	            { property: 'type', Class: MessageInfoType, isArray: false, isRequired: false },
	            { property: 'vmTranscriptionStatus', Class: MessageInfoVmTranscriptionStatus, isArray: false, isRequired: false }
	        ];
	    };
	    MessageInfo.prototype.getClassName = function () {
	        return 'MessageInfo';
	    };
	    return MessageInfo;
	}(model.Model));
	exports.MessageInfo = MessageInfo;
	(function (MessageInfoAvailability) {
	    MessageInfoAvailability[MessageInfoAvailability["Alive"] = 'Alive'] = "Alive";
	    MessageInfoAvailability[MessageInfoAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    MessageInfoAvailability[MessageInfoAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.MessageInfoAvailability || (exports.MessageInfoAvailability = {}));
	var MessageInfoAvailability = exports.MessageInfoAvailability;
	(function (MessageInfoDirection) {
	    MessageInfoDirection[MessageInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    MessageInfoDirection[MessageInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.MessageInfoDirection || (exports.MessageInfoDirection = {}));
	var MessageInfoDirection = exports.MessageInfoDirection;
	(function (MessageInfoFaxResolution) {
	    MessageInfoFaxResolution[MessageInfoFaxResolution["High"] = 'High'] = "High";
	    MessageInfoFaxResolution[MessageInfoFaxResolution["Low"] = 'Low'] = "Low";
	})(exports.MessageInfoFaxResolution || (exports.MessageInfoFaxResolution = {}));
	var MessageInfoFaxResolution = exports.MessageInfoFaxResolution;
	(function (MessageInfoMessageStatus) {
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageInfoMessageStatus || (exports.MessageInfoMessageStatus = {}));
	var MessageInfoMessageStatus = exports.MessageInfoMessageStatus;
	(function (MessageInfoPriority) {
	    MessageInfoPriority[MessageInfoPriority["Normal"] = 'Normal'] = "Normal";
	    MessageInfoPriority[MessageInfoPriority["High"] = 'High'] = "High";
	})(exports.MessageInfoPriority || (exports.MessageInfoPriority = {}));
	var MessageInfoPriority = exports.MessageInfoPriority;
	(function (MessageInfoReadStatus) {
	    MessageInfoReadStatus[MessageInfoReadStatus["Read"] = 'Read'] = "Read";
	    MessageInfoReadStatus[MessageInfoReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.MessageInfoReadStatus || (exports.MessageInfoReadStatus = {}));
	var MessageInfoReadStatus = exports.MessageInfoReadStatus;
	(function (MessageInfoType) {
	    MessageInfoType[MessageInfoType["Fax"] = 'Fax'] = "Fax";
	    MessageInfoType[MessageInfoType["SMS"] = 'SMS'] = "SMS";
	    MessageInfoType[MessageInfoType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    MessageInfoType[MessageInfoType["Pager"] = 'Pager'] = "Pager";
	    MessageInfoType[MessageInfoType["Text"] = 'Text'] = "Text";
	})(exports.MessageInfoType || (exports.MessageInfoType = {}));
	var MessageInfoType = exports.MessageInfoType;
	(function (MessageInfoVmTranscriptionStatus) {
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["NotAvailable"] = 'NotAvailable'] = "NotAvailable";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["InProgress"] = 'InProgress'] = "InProgress";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["TimedOut"] = 'TimedOut'] = "TimedOut";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Completed"] = 'Completed'] = "Completed";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["CompletedPartially"] = 'CompletedPartially'] = "CompletedPartially";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Failed"] = 'Failed'] = "Failed";
	})(exports.MessageInfoVmTranscriptionStatus || (exports.MessageInfoVmTranscriptionStatus = {}));
	var MessageInfoVmTranscriptionStatus = exports.MessageInfoVmTranscriptionStatus;
	
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageAttachmentInfo = (function (_super) {
	    __extends(MessageAttachmentInfo, _super);
	    function MessageAttachmentInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageAttachmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MessageAttachmentInfoType, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'vmDuration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageAttachmentInfo.prototype.getClassName = function () {
	        return 'MessageAttachmentInfo';
	    };
	    return MessageAttachmentInfo;
	}(model.Model));
	exports.MessageAttachmentInfo = MessageAttachmentInfo;
	(function (MessageAttachmentInfoType) {
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioRecording"] = 'AudioRecording'] = "AudioRecording";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioTranscription"] = 'AudioTranscription'] = "AudioTranscription";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["Text"] = 'Text'] = "Text";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["SourceDocument"] = 'SourceDocument'] = "SourceDocument";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["RenderedDocument"] = 'RenderedDocument'] = "RenderedDocument";
	})(exports.MessageAttachmentInfoType || (exports.MessageAttachmentInfoType = {}));
	var MessageAttachmentInfoType = exports.MessageAttachmentInfoType;
	
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageStoreCallerInfo = (function (_super) {
	    __extends(MessageStoreCallerInfo, _super);
	    function MessageStoreCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageStoreCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageStoreCallerInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'faxErrorCode', Class: MessageStoreCallerInfoFaxErrorCode, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageStoreCallerInfo.prototype.getClassName = function () {
	        return 'MessageStoreCallerInfo';
	    };
	    return MessageStoreCallerInfo;
	}(model.Model));
	exports.MessageStoreCallerInfo = MessageStoreCallerInfo;
	(function (MessageStoreCallerInfoMessageStatus) {
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageStoreCallerInfoMessageStatus || (exports.MessageStoreCallerInfoMessageStatus = {}));
	var MessageStoreCallerInfoMessageStatus = exports.MessageStoreCallerInfoMessageStatus;
	(function (MessageStoreCallerInfoFaxErrorCode) {
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["Undefined"] = 'Undefined'] = "Undefined";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxSendPermission"] = 'NoFaxSendPermission'] = "NoFaxSendPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoInternationalPermission"] = 'NoInternationalPermission'] = "NoInternationalPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxMachine"] = 'NoFaxMachine'] = "NoFaxMachine";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["OutgoingCallError"] = 'OutgoingCallError'] = "OutgoingCallError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["RenderingFailed"] = 'RenderingFailed'] = "RenderingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["TooManyPages"] = 'TooManyPages'] = "TooManyPages";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ReturnToDBQueue"] = 'ReturnToDBQueue'] = "ReturnToDBQueue";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoCallTime"] = 'NoCallTime'] = "NoCallTime";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["WrongNumber"] = 'WrongNumber'] = "WrongNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedNumber"] = 'ProhibitedNumber'] = "ProhibitedNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternalError"] = 'InternalError'] = "InternalError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["FaxSendingProhibited"] = 'FaxSendingProhibited'] = "FaxSendingProhibited";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ThePhoneIsBlacklisted"] = 'ThePhoneIsBlacklisted'] = "ThePhoneIsBlacklisted";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["UserNotFound"] = 'UserNotFound'] = "UserNotFound";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ConvertError"] = 'ConvertError'] = "ConvertError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["DBGeneralError"] = 'DBGeneralError'] = "DBGeneralError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["SkypeBillingFailed"] = 'SkypeBillingFailed'] = "SkypeBillingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["AccountSuspended"] = 'AccountSuspended'] = "AccountSuspended";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedDestination"] = 'ProhibitedDestination'] = "ProhibitedDestination";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	})(exports.MessageStoreCallerInfoFaxErrorCode || (exports.MessageStoreCallerInfoFaxErrorCode = {}));
	var MessageStoreCallerInfoFaxErrorCode = exports.MessageStoreCallerInfoFaxErrorCode;
	
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MessageList = (function (_super) {
	    __extends(MessageList, _super);
	    function MessageList() {
	        _super.apply(this, arguments);
	    }
	    MessageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageList.prototype.getClassName = function () {
	        return 'MessageList';
	    };
	    return MessageList;
	}(model.Model));
	exports.MessageList = MessageList;
	
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var messagessyncinfo = __webpack_require__(83);
	var MessageSync = (function (_super) {
	    __extends(MessageSync, _super);
	    function MessageSync() {
	        _super.apply(this, arguments);
	    }
	    MessageSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: messagessyncinfo.MessagesSyncInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageSync.prototype.getClassName = function () {
	        return 'MessageSync';
	    };
	    return MessageSync;
	}(model.Model));
	exports.MessageSync = MessageSync;
	
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessagesSyncInfo = (function (_super) {
	    __extends(MessagesSyncInfo, _super);
	    function MessagesSyncInfo() {
	        _super.apply(this, arguments);
	    }
	    MessagesSyncInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: MessagesSyncInfoSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessagesSyncInfo.prototype.getClassName = function () {
	        return 'MessagesSyncInfo';
	    };
	    return MessagesSyncInfo;
	}(model.Model));
	exports.MessagesSyncInfo = MessagesSyncInfo;
	(function (MessagesSyncInfoSyncType) {
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["FSync"] = 'FSync'] = "FSync";
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.MessagesSyncInfoSyncType || (exports.MessagesSyncInfoSyncType = {}));
	var MessagesSyncInfoSyncType = exports.MessagesSyncInfoSyncType;
	
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var getsubscriptioninforesponse = __webpack_require__(85);
	var NotificationsSubscriptionAPI = (function (_super) {
	    __extends(NotificationsSubscriptionAPI, _super);
	    function NotificationsSubscriptionAPI() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Creates a new subscription. To call this method with APNS transport type you have to specify endpoint_id attribute in get token request at authorization.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.create = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/subscription', options, exports.createOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Get Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Returns the requested subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Light</p>
	     */
	    NotificationsSubscriptionAPI.prototype.load = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.loadOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Renew Subscription / Modify Event Filters
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>With empty request body - renews the existent subscription. If event filters specified - modifies the event filters for the existing subscription. The client application can extend or narrow the events for which it receives notifications in the frame
	     *     of one subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.update = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.updateOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Cancel Subscription
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the existent subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.remove = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.removeOptions), null);
	    };
	    return NotificationsSubscriptionAPI;
	}(client.Client));
	exports.NotificationsSubscriptionAPI = NotificationsSubscriptionAPI;
	/**
	 * Definition of options for create operation
	 */
	exports.createOptions = [
	    {
	        "name": "body",
	        "type": "createsubscriptionrequest.CreateSubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for load operation
	 */
	exports.loadOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for update operation
	 */
	exports.updateOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "type": "modifysubscriptionrequest.ModifySubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for remove operation
	 */
	exports.removeOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var notificationdeliverymode = __webpack_require__(86);
	var GetSubscriptionInfoResponse = (function (_super) {
	    __extends(GetSubscriptionInfoResponse, _super);
	    function GetSubscriptionInfoResponse() {
	        _super.apply(this, arguments);
	    }
	    GetSubscriptionInfoResponse.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'eventFilters', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'expirationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'expiresIn', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'status', Class: GetSubscriptionInfoResponseStatus, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryMode', Class: notificationdeliverymode.NotificationDeliveryMode, isArray: false, isRequired: true }
	        ];
	    };
	    GetSubscriptionInfoResponse.prototype.getClassName = function () {
	        return 'GetSubscriptionInfoResponse';
	    };
	    return GetSubscriptionInfoResponse;
	}(model.Model));
	exports.GetSubscriptionInfoResponse = GetSubscriptionInfoResponse;
	(function (GetSubscriptionInfoResponseStatus) {
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Active"] = 'Active'] = "Active";
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Suspended"] = 'Suspended'] = "Suspended";
	})(exports.GetSubscriptionInfoResponseStatus || (exports.GetSubscriptionInfoResponseStatus = {}));
	var GetSubscriptionInfoResponseStatus = exports.GetSubscriptionInfoResponseStatus;
	
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NotificationDeliveryMode = (function (_super) {
	    __extends(NotificationDeliveryMode, _super);
	    function NotificationDeliveryMode() {
	        _super.apply(this, arguments);
	    }
	    NotificationDeliveryMode.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'transportType', Class: NotificationDeliveryModeTransportType, isArray: false, isRequired: true },
	            { property: 'encryption', Class: null /* boolean */, isArray: false, isRequired: true },
	            { property: 'address', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'subscriberKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionAlgorithm', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'registrationId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'certificateName', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NotificationDeliveryMode.prototype.getClassName = function () {
	        return 'NotificationDeliveryMode';
	    };
	    return NotificationDeliveryMode;
	}(model.Model));
	exports.NotificationDeliveryMode = NotificationDeliveryMode;
	(function (NotificationDeliveryModeTransportType) {
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["PubNub"] = 'PubNub'] = "PubNub";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["APNS"] = 'APNS'] = "APNS";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType['PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP';
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["WebHook"] = 'WebHook'] = "WebHook";
	})(exports.NotificationDeliveryModeTransportType || (exports.NotificationDeliveryModeTransportType = {}));
	var NotificationDeliveryModeTransportType = exports.NotificationDeliveryModeTransportType;
	
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var presenceinfo = __webpack_require__(88);
	var monitoredextensions = __webpack_require__(90);
	var Presence = (function (_super) {
	    __extends(Presence, _super);
	    function Presence() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension(s) Presence Status by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns presence status of an extension or several extensions by their ID(s). Batch request is supported, see Batch Requests for details.The presenceStatus is returned as Offline (the parameters telephonyStatus, message, userStatus and dndStatus are not
	     *     returned at all) for the following extension types: Department/Announcement Only/Take Messages Only (Voicemail)/Fax User/Paging Only Group/Shared Lines Group/IVR Menu/Application Extension/Park Location.If the user requests his/her own presence status,
	     *     the response contains actual presence status even if the status publication is turned off.Batch request is supported. For batch requests the number of extensions in one request is limited to 30. If more extensions are included in the request, the
	     *     error code 400 Bad Request is returned with the logical error code InvalidMultipartRequest and the corresponding message 'Extension Presence Info multipart request is limited to 30 extensions'.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.getPresenceStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence', options, exports.getPresenceStatusOptions), presenceinfo.PresenceInfo);
	    };
	    /**
	     * Get Monitored Extensions
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns list of lines - extensions which presence status can be indicated and monitored on BLF-enabled (Busy Lamp Field) devices.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.listMonitoredExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence/line', options, exports.listMonitoredExtensionsOptions), monitoredextensions.MonitoredExtensions);
	    };
	    return Presence;
	}(client.Client));
	exports.Presence = Presence;
	/**
	 * Definition of options for getPresenceStatus operation
	 */
	exports.getPresenceStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listMonitoredExtensions operation
	 */
	exports.listMonitoredExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var presenceextensioninfo = __webpack_require__(89);
	var PresenceInfo = (function (_super) {
	    __extends(PresenceInfo, _super);
	    function PresenceInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'allowSeeMyPresence', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'dndStatus', Class: PresenceInfoDndStatus, isArray: false, isRequired: false },
	            { property: 'extension', Class: presenceextensioninfo.PresenceExtensionInfo, isArray: false, isRequired: false },
	            { property: 'message', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'pickUpCallsOnHold', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'presenceStatus', Class: PresenceInfoPresenceStatus, isArray: false, isRequired: false },
	            { property: 'ringOnMonitoredCall', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'telephonyStatus', Class: PresenceInfoTelephonyStatus, isArray: false, isRequired: false },
	            { property: 'userStatus', Class: PresenceInfoUserStatus, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceInfo.prototype.getClassName = function () {
	        return 'PresenceInfo';
	    };
	    return PresenceInfo;
	}(model.Model));
	exports.PresenceInfo = PresenceInfo;
	(function (PresenceInfoDndStatus) {
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeAllCalls"] = 'TakeAllCalls'] = "TakeAllCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptAnyCalls"] = 'DoNotAcceptAnyCalls'] = "DoNotAcceptAnyCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptDepartmentCalls"] = 'DoNotAcceptDepartmentCalls'] = "DoNotAcceptDepartmentCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeDepartmentCallsOnly"] = 'TakeDepartmentCallsOnly'] = "TakeDepartmentCallsOnly";
	})(exports.PresenceInfoDndStatus || (exports.PresenceInfoDndStatus = {}));
	var PresenceInfoDndStatus = exports.PresenceInfoDndStatus;
	(function (PresenceInfoPresenceStatus) {
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoPresenceStatus || (exports.PresenceInfoPresenceStatus = {}));
	var PresenceInfoPresenceStatus = exports.PresenceInfoPresenceStatus;
	(function (PresenceInfoTelephonyStatus) {
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["NoCall"] = 'NoCall'] = "NoCall";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["CallConnected"] = 'CallConnected'] = "CallConnected";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["Ringing"] = 'Ringing'] = "Ringing";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["OnHold"] = 'OnHold'] = "OnHold";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["ParkedCall"] = 'ParkedCall'] = "ParkedCall";
	})(exports.PresenceInfoTelephonyStatus || (exports.PresenceInfoTelephonyStatus = {}));
	var PresenceInfoTelephonyStatus = exports.PresenceInfoTelephonyStatus;
	(function (PresenceInfoUserStatus) {
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoUserStatus || (exports.PresenceInfoUserStatus = {}));
	var PresenceInfoUserStatus = exports.PresenceInfoUserStatus;
	
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PresenceExtensionInfo = (function (_super) {
	    __extends(PresenceExtensionInfo, _super);
	    function PresenceExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceExtensionInfo.prototype.getClassName = function () {
	        return 'PresenceExtensionInfo';
	    };
	    return PresenceExtensionInfo;
	}(model.Model));
	exports.PresenceExtensionInfo = PresenceExtensionInfo;
	
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var lineinfo = __webpack_require__(91);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MonitoredExtensions = (function (_super) {
	    __extends(MonitoredExtensions, _super);
	    function MonitoredExtensions() {
	        _super.apply(this, arguments);
	    }
	    MonitoredExtensions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: lineinfo.LineInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MonitoredExtensions.prototype.getClassName = function () {
	        return 'MonitoredExtensions';
	    };
	    return MonitoredExtensions;
	}(model.Model));
	exports.MonitoredExtensions = MonitoredExtensions;
	
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var monitoredlinesextensioninfo = __webpack_require__(92);
	var LineInfo = (function (_super) {
	    __extends(LineInfo, _super);
	    function LineInfo() {
	        _super.apply(this, arguments);
	    }
	    LineInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: monitoredlinesextensioninfo.MonitoredLinesExtensionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    LineInfo.prototype.getClassName = function () {
	        return 'LineInfo';
	    };
	    return LineInfo;
	}(model.Model));
	exports.LineInfo = LineInfo;
	
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MonitoredLinesExtensionInfo = (function (_super) {
	    __extends(MonitoredLinesExtensionInfo, _super);
	    function MonitoredLinesExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    MonitoredLinesExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MonitoredLinesExtensionInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    MonitoredLinesExtensionInfo.prototype.getClassName = function () {
	        return 'MonitoredLinesExtensionInfo';
	    };
	    return MonitoredLinesExtensionInfo;
	}(model.Model));
	exports.MonitoredLinesExtensionInfo = MonitoredLinesExtensionInfo;
	(function (MonitoredLinesExtensionInfoType) {
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["User"] = 'User'] = "User";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["Department"] = 'Department'] = "Department";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.MonitoredLinesExtensionInfoType || (exports.MonitoredLinesExtensionInfoType = {}));
	var MonitoredLinesExtensionInfoType = exports.MonitoredLinesExtensionInfoType;
	
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var ringoutstatus = __webpack_require__(94);
	var RingOut = (function (_super) {
	    __extends(RingOut, _super);
	    function RingOut() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Make RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Makes a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.makeRingOutCall = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout', options, exports.makeRingOutCallOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Get Status of RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the status of a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    RingOut.prototype.getRingOutCallStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.getRingOutCallStatusOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Cancel RingOut Call
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.cancelRingOutCall = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.cancelRingOutCallOptions), null);
	    };
	    return RingOut;
	}(client.Client));
	exports.RingOut = RingOut;
	/**
	 * Definition of options for makeRingOutCall operation
	 */
	exports.makeRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "makeringoutrequest.MakeRingOutRequest"
	    }
	];
	/**
	 * Definition of options for getRingOutCallStatus operation
	 */
	exports.getRingOutCallStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for cancelRingOutCall operation
	 */
	exports.cancelRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ringoutstatusinfo = __webpack_require__(95);
	var RingOutStatus = (function (_super) {
	    __extends(RingOutStatus, _super);
	    function RingOutStatus() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatus.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: ringoutstatusinfo.RingOutStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatus.prototype.getClassName = function () {
	        return 'RingOutStatus';
	    };
	    return RingOutStatus;
	}(model.Model));
	exports.RingOutStatus = RingOutStatus;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RingOutStatusInfo = (function (_super) {
	    __extends(RingOutStatusInfo, _super);
	    function RingOutStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'callStatus', Class: RingOutStatusInfoCallStatus, isArray: false, isRequired: false },
	            { property: 'callerStatus', Class: RingOutStatusInfoCallerStatus, isArray: false, isRequired: false },
	            { property: 'calleeStatus', Class: RingOutStatusInfoCalleeStatus, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatusInfo.prototype.getClassName = function () {
	        return 'RingOutStatusInfo';
	    };
	    return RingOutStatusInfo;
	}(model.Model));
	exports.RingOutStatusInfo = RingOutStatusInfo;
	(function (RingOutStatusInfoCallStatus) {
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallStatus || (exports.RingOutStatusInfoCallStatus = {}));
	var RingOutStatusInfoCallStatus = exports.RingOutStatusInfoCallStatus;
	(function (RingOutStatusInfoCallerStatus) {
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallerStatus || (exports.RingOutStatusInfoCallerStatus = {}));
	var RingOutStatusInfoCallerStatus = exports.RingOutStatusInfoCallerStatus;
	(function (RingOutStatusInfoCalleeStatus) {
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCalleeStatus || (exports.RingOutStatusInfoCalleeStatus = {}));
	var RingOutStatusInfoCalleeStatus = exports.RingOutStatusInfoCalleeStatus;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionforwardingnumberlist = __webpack_require__(97);
	var forwardingnumberinfo = __webpack_require__(98);
	var ForwardingNumbers = (function (_super) {
	    __extends(ForwardingNumbers, _super);
	    function ForwardingNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension Forwarding Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the list of extension phone numbers used for call forwarding and call flip. The returned list contains all the extension phone numbers that are used for call forwarding and call flip.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    ForwardingNumbers.prototype.listExtensionForwardingNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.listExtensionForwardingNumbersOptions), extensionforwardingnumberlist.ExtensionForwardingNumberList);
	    };
	    /**
	     * Create Forwarding Number
	     *
	     * <p style='font-style:italic;'>Since 1.0.12 (Release 6.4)</p>
	     * <p>Adds a new forwarding number to the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.createExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.createExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Update Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Updates an existent forwarding number from the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.updateExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.updateExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Delete Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Deletes a forwarding number from the forwarding number list by its ID.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.deleteExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.deleteExtensionForwardingNumberOptions), null);
	    };
	    return ForwardingNumbers;
	}(client.Client));
	exports.ForwardingNumbers = ForwardingNumbers;
	/**
	 * Definition of options for listExtensionForwardingNumbers operation
	 */
	exports.listExtensionForwardingNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for createExtensionForwardingNumber operation
	 */
	exports.createExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createforwardingnumberrequest.CreateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for updateExtensionForwardingNumber operation
	 */
	exports.updateExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updateforwardingnumberrequest.UpdateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for deleteExtensionForwardingNumber operation
	 */
	exports.deleteExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var forwardingnumberinfo = __webpack_require__(98);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionForwardingNumberList = (function (_super) {
	    __extends(ExtensionForwardingNumberList, _super);
	    function ExtensionForwardingNumberList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionForwardingNumberList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: forwardingnumberinfo.ForwardingNumberInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionForwardingNumberList.prototype.getClassName = function () {
	        return 'ExtensionForwardingNumberList';
	    };
	    return ExtensionForwardingNumberList;
	}(model.Model));
	exports.ExtensionForwardingNumberList = ExtensionForwardingNumberList;
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ForwardingNumberInfo = (function (_super) {
	    __extends(ForwardingNumberInfo, _super);
	    function ForwardingNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    ForwardingNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'label', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'features', Class: ForwardingNumberInfoFeatures, isArray: false, isRequired: false },
	            { property: 'flipNumber', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    ForwardingNumberInfo.prototype.getClassName = function () {
	        return 'ForwardingNumberInfo';
	    };
	    return ForwardingNumberInfo;
	}(model.Model));
	exports.ForwardingNumberInfo = ForwardingNumberInfo;
	(function (ForwardingNumberInfoFeatures) {
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallFlip"] = 'CallFlip'] = "CallFlip";
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallForwarding"] = 'CallForwarding'] = "CallForwarding";
	})(exports.ForwardingNumberInfoFeatures || (exports.ForwardingNumberInfoFeatures = {}));
	var ForwardingNumberInfoFeatures = exports.ForwardingNumberInfoFeatures;
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var blockednumberinfo = __webpack_require__(100);
	var blockednumberslist = __webpack_require__(101);
	var BlockedNumbers = (function (_super) {
	    __extends(BlockedNumbers, _super);
	    function BlockedNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Add Blocked Number
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.blockNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.blockNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Get Blocked Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers which are specified by the user to block inbound calls and SMS messages.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.listBlockedNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.listBlockedNumbersOptions), blockednumberslist.BlockedNumbersList);
	    };
	    /**
	     * Get Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.loadBlockedNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.loadBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Update Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.updateBlockedNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.updateBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Delete Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.unblockNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.unblockNumberOptions), null);
	    };
	    return BlockedNumbers;
	}(client.Client));
	exports.BlockedNumbers = BlockedNumbers;
	/**
	 * Definition of options for blockNumber operation
	 */
	exports.blockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listBlockedNumbers operation
	 */
	exports.listBlockedNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadBlockedNumber operation
	 */
	exports.loadBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateBlockedNumber operation
	 */
	exports.updateBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for unblockNumber operation
	 */
	exports.unblockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BlockedNumberInfo = (function (_super) {
	    __extends(BlockedNumberInfo, _super);
	    function BlockedNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BlockedNumberInfo.prototype.getClassName = function () {
	        return 'BlockedNumberInfo';
	    };
	    return BlockedNumberInfo;
	}(model.Model));
	exports.BlockedNumberInfo = BlockedNumberInfo;
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var blockednumberinfo = __webpack_require__(100);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var BlockedNumbersList = (function (_super) {
	    __extends(BlockedNumbersList, _super);
	    function BlockedNumbersList() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumbersList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: blockednumberinfo.BlockedNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    BlockedNumbersList.prototype.getClassName = function () {
	        return 'BlockedNumbersList';
	    };
	    return BlockedNumbersList;
	}(model.Model));
	exports.BlockedNumbersList = BlockedNumbersList;
	
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral-client.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['store', 'mapper', 'prefix', 'actions', 'emitter']);
	
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default reducer if module does not has its own reducer.
	 */
	function defaultReducer(state) {
	  if (typeof state === 'undefined') return {};
	  return state;
	}
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default parent state to module state mapper.
	 */
	function defaultMapper(state) {
	  return state;
	}
	
	/**
	 * @class
	 * @default
	 * @description Base module class.
	 */
	
	var RcModule = function () {
	  /**
	   * @constructor
	   */
	
	  function RcModule(_ref) {
	    var _this = this;
	
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? defaultMapper : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var actions = _ref.actions;
	    (0, _classCallCheck3.default)(this, RcModule);
	
	    // Extending EventEmitter breaks some mechanic, so we wire emitter up like this instead.
	    this[symbols.emitter] = new _eventEmitter2.default();
	    this[symbols.mapper] = stateMapper;
	    this[symbols.prefix] = prefix;
	    this[symbols.actions] = actions && (0, _reduxHelper.prefixActions)(actions, prefix);
	    registerStoreHandler(function (store) {
	      _this[symbols.store] = store;
	    });
	  }
	
	  /**
	   * @function
	   * @param {String} event
	   * @param {Function} handler
	   * @return {Function} Unregister function.
	   */
	
	
	  (0, _createClass3.default)(RcModule, [{
	    key: 'on',
	    value: function on(event, handler) {
	      var _this2 = this;
	
	      this[symbols.emitter].on(event, handler);
	      return function () {
	        _this2[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function)} handler
	     * @return {Function} Unregister function.
	     */
	
	  }, {
	    key: 'once',
	    value: function once(event, handler) {
	      var _this3 = this;
	
	      this[symbols.emitter].once(event, handler);
	      return function () {
	        _this3[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {...args} args
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var _symbols$emitter;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      (_symbols$emitter = this[symbols.emitter]).emit.apply(_symbols$emitter, [event].concat(args));
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'off',
	    value: function off(event, handler) {
	      this[symbols.emitter].off(event, handler);
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this[symbols.mapper](this[symbols.store].getState());
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return defaultReducer;
	    }
	  }, {
	    key: 'store',
	    get: function get() {
	      return this[symbols.store];
	    }
	  }, {
	    key: 'prefix',
	    get: function get() {
	      return this[symbols.prefix];
	    }
	  }, {
	    key: 'actions',
	    get: function get() {
	      return this[symbols.actions];
	    }
	  }]);
	  return RcModule;
	}();
	
	exports.default = RcModule;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class
	 * @description Helper class for creating a symbol mapping
	 */
	
	var SymbolMap = function (_Enum) {
	  (0, _inherits3.default)(SymbolMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} keys
	   */
	
	  function SymbolMap(keys) {
	    (0, _classCallCheck3.default)(this, SymbolMap);
	
	    var definition = {};
	    keys.forEach(function (key) {
	      definition[key] = (0, _symbol2.default)();
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SymbolMap).call(this, definition));
	  }
	
	  return SymbolMap;
	}(_enum2.default);
	
	exports.default = SymbolMap;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = {}.hasOwnProperty;
	var DEFINITION = (0, _symbol2.default)();
	var VALUES = (0, _symbol2.default)();
	
	var Enum = function () {
	  function Enum(definition) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, Enum);
	
	    this[DEFINITION] = (0, _assign2.default)({}, definition);
	    this[VALUES] = new _set2.default();
	
	    var _loop = function _loop(key) {
	      if (hasOwnProperty.call(definition, key)) {
	        (0, _defineProperty2.default)(_this, key, {
	          get: function get() {
	            return this[DEFINITION][key];
	          },
	
	          enumerable: true
	        });
	        _this[VALUES].add(_this[DEFINITION][key]);
	      }
	    };
	
	    for (var key in definition) {
	      _loop(key);
	    }
	  }
	
	  (0, _createClass3.default)(Enum, null, [{
	    key: "hasValue",
	    value: function hasValue(value) {
	      return this[VALUES].has(value);
	    }
	  }]);
	  return Enum;
	}();
	
	/*
	 * //with Proxy support
	 *const enumHandler = {
	 *  get(target, key) {
	 *    return target[key];
	 *  },
	 *  set() {
	 *    return;
	 *  }
	 *};
	 *Enum = class Enum extends Proxy {
	 *  constructor(definition) {
	 *    super(Object.assign({}, definition), enumHandler);
	 *  }
	 *}
	 */
	
	
	exports.default = Enum;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionMap = undefined;
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	exports.prefixActions = prefixActions;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * @class
	 * @description helper class for creating redux action definition maps
	 */
	
	var ActionMap = exports.ActionMap = function (_Enum) {
	  (0, _inherits3.default)(ActionMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} actions - list of action strings
	   * @extends Enum
	   */
	
	  function ActionMap() {
	    var actions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	    (0, _classCallCheck3.default)(this, ActionMap);
	
	    var definition = {};
	    actions.forEach(function (action) {
	      definition[action] = prefix !== '' ? prefix + '-' + action : action;
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ActionMap).call(this, definition));
	  }
	
	  return ActionMap;
	}(_enum2.default);
	
	/**
	 * @function
	 * @description helper function to return a prefixed action definition maps
	 */
	
	
	function prefixActions(actions, prefix) {
	  if (!prefix || prefix === '') return actions;
	  var definition = {};
	  for (var action in actions) {
	    if (hasOwnProperty.call(actions, action)) {
	      definition[action] = prefix + '-' + action;
	    }
	  }
	  return new _enum2.default(definition);
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var d        = __webpack_require__(138)
	  , callable = __webpack_require__(151)
	
	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }
	
	  , on, once, off, emit, methods, descriptors, base;
	
	on = function (type, listener) {
		var data;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];
	
		return this;
	};
	
	once = function (type, listener) {
		var once, self;
	
		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});
	
		once.__eeOnceListener__ = listener;
		return this;
	};
	
	off = function (type, listener) {
		var data, listeners, candidate, i;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];
	
		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}
	
		return this;
	};
	
	emit = function (type) {
		var i, l, listener, listeners, args;
	
		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;
	
		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
	
			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};
	
	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};
	
	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};
	
	base = defineProperties({}, descriptors);
	
	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign        = __webpack_require__(139)
	  , normalizeOpts = __webpack_require__(146)
	  , isCallable    = __webpack_require__(147)
	  , contains      = __webpack_require__(148)
	
	  , d;
	
	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}
	
		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};
	
	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}
	
		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(140)()
		? Object.assign
		: __webpack_require__(141);


/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys  = __webpack_require__(142)
	  , value = __webpack_require__(145)
	
	  , max = Math.max;
	
	module.exports = function (dest, src/*, srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(143)()
		? Object.keys
		: __webpack_require__(144);


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	'use strict';
	
	var keys = Object.keys;
	
	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};
	
	module.exports = function (options/*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 147 */
/***/ function(module, exports) {

	// Deprecated
	
	'use strict';
	
	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(149)()
		? String.prototype.contains
		: __webpack_require__(150);


/***/ },
/* 149 */
/***/ function(module, exports) {

	'use strict';
	
	var str = 'razdwatrzy';
	
	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	var indexOf = String.prototype.indexOf;
	
	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _redux = __webpack_require__(153);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['reducer']);
	
	function getSettingsReducer(prefix) {
	  return function (state, action) {
	    if (typeof state === 'undefined') return {};
	
	    return state;
	  };
	}
	
	var Settings = function (_RcModule) {
	  (0, _inherits3.default)(Settings, _RcModule);
	
	  function Settings(options) {
	    (0, _classCallCheck3.default)(this, Settings);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Settings).call(this, (0, _extends3.default)({}, options)));
	
	    _this[symbols.reducer] = {
	      base: getSettingsReducer(_this.prefix)
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'registerReducer',
	    value: function registerReducer(name, reducer) {
	      this[symbols.reducer][name] = reducer;
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _redux.combineReducers)(this[symbols.reducer]);
	    }
	  }]);
	  return Settings;
	}(_rcModule2.default);
	
	exports.default = Settings;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(154);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(161);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(163);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(164);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(159);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(156),
	    isHostObject = __webpack_require__(157),
	    isObjectLike = __webpack_require__(158);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(160)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(154);
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _brandReducer = __webpack_require__(168);
	
	var _brandReducer2 = _interopRequireDefault(_brandReducer);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['initialState']);
	
	var Brand = function (_RcModule) {
	  (0, _inherits3.default)(Brand, _RcModule);
	
	  function Brand(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? function (state) {
	      return state.brand;
	    } : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var id = _ref.id;
	    var name = _ref.name;
	    (0, _classCallCheck3.default)(this, Brand);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Brand).call(this, {
	      registerStoreHandler: registerStoreHandler,
	      stateMapper: stateMapper,
	      prefix: prefix,
	      actions: _brandActions2.default
	    }));
	
	    _this[symbols.initialState] = {
	      id: id,
	      name: name
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Brand, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _brandReducer2.default)(this[symbols.initialState], this.prefix);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this.state.id;
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return this.state.name;
	    }
	  }]);
	  return Brand;
	}(_rcModule2.default);
	
	exports.default = Brand;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['setBrand']);

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _reduxHelper = __webpack_require__(136);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getReducer(initialState, prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_brandActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	
	    if (!action) return state;
	    switch (action.type) {
	      case actions.setBrand:
	        return (0, _assign2.default)({}, state, {
	          name: action.payload.name,
	          id: action.payload.id
	        });
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _toConsumableArray2 = __webpack_require__(170);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _authReducer = __webpack_require__(189);
	
	var _authReducer2 = _interopRequireDefault(_authReducer);
	
	var _authEvents = __webpack_require__(190);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['platform', 'emitter', 'beforeLogoutHandlers']);
	
	var ENUMS = new _enum2.default({
	  loginStatus: _loginStatus2.default
	});
	
	/**
	 * @class
	 * @description Authentication module
	 */
	
	var Auth = function (_RcModule) {
	  (0, _inherits3.default)(Auth, _RcModule);
	
	  /**
	   * @function
	   */
	
	  function Auth(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Auth);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Auth).call(this, (0, _extends3.default)({}, options, {
	      actions: _authActions2.default
	    })));
	
	    var platform = options.platform;
	
	
	    _this[symbols.platform] = platform;
	    _this[symbols.beforeLogoutHandlers] = new _set2.default();
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.loginSuccess
	      });
	      _utils.emit.call(_this, _authEvents.authEventTypes.loginStatusChanged, _this.state.status);
	    });
	    // loginError
	    platform.on(platform.events.loginError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.loginError,
	        error: error
	      });
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.logoutSuccess
	      });
	      // this.emit(authEvents.userInfoCleared);
	    });
	
	    platform.on(platform.events.logoutError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.logoutError,
	        error: error
	      });
	    });
	
	    platform.on(platform.events.refreshError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.refreshError,
	        error: error
	      });
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      var loggedIn;
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              loggedIn = _context.sent;
	
	              _this.store.dispatch({
	                type: _this.actions.init,
	                status: loggedIn ? _loginStatus2.default.loggedIn : _loginStatus2.default.notLoggedIn
	              });
	              _this.emit(_authEvents.authEventTypes.loginStatusChanged, _this.state.status);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this2);
	    }))();
	    return _this;
	  }
	
	  (0, _createClass3.default)(Auth, [{
	    key: 'login',
	
	    /**
	     * @function
	     * @async
	     * @description Login function using username and password
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref) {
	        var username = _ref.username;
	        var password = _ref.password;
	        var extension = _ref.extension;
	        var remember = _ref.remember;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    username: username,
	                    password: password,
	                    extension: extension,
	                    remember: remember
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context2.next = 4;
	                return this[symbols.platform].login({
	                  username: username,
	                  password: password,
	                  extension: extension,
	                  remember: remember
	                });
	
	              case 4:
	                return _context2.abrupt('return', _context2.sent);
	
	              case 5:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	
	      function login(_x) {
	        return ref.apply(this, arguments);
	      }
	
	      return login;
	    }()
	
	    /**
	     * @function
	     * @description get OAuth page url
	     */
	
	  }, {
	    key: 'loginUrl',
	    value: function loginUrl(_ref2) {
	      var redirectUri = _ref2.redirectUri;
	      var state = _ref2.state;
	      var brandId = _ref2.brandId;
	      var display = _ref2.display;
	      var prompt = _ref2.prompt;
	
	      return this[symbols.platform].loginUrl({
	        redirectUri: redirectUri,
	        state: state,
	        brandId: brandId,
	        display: display,
	        prompt: prompt
	      });
	    }
	
	    /**
	     * @function
	     * @param {string} url
	     * @return {Object}
	     */
	
	  }, {
	    key: 'parseLoginUrl',
	    value: function parseLoginUrl(url) {
	      return this[symbols.platform].parseLoginRedirectUrl(url);
	    }
	
	    /**
	     * @function
	     * @async
	     * @description Authorize using OAauth code
	     */
	
	  }, {
	    key: 'authorize',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(_ref3) {
	        var code = _ref3.code;
	        var redirectUri = _ref3.redirectUri;
	        return _regenerator2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    code: code,
	                    redirectUri: redirectUri
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context3.next = 4;
	                return this[symbols.platform].login({
	                  code: code,
	                  redirectUri: redirectUri
	                });
	
	              case 4:
	                return _context3.abrupt('return', _context3.sent);
	
	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	
	      function authorize(_x2) {
	        return ref.apply(this, arguments);
	      }
	
	      return authorize;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Log the user out
	     */
	
	  }, {
	    key: 'logout',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	        var _this3 = this;
	
	        var handlers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
	
	        return _regenerator2.default.wrap(function _callee5$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                // deal with removing subscriptions
	
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingOut);
	                handlers = [].concat((0, _toConsumableArray3.default)(this[symbols.beforeLogoutHandlers]));
	                _iteratorNormalCompletion = true;
	                _didIteratorError = false;
	                _iteratorError = undefined;
	                _context6.prev = 5;
	                _loop = _regenerator2.default.mark(function _loop() {
	                  var handler;
	                  return _regenerator2.default.wrap(function _loop$(_context5) {
	                    while (1) {
	                      switch (_context5.prev = _context5.next) {
	                        case 0:
	                          handler = _step.value;
	                          _context5.prev = 1;
	                          _context5.next = 4;
	                          return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                            return _regenerator2.default.wrap(function _callee4$(_context4) {
	                              while (1) {
	                                switch (_context4.prev = _context4.next) {
	                                  case 0:
	                                    return _context4.abrupt('return', handler());
	
	                                  case 1:
	                                  case 'end':
	                                    return _context4.stop();
	                                }
	                              }
	                            }, _callee4, _this3);
	                          }))();
	
	                        case 4:
	                          _context5.next = 8;
	                          break;
	
	                        case 6:
	                          _context5.prev = 6;
	                          _context5.t0 = _context5['catch'](1);
	
	                        case 8:
	                        case 'end':
	                          return _context5.stop();
	                      }
	                    }
	                  }, _loop, _this3, [[1, 6]]);
	                });
	                _iterator = (0, _getIterator3.default)(handlers);
	
	              case 8:
	                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                  _context6.next = 13;
	                  break;
	                }
	
	                return _context6.delegateYield(_loop(), 't0', 10);
	
	              case 10:
	                _iteratorNormalCompletion = true;
	                _context6.next = 8;
	                break;
	
	              case 13:
	                _context6.next = 19;
	                break;
	
	              case 15:
	                _context6.prev = 15;
	                _context6.t1 = _context6['catch'](5);
	                _didIteratorError = true;
	                _iteratorError = _context6.t1;
	
	              case 19:
	                _context6.prev = 19;
	                _context6.prev = 20;
	
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	
	              case 22:
	                _context6.prev = 22;
	
	                if (!_didIteratorError) {
	                  _context6.next = 25;
	                  break;
	                }
	
	                throw _iteratorError;
	
	              case 25:
	                return _context6.finish(22);
	
	              case 26:
	                return _context6.finish(19);
	
	              case 27:
	                _context6.next = 29;
	                return this[symbols.platform].logout();
	
	              case 29:
	                return _context6.abrupt('return', _context6.sent);
	
	              case 30:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee5, this, [[5, 15, 19, 27], [20,, 22, 26]]);
	      }));
	
	      function logout() {
	        return ref.apply(this, arguments);
	      }
	
	      return logout;
	    }()
	    /**
	     * @function
	     * @param {Function} handler
	     * @returns {Function}
	     */
	
	  }, {
	    key: 'addBeforeLogoutHandler',
	    value: function addBeforeLogoutHandler(handler) {
	      var _this4 = this;
	
	      this[symbols.beforeLogoutHandlers].add(handler);
	      return function () {
	        _this4[symbols.beforeLogoutHandlers].remove(handler);
	      };
	    }
	    /**
	     * @function
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'removeBeforeLogoutHandler',
	    value: function removeBeforeLogoutHandler(handler) {
	      this[symbols.beforeLogoutHandlers].remove(handler);
	    }
	  }, {
	    key: 'isLoggedIn',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	        return _regenerator2.default.wrap(function _callee6$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                _context7.next = 2;
	                return this[symbols.platform].loggedIn();
	
	              case 2:
	                return _context7.abrupt('return', _context7.sent);
	
	              case 3:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee6, this);
	      }));
	
	      function isLoggedIn() {
	        return ref.apply(this, arguments);
	      }
	
	      return isLoggedIn;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _authReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _authEvents.authEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _authEvents.authEventTypes;
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Auth;
	}(_rcModule2.default);
	
	exports.default = Auth;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(171);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(172), __esModule: true };

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(173);
	module.exports = __webpack_require__(8).Array.from;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(9)
	  , $export        = __webpack_require__(6)
	  , toObject       = __webpack_require__(39)
	  , call           = __webpack_require__(109)
	  , isArrayIter    = __webpack_require__(110)
	  , toLength       = __webpack_require__(30)
	  , createProperty = __webpack_require__(174)
	  , getIterFn      = __webpack_require__(69);
	
	$export($export.S + $export.F * !__webpack_require__(175)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12)
	  , createDesc      = __webpack_require__(20);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(61)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(177);


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(178);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }
	
	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            return step("next", value);
	          }, function (err) {
	            return step("throw", err);
	          });
	        }
	      }
	
	      return step("next");
	    });
	  };
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(181), __esModule: true };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(182);
	module.exports = __webpack_require__(8).Promise;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(54)
	  , global             = __webpack_require__(7)
	  , ctx                = __webpack_require__(9)
	  , classof            = __webpack_require__(65)
	  , $export            = __webpack_require__(6)
	  , isObject           = __webpack_require__(14)
	  , anObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(10)
	  , anInstance         = __webpack_require__(107)
	  , forOf              = __webpack_require__(108)
	  , setProto           = __webpack_require__(98).set
	  , speciesConstructor = __webpack_require__(183)
	  , task               = __webpack_require__(184).set
	  , microtask          = __webpack_require__(186)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(61)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(106)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(60)($Promise, PROMISE);
	__webpack_require__(111)(PROMISE);
	Wrapper = __webpack_require__(8)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(175)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(13)
	  , aFunction = __webpack_require__(10)
	  , SPECIES   = __webpack_require__(61)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(9)
	  , invoke             = __webpack_require__(185)
	  , html               = __webpack_require__(59)
	  , cel                = __webpack_require__(18)
	  , global             = __webpack_require__(7)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(27)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , macrotask = __webpack_require__(184).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(27)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING', // after init, before status from platform is determined
	  notLoggedIn: 'NOT_LOGGED_IN',
	  loggingIn: 'LOGGING_IN',
	  loggedIn: 'LOGGED_IN',
	  loggingOut: 'LOGGING_OUT'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['login', 'loginSuccess', 'loginError', 'logout', 'logoutSuccess', 'logoutError', 'refresh', 'refreshSuccess', 'refreshError', 'init'], 'auth');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getAuthReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _loginStatus2.default.pending,
	  authError: null
	};
	
	function getAuthReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_authActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.init:
	        return (0, _assign2.default)({}, state, { status: action.status });
	
	      case actions.login:
	        return {
	          status: _loginStatus2.default.loggingIn,
	          authError: null
	        };
	
	      case actions.loginSuccess:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: null
	        };
	
	      case actions.logoutSuccess:
	        return {
	          status: _loginStatus2.default.notLoggedIn,
	          authError: null
	        };
	
	      case actions.loginError:
	        return {
	          state: _loginStatus2.default.notLoggedIn,
	          authError: action.error
	        };
	
	      case actions.logoutError:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: action.error
	        };
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.authEventTypes = exports.authEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = (0, _extends3.default)({}, _loginStatus2.default);
	
	var authEvents = exports.authEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  loginStatusChanged: 'LOGIN_STATUS_CHANGED'
	};
	
	var authEventTypes = exports.authEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sleep = exports.fetchList = undefined;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var fetchList = exports.fetchList = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(fn) {
	    var fetchedPages, totalPages, list, data;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fetchedPages = 0;
	            totalPages = 1;
	            list = [];
	
	          case 3:
	            if (!(fetchedPages < totalPages)) {
	              _context.next = 12;
	              break;
	            }
	
	            fetchedPages++;
	            _context.next = 7;
	            return fn({
	              page: fetchedPages
	            });
	
	          case 7:
	            data = _context.sent;
	
	            totalPages = data.paging.totalPages;
	            list = list.concat(data.records);
	            _context.next = 3;
	            break;
	
	          case 12:
	            return _context.abrupt('return', list);
	
	          case 13:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function fetchList(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @param {String} eventType
	 * @param {String} event
	 * @description Helper function to emit eventTyped events and the event itself
	 */
	
	
	/**
	 * @function
	 * @param {Number} t
	 */
	
	var sleep = exports.sleep = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(t) {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            return _context2.abrupt('return', new _promise2.default(function (resolve) {
	              setTimeout(resolve, t);
	            }));
	
	          case 1:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function sleep(_x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	exports.extractData = extractData;
	exports.emit = emit;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function extractData(model) {
	  if (Array.isArray(model)) {
	    return model.map(function (item) {
	      return extractData(item);
	    });
	  } else if ((typeof model === 'undefined' ? 'undefined' : (0, _typeof3.default)(model)) === 'object') {
	    var data = {};
	    for (var key in model) {
	      if (key[0] !== '_' && model.hasOwnProperty(key)) {
	        data[key] = extractData(model[key]);
	      }
	    }
	    return data;
	  }
	  return model;
	}
	
	function emit(eventType, event) {
	  for (var _len = arguments.length, payloads = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    payloads[_key - 2] = arguments[_key];
	  }
	
	  this.emit.apply(this, [event].concat(payloads));
	  this.emit.apply(this, [eventType, event].concat(payloads));
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _stringify = __webpack_require__(193);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionReducer = __webpack_require__(196);
	
	var _subscriptionReducer2 = _interopRequireDefault(_subscriptionReducer);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['auth', 'sdk', 'platform', 'subscription', 'filterCache']);
	
	var filterRegex = {
	  message: /message-store$/,
	  presence: /presence(\?detailedTelephonyState=true)?$/,
	  telephony: /presence\?detailedTelephonyState=true$/,
	  line: /presence\/line$/,
	  linePresence: /presence\/line\/presence(\?detailedTelephonyState=true)?$/,
	  lineTelephony: /presence\/line\/presence\?detailedTelephonyState=true$/
	};
	
	/**
	 * @function
	 * @param {Object} message
	 * @description Handles messages delivered by the subscripton
	 */
	function messageHandler(message) {
	  var _this = this;
	
	  // determine which events the message falls under
	  var events = [];
	  if (filterRegex.message.test(message.event)) {
	    events.push('message');
	  } else if (filterRegex.line.test(message.event)) {
	    events.push('line');
	  } else if (filterRegex.linePresence.test(message.event)) {
	    events.push('linePresence');
	    if (filterRegex.lineTelephony.test(message.event)) events.push('lineTelephony');
	  } else if (filterRegex.presence.test(message.event)) {
	    events.push('presence');
	    if (filterRegex.telephony.test(message.event)) events.push('telephony');
	  }
	  // dispatch the message in redux manner
	  this.store.dispatch({
	    type: this.actions.notification,
	    eventTypes: events,
	    payload: message
	  });
	  // emit the messages as events
	  events.forEach(function (event) {
	    _utils.emit.call(_this, _subscriptionEvents.subscriptionEventTypes.notification, _subscriptionEvents.subscriptionEvents[event], message);
	  });
	}
	function init() {
	  var _this2 = this;
	
	  var platform = this[symbols.platform];
	  this[symbols.subscription] = this[symbols.sdk].createSubscription();
	  var ownerId = platform.auth().data().owner_id;
	  var cacheKey = null;
	  if (typeof localStorage !== 'undefined') {
	    cacheKey = this.prefix + '-sub-' + ownerId;
	    var cachedSubscription = localStorage.getItem(cacheKey);
	    if (cachedSubscription) {
	      try {
	        this.base.setSubscription(JSON.parse(cachedSubscription));
	      } catch (e) {
	        /* do nothing */
	      }
	    }
	  }
	
	  this.base.setEventFilters(this.filters);
	
	  this.base.on(this.base.events.notification, function (message) {
	    messageHandler.call(_this2, message);
	  });
	  this.base.on(this.base.events.removeSuccess, function () {
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.removeError, function () {
	    // TODO
	  });
	  this.base.on(this.base.events.renewSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    var oldStatus = _this2.status;
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    if (oldStatus !== _this2.status) {
	      _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    }
	  });
	  this.base.on(this.base.events.renewError, function (error) {
	    // TODO handle 429
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    _this2.base.reset().setEventFilters(_this2.filters).register().catch(function (e) {});
	  });
	  this.base.on(this.base.events.subscribeSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.subscribeError, function (error) {
	    // TODO
	    // handle 429
	    // handle subscription limit
	  });
	
	  if (this.filters.length) {
	    this.base.register().catch(function () {/* do nothing */});
	  }
	}
	
	var Subscription = function (_RcModule) {
	  (0, _inherits3.default)(Subscription, _RcModule);
	
	  function Subscription(options) {
	    var _this4 = this;
	
	    (0, _classCallCheck3.default)(this, Subscription);
	
	    var _this3 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Subscription).call(this, (0, _extends3.default)({}, options, {
	      registerStoreHandler: function registerStoreHandler(handler) {
	        options.registerStoreHandler(function (store) {
	          // set store to self first
	          handler(store);
	
	          // update store with cachedFilters
	          _this3.store.dispatch({
	            type: _this3.actions.updateFilters,
	            filters: _this3.filters
	          });
	
	          _this3[symbols.filterCache] = null;
	        });
	      },
	      actions: _subscriptionActions2.default
	    })));
	
	    var auth = options.auth;
	    var platform = options.platform;
	    var sdk = options.sdk;
	
	    _this3[symbols.auth] = auth;
	    _this3[symbols.platform] = platform;
	    _this3[symbols.sdk] = sdk;
	    _this3[symbols.subscription] = null;
	
	    // caches filters before redux store is created
	    _this3[symbols.filterCache] = [];
	
	    auth.on(auth.events.loggedIn, function () {
	      init.call(_this3);
	    });
	
	    auth.on(auth.events.loggedOut, function () {
	      if (_this3.base) {
	        _this3.reset();
	      }
	    });
	
	    // platform.on(platform.events.loginSuccess, () => {
	    //   this::init();
	    // });
	    // platform.on(platform.events.logoutSuccess, async () => {
	    //   if (this.base) {
	    //     await this.reset();
	    //   }
	    //   this[symbols.subscription] = null;
	    // });
	
	    auth.addBeforeLogoutHandler((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return _this3.reset();
	
	            case 2:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this4);
	    })));
	
	    // (async () => {
	    //   if (await platform.loggedIn()) {
	    //     this::init();
	    //   }
	    // })();
	    return _this3;
	  }
	
	  (0, _createClass3.default)(Subscription, [{
	    key: 'subscribe',
	    value: function subscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	
	      if (this.filters.indexOf(event) === -1) {
	        var newFilters = this.filters.slice();
	        newFilters.push(event);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          this.base.register().catch(function () {/* do nothing */});
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'unsubscribe',
	    value: function unsubscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	      var idx = this.filters.indexOf(event);
	      if (this.filters.indexOf(event) > -1) {
	        var newFilters = this.filters.slice();
	        newFilters.splice(idx, 1);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          if (newFilters.length) {
	            this.base.register().catch(function () {/* do nothing */});
	          } else {
	            this.base.remove();
	          }
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'reset',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	        var oldStatus;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	
	                if (!this.base) {
	                  _context2.next = 9;
	                  break;
	                }
	
	                if (!(this.status === _subscriptionStatus2.default.subscribed)) {
	                  _context2.next = 7;
	                  break;
	                }
	
	                _context2.next = 5;
	                return this.base.remove();
	
	              case 5:
	                _context2.next = 9;
	                break;
	
	              case 7:
	                _context2.next = 9;
	                return this.base.reset();
	
	              case 9:
	                _context2.next = 13;
	                break;
	
	              case 11:
	                _context2.prev = 11;
	                _context2.t0 = _context2['catch'](0);
	
	              case 13:
	                this[symbols.subscription] = null;
	                oldStatus = this.status;
	
	                this.store.dispatch({
	                  type: this.actions.updateStatus,
	                  status: _subscriptionStatus2.default.notSubscribed,
	                  subscription: null
	                });
	                if (oldStatus !== this.status) {
	                  _utils.emit.call(this, _subscriptionEvents.subscriptionEventTypes.statusChanged, this.status);
	                }
	
	              case 17:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[0, 11]]);
	      }));
	
	      function reset() {
	        return ref.apply(this, arguments);
	      }
	
	      return reset;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _subscriptionReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'filters',
	    get: function get() {
	      return this[symbols.filterCache] || this.state.filters;
	    }
	  }, {
	    key: 'base',
	    get: function get() {
	      return this[symbols.subscription];
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEventTypes;
	    }
	  }]);
	  return Subscription;
	}(_rcModule2.default);
	
	exports.default = Subscription;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(8)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['updateFilters', 'notification', 'updateStatus'], 'subscription');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getSubscriptionReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  cacheKey: null,
	  filters: [],
	  status: _subscriptionEvents.subscriptionEvents.pending
	};
	
	function getSubscriptionReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_subscriptionActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	      case actions.updateStatus:
	        return (0, _assign2.default)({}, state, {
	          status: action.status,
	          subscription: actions.subscription
	        });
	
	      case actions.updateFilters:
	        return (0, _assign2.default)({}, state, {
	          filters: action.filters.slice()
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.subscriptionEventTypes = exports.subscriptionEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinition = (0, _extends3.default)({
	  message: '/restapi/v1.0/account/~/extension/~/message-store',
	  presence: '/restapi/v1.0/account/~/extension/~/presence',
	  telephony: '/restapi/v1.0/account/~/extension/~/presence?detailedTelephonyState=true',
	  line: '/restapi/v1.0/account/~/extension/~/presence/line',
	  linePresence: '/restapi/v1.0/account/~/extension/~/presence/line/presence',
	  lineTelephony: '/restapi/v1.0/account/~/extension/~/presence/line/presence?detailedTelephonyState=true'
	}, _subscriptionStatus2.default);
	
	var subscriptionEvents = exports.subscriptionEvents = new _enum2.default(eventDefinition);
	
	var eventTypeDefinition = {
	  notification: 'NOTIFICATION',
	  statusChanged: 'STATUS_CHANGED'
	};
	
	var subscriptionEventTypes = exports.subscriptionEventTypes = new _enum2.default(eventTypeDefinition);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING',
	  subscribed: 'SUBSCRIBED',
	  notSubscribed: 'NOT_SUBSCRIBED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	// const initialState = {
	//   test: true,
	// };
	
	// function getUserSettingsReducer(prefix) {
	//   return (state, action) => {
	//     if (typeof state === 'undefined') return Object.assign({}, initialState);
	//     if (!action) return state;
	//     switch (action.type) {
	//       default:
	//         return state;
	//     }
	//   };
	// }
	
	/**
	 * @function
	 * @param {String} dataType
	 * @param {function} loadFunction - async loader function returning a promise
	 * @return {Promise}
	 * @description Generic data loading logic with events
	 */
	
	var loadData = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(dataType, loadFunction) {
	    var payload;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            this.store.dispatch({
	              type: this.actions['load' + dataType]
	            });
	            this.emit(_userEvents.userEvents['load' + dataType]);
	            _context.prev = 2;
	            _context.next = 5;
	            return loadFunction.call(this);
	
	          case 5:
	            payload = _context.sent;
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Success'],
	              payload: payload
	            });
	            _utils.emit.call(this, _userEvents.userEventTypes.userInfoChanged, _userEvents.userEvents['load' + dataType + 'Success']);
	            _context.next = 15;
	            break;
	
	          case 10:
	            _context.prev = 10;
	            _context.t0 = _context['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Failed']
	            });
	            this.emit(_userEvents.userEvents['load' + dataType + 'Failed']);
	            throw _context.t0;
	
	          case 15:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[2, 10]]);
	  }));
	  return function loadData(_x, _x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise<Object>}
	 * @description Fetch account info and extract the data
	 */
	
	
	var extractAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return this[symbols.api].account().loadAccount();
	
	          case 2:
	            _context2.t0 = _context2.sent;
	            return _context2.abrupt('return', (0, _utils.extractData)(_context2.t0));
	
	          case 4:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function extractAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return loadData.call(this, 'AccountInfo', extractAccountInfo);
	
	          case 2:
	            return _context3.abrupt('return', _context3.sent);
	
	          case 3:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function loadAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return this[symbols.api].extension().loadExtensionInfo();
	
	          case 2:
	            _context4.t0 = _context4.sent;
	            return _context4.abrupt('return', (0, _utils.extractData)(_context4.t0));
	
	          case 4:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function extractExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return loadData.call(this, 'ExtensionInfo', extractExtensionInfo);
	
	          case 2:
	            return _context5.abrupt('return', _context5.sent);
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function loadExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	    var _this = this;
	
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this[symbols.api].account().listDialingPlans(options);
	            });
	
	          case 2:
	            _context6.t0 = _context6.sent;
	            return _context6.abrupt('return', (0, _utils.extractData)(_context6.t0));
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function extractDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            _context7.next = 2;
	            return loadData.call(this, 'DialingPlans', extractDialingPlans);
	
	          case 2:
	            return _context7.abrupt('return', _context7.sent);
	
	          case 3:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function loadDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
	    var _this2 = this;
	
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            _context8.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this2[symbols.api].extension().listExtensionPhoneNumbers(options);
	            });
	
	          case 2:
	            _context8.t0 = _context8.sent;
	            return _context8.abrupt('return', (0, _utils.extractData)(_context8.t0));
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function extractPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            _context9.next = 2;
	            return loadData.call(this, 'PhoneNumbers', extractPhoneNumbers);
	
	          case 2:
	            return _context9.abrupt('return', _context9.sent);
	
	          case 3:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this);
	  }));
	  return function loadPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	    var _this3 = this;
	
	    return _regenerator2.default.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this3[symbols.api].forwardingNumbers().listExtensionForwardingNumbers(options);
	            });
	
	          case 2:
	            _context10.t0 = _context10.sent;
	            return _context10.abrupt('return', (0, _utils.extractData)(_context10.t0));
	
	          case 4:
	          case 'end':
	            return _context10.stop();
	        }
	      }
	    }, _callee10, this);
	  }));
	  return function extractForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
	    return _regenerator2.default.wrap(function _callee11$(_context11) {
	      while (1) {
	        switch (_context11.prev = _context11.next) {
	          case 0:
	            _context11.next = 2;
	            return loadData.call(this, 'ForwardingNumbers', extractForwardingNumbers);
	
	          case 2:
	            return _context11.abrupt('return', _context11.sent);
	
	          case 3:
	          case 'end':
	            return _context11.stop();
	        }
	      }
	    }, _callee11, this);
	  }));
	  return function loadForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
	    var _this4 = this;
	
	    return _regenerator2.default.wrap(function _callee12$(_context12) {
	      while (1) {
	        switch (_context12.prev = _context12.next) {
	          case 0:
	            _context12.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this4[symbols.api].blockedNumbers().listBlockedNumbers(options);
	            });
	
	          case 2:
	            _context12.t0 = _context12.sent;
	            return _context12.abrupt('return', (0, _utils.extractData)(_context12.t0));
	
	          case 4:
	          case 'end':
	            return _context12.stop();
	        }
	      }
	    }, _callee12, this);
	  }));
	  return function extractBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	    return _regenerator2.default.wrap(function _callee13$(_context13) {
	      while (1) {
	        switch (_context13.prev = _context13.next) {
	          case 0:
	            _context13.next = 2;
	            return loadData.call(this, 'BlockedNumbers', extractBlockedNumbers);
	
	          case 2:
	            return _context13.abrupt('return', _context13.sent);
	
	          case 3:
	          case 'end':
	            return _context13.stop();
	        }
	      }
	    }, _callee13, this);
	  }));
	  return function loadBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise}
	 */
	
	
	var loadInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14() {
	    return _regenerator2.default.wrap(function _callee14$(_context14) {
	      while (1) {
	        switch (_context14.prev = _context14.next) {
	          case 0:
	            _context14.prev = 0;
	            _context14.next = 3;
	            return _promise2.default.all([loadAccountInfo.call(this), loadExtensionInfo.call(this), loadDialingPlans.call(this), loadPhoneNumbers.call(this), loadForwardingNumbers.call(this), loadBlockedNumbers.call(this)]);
	
	          case 3:
	            _context14.next = 8;
	            break;
	
	          case 5:
	            _context14.prev = 5;
	            _context14.t0 = _context14['catch'](0);
	
	            // TODO send error out
	            console.log(_context14.t0);
	
	          case 8:
	          case 'end':
	            return _context14.stop();
	        }
	      }
	    }, _callee14, this, [[0, 5]]);
	  }));
	  return function loadInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @class User
	 * @extends RcModule
	 * @default
	 * @export
	 */
	
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _utils = __webpack_require__(191);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	var _userReducer = __webpack_require__(201);
	
	var _userReducer2 = _interopRequireDefault(_userReducer);
	
	var _userEvents = __webpack_require__(202);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'settings']);
	var User = function (_RcModule) {
	  (0, _inherits3.default)(User, _RcModule);
	
	  /**
	   * @function
	   * @param {Object} options
	   */
	
	  function User(options) {
	    var _this6 = this;
	
	    (0, _classCallCheck3.default)(this, User);
	
	    var _this5 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(User).call(this, (0, _extends3.default)({}, options, {
	      actions: _userActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this5[symbols.api] = api;
	    _this5[symbols.platform] = platform;
	    _this5[symbols.settings] = settings;
	
	    // settings.registerReducer('user', getUserSettingsReducer());
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      loadInfo.call(_this5);
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this5.store.dispatch({
	        type: _this5.actions.clearUserInfo
	      });
	      // this.emit(userEvents.userInfoCleared);
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15() {
	      return _regenerator2.default.wrap(function _callee15$(_context15) {
	        while (1) {
	          switch (_context15.prev = _context15.next) {
	            case 0:
	              _context15.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              if (!_context15.sent) {
	                _context15.next = 5;
	                break;
	              }
	
	              _context15.next = 5;
	              return loadInfo.call(_this5);
	
	            case 5:
	            case 'end':
	              return _context15.stop();
	          }
	        }
	      }, _callee15, _this6);
	    }))();
	
	    /**
	     * TODO:
	     *   1. Dialing Plan Checking
	     */
	    return _this5;
	  }
	
	  (0, _createClass3.default)(User, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _userReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _userEvents.userEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _userEvents.userEventTypes;
	    }
	  }, {
	    key: 'directNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.usageType === 'DirectNumber';
	      });
	    }
	  }, {
	    key: 'mainCompanyNumber',
	    get: function get() {
	      return this.state.phoneNumbers.find(function (n) {
	        return n.usageType === 'MainCompanyNumber';
	      });
	    }
	  }, {
	    key: 'dialingPlans',
	    get: function get() {
	      return this.state.dialingPlans;
	    }
	  }, {
	    key: 'extensionNumber',
	    get: function get() {
	      return this.state.extensionInfo.extensionNumber;
	    }
	  }, {
	    key: 'smsNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.features.indexOf('SmsSender') > -1;
	      });
	    }
	  }]);
	  return User;
	}(_rcModule2.default);
	
	exports.default = User;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['clearUserInfo', 'loadAccountInfo', 'loadAccountInfoSuccess', 'loadAccountInfoFailed', 'loadExtensionInfo', 'loadExtensionInfoSuccess', 'loadExtensionInfoFailed', 'loadDialingPlans', 'loadDialingPlansSuccess', 'loadDialingPlansFailed', 'loadPhoneNumbers', 'loadPhoneNumbersSuccess', 'loadPhoneNumbersFailed', 'loadForwardingNumbers', 'loadForwardingNumbersSuccess', 'loadForwardingNumbersFailed', 'loadBlockedNumbers', 'loadBlockedNumbersSuccess', 'loadBlockedNumbersFailed'], 'user');

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getUserReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  accountInfo: null,
	  accountInfoLoading: false,
	  accountInfoError: null,
	
	  extensionInfo: null,
	  extensionInfoLoading: false,
	  extensionInfoError: null,
	
	  dialingPlans: [],
	  dialingPlansLoading: false,
	  dialingPlansError: null,
	
	  phoneNumbers: [],
	  phoneNumbersLoading: false,
	  phoneNumbersError: null,
	
	  forwardingNumbers: [],
	  forwardingNumbersLoading: false,
	  forwardingNumbersError: null,
	
	  blockedNumbers: [],
	  blockedNumbersLoading: false,
	  blockedNumbersError: null
	};
	
	function getUserReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_userActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      // account info
	      case actions.loadAccountInfo:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: true
	        });
	      case actions.loadAccountInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          accountInfo: action.payload,
	          accountInfoLoading: false,
	          accountInfoError: null
	        });
	      case actions.loadAccountInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: false,
	          accountInfoError: action.error
	        });
	
	      // extension info
	      case actions.loadExtensionInfo:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: true
	        });
	      case actions.loadExtensionInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          extensionInfo: action.payload,
	          extensionInfoLoading: false,
	          extensionInfoError: null
	        });
	      case actions.loadExtensionInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: false,
	          extensionInfoError: action.error
	        });
	
	      // dialing plans
	      case actions.loadDialingPlans:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: true
	        });
	      case actions.loadDialingPlansSuccess:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlans: action.payload
	        });
	      case action.loadDialingPlansFailed:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlansError: action.error
	        });
	
	      // phone numbers
	      case actions.loadPhoneNumbers:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: true
	        });
	      case actions.loadPhoneNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbers: action.payload
	        });
	      case action.loadPhoneNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbersError: action.error
	        });
	
	      // forwarding numbers
	      case actions.loadForwardingNumbers:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: true
	        });
	      case actions.loadForwardingNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbers: action.payload
	        });
	      case action.loadForwardingNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbersError: action.error
	        });
	
	      // blocked numbers
	      case actions.loadBlockedNumbers:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: true
	        });
	      case actions.loadBlockedNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbers: action.payload
	        });
	      case action.loadBlockedNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbersError: action.error
	        });
	
	      case action.clearUserInfo:
	        return (0, _assign2.default)({}, initialState);
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.userEventTypes = exports.userEvents = undefined;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = {
	  userInfoLoaded: 'USER_INFO_LOADED',
	  userInfoCleared: 'USER_INFO_CLEARED',
	
	  loadAccountInfo: 'LOAD_ACCOUNT_INFO',
	  loadAccountInfoSuccess: 'LOAD_ACCOUNT_INFO_SUCCESS',
	  loadAccountInfoFailed: 'LOAD_ACCOUNT_INFO_FAILED',
	
	  loadExtensionInfo: 'LOAD_EXTENSION_INFO',
	  loadExtensionInfoSuccess: 'LOAD_EXTENSION_INFO_SUCCESS',
	  loadExtensionInfoFailed: 'LOAD_EXTENSION_INFO_FAILED',
	
	  loadDialingPlans: 'LOAD_DIALING_PLANS',
	  loadDialingPlansSuccess: 'LOAD_DIALING_PLANS_SUCCESS',
	  loadDialingPlansFailed: 'LOAD_DIALING_PLANS_FAILED',
	
	  loadPhoneNumbers: 'LOAD_PHONE_NUMBERS',
	  loadPhoneNumbersSuccess: 'LOAD_PHONE_NUMBERS_SUCCESS',
	  loadPhoneNumbersFailed: 'LOAD_PHONE_NUMBERS_FAILED',
	
	  loadForwardingNumbers: 'LOAD_FORWARDING_NUMBERS',
	  loadForwardingNumbersSuccess: 'LOAD_FORWARDING_NUMBERS_SUCCESS',
	  loadForwardingNumbersFailed: 'LOAD_FORWARDING_NUMBERS_FAILED',
	
	  loadBlockedNumbers: 'LOAD_BLOCKED_NUMBERS',
	  loadBlockedNumbersSuccess: 'LOAD_BLOCKED_NUMBERS_SUCCESS',
	  loadBlockedNumbersFailed: 'LOAD_BLOCKED_NUMBERS_FAILED'
	};
	
	var userEvents = exports.userEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  userInfoChanged: 'USER_INFO_CHANGED'
	};
	
	var userEventTypes = exports.userEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var initPhoneInstance = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	    var info;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return this[symbols.platform].post('/client-info/sip-provision', {
	              sipInfo: [{ transport: 'WSS' }]
	            }).then(function (res) {
	              return res.json();
	            });
	
	          case 2:
	            info = _context.sent;
	            return _context.abrupt('return', new _ringcentralWebPhone2.default(info, {
	              logLevel: 0,
	              audioHelper: {
	                enabled: true
	              }
	            }));
	
	          case 4:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function initPhoneInstance() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var record = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (flag) {
	              _context2.next = 6;
	              break;
	            }
	
	            _context2.next = 3;
	            return this.currentSession.stopRecord();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.stopRecord
	              }
	            });
	            _context2.next = 9;
	            break;
	
	          case 6:
	            _context2.next = 8;
	            return this.currentSession.startRecord();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.record
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function record(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var mute = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if (flag) {
	              _context3.next = 6;
	              break;
	            }
	
	            _context3.next = 3;
	            return this.currentSession.unmute();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unmute
	              }
	            });
	            _context3.next = 9;
	            break;
	
	          case 6:
	            _context3.next = 8;
	            return this.currentSession.mute();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.mute
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function mute(_x3) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var hold = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            if (flag) {
	              _context4.next = 6;
	              break;
	            }
	
	            _context4.next = 3;
	            return this.currentSession.unhold();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unhold
	              }
	            });
	            _context4.next = 9;
	            break;
	
	          case 6:
	            _context4.next = 8;
	            return this.currentSession.hold();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.hold
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function hold(_x5) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var park = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return this.currentSession.park();
	
	          case 2:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.park
	              }
	            });
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function park() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var transfer = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(number) {
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            this.checkSession();
	            _context6.next = 3;
	            return this.currentSession.transfer(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.transfer,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function transfer(_x7) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var flip = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(number) {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            this.checkSession();
	            _context7.next = 3;
	            return this.currentSession.flip(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.flip,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function flip(_x8) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var dtmf = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(number) {
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            this.checkSession();
	            _context8.next = 3;
	            return this.currentSession.dtmf(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.dtmf,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function dtmf(_x9) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var operations = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(name) {
	    var actions,
	        _actions$name,
	        _len,
	        args,
	        _key,
	        _args9 = arguments;
	
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            actions = { record: record, mute: mute, hold: hold, park: park, transfer: transfer, flip: flip, dtmf: dtmf };
	
	            this.checkSession();
	            _context9.prev = 2;
	
	            for (_len = _args9.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = _args9[_key];
	            }
	
	            _context9.next = 6;
	            return (_actions$name = actions[name]).call.apply(_actions$name, [this].concat(args));
	
	          case 6:
	            _context9.next = 12;
	            break;
	
	          case 8:
	            _context9.prev = 8;
	            _context9.t0 = _context9['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.error,
	                error: _context9.t0
	              }
	            });
	            // TODO: needed?
	            throw _context9.t0;
	
	          case 12:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this, [[2, 8]]);
	  }));
	  return function operations(_x10, _x11) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _webphoneReducer = __webpack_require__(206);
	
	var _webphoneReducer2 = _interopRequireDefault(_webphoneReducer);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _ringcentralWebPhone = __webpack_require__(210);
	
	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	var _authEvents = __webpack_require__(190);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'auth', 'platform', 'emitter', 'settings', 'phoneInstance']);
	
	var ENUMS = new _enum2.default({
	  webphoneStatus: _webphoneStatus2.default,
	  callStatus: _callStatus2.default
	});
	
	var Webphone = function (_RcModule) {
	  (0, _inherits3.default)(Webphone, _RcModule);
	
	  function Webphone(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Webphone);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Webphone).call(this, (0, _extends3.default)({}, options, {
	      actions: _webphoneActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	    var auth = options.auth;
	
	    _this[symbols.api] = api;
	    _this[symbols.platform] = platform;
	    _this[symbols.emitter] = new _eventEmitter2.default();
	    _this[symbols.settings] = settings;
	    _this[symbols.auth] = auth;
	
	    _this.currentSession = null;
	    _this.isRegistered = false;
	
	    // TODO: commented out until setting module completed
	    // settings.registerReducer('webphone', getWebphoneReducer())
	    _this[symbols.auth].on(_authEvents.authEventTypes.loginStatusChanged, (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	      return _regenerator2.default.wrap(function _callee10$(_context10) {
	        while (1) {
	          switch (_context10.prev = _context10.next) {
	            case 0:
	              _context10.next = 2;
	              return initPhoneInstance.call(_this);
	
	            case 2:
	              _this[symbols.phoneInstance] = _context10.sent;
	
	              _this[symbols.phoneInstance].userAgent.on('registered', function () {
	                // sip will fire multiple registered events, only dispatch one register action to state.
	                // TODO: is this isRegistered state needed to be store as instance variable
	                //       or just check store state
	                if (!_this.isRegistered) {
	                  _this.store.dispatch({
	                    type: _this.actions.registerSuccess
	                  });
	                }
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	              });
	              _this[symbols.phoneInstance].userAgent.on('unregistered', function () {
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	                _this.store.dispatch({
	                  type: _this.actions.unregister,
	                  operation: {
	                    type: _callActions2.default.clear
	                  }
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('registrationFailed', function (error) {
	                _this.store.dispatch({
	                  type: _this.actions.registerError,
	                  error: error
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('invite', function (session) {
	                _this.currentSession = session;
	                _this.listenSessionEvents();
	                console.log(session);
	                _this.store.dispatch({
	                  type: _this.actions.callIncoming,
	                  payload: {
	                    remoteIdentity: session.remoteIdentity,
	                    localIdentity: session.localIdentity
	                  }
	                });
	              });
	
	            case 7:
	            case 'end':
	              return _context10.stop();
	          }
	        }
	      }, _callee10, _this2);
	    })));
	    return _this;
	  }
	
	  (0, _createClass3.default)(Webphone, [{
	    key: 'call',
	
	
	    /**
	     * Make a phone call, this method should be called in registerSuccess state
	     * @param {string} toNumber
	     * @param {string} [fromNumber]
	     * @return {Session}
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(_ref) {
	        var toNumber = _ref.toNumber;
	        var fromNumber = _ref.fromNumber;
	        var media = _ref.media;
	        return _regenerator2.default.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                if (this[symbols.phoneInstance]) {
	                  _context11.next = 2;
	                  break;
	                }
	
	                throw Error('not registered');
	
	              case 2:
	                this.store.dispatch({
	                  type: this.actions.call,
	                  payload: {
	                    toNumber: toNumber,
	                    fromNumber: fromNumber
	                  }
	                });
	                this.currentSession = this[symbols.phoneInstance].userAgent.invite(toNumber, {
	                  media: {
	                    render: media
	                  }
	                });
	                this.listenSessionEvents();
	                _context11.prev = 5;
	                _context11.next = 8;
	                return this.currentSession;
	
	              case 8:
	                _context11.next = 14;
	                break;
	
	              case 10:
	                _context11.prev = 10;
	                _context11.t0 = _context11['catch'](5);
	
	                console.error(_context11.t0);
	                this.store.dispatch({
	                  type: this.actions.callError,
	                  error: _context11.t0
	                });
	
	              case 14:
	                return _context11.abrupt('return', this.currentSession);
	
	              case 15:
	              case 'end':
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this, [[5, 10]]);
	      }));
	
	      function call(_x12) {
	        return ref.apply(this, arguments);
	      }
	
	      return call;
	    }()
	
	    /**
	     * Accept a phone call, this method should be called when call is incoming
	     * @param {Object} media, see https://github.com/ringcentral/ringcentral-web-phone#accepting-incoming-call
	     * @return {Promise}
	     */
	
	  }, {
	    key: 'accept',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(media) {
	        return _regenerator2.default.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                this.checkSession();
	                _context12.prev = 1;
	                _context12.next = 4;
	                return this.currentSession.accept(media);
	
	              case 4:
	                _context12.next = 9;
	                break;
	
	              case 6:
	                _context12.prev = 6;
	                _context12.t0 = _context12['catch'](1);
	
	                // TODO
	                console.error(_context12.t0);
	
	              case 9:
	              case 'end':
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this, [[1, 6]]);
	      }));
	
	      function accept(_x13) {
	        return ref.apply(this, arguments);
	      }
	
	      return accept;
	    }()
	  }, {
	    key: 'bye',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	        return _regenerator2.default.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                this.checkSession();
	                _context13.prev = 1;
	                _context13.next = 4;
	                return this.currentSession.terminate();
	
	              case 4:
	                _context13.next = 9;
	                break;
	
	              case 6:
	                _context13.prev = 6;
	                _context13.t0 = _context13['catch'](1);
	
	                // TODO
	                console.error(_context13.t0);
	
	              case 9:
	              case 'end':
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this, [[1, 6]]);
	      }));
	
	      function bye() {
	        return ref.apply(this, arguments);
	      }
	
	      return bye;
	    }()
	  }, {
	    key: 'record',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(flag) {
	        return _regenerator2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                operations.call(this, 'record', flag);
	
	              case 1:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));
	
	      function record(_x14) {
	        return ref.apply(this, arguments);
	      }
	
	      return record;
	    }()
	  }, {
	    key: 'mute',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(flag) {
	        return _regenerator2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                operations.call(this, 'mute', flag);
	
	              case 1:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));
	
	      function mute(_x15) {
	        return ref.apply(this, arguments);
	      }
	
	      return mute;
	    }()
	  }, {
	    key: 'hold',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(flag) {
	        return _regenerator2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                operations.call(this, 'hold', flag);
	
	              case 1:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));
	
	      function hold(_x16) {
	        return ref.apply(this, arguments);
	      }
	
	      return hold;
	    }()
	  }, {
	    key: 'park',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(flag) {
	        return _regenerator2.default.wrap(function _callee17$(_context17) {
	          while (1) {
	            switch (_context17.prev = _context17.next) {
	              case 0:
	                operations.call(this, 'park', flag);
	
	              case 1:
	              case 'end':
	                return _context17.stop();
	            }
	          }
	        }, _callee17, this);
	      }));
	
	      function park(_x17) {
	        return ref.apply(this, arguments);
	      }
	
	      return park;
	    }()
	  }, {
	    key: 'transfer',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(number) {
	        return _regenerator2.default.wrap(function _callee18$(_context18) {
	          while (1) {
	            switch (_context18.prev = _context18.next) {
	              case 0:
	                operations.call(this, 'transfer', number);
	
	              case 1:
	              case 'end':
	                return _context18.stop();
	            }
	          }
	        }, _callee18, this);
	      }));
	
	      function transfer(_x18) {
	        return ref.apply(this, arguments);
	      }
	
	      return transfer;
	    }()
	  }, {
	    key: 'flip',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(number) {
	        return _regenerator2.default.wrap(function _callee19$(_context19) {
	          while (1) {
	            switch (_context19.prev = _context19.next) {
	              case 0:
	                operations.call(this, 'flip', number);
	
	              case 1:
	              case 'end':
	                return _context19.stop();
	            }
	          }
	        }, _callee19, this);
	      }));
	
	      function flip(_x19) {
	        return ref.apply(this, arguments);
	      }
	
	      return flip;
	    }()
	  }, {
	    key: 'dtmf',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20(number) {
	        return _regenerator2.default.wrap(function _callee20$(_context20) {
	          while (1) {
	            switch (_context20.prev = _context20.next) {
	              case 0:
	                operations.call(this, 'dtmf', number);
	
	              case 1:
	              case 'end':
	                return _context20.stop();
	            }
	          }
	        }, _callee20, this);
	      }));
	
	      function dtmf(_x20) {
	        return ref.apply(this, arguments);
	      }
	
	      return dtmf;
	    }()
	  }, {
	    key: 'loadRingAudio',
	    value: function loadRingAudio(_ref2) {
	      var incoming = _ref2.incoming;
	      var outgoing = _ref2.outgoing;
	
	      this[symbols.phoneInstance].userAgent.audioHelper.loadAudio({
	        incoming: incoming,
	        outgoing: outgoing
	      });
	    }
	  }, {
	    key: 'checkSession',
	    value: function checkSession() {
	      if (!this.currentSession) {
	        this.store.dispatch({
	          type: this.actions.sessionError
	        });
	        throw Error('No active session');
	      }
	    }
	
	    /**
	     * Internal method for listen session events
	     */
	
	  }, {
	    key: 'listenSessionEvents',
	    value: function listenSessionEvents() {
	      var _this3 = this;
	
	      this.currentSession.on('accepted', function (response) {
	        // accepted event for outbound call will returne a incomingResponse
	        if (response.data) {
	          _this3.store.dispatch({
	            type: _this3.actions.callConnect,
	            payload: {
	              remoteIdentity: response.to,
	              localIdentity: response.from
	            }
	          });
	          // accepted event for inbound call will only contain a row sip data
	        } else {
	          _this3.store.dispatch({
	            type: _this3.actions.callAccept
	          });
	        }
	      });
	      // all situation about call terminated except 'call cancel'
	      this.currentSession.on('terminated', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // when we call out and cancel the phone call
	      this.currentSession.on('cancel', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // should not need
	      this.currentSession.on('bye', function (response) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd
	        });
	        _this3.currentSession = null;
	      });
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _webphoneReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Webphone;
	}(_rcModule2.default);
	
	exports.default = Webphone;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['register', 'registerSuccess', 'registerError', 'unregister',
	
	// outbound call
	'call', 'callConnect',
	// inbound call
	'callAccept', 'callIncoming', 'callEnd', 'callError', 'callOperation',
	// no active session
	'sessionError']);

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap([
	// operational error
	'error',
	// unregister, clear operational state
	'clear',
	// operation
	'flip', 'record', 'stopRecord', 'hold', 'unhold', 'mute', 'unmute', 'park', 'transfer', 'forward', 'dtmf']);

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callReducer = __webpack_require__(208);
	
	var _callReducer2 = _interopRequireDefault(_callReducer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _webphoneStatus2.default.preRegister,
	  // assign from UI
	  toNumber: '',
	  fromNumber: '',
	  // sip info return from sip server
	  remoteIdentity: null,
	  localIdentity: null,
	  operation: (0, _callReducer2.default)(),
	  error: null
	};
	
	function getReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_webphoneActions2.default, prefix);
	
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.registerSuccess:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerSuccessed
	        });
	      case actions.registerError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerFailed,
	          error: action.error
	        });
	      case actions.unregister:
	        return initialState;
	      case actions.call:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnecting,
	          toNumber: action.payload.toNumber,
	          fromNumber: action.payload.fromNumber
	        });
	      case actions.callIncoming:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callIncoming,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      // TODO: update fromNumber, toNumber
	      case actions.callConnect:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      case actions.callAccept:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected
	        });
	      case actions.callEnd:
	        return (0, _assign2.default)({}, initialState, {
	          status: _webphoneStatus2.default.registerSuccessed,
	          error: action.error
	        });
	      case actions.callError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callFailed,
	          error: action.error
	        });
	      case actions.callOperation:
	        return (0, _assign2.default)({}, state, {
	          operation: (0, _callReducer2.default)(state.operation, action.operation)
	        });
	      case actions.sessionError:
	        return (0, _assign2.default)({}, initialState, {
	          error: action.error
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  // For registering
	  preRegister: 'PRE_REGISTER',
	  registerSuccessed: 'REGISTER_SUCCESSED',
	  registerFailed: 'REGISTER_FAILED',
	  // For callout and active call
	  callConnecting: 'CALL_CONNECTING',
	  callConnected: 'CALL_CONNECTED',
	  callFailed: 'CALL_FAILED',
	  // For incoming call
	  callIncoming: 'CALL_INCOMING'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = function (state, action) {
	  if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	  if (!action) return state;
	  switch (action.type) {
	
	    case _callActions2.default.error:
	      return (0, _assign2.default)({}, state, {
	        error: action.error
	      });
	    case _callActions2.default.clear:
	      return (0, _assign2.default)({}, initialState);
	    case _callActions2.default.record:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.recording) ? state.status : state.status.concat(_callStatus2.default.recording)
	      });
	    case _callActions2.default.stopRecord:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.recording)
	      });
	    case _callActions2.default.mute:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.muted) ? state.status : state.status.concat(_callStatus2.default.muted)
	      });
	    case _callActions2.default.unmute:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.muted)
	      });
	    case _callActions2.default.hold:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.holding) ? state.status : state.status.concat(_callStatus2.default.holding),
	        disabled: ['park', 'record']
	      });
	    case _callActions2.default.unhold:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.holding),
	        disabled: []
	      });
	    case _callActions2.default.park:
	      // https://en.wikipedia.org/wiki/Call_parking
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.parker) ? state.status : state.status.concat(_callStatus2.default.parker)
	      });
	    case _callActions2.default.transfer:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.transfered) ? state.status : state.status.concat(_callStatus2.default.transfered),
	        transferTaget: action.payload.number
	      });
	    case _callActions2.default.flip:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.flip) ? state.status : state.status.concat(_callStatus2.default.flip),
	        flipTarget: action.payload.number
	      });
	    case _callActions2.default.dtmf:
	      // TODO: clarify park action
	      return (0, _assign2.default)({}, state, {
	        status: state.status.concat(_callStatus2.default.parked),
	        dtmfNumber: action.payload.number
	      });
	
	    default:
	      return state;
	  }
	};
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function contain(arr, ele) {
	  return arr.indexOf(ele) > -1;
	}
	
	function remove(arr, ele) {
	  if (contain(arr, ele)) {
	    arr.splice(arr.indexOf(ele), 1);
	  }
	  return arr;
	}
	
	var initialState = {
	  // operations which is enable
	  status: [],
	  // some operations will disable another, such as 'hold'
	  disabled: [],
	  // some operations have infomation need to be stored
	  transferTaget: null,
	  flipTarget: null,
	  dtmfNumber: null,
	  // operation error
	  error: null
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  flip: 'FLIPED',
	  recording: 'RECORDING',
	  holding: 'HOLDING',
	  muted: 'MUTED',
	  parked: 'PARKED',
	  transfered: 'TRANSFERED',
	  forwarded: 'FOWARDED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(211)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {
	            return factory(SIP);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object') {
	        module.exports = factory(require('sip.js'));
	        module.exports.default = module.exports; //ES6
	    } else {
	        root.RingCentral = root.RingCentral || {};
	        root.RingCentral.WebPhone = factory(root.SIP);
	    }
	}(this, function(SIP) {
	
	    var messages = {
	        park: {reqid: 1, command: 'callpark'},
	        startRecord: {reqid: 2, command: 'startcallrecord'},
	        stopRecord: {reqid: 3, command: 'stopcallrecord'},
	        flip: {reqid: 3, command: 'callflip', target: ''},
	        monitor: {reqid: 4, command: 'monitor'},
	        barge: {reqid: 5, command: 'barge'},
	        whisper: {reqid: 6, command: 'whisper'},
	        takeover: {reqid: 7, command: 'takeover'}
	    };
	
	    var responseTimeout = 10000;
	
	    function uuid() {
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    }
	
	    function delay(ms) {
	        return new Promise(function(resolve, reject) {
	            setTimeout(resolve, ms);
	        });
	    }
	
	    function extend(dst, src) {
	        src = src || {};
	        dst = dst || {};
	        Object.keys(src).forEach(function(k) {
	            dst[k] = src[k];
	        });
	        return dst;
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param options
	     * @constructor
	     */
	    function AudioHelper(options) {
	
	        options = options || {};
	
	        this._enabled = !!options.enabled;
	        this.loadAudio(options);
	
	    }
	
	    AudioHelper.prototype._playSound = function(url, val, volume) {
	
	        if (!this._enabled || !url) return this;
	
	        if (!this._audio[url]) {
	            if (val) {
	                this._audio[url] = new Audio();
	                this._audio[url].src = url;
	                this._audio[url].loop = true;
	                this._audio[url].volume = volume;
	                this._audio[url].play();
	            }
	        } else {
	            if (val) {
	                this._audio[url].currentTime = 0;
	                this._audio[url].play();
	            } else {
	                this._audio[url].pause();
	            }
	        }
	
	        return this;
	
	    };
	
	    AudioHelper.prototype.loadAudio = function(options) {
	        this._incoming = options.incoming;
	        this._outgoing = options.outgoing;
	        this._audio = {};
	    }
	
	    AudioHelper.prototype.setVolume = function(volume) {
	        if (volume < 0) { volume = 0; }
	        if (volume > 1) { volume = 1; }
	        this.volume = volume;
	        for (var url in this._audio) {
	            if (this._audio.hasOwnProperty(url)) {
	                this._audio[url].volume = volume;
	            }
	        }
	    }
	
	    AudioHelper.prototype.playIncoming = function(val) {
	        return this._playSound(this._incoming, val, (this.volume || 0.5));
	    };
	
	    AudioHelper.prototype.playOutgoing = function(val) {
	        return this._playSound(this._outgoing, val, (this.volume || 1));
	    };
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param {object} regData
	     * @param {object} [options]
	     * @param {string} [options.uuid]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.audioHelper]
	     * @param {string} [options.onSession] fired each time UserAgent starts working with session
	     * @constructor
	     */
	    function WebPhone(regData, options) {
	
	        regData = regData || {};
	        options = options || {};
	
	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;
	        this.sipFlags = regData.sipFlags;
	
	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable
	        localStorage.setItem('rc-webPhone-uuid', id);
	
	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;
	
	        var configuration = {
	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,
	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport
	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy
	                : this.sipInfo.wsServers,
	            authorizationUser: this.sipInfo.authorizationId,
	            password: this.sipInfo.password,
	            traceSip: true,
	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?
	            turnServers: [],
	            log: {
	                level: options.logLevel || 1 //FIXME LOG LEVEL 3
	            },
	            domain: this.sipInfo.domain,
	            autostart: true,
	            register: true,
	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000
	        };
	
	        this.appKey = options.appKey;
	        this.appName = options.appName;
	        this.appVersion = options.appVersion;
	        this.userAgentHeader = 'RC-User-Agent: ' +
	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +
	                               'RCWEBPHONE/' + WebPhone.version;
	
	        this.clientIdHeader = 'Client-id:' + options.appKey;
	
	        this.userAgent = new SIP.UA(configuration).register({
	            extraHeaders: [
	                this.endpointHeader,
	                this.userAgentHeader,
	                this.clientIdHeader
	            ]
	        });
	
	        this.userAgent.endpointHeader = this.endpointHeader;
	        this.userAgent.userAgentHeader = this.userAgentHeader;
	        this.userAgent.clientIdHeader = this.clientIdHeader;
	        this.userAgent.sipInfo = this.sipInfo;
	
	        this.userAgent.__invite = this.userAgent.invite;
	        this.userAgent.invite = invite;
	
	        this.userAgent.on('invite', function(session) {
	            this.userAgent.audioHelper.playIncoming(true);
	            patchSession(session);
	        }.bind(this));
	
	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);
	
	        this.userAgent.onSession = options.onSession || null;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    WebPhone.version = '0.3.1';
	    WebPhone.uuid = uuid;
	    WebPhone.delay = delay;
	    WebPhone.extend = extend;
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function patchSession(session) {
	
	        if (session.__patched) return session;
	
	        session.__patched = true;
	
	        session.__sendRequest = session.sendRequest;
	        session.__receiveRequest = session.receiveRequest;
	        session.__receiveInviteResponse = session.receiveInviteResponse;
	        session.__receiveResponse = session.receiveResponse;
	        session.__accept = session.accept;
	        session.__hold = session.hold;
	        session.__unhold = session.unhold;
	        session.__dtmf = session.dtmf;
	
	        session.sendRequest = sendRequest;
	        session.receiveRequest = receiveRequest;
	        session.receiveInviteResponse = receiveInviteResponse;
	        session.receiveResponse = receiveResponse;
	        session.accept = accept;
	        session.hold = hold;
	        session.unhold = unhold;
	        session.dtmf = dtmf;
	
	        session.blindTransfer = blindTransfer;
	        session.transfer = transfer;
	        session.park = park;
	        session.forward = forward;
	        session.startRecord = startRecord;
	        session.stopRecord = stopRecord;
	        session.flip = flip;
	
	        session.on('replaced', patchSession);
	        // session.on('connecting', onConnecting);
	
	        // Audio
	        session.on('accepted', stopPlaying);
	        session.on('rejected', stopPlaying);
	        session.on('bye', stopPlaying);
	        session.on('terminated', stopPlaying);
	        session.on('cancel', stopPlaying);
	        session.on('failed', stopPlaying);
	        session.on('replaced', stopPlaying);
	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);
	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);
	
	        function stopPlaying() {
	            session.ua.audioHelper.playOutgoing(false);
	            session.ua.audioHelper.playIncoming(false);
	            session.removeListener('accepted', stopPlaying);
	            session.removeListener('rejected', stopPlaying);
	            session.removeListener('bye', stopPlaying);
	            session.removeListener('terminated', stopPlaying);
	            session.removeListener('cancel', stopPlaying);
	            session.removeListener('failed', stopPlaying);
	            session.removeListener('replaced', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);
	        }
	
	        if (session.ua.onSession) session.ua.onSession(session);
	
	        return session;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {object} command
	     * @param {object} [options]
	     * @return {Promise}
	     */
	    function sendReceive(session, command, options) {
	
	        options = options || {};
	
	        extend(command, options);
	
	        var cseq = null;
	
	        return new Promise(function(resolve, reject) {
	
	            session.sendRequest(SIP.C.INFO, {
	                body: JSON.stringify({
	                    request: command
	                }),
	                extraHeaders: [
	                    "Content-Type: application/json;charset=utf-8",
	                    session.ua.userAgentHeader,
	                    session.ua.endpointHeader,
	                    session.ua.clientIdHeader
	                ],
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 200) {
	                        cseq = response.cseq;
	                        var onInfo = function(request) {
	                            if (response.cseq === cseq) {
	
	                                var body = request && request.body || '{}';
	                                var obj;
	
	                                try {
	                                    obj = JSON.parse(body);
	                                } catch (e) {
	                                    obj = {};
	                                }
	
	                                if (obj.response && obj.response.command === command.command) {
	                                    if (obj.response.result) {
	                                        if (obj.response.result.code == 0) {
	                                            return resolve(obj.response.result);
	                                        } else {
	                                            return reject(obj.response.result);
	                                        }
	                                    }
	                                }
	                                timeout && clearTimeout(timeout);
	                                session.removeListener('RC_SIP_INFO', onInfo);
	                                resolve(null); //FIXME What to resolve
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_INFO', onInfo);
	                        }, responseTimeout);
	                        session.on('RC_SIP_INFO', onInfo);
	                    }
	                    else {
	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));
	                    }
	                }
	            });
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function sendRequest(type, config) {
	        if (type == SIP.C.PRACK) {
	            type = SIP.C.ACK;
	        }
	        return this.__sendRequest(type, config);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * Fired each time a provisional (100-199) response is received.
	     * Early media is supported by SIP.js library
	     * But in case it is sent without 100rel support we play it manually
	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	     *
	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
	     * @param {SIP.Session} session
	     * @param response
	     * @param {funciton} cb
	     */
	    function patch100rel(session, response, cb) {
	
	        //Early media is supported by SIP.js library
	        //But in case it is sent without 100rel support we play it manually
	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\n') !== -1) {
	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');
	        }
	
	        return cb.call(session, response);
	
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveInviteResponse(response) {
	        return patch100rel(this, response, this.__receiveInviteResponse);
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveResponse(response) {
	        return patch100rel(this, response, this.__receiveResponse);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setRecord(session, flag) {
	
	        var message = !!flag
	            ? messages.startRecord
	            : messages.stopRecord;
	
	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {
	            return sendReceive(session, message)
	                .then(function(data) {
	                    session.__onRecord = !!flag;
	                    return data;
	                });
	        }
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setHold(session, flag) {
	        return new Promise(function(resolve, reject) {
	
	            var options = {
	                eventHandlers: {
	                    succeeded: resolve,
	                    failed: reject
	                }
	            };
	
	            if (flag) {
	                session.__hold(options);
	            } else {
	                session.__unhold(options);
	            }
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.UA}
	     * @param number
	     * @param options
	     * @return {SIP.Session}
	     */
	    function invite(number, options) {
	
	        var ua = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(ua.userAgentHeader);
	        options.extraHeaders.push(ua.endpointHeader);
	        options.extraHeaders.push(ua.clientIdHeader);
	
	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number
	
	        //FIXME Backend should know it already
	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        ua.audioHelper.playOutgoing(true);
	
	        return patchSession(ua.__invite(number, options));
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param request
	     * @return {*}
	     */
	    function receiveRequest(request) {
	        var session = this;
	        switch (request.method) {
	            case SIP.C.INFO:
	                session.emit('RC_SIP_INFO', request);
	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	                    var contentType = request.getHeader('content-type');
	                    if (contentType.match(/^application\/json/i)) {
	                        request.reply(200);
	                        return session;
	                    }
	                }
	                break;
	            //Refresh invite should not be rejected with 488
	            case SIP.C.INVITE:
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {
	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {
	                        //TODO: check that SDP did not change
	                        session.logger.log('re-INVITE received');
	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;
	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {
	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;
	                            session.setInvite2xxTimer(request, localSDP);
	                            session.setACKTimer();
	                        });
	                        return session;
	                    }
	                    //else will be rejected with 488 by SIP.js
	                }
	                break;
	            //We need to analize NOTIFY messages sometimes, so we fire an event
	            case SIP.C.NOTIFY:
	                session.emit('RC_SIP_NOTIFY', request);
	                break;
	        }
	        return session.__receiveRequest.apply(session, arguments);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {object} options
	     * @return {Promise}
	     */
	    function accept(options) {
	
	        var session = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(session.ua.userAgentHeader);
	        options.extraHeaders.push(session.ua.endpointHeader);
	        options.extraHeaders.push(session.ua.clientIdHeader);
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        return new Promise(function(resolve, reject) {
	
	            function onAnswered() {
	                resolve(session);
	                session.removeListener('failed', onFail);
	            }
	
	            function onFail(e) {
	                reject(e);
	                session.removeListener('accepted', onAnswered);
	            }
	
	            //TODO More events?
	            session.once('accepted', onAnswered);
	            session.once('failed', onFail);
	
	            session.__accept(options);
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} dtmf
	     * @param {number} duration
	     * @return {Promise}
	     */
	    function dtmf(dtmf, duration) {
	        var session = this;
	        duration = parseInt(duration) || 1000;
	        var peer = session.mediaHandler.peerConnection;
	        var stream = session.getLocalStreams()[0];
	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);
	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {
	            return dtmfSender.insertDTMF(dtmf, duration);
	        }
	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\'t insert DTMF' : 'Unknown')));
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function hold() {
	        return setHold(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function unhold() {
	        return setHold(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function blindTransfer(target, options) {
	
	        options = options || {};
	
	        var session = this;
	        var extraHeaders = options.extraHeaders || [];
	        var originalTarget = target;
	
	        return new Promise(function(resolve, reject) {
	            //Blind Transfer is taken from SIP.js source
	
	            // Check Session Status
	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {
	                throw new SIP.Exceptions.InvalidStateError(session.status);
	            }
	
	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	            // so try to make one ahead of time
	            try {
	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	            } catch (e) {
	                session.logger.debug(".refer() cannot parse Refer_To from", target);
	                session.logger.debug("...falling through to normalizeTarget()");
	            }
	
	            // Check target validity
	            target = session.ua.normalizeTarget(target);
	            if (!target) {
	                throw new TypeError('Invalid target: ' + originalTarget);
	            }
	
	            extraHeaders.push('Contact: ' + session.contact);
	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	            extraHeaders.push('Refer-To: ' + target);
	            extraHeaders.push(session.ua.userAgentHeader);
	            extraHeaders.push(session.ua.endpointHeader);
	            extraHeaders.push(session.ua.clientIdHeader);
	
	            // Send the request
	            session.sendRequest(SIP.C.REFER, {
	                extraHeaders: extraHeaders,
	                body: options.body,
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 202) {
	                        var callId = response.call_id;
	
	                        var onNotify = function(request) {
	                            if (request.call_id === callId) {
	                                var body = request && request.body || '';
	                                switch (true) {
	                                    case /1[0-9]{2}/.test(body):
	                                        request.reply(200);
	                                        break;
	                                    case /2[0-9]{2}/.test(body):
	                                        session.terminate();
	                                        clearTimeout(timeout);
	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);
	                                        resolve();
	                                        break;
	                                    default:
	                                        reject(body);
	                                        break;
	                                }
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_NOTIFY', onNotify);
	                        }, responseTimeout);
	                        session.on('RC_SIP_NOTIFY', onNotify);
	                    }
	                    else {
	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));
	                    }
	                }
	            });
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function transfer(target, options) {
	
	        var session = this;
	
	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())
	            .then(function() { return delay(300); })
	            .then(function() {
	                return session.blindTransfer(target, options);
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} acceptOptions
	     * @param {object} [transferOptions]
	     * @return {Promise}
	     */
	    function forward(target, acceptOptions, transferOptions) {
	
	        var interval = null,
	            session = this;
	
	        return session.accept(acceptOptions)
	            .then(function() {
	
	                return new Promise(function(resolve, reject) {
	                    interval = setInterval(function() {
	                        if (session.status === 12) {
	                            clearInterval(interval);
	                            session.mute();
	                            setTimeout(function() {
	                                resolve(session.transfer(target, transferOptions));
	                            }, 700);
	                        }
	                    }, 50);
	                });
	
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function startRecord() {
	        return setRecord(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function stopRecord() {
	        return setRecord(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param target
	     * @return {Promise}
	     */
	    function flip(target) {
	        return sendReceive(this, messages.flip, {target: target});
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function park() {
	        return sendReceive(this, messages.park);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    return WebPhone;
	
	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = __webpack_require__(212)(__webpack_require__(245));


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SIP
	 * @namespace
	 */
	"use strict";
	
	module.exports = function (environment) {
	
	var pkg = __webpack_require__(213);
	
	var SIP = Object.defineProperties({}, {
	  version: {
	    get: function(){ return pkg.version; }
	  },
	  name: {
	    get: function(){ return pkg.title; }
	  }
	});
	
	__webpack_require__(214)(SIP, environment);
	SIP.LoggerFactory = __webpack_require__(215)(environment.console);
	SIP.EventEmitter = __webpack_require__(216)(environment.console);
	SIP.C = __webpack_require__(218)(SIP.name, SIP.version);
	SIP.Exceptions = __webpack_require__(219);
	SIP.Timers = __webpack_require__(220)(environment.timers);
	SIP.Transport = environment.Transport(SIP, environment.WebSocket);
	__webpack_require__(221)(SIP);
	__webpack_require__(222)(SIP);
	__webpack_require__(223)(SIP);
	__webpack_require__(224)(SIP);
	__webpack_require__(225)(SIP);
	__webpack_require__(226)(SIP);
	__webpack_require__(228)(SIP);
	__webpack_require__(229)(SIP);
	SIP.MediaHandler = __webpack_require__(230)(SIP.EventEmitter);
	__webpack_require__(231)(SIP);
	__webpack_require__(232)(SIP);
	__webpack_require__(233)(SIP, environment);
	__webpack_require__(235)(SIP);
	SIP.WebRTC = __webpack_require__(236)(SIP, environment);
	__webpack_require__(239)(SIP, environment);
	SIP.Hacks = __webpack_require__(240)(SIP);
	__webpack_require__(241)(SIP);
	SIP.DigestAuthentication = __webpack_require__(242)(SIP.Utils);
	SIP.Grammar = __webpack_require__(243)(SIP);
	
	return SIP;
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"sip.js@0.7.5",
				"/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone"
			]
		],
		"_from": "sip.js@0.7.5",
		"_id": "sip.js@0.7.5",
		"_inCache": true,
		"_installable": true,
		"_location": "/sip.js",
		"_nodeVersion": "4.4.3",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873"
		},
		"_npmUser": {
			"email": "1212jtraceur@gmail.com",
			"name": "josephfrazier"
		},
		"_npmVersion": "2.15.1",
		"_phantomChildren": {},
		"_requested": {
			"name": "sip.js",
			"raw": "sip.js@0.7.5",
			"rawSpec": "0.7.5",
			"scope": null,
			"spec": "0.7.5",
			"type": "version"
		},
		"_requiredBy": [
			"/ringcentral-web-phone"
		],
		"_resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz",
		"_shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
		"_shrinkwrap": null,
		"_spec": "sip.js@0.7.5",
		"_where": "/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone",
		"author": {
			"email": "developer@onsip.com",
			"name": "OnSIP",
			"url": "http://sipjs.com/authors/"
		},
		"browser": {
			"./src/environment.js": "./src/environment_browser.js"
		},
		"bugs": {
			"url": "https://github.com/onsip/SIP.js/issues"
		},
		"contributors": [
			{
				"url": "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
			}
		],
		"dependencies": {
			"promiscuous": "^0.6.0",
			"ws": "^0.6.4"
		},
		"description": "A simple, intuitive, and powerful JavaScript signaling library",
		"devDependencies": {
			"beefy": "^2.1.5",
			"browserify": "^4.1.8",
			"grunt": "~0.4.0",
			"grunt-browserify": "^4.0.1",
			"grunt-cli": "~0.1.6",
			"grunt-contrib-copy": "^0.5.0",
			"grunt-contrib-jasmine": "^0.9.2",
			"grunt-contrib-jshint": ">0.5.0",
			"grunt-contrib-uglify": "~0.2.0",
			"grunt-peg": "~1.3.1",
			"grunt-trimtrailingspaces": "^0.4.0",
			"pegjs": "^0.8.0"
		},
		"directories": {},
		"dist": {
			"shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
			"tarball": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz"
		},
		"engines": {
			"node": ">=0.8"
		},
		"gitHead": "bae44bd0359f4d70ded309a32361f04a04e78d6e",
		"homepage": "http://sipjs.com",
		"keywords": [
			"sip",
			"websocket",
			"webrtc",
			"library",
			"javascript"
		],
		"license": "MIT",
		"main": "src/index.js",
		"maintainers": [
			{
				"email": "eric.green@onsip.com",
				"name": "egreen_onsip"
			},
			{
				"email": "james@onsip.com",
				"name": "james-criscuolo"
			},
			{
				"email": "1212jtraceur@gmail.com",
				"name": "josephfrazier"
			}
		],
		"name": "sip.js",
		"optionalDependencies": {
			"promiscuous": "^0.6.0"
		},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/onsip/SIP.js.git"
		},
		"scripts": {
			"build": "grunt build",
			"prepublish": "cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js",
			"repl": "beefy test/repl.js --open",
			"test": "grunt travis --verbose"
		},
		"title": "SIP.js",
		"version": "0.7.5"
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Utils
	 */
	
	module.exports = function (SIP, environment) {
	var Utils;
	
	Utils= {
	
	  Promise: environment.Promise,
	
	  defer: function defer () {
	    var deferred = {};
	    deferred.promise = new Utils.Promise(function (resolve, reject) {
	      deferred.resolve = resolve;
	      deferred.reject = reject;
	    });
	    return deferred;
	  },
	
	  promisify: function promisify (object, methodName, callbacksFirst) {
	    var oldMethod = object[methodName];
	    return function promisifiedMethod (arg, onSuccess, onFailure) {
	      return new Utils.Promise(function (resolve, reject) {
	        var oldArgs = [arg, resolve, reject];
	        if (callbacksFirst) {
	          oldArgs = [resolve, reject, arg];
	        }
	        oldMethod.apply(object, oldArgs);
	      }).then(onSuccess, onFailure);
	    };
	  },
	
	  augment: function (object, constructor, args, override) {
	    var idx, proto;
	
	    // Add public properties from constructor's prototype onto object
	    proto = constructor.prototype;
	    for (idx in proto) {
	      if (override || object[idx] === undefined) {
	        object[idx] = proto[idx];
	      }
	    }
	
	    // Construct the object as though it were just created by constructor
	    constructor.apply(object, args);
	  },
	
	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {
	    if (isDeprecated && options[loser]) {
	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');
	    }
	
	    if (options[winner] && options[loser]) {
	      logger.warn(winner + ' overriding ' + loser);
	    }
	
	    options[winner] = options[winner] || options[loser] || defaultValue;
	  },
	
	  str_utf8_length: function(string) {
	    return encodeURIComponent(string).replace(/%[A-F\d]{2}/g, 'U').length;
	  },
	
	  generateFakeSDP: function(body) {
	    if (!body) {
	      return;
	    }
	
	    var start = body.indexOf('o=');
	    var end = body.indexOf('\r\n', start);
	
	    return 'v=0\r\n' + body.slice(start, end) + '\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0';
	  },
	
	  isFunction: function(fn) {
	    if (fn !== undefined) {
	      return Object.prototype.toString.call(fn) === '[object Function]';
	    } else {
	      return false;
	    }
	  },
	
	  isDecimal: function (num) {
	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
	  },
	
	  createRandomToken: function(size, base) {
	    var i, r,
	      token = '';
	
	    base = base || 32;
	
	    for( i=0; i < size; i++ ) {
	      r = Math.random() * base|0;
	      token += r.toString(base);
	    }
	
	    return token;
	  },
	
	  newTag: function() {
	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);
	  },
	
	  // http://stackoverflow.com/users/109538/broofa
	  newUUID: function() {
	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
	      return v.toString(16);
	    });
	
	    return UUID;
	  },
	
	  hostType: function(host) {
	    if (!host) {
	      return;
	    } else {
	      host = SIP.Grammar.parse(host,'host');
	      if (host !== -1) {
	        return host.host_type;
	      }
	    }
	  },
	
	  /**
	  * Normalize SIP URI.
	  * NOTE: It does not allow a SIP URI without username.
	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
	  * Detects the domain part (if given) and properly hex-escapes the user portion.
	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
	  * @private
	  * @param {String} target
	  * @param {String} [domain]
	  */
	  normalizeTarget: function(target, domain) {
	    var uri, target_array, target_user, target_domain;
	
	    // If no target is given then raise an error.
	    if (!target) {
	      return;
	    // If a SIP.URI instance is given then return it.
	    } else if (target instanceof SIP.URI) {
	      return target;
	
	    // If a string is given split it by '@':
	    // - Last fragment is the desired domain.
	    // - Otherwise append the given domain argument.
	    } else if (typeof target === 'string') {
	      target_array = target.split('@');
	
	      switch(target_array.length) {
	        case 1:
	          if (!domain) {
	            return;
	          }
	          target_user = target;
	          target_domain = domain;
	          break;
	        case 2:
	          target_user = target_array[0];
	          target_domain = target_array[1];
	          break;
	        default:
	          target_user = target_array.slice(0, target_array.length-1).join('@');
	          target_domain = target_array[target_array.length-1];
	      }
	
	      // Remove the URI scheme (if present).
	      target_user = target_user.replace(/^(sips?|tel):/i, '');
	
	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
	      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
	        target_user = target_user.replace(/[\-\.\(\)]/g, '');
	      }
	
	      // Build the complete SIP URI.
	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;
	
	      // Finally parse the resulting URI.
	      if (uri = SIP.URI.parse(target)) {
	        return uri;
	      } else {
	        return;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	  * Hex-escape a SIP URI user.
	  * @private
	  * @param {String} user
	  */
	  escapeUser: function(user) {
	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
	  },
	
	  headerize: function(string) {
	    var exceptions = {
	      'Call-Id': 'Call-ID',
	      'Cseq': 'CSeq',
	      'Min-Se': 'Min-SE',
	      'Rack': 'RAck',
	      'Rseq': 'RSeq',
	      'Www-Authenticate': 'WWW-Authenticate'
	      },
	      name = string.toLowerCase().replace(/_/g,'-').split('-'),
	      hname = '',
	      parts = name.length, part;
	
	    for (part = 0; part < parts; part++) {
	      if (part !== 0) {
	        hname +='-';
	      }
	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
	    }
	    if (exceptions[hname]) {
	      hname = exceptions[hname];
	    }
	    return hname;
	  },
	
	  sipErrorCause: function(status_code) {
	    var cause;
	
	    for (cause in SIP.C.SIP_ERROR_CAUSES) {
	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
	        return SIP.C.causes[cause];
	      }
	    }
	
	    return SIP.C.causes.SIP_FAILURE_CODE;
	  },
	
	  getReasonPhrase: function getReasonPhrase (code, specific) {
	    return specific || SIP.C.REASON_PHRASE[code] || '';
	  },
	
	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {
	    reason = SIP.Utils.getReasonPhrase(code, reason);
	    return 'SIP ;cause=' + code + ' ;text="' + reason + '"';
	  },
	
	  getCancelReason: function getCancelReason (code, reason) {
	    if (code && code < 200 || code > 699) {
	      throw new TypeError('Invalid status_code: ' + code);
	    } else if (code) {
	      return SIP.Utils.getReasonHeaderValue(code, reason);
	    }
	  },
	
	  buildStatusLine: function buildStatusLine (code, reason) {
	    code = code || null;
	    reason = reason || null;
	
	    // Validate code and reason values
	    if (!code || (code < 100 || code > 699)) {
	      throw new TypeError('Invalid status_code: '+ code);
	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
	      throw new TypeError('Invalid reason_phrase: '+ reason);
	    }
	
	    reason = Utils.getReasonPhrase(code, reason);
	
	    return 'SIP/2.0 ' + code + ' ' + reason + '\r\n';
	  },
	
	  /**
	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
	  * @private
	  */
	  getRandomTestNetIP: function() {
	    function getOctet(from,to) {
	      return Math.floor(Math.random()*(to-from+1)+from);
	    }
	    return '192.0.2.' + getOctet(1, 254);
	  },
	
	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
	  calculateMD5: function(string) {
	    function RotateLeft(lValue, iShiftBits) {
	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
	    }
	
	    function AddUnsigned(lX,lY) {
	      var lX4,lY4,lX8,lY8,lResult;
	      lX8 = (lX & 0x80000000);
	      lY8 = (lY & 0x80000000);
	      lX4 = (lX & 0x40000000);
	      lY4 = (lY & 0x40000000);
	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
	      if (lX4 & lY4) {
	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
	      }
	      if (lX4 | lY4) {
	        if (lResult & 0x40000000) {
	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
	        } else {
	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
	        }
	      } else {
	        return (lResult ^ lX8 ^ lY8);
	      }
	    }
	
	    function F(x,y,z) {
	      return (x & y) | ((~x) & z);
	    }
	
	    function G(x,y,z) {
	      return (x & z) | (y & (~z));
	    }
	
	    function H(x,y,z) {
	      return (x ^ y ^ z);
	    }
	
	    function I(x,y,z) {
	      return (y ^ (x | (~z)));
	    }
	
	    function FF(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function GG(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function HH(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function II(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function ConvertToWordArray(string) {
	      var lWordCount;
	      var lMessageLength = string.length;
	      var lNumberOfWords_temp1=lMessageLength + 8;
	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
	      var lWordArray=Array(lNumberOfWords-1);
	      var lBytePosition = 0;
	      var lByteCount = 0;
	      while ( lByteCount < lMessageLength ) {
	        lWordCount = (lByteCount-(lByteCount % 4))/4;
	        lBytePosition = (lByteCount % 4)*8;
	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
	        lByteCount++;
	      }
	      lWordCount = (lByteCount-(lByteCount % 4))/4;
	      lBytePosition = (lByteCount % 4)*8;
	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
	      return lWordArray;
	    }
	
	    function WordToHex(lValue) {
	      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
	      for (lCount = 0;lCount<=3;lCount++) {
	        lByte = (lValue>>>(lCount*8)) & 255;
	        WordToHexValue_temp = "0" + lByte.toString(16);
	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
	      }
	      return WordToHexValue;
	    }
	
	    function Utf8Encode(string) {
	      string = string.replace(/\r\n/g,"\n");
	      var utftext = "";
	
	      for (var n = 0; n < string.length; n++) {
	        var c = string.charCodeAt(n);
	
	        if (c < 128) {
	          utftext += String.fromCharCode(c);
	        }
	        else if((c > 127) && (c < 2048)) {
	          utftext += String.fromCharCode((c >> 6) | 192);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	        else {
	          utftext += String.fromCharCode((c >> 12) | 224);
	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	      }
	      return utftext;
	    }
	
	    var x=[];
	    var k,AA,BB,CC,DD,a,b,c,d;
	    var S11=7, S12=12, S13=17, S14=22;
	    var S21=5, S22=9 , S23=14, S24=20;
	    var S31=4, S32=11, S33=16, S34=23;
	    var S41=6, S42=10, S43=15, S44=21;
	
	    string = Utf8Encode(string);
	
	    x = ConvertToWordArray(string);
	
	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
	
	    for (k=0;k<x.length;k+=16) {
	      AA=a; BB=b; CC=c; DD=d;
	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
	      a=AddUnsigned(a,AA);
	      b=AddUnsigned(b,BB);
	      c=AddUnsigned(c,CC);
	      d=AddUnsigned(d,DD);
	    }
	
	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
	
	    return temp.toLowerCase();
	  }
	};
	
	SIP.Utils = Utils;
	};


/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";
	var levels = {
	  'error': 0,
	  'warn': 1,
	  'log': 2,
	  'debug': 3
	};
	
	module.exports = function (console) {
	
	var LoggerFactory = function () {
	  var logger,
	    level = 2,
	    builtinEnabled = true,
	    connector = null;
	
	    this.loggers = {};
	
	    logger = this.getLogger('sip.loggerfactory');
	
	
	  Object.defineProperties(this, {
	    builtinEnabled: {
	      get: function(){ return builtinEnabled; },
	      set: function(value){
	        if (typeof value === 'boolean') {
	          builtinEnabled = value;
	        } else {
	          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    level: {
	      get: function() {return level; },
	      set: function(value) {
	        if (value >= 0 && value <=3) {
	          level = value;
	        } else if (value > 3) {
	          level = 3;
	        } else if (levels.hasOwnProperty(value)) {
	          level = levels[value];
	        } else {
	          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    connector: {
	      get: function() {return connector; },
	      set: function(value){
	        if(value === null || value === "" || value === undefined) {
	          connector = null;
	        } else if (typeof value === 'function') {
	          connector = value;
	        } else {
	          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    }
	  });
	};
	
	LoggerFactory.prototype.print = function(target, category, label, content) {
	  if (typeof content === 'string') {
	    var prefix = [new Date(), category];
	    if (label) {
	      prefix.push(label);
	    }
	    content = prefix.concat(content).join(' | ');
	  }
	  target.call(console, content);
	};
	
	function Logger (logger, category, label) {
	  this.logger = logger;
	  this.category = category;
	  this.label = label;
	}
	
	Object.keys(levels).forEach(function (targetName) {
	  Logger.prototype[targetName] = function (content) {
	    this.logger[targetName](this.category, this.label, content);
	  };
	
	  LoggerFactory.prototype[targetName] = function (category, label, content) {
	    if (this.level >= levels[targetName]) {
	      if (this.builtinEnabled) {
	        this.print(console[targetName], category, label, content);
	      }
	
	      if (this.connector) {
	        this.connector(targetName, category, label, content);
	      }
	    }
	  };
	});
	
	LoggerFactory.prototype.getLogger = function(category, label) {
	  var logger;
	
	  if (label && this.level === 3) {
	    return new Logger(this, category, label);
	  } else if (this.loggers[category]) {
	    return this.loggers[category];
	  } else {
	    logger = new Logger(this, category);
	    this.loggers[category] = logger;
	    return logger;
	  }
	};
	
	return LoggerFactory;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NodeEventEmitter = __webpack_require__(217).EventEmitter;
	
	module.exports = function (console) {
	
	// Don't use `new SIP.EventEmitter()` for inheriting.
	// Use Object.create(SIP.EventEmitter.prototoype);
	function EventEmitter () {
	  NodeEventEmitter.call(this);
	}
	
	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {
	  constructor: {
	    value: EventEmitter,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	EventEmitter.prototype.off = function off (eventName, listener) {
	  var warning = '';
	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\n';
	  warning += 'Please use removeListener or removeAllListeners instead.\n';
	  warning += 'See here for more details:\n';
	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';
	  console.warn(warning);
	
	  if (arguments.length < 2) {
	    return this.removeAllListeners.apply(this, arguments);
	  } else {
	    return this.removeListener(eventName, listener);
	  }
	};
	
	return EventEmitter;
	
	};


/***/ },
/* 217 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Constants
	 */
	
	/**
	 * SIP Constants.
	 * @augments SIP
	 */
	
	module.exports = function (name, version) {
	return {
	  USER_AGENT: name +'/'+ version,
	
	  // SIP scheme
	  SIP:  'sip',
	  SIPS: 'sips',
	
	  // End and Failure causes
	  causes: {
	    // Generic error causes
	    CONNECTION_ERROR:         'Connection Error',
	    REQUEST_TIMEOUT:          'Request Timeout',
	    SIP_FAILURE_CODE:         'SIP Failure Code',
	    INTERNAL_ERROR:           'Internal Error',
	
	    // SIP error causes
	    BUSY:                     'Busy',
	    REJECTED:                 'Rejected',
	    REDIRECTED:               'Redirected',
	    UNAVAILABLE:              'Unavailable',
	    NOT_FOUND:                'Not Found',
	    ADDRESS_INCOMPLETE:       'Address Incomplete',
	    INCOMPATIBLE_SDP:         'Incompatible SDP',
	    AUTHENTICATION_ERROR:     'Authentication Error',
	    DIALOG_ERROR:             'Dialog Error',
	
	    // Session error causes
	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
	    WEBRTC_ERROR:             'WebRTC Error',
	    CANCELED:                 'Canceled',
	    NO_ANSWER:                'No Answer',
	    EXPIRES:                  'Expires',
	    NO_ACK:                   'No ACK',
	    NO_PRACK:                 'No PRACK',
	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
	    RTP_TIMEOUT:              'RTP Timeout'
	  },
	
	  supported: {
	    UNSUPPORTED:        'none',
	    SUPPORTED:          'supported',
	    REQUIRED:           'required'
	  },
	
	  SIP_ERROR_CAUSES: {
	    REDIRECTED: [300,301,302,305,380],
	    BUSY: [486,600],
	    REJECTED: [403,603],
	    NOT_FOUND: [404,604],
	    UNAVAILABLE: [480,410,408,430],
	    ADDRESS_INCOMPLETE: [484],
	    INCOMPATIBLE_SDP: [488,606],
	    AUTHENTICATION_ERROR:[401,407]
	  },
	
	  // SIP Methods
	  ACK:        'ACK',
	  BYE:        'BYE',
	  CANCEL:     'CANCEL',
	  INFO:       'INFO',
	  INVITE:     'INVITE',
	  MESSAGE:    'MESSAGE',
	  NOTIFY:     'NOTIFY',
	  OPTIONS:    'OPTIONS',
	  REGISTER:   'REGISTER',
	  UPDATE:     'UPDATE',
	  SUBSCRIBE:  'SUBSCRIBE',
	  REFER:      'REFER',
	  PRACK:      'PRACK',
	
	  /* SIP Response Reasons
	   * DOC: http://www.iana.org/assignments/sip-parameters
	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
	   */
	  REASON_PHRASE: {
	    100: 'Trying',
	    180: 'Ringing',
	    181: 'Call Is Being Forwarded',
	    182: 'Queued',
	    183: 'Session Progress',
	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
	    200: 'OK',
	    202: 'Accepted',  // RFC 3265
	    204: 'No Notification',  //RFC 5839
	    300: 'Multiple Choices',
	    301: 'Moved Permanently',
	    302: 'Moved Temporarily',
	    305: 'Use Proxy',
	    380: 'Alternative Service',
	    400: 'Bad Request',
	    401: 'Unauthorized',
	    402: 'Payment Required',
	    403: 'Forbidden',
	    404: 'Not Found',
	    405: 'Method Not Allowed',
	    406: 'Not Acceptable',
	    407: 'Proxy Authentication Required',
	    408: 'Request Timeout',
	    410: 'Gone',
	    412: 'Conditional Request Failed',  // RFC 3903
	    413: 'Request Entity Too Large',
	    414: 'Request-URI Too Long',
	    415: 'Unsupported Media Type',
	    416: 'Unsupported URI Scheme',
	    417: 'Unknown Resource-Priority',  // RFC 4412
	    420: 'Bad Extension',
	    421: 'Extension Required',
	    422: 'Session Interval Too Small',  // RFC 4028
	    423: 'Interval Too Brief',
	    428: 'Use Identity Header',  // RFC 4474
	    429: 'Provide Referrer Identity',  // RFC 3892
	    430: 'Flow Failed',  // RFC 5626
	    433: 'Anonymity Disallowed',  // RFC 5079
	    436: 'Bad Identity-Info',  // RFC 4474
	    437: 'Unsupported Certificate',  // RFC 4744
	    438: 'Invalid Identity Header',  // RFC 4744
	    439: 'First Hop Lacks Outbound Support',  // RFC 5626
	    440: 'Max-Breadth Exceeded',  // RFC 5393
	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
	    470: 'Consent Needed',  // RFC 5360
	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
	    480: 'Temporarily Unavailable',
	    481: 'Call/Transaction Does Not Exist',
	    482: 'Loop Detected',
	    483: 'Too Many Hops',
	    484: 'Address Incomplete',
	    485: 'Ambiguous',
	    486: 'Busy Here',
	    487: 'Request Terminated',
	    488: 'Not Acceptable Here',
	    489: 'Bad Event',  // RFC 3265
	    491: 'Request Pending',
	    493: 'Undecipherable',
	    494: 'Security Agreement Required',  // RFC 3329
	    500: 'Internal Server Error',
	    501: 'Not Implemented',
	    502: 'Bad Gateway',
	    503: 'Service Unavailable',
	    504: 'Server Time-out',
	    505: 'Version Not Supported',
	    513: 'Message Too Large',
	    580: 'Precondition Failure',  // RFC 3312
	    600: 'Busy Everywhere',
	    603: 'Decline',
	    604: 'Does Not Exist Anywhere',
	    606: 'Not Acceptable'
	  },
	
	  /* SIP Option Tags
	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
	   */
	  OPTION_TAGS: {
	    '100rel':                   true,  // RFC 3262
	    199:                        true,  // RFC 6228
	    answermode:                 true,  // RFC 5373
	    'early-session':            true,  // RFC 3959
	    eventlist:                  true,  // RFC 4662
	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    'from-change':              true,  // RFC 4916
	    'geolocation-http':         true,  // RFC 6442
	    'geolocation-sip':          true,  // RFC 6442
	    gin:                        true,  // RFC 6140
	    gruu:                       true,  // RFC 5627
	    histinfo:                   true,  // RFC 7044
	    ice:                        true,  // RFC 5768
	    join:                       true,  // RFC 3911
	    'multiple-refer':           true,  // RFC 5368
	    norefersub:                 true,  // RFC 4488
	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    outbound:                   true,  // RFC 5626
	    path:                       true,  // RFC 3327
	    policy:                     true,  // RFC 6794
	    precondition:               true,  // RFC 3312
	    pref:                       true,  // RFC 3840
	    privacy:                    true,  // RFC 3323
	    'recipient-list-invite':    true,  // RFC 5366
	    'recipient-list-message':   true,  // RFC 5365
	    'recipient-list-subscribe': true,  // RFC 5367
	    replaces:                   true,  // RFC 3891
	    'resource-priority':        true,  // RFC 4412
	    'sdp-anat':                 true,  // RFC 4092
	    'sec-agree':                true,  // RFC 3329
	    tdialog:                    true,  // RFC 4538
	    timer:                      true,  // RFC 4028
	    uui:                        true   // RFC 7433
	  }
	};
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Exceptions
	 */
	
	/**
	 * SIP Exceptions.
	 * @augments SIP
	 */
	module.exports = {
	  ConfigurationError: (function(){
	    var exception = function(parameter, value) {
	      this.code = 1;
	      this.name = 'CONFIGURATION_ERROR';
	      this.parameter = parameter;
	      this.value = value;
	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  InvalidStateError: (function(){
	    var exception = function(status) {
	      this.code = 2;
	      this.name = 'INVALID_STATE_ERROR';
	      this.status = status;
	      this.message = 'Invalid status: ' + status;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  NotSupportedError: (function(){
	    var exception = function(message) {
	      this.code = 3;
	      this.name = 'NOT_SUPPORTED_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  GetDescriptionError: (function(){
	    var exception = function(message) {
	      this.code = 4;
	      this.name = 'GET_DESCRIPTION_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }())
	};


/***/ },
/* 220 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP TIMERS
	 */
	
	/**
	 * @augments SIP
	 */
	var
	  T1 = 500,
	  T2 = 4000,
	  T4 = 5000;
	module.exports = function (timers) {
	  var Timers = {
	    T1: T1,
	    T2: T2,
	    T4: T4,
	    TIMER_B: 64 * T1,
	    TIMER_D: 0  * T1,
	    TIMER_F: 64 * T1,
	    TIMER_H: 64 * T1,
	    TIMER_I: 0  * T1,
	    TIMER_J: 0  * T1,
	    TIMER_K: 0  * T4,
	    TIMER_L: 64 * T1,
	    TIMER_M: 64 * T1,
	    TIMER_N: 64 * T1,
	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
	  };
	
	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
	  .forEach(function (name) {
	    // can't just use timers[name].bind(timers) since it bypasses jasmine's
	    // clock-mocking
	    Timers[name] = function () {
	      return timers[name].apply(timers, arguments);
	    };
	  });
	
	  return Timers;
	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message Parser
	 */
	
	/**
	 * Extract and parse every header of a SIP message.
	 * @augments SIP
	 * @namespace
	 */
	module.exports = function (SIP) {
	var Parser;
	
	function getHeader(data, headerStart) {
	  var
	    // 'start' position of the header.
	    start = headerStart,
	    // 'end' position of the header.
	    end = 0,
	    // 'partial end' position of the header.
	    partialEnd = 0;
	
	  //End of message.
	  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
	    return -2;
	  }
	
	  while(end === 0) {
	    // Partial End of Header.
	    partialEnd = data.indexOf('\r\n', start);
	
	    // 'indexOf' returns -1 if the value to be found never occurs.
	    if (partialEnd === -1) {
	      return partialEnd;
	    }
	
	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
	      // Not the end of the message. Continue from the next position.
	      start = partialEnd + 2;
	    } else {
	      end = partialEnd;
	    }
	  }
	
	  return end;
	}
	
	function parseHeader(message, data, headerStart, headerEnd) {
	  var header, idx, length, parsed,
	    hcolonIndex = data.indexOf(':', headerStart),
	    headerName = data.substring(headerStart, hcolonIndex).trim(),
	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
	
	  // If header-field is well-known, parse it.
	  switch(headerName.toLowerCase()) {
	    case 'via':
	    case 'v':
	      message.addHeader('via', headerValue);
	      if(message.getHeaders('via').length === 1) {
	        parsed = message.parseHeader('Via');
	        if(parsed) {
	          message.via = parsed;
	          message.via_branch = parsed.branch;
	        }
	      } else {
	        parsed = 0;
	      }
	      break;
	    case 'from':
	    case 'f':
	      message.setHeader('from', headerValue);
	      parsed = message.parseHeader('from');
	      if(parsed) {
	        message.from = parsed;
	        message.from_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'to':
	    case 't':
	      message.setHeader('to', headerValue);
	      parsed = message.parseHeader('to');
	      if(parsed) {
	        message.to = parsed;
	        message.to_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'record-route':
	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));
	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'call-id':
	    case 'i':
	      message.setHeader('call-id', headerValue);
	      parsed = message.parseHeader('call-id');
	      if(parsed) {
	        message.call_id = headerValue;
	      }
	      break;
	    case 'contact':
	    case 'm':
	      parsed = SIP.Grammar.parse(headerValue, 'Contact');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('contact', headerValue.substring(header.position, header.offset));
	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'content-length':
	    case 'l':
	      message.setHeader('content-length', headerValue);
	      parsed = message.parseHeader('content-length');
	      break;
	    case 'content-type':
	    case 'c':
	      message.setHeader('content-type', headerValue);
	      parsed = message.parseHeader('content-type');
	      break;
	    case 'cseq':
	      message.setHeader('cseq', headerValue);
	      parsed = message.parseHeader('cseq');
	      if(parsed) {
	        message.cseq = parsed.value;
	      }
	      if(message instanceof SIP.IncomingResponse) {
	        message.method = parsed.method;
	      }
	      break;
	    case 'max-forwards':
	      message.setHeader('max-forwards', headerValue);
	      parsed = message.parseHeader('max-forwards');
	      break;
	    case 'www-authenticate':
	      message.setHeader('www-authenticate', headerValue);
	      parsed = message.parseHeader('www-authenticate');
	      break;
	    case 'proxy-authenticate':
	      message.setHeader('proxy-authenticate', headerValue);
	      parsed = message.parseHeader('proxy-authenticate');
	      break;
	    case 'refer-to':
	    case 'r':
	      message.setHeader('refer-to', headerValue);
	      parsed = message.parseHeader('refer-to');
	      if (parsed) {
	        message.refer_to = parsed;
	      }
	      break;
	    default:
	      // Do not parse this header.
	      message.setHeader(headerName, headerValue);
	      parsed = 0;
	  }
	
	  if (parsed === undefined) {
	    return {
	      error: 'error parsing header "'+ headerName +'"'
	    };
	  } else {
	    return true;
	  }
	}
	
	/** Parse SIP Message
	 * @function
	 * @param {String} message SIP message.
	 * @param {Object} logger object.
	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
	 */
	Parser = {};
	Parser.parseMessage = function(data, ua) {
	  var message, firstLine, contentLength, bodyStart, parsed,
	    headerStart = 0,
	    headerEnd = data.indexOf('\r\n'),
	    logger = ua.getLogger('sip.parser');
	
	  if(headerEnd === -1) {
	    logger.warn('no CRLF found, not a SIP message, discarded');
	    return;
	  }
	
	  // Parse first line. Check if it is a Request or a Reply.
	  firstLine = data.substring(0, headerEnd);
	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');
	
	  if(parsed === -1) {
	    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
	    return;
	  } else if(!parsed.status_code) {
	    message = new SIP.IncomingRequest(ua);
	    message.method = parsed.method;
	    message.ruri = parsed.uri;
	  } else {
	    message = new SIP.IncomingResponse(ua);
	    message.status_code = parsed.status_code;
	    message.reason_phrase = parsed.reason_phrase;
	  }
	
	  message.data = data;
	  headerStart = headerEnd + 2;
	
	  /* Loop over every line in data. Detect the end of each header and parse
	  * it or simply add to the headers collection.
	  */
	  while(true) {
	    headerEnd = getHeader(data, headerStart);
	
	    // The SIP message has normally finished.
	    if(headerEnd === -2) {
	      bodyStart = headerStart + 2;
	      break;
	    }
	    // data.indexOf returned -1 due to a malformed message.
	    else if(headerEnd === -1) {
	      logger.error('malformed message');
	      return;
	    }
	
	    parsed = parseHeader(message, data, headerStart, headerEnd);
	
	    if(parsed !== true) {
	      logger.error(parsed.error);
	      return;
	    }
	
	    headerStart = headerEnd + 2;
	  }
	
	  /* RFC3261 18.3.
	   * If there are additional bytes in the transport packet
	   * beyond the end of the body, they MUST be discarded.
	   */
	  if(message.hasHeader('content-length')) {
	    contentLength = message.getHeader('content-length');
	    message.body = data.substr(bodyStart, contentLength);
	  } else {
	    message.body = data.substring(bodyStart);
	  }
	
	  return message;
	};
	
	SIP.Parser = Parser;
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message
	 */
	
	module.exports = function (SIP) {
	var
	  OutgoingRequest,
	  IncomingMessage,
	  IncomingRequest,
	  IncomingResponse;
	
	function getSupportedHeader (request) {
	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;
	  var optionTags = [];
	  var optionTagSet = {};
	
	  if (request.method === SIP.C.REGISTER) {
	    optionTags.push('path', 'gruu');
	  } else if (request.method === SIP.C.INVITE &&
	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {
	    optionTags.push('gruu');
	  }
	
	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {
	    optionTags.push('100rel');
	  }
	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {
	    optionTags.push('replaces');
	  }
	
	  optionTags.push('outbound');
	
	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);
	
	  optionTags = optionTags.filter(function(optionTag) {
	    var registered = SIP.C.OPTION_TAGS[optionTag];
	    var unique = !optionTagSet[optionTag];
	    optionTagSet[optionTag] = true;
	    return (registered || allowUnregistered) && unique;
	  });
	
	  return 'Supported: ' + optionTags.join(', ') + '\r\n';
	}
	
	/**
	 * @augments SIP
	 * @class Class for outgoing SIP request.
	 * @param {String} method request method
	 * @param {String} ruri request uri
	 * @param {SIP.UA} ua
	 * @param {Object} params parameters that will have priority over ua.configuration parameters:
	 * <br>
	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set
	 * @param {Object} [headers] extra headers
	 * @param {String} [body]
	 */
	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
	  var
	    to,
	    from,
	    call_id,
	    cseq,
	    to_uri,
	    from_uri;
	
	  params = params || {};
	
	  // Mandatory parameters check
	  if(!method || !ruri || !ua) {
	    return null;
	  }
	
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.method = method;
	  this.ruri = ruri;
	  this.body = body;
	  this.extraHeaders = (extraHeaders || []).slice();
	  this.statusCode = params.status_code;
	  this.reasonPhrase = params.reason_phrase;
	
	  // Fill the Common SIP Request Headers
	
	  // Route
	  if (params.route_set) {
	    this.setHeader('route', params.route_set);
	  } else if (ua.configuration.usePreloadedRoute){
	    this.setHeader('route', ua.transport.server.sip_uri);
	  }
	
	  // Via
	  // Empty Via header. Will be filled by the client transaction.
	  this.setHeader('via', '');
	
	  // Max-Forwards
	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);
	
	  // To
	  to_uri = params.to_uri || ruri;
	  to = (params.to_displayName || params.to_displayName === 0) ? '"' + params.to_displayName + '" ' : '';
	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';
	  to += params.to_tag ? ';tag=' + params.to_tag : '';
	  this.to = new SIP.NameAddrHeader.parse(to);
	  this.setHeader('to', to);
	
	  // From
	  from_uri = params.from_uri || ua.configuration.uri;
	  if (params.from_displayName || params.from_displayName === 0) {
	    from = '"' + params.from_displayName + '" ';
	  } else if (ua.configuration.displayName) {
	    from = '"' + ua.configuration.displayName + '" ';
	  } else {
	    from = '';
	  }
	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';
	  from += params.from_tag || SIP.Utils.newTag();
	  this.from = new SIP.NameAddrHeader.parse(from);
	  this.setHeader('from', from);
	
	  // Call-ID
	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));
	  this.call_id = call_id;
	  this.setHeader('call-id', call_id);
	
	  // CSeq
	  cseq = params.cseq || Math.floor(Math.random() * 10000);
	  this.cseq = cseq;
	  this.setHeader('cseq', cseq + ' ' + method);
	};
	
	OutgoingRequest.prototype = {
	  /**
	   * Replace the the given header by the given value.
	   * @param {String} name header name
	   * @param {String | Array} value header value
	   */
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length,
	      header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0];
	      }
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          return header.substring(header.indexOf(':')+1).trim();
	        }
	      }
	    }
	
	    return;
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length, regexp,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(header) {
	      length = header.length;
	      for (idx = 0; idx < length; idx++) {
	        result.push(header[idx]);
	      }
	      return result;
	    } else {
	      length = this.extraHeaders.length;
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          result.push(header.substring(header.indexOf(':')+1).trim());
	        }
	      }
	      return result;
	    }
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length;
	
	    if (this.headers[SIP.Utils.headerize(name)]) {
	      return true;
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        if (regexp.test(this.extraHeaders[idx])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  },
	
	  toString: function() {
	    var msg = '', header, length, idx;
	
	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\r\n';
	
	    for (header in this.headers) {
	      length = this.headers[header].length;
	      for (idx = 0; idx < length; idx++) {
	        msg += header + ': ' + this.headers[header][idx] + '\r\n';
	      }
	    }
	
	    length = this.extraHeaders.length;
	    for (idx = 0; idx < length; idx++) {
	      msg += this.extraHeaders[idx].trim() +'\r\n';
	    }
	
	    msg += getSupportedHeader(this);
	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	    if(this.body) {
	      length = SIP.Utils.str_utf8_length(this.body);
	      msg += 'Content-Length: ' + length + '\r\n\r\n';
	      msg += this.body;
	    } else {
	      msg += 'Content-Length: 0\r\n\r\n';
	    }
	
	    return msg;
	  }
	};
	
	/**
	 * @augments SIP
	 * @class Class for incoming SIP message.
	 */
	IncomingMessage = function(){
	  this.data = null;
	  this.headers = null;
	  this.method =  null;
	  this.via = null;
	  this.via_branch = null;
	  this.call_id = null;
	  this.cseq = null;
	  this.from = null;
	  this.from_tag = null;
	  this.to = null;
	  this.to_tag = null;
	  this.body = null;
	};
	
	IncomingMessage.prototype = {
	  /**
	  * Insert a header of the given name and value into the last position of the
	  * header array.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  addHeader: function(name, value) {
	    var header = { raw: value };
	
	    name = SIP.Utils.headerize(name);
	
	    if(this.headers[name]) {
	      this.headers[name].push(header);
	    } else {
	      this.headers[name] = [header];
	    }
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0].raw;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(!header) {
	      return [];
	    }
	
	    length = header.length;
	    for (idx = 0; idx < length; idx++) {
	      result.push(header[idx].raw);
	    }
	
	    return result;
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;
	  },
	
	  /**
	  * Parse the given header on the given index.
	  * @param {String} name header name
	  * @param {Number} [idx=0] header index
	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	  */
	  parseHeader: function(name, idx) {
	    var header, value, parsed;
	
	    name = SIP.Utils.headerize(name);
	
	    idx = idx || 0;
	
	    if(!this.headers[name]) {
	      this.logger.log('header "' + name + '" not present');
	      return;
	    } else if(idx >= this.headers[name].length) {
	      this.logger.log('not so many "' + name + '" headers present');
	      return;
	    }
	
	    header = this.headers[name][idx];
	    value = header.raw;
	
	    if(header.parsed) {
	      return header.parsed;
	    }
	
	    //substitute '-' by '_' for grammar rule matching.
	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));
	
	    if(parsed === -1) {
	      this.headers[name].splice(idx, 1); //delete from headers
	      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
	      return;
	    } else {
	      header.parsed = parsed;
	      return parsed;
	    }
	  },
	
	  /**
	   * Message Header attribute selector. Alias of parseHeader.
	   * @param {String} name header name
	   * @param {Number} [idx=0] header index
	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	   *
	   * @example
	   * message.s('via',3).port
	   */
	  s: function(name, idx) {
	    return this.parseHeader(name, idx);
	  },
	
	  /**
	  * Replace the value of the given header by the value.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  setHeader: function(name, value) {
	    var header = { raw: value };
	    this.headers[SIP.Utils.headerize(name)] = [header];
	  },
	
	  toString: function() {
	    return this.data;
	  }
	};
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP request.
	 */
	IncomingRequest = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.ruri = null;
	  this.transport = null;
	  this.server_transaction = null;
	};
	IncomingRequest.prototype = new IncomingMessage();
	
	/**
	* Stateful reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	* @param {Object} headers extra headers
	* @param {String} body body
	* @param {Function} [onSuccess] onSuccess callback
	* @param {Function} [onFailure] onFailure callback
	*/
	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
	  var rr, vias, length, idx, response,
	    to = this.getHeader('To'),
	    r = 0,
	    v = 0;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	  extraHeaders = (extraHeaders || []).slice();
	
	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {
	    rr = this.getHeaders('record-route');
	    length = rr.length;
	
	    for(r; r < length; r++) {
	      response += 'Record-Route: ' + rr[r] + '\r\n';
	    }
	  }
	
	  vias = this.getHeaders('via');
	  length = vias.length;
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	
	  length = extraHeaders.length;
	  for (idx = 0; idx < length; idx++) {
	    response += extraHeaders[idx].trim() +'\r\n';
	  }
	
	  response += getSupportedHeader(this);
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	  if(body) {
	    length = SIP.Utils.str_utf8_length(body);
	    response += 'Content-Type: application/sdp\r\n';
	    response += 'Content-Length: ' + length + '\r\n\r\n';
	    response += body;
	  } else {
	    response += 'Content-Length: ' + 0 + '\r\n\r\n';
	  }
	
	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);
	
	  return response;
	};
	
	/**
	* Stateless reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	*/
	IncomingRequest.prototype.reply_sl = function(code, reason) {
	  var to, response,
	    v = 0,
	    vias = this.getHeaders('via'),
	    length = vias.length;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  to = this.getHeader('To');
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	  response += 'Content-Length: ' + 0 + '\r\n\r\n';
	
	  this.transport.send(response);
	};
	
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP response.
	 */
	IncomingResponse = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.headers = {};
	  this.status_code = null;
	  this.reason_phrase = null;
	};
	IncomingResponse.prototype = new IncomingMessage();
	
	SIP.OutgoingRequest = OutgoingRequest;
	SIP.IncomingRequest = IncomingRequest;
	SIP.IncomingResponse = IncomingResponse;
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP URI
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP URI.
	 *
	 * @param {String} [scheme]
	 * @param {String} [user]
	 * @param {String} host
	 * @param {String} [port]
	 * @param {Object} [parameters]
	 * @param {Object} [headers]
	 *
	 */
	module.exports = function (SIP) {
	var URI;
	
	URI = function(scheme, user, host, port, parameters, headers) {
	  var param, header, raw, normal;
	
	  // Checks
	  if(!host) {
	    throw new TypeError('missing or invalid "host" parameter');
	  }
	
	  // Initialize parameters
	  scheme = scheme || SIP.C.SIP;
	  this.parameters = {};
	  this.headers = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  for (header in headers) {
	    this.setHeader(header, headers[header]);
	  }
	
	  // Raw URI
	  raw = {
	    scheme: scheme,
	    user: user,
	    host: host,
	    port: port
	  };
	
	  // Normalized URI
	  normal = {
	    scheme: scheme.toLowerCase(),
	    user: user,
	    host: host.toLowerCase(),
	    port: port
	  };
	
	  Object.defineProperties(this, {
	    _normal: {
	      get: function() { return normal; }
	    },
	
	    _raw: {
	      get: function() { return raw; }
	    },
	
	    scheme: {
	      get: function() { return normal.scheme; },
	      set: function(value) {
	        raw.scheme = value;
	        normal.scheme = value.toLowerCase();
	      }
	    },
	
	    user: {
	      get: function() { return normal.user; },
	      set: function(value) {
	        normal.user = raw.user = value;
	      }
	    },
	
	    host: {
	      get: function() { return normal.host; },
	      set: function(value) {
	        raw.host = value;
	        normal.host = value.toLowerCase();
	      }
	    },
	
	    aor: {
	      get: function() { return normal.user + '@' + normal.host; }
	    },
	
	    port: {
	      get: function() { return normal.port; },
	      set: function(value) {
	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);
	      }
	    }
	  });
	};
	
	URI.prototype = {
	  setParam: function(key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
	    }
	  },
	
	  getParam: function(key) {
	    if(key) {
	      return this.parameters[key.toLowerCase()];
	    }
	  },
	
	  hasParam: function(key) {
	    if(key) {
	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
	    }
	  },
	
	  deleteParam: function(parameter) {
	    var value;
	    parameter = parameter.toLowerCase();
	    if (this.parameters.hasOwnProperty(parameter)) {
	      value = this.parameters[parameter];
	      delete this.parameters[parameter];
	      return value;
	    }
	  },
	
	  clearParams: function() {
	    this.parameters = {};
	  },
	
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  getHeader: function(name) {
	    if(name) {
	      return this.headers[SIP.Utils.headerize(name)];
	    }
	  },
	
	  hasHeader: function(name) {
	    if(name) {
	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;
	    }
	  },
	
	  deleteHeader: function(header) {
	    var value;
	    header = SIP.Utils.headerize(header);
	    if(this.headers.hasOwnProperty(header)) {
	      value = this.headers[header];
	      delete this.headers[header];
	      return value;
	    }
	  },
	
	  clearHeaders: function() {
	    this.headers = {};
	  },
	
	  clone: function() {
	    return new URI(
	      this._raw.scheme,
	      this._raw.user,
	      this._raw.host,
	      this._raw.port,
	      JSON.parse(JSON.stringify(this.parameters)),
	      JSON.parse(JSON.stringify(this.headers)));
	  },
	
	  toRaw: function() {
	    return this._toString(this._raw);
	  },
	
	  toString: function() {
	    return this._toString(this._normal);
	  },
	
	  _toString: function(uri) {
	    var header, parameter, idx, uriString, headers = [];
	
	    uriString  = uri.scheme + ':';
	    // add slashes if it's not a sip(s) URI
	    if (!uri.scheme.toLowerCase().match("^sips?$")) {
	      uriString += "//";
	    }
	    if (uri.user) {
	      uriString += SIP.Utils.escapeUser(uri.user) + '@';
	    }
	    uriString += uri.host;
	    if (uri.port || uri.port === 0) {
	      uriString += ':' + uri.port;
	    }
	
	    for (parameter in this.parameters) {
	      uriString += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        uriString += '='+ this.parameters[parameter];
	      }
	    }
	
	    for(header in this.headers) {
	      for(idx in this.headers[header]) {
	        headers.push(header + '=' + this.headers[header][idx]);
	      }
	    }
	
	    if (headers.length > 0) {
	      uriString += '?' + headers.join('&');
	    }
	
	    return uriString;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.URI instance or undefined if
	  * it is an invalid URI.
	  * @public
	  * @param {String} uri
	  */
	URI.parse = function(uri) {
	  uri = SIP.Grammar.parse(uri,'SIP_URI');
	
	  if (uri !== -1) {
	    return uri;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.URI = URI;
	};


/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP NameAddrHeader
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a Name Address SIP header.
	 *
	 * @param {SIP.URI} uri
	 * @param {String} [displayName]
	 * @param {Object} [parameters]
	 *
	 */
	module.exports = function (SIP) {
	var NameAddrHeader;
	
	NameAddrHeader = function(uri, displayName, parameters) {
	  var param;
	
	  // Checks
	  if(!uri || !(uri instanceof SIP.URI)) {
	    throw new TypeError('missing or invalid "uri" parameter');
	  }
	
	  // Initialize parameters
	  this.uri = uri;
	  this.parameters = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  Object.defineProperties(this, {
	    friendlyName: {
	      get: function() { return this.displayName || uri.aor; }
	    },
	
	    displayName: {
	      get: function() { return displayName; },
	      set: function(value) {
	        displayName = (value === 0) ? '0' : value;
	      }
	    }
	  });
	};
	NameAddrHeader.prototype = {
	  setParam: function (key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
	    }
	  },
	  getParam: SIP.URI.prototype.getParam,
	  hasParam: SIP.URI.prototype.hasParam,
	  deleteParam: SIP.URI.prototype.deleteParam,
	  clearParams: SIP.URI.prototype.clearParams,
	
	  clone: function() {
	    return new NameAddrHeader(
	      this.uri.clone(),
	      this.displayName,
	      JSON.parse(JSON.stringify(this.parameters)));
	  },
	
	  toString: function() {
	    var body, parameter;
	
	    body  = (this.displayName || this.displayName === 0) ? '"' + this.displayName + '" ' : '';
	    body += '<' + this.uri.toString() + '>';
	
	    for (parameter in this.parameters) {
	      body += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        body += '='+ this.parameters[parameter];
	      }
	    }
	
	    return body;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
	  * it is an invalid NameAddrHeader.
	  * @public
	  * @param {String} name_addr_header
	  */
	NameAddrHeader.parse = function(name_addr_header) {
	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');
	
	  if (name_addr_header !== -1) {
	    return name_addr_header;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.NameAddrHeader = NameAddrHeader;
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Transactions
	 */
	
	/**
	 * SIP Transactions module.
	 * @augments SIP
	 */
	module.exports = function (SIP) {
	var
	  C = {
	    // Transaction states
	    STATUS_TRYING:     1,
	    STATUS_PROCEEDING: 2,
	    STATUS_CALLING:    3,
	    STATUS_ACCEPTED:   4,
	    STATUS_COMPLETED:  5,
	    STATUS_TERMINATED: 6,
	    STATUS_CONFIRMED:  7,
	
	    // Transaction types
	    NON_INVITE_CLIENT: 'nict',
	    NON_INVITE_SERVER: 'nist',
	    INVITE_CLIENT: 'ict',
	    INVITE_SERVER: 'ist'
	  };
	
	function buildViaHeader (request_sender, transport, id) {
	  var via;
	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);
	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;
	  if (request_sender.ua.configuration.forceRport) {
	    via += ';rport';
	  }
	  return via;
	}
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var NonInviteClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.type = C.NON_INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	};
	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteClientTransaction.prototype.send = function() {
	  var tr = this;
	
	  this.stateChanged(C.STATUS_TRYING);
	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	NonInviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.F);
	  SIP.Timers.clearTimeout(this.K);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onTransportError();
	};
	
	NonInviteClientTransaction.prototype.timer_F = function() {
	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onRequestTimeout();
	};
	
	NonInviteClientTransaction.prototype.timer_K = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	NonInviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	    tr = this,
	    status_code = response.status_code;
	
	  if(status_code < 200) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        SIP.Timers.clearTimeout(this.F);
	
	        if(status_code === 408) {
	          this.request_sender.onRequestTimeout();
	        } else {
	          this.request_sender.receiveResponse(response);
	        }
	
	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	};
	
	
	
	/**
	* @augments SIP.Transactions
	* @class Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var InviteClientTransaction = function(request_sender, request, transport) {
	  var via,
	    tr = this;
	
	  this.type = C.INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	
	  // Add the cancel property to the request.
	  //Will be called from the request instance, not the transaction itself.
	  this.request.cancel = function(reason) {
	    tr.cancel_request(tr, reason);
	  };
	};
	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteClientTransaction.prototype.send = function() {
	  var tr = this;
	  this.stateChanged(C.STATUS_CALLING);
	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	InviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  SIP.Timers.clearTimeout(this.D);
	  SIP.Timers.clearTimeout(this.M);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	
	  if (this.state !== C.STATUS_ACCEPTED) {
	    this.request_sender.onTransportError();
	  }
	};
	
	// RFC 6026 7.2
	InviteClientTransaction.prototype.timer_M = function() {
	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    SIP.Timers.clearTimeout(this.B);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	  }
	};
	
	// RFC 3261 17.1.1
	InviteClientTransaction.prototype.timer_B = function() {
	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);
	  if(this.state === C.STATUS_CALLING) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	    this.request_sender.onRequestTimeout();
	  }
	};
	
	InviteClientTransaction.prototype.timer_D = function() {
	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	InviteClientTransaction.prototype.sendACK = function(response) {
	  var tr = this;
	
	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
	  this.ack += 'Content-Length: 0\r\n';
	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
	  this.ack += ' ACK\r\n\r\n';
	
	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);
	
	  this.transport.send(this.ack);
	};
	
	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
	  var request = tr.request;
	
	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
	  this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
	  ' CANCEL\r\n';
	
	  if(reason) {
	    this.cancel += 'Reason: ' + reason + '\r\n';
	  }
	
	  this.cancel += 'Content-Length: 0\r\n\r\n';
	
	  // Send only if a provisional response (>100) has been received.
	  if(this.state === C.STATUS_PROCEEDING) {
	    this.transport.send(this.cancel);
	  }
	};
	
	InviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	  tr = this,
	  status_code = response.status_code;
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        if(this.cancel) {
	          this.transport.send(this.cancel);
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_ACCEPTED:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.sendACK(response);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_COMPLETED:
	        this.sendACK(response);
	        break;
	    }
	  }
	};
	
	
	/**
	 * @augments SIP.Transactions
	 * @class ACK Client Transaction
	 * @param {SIP.RequestSender} request_sender
	 * @param {SIP.OutgoingRequest} request
	 * @param {SIP.Transport} transport
	 */
	var AckClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	};
	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	AckClientTransaction.prototype.send = function() {
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	AckClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);
	  this.request_sender.onTransportError();
	};
	
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var NonInviteServerTransaction = function(request, ua) {
	  this.type = C.NON_INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.nist', this.id);
	
	  this.state = C.STATUS_TRYING;
	
	  ua.newTransaction(this);
	};
	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteServerTransaction.prototype.timer_J = function() {
	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	NonInviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);
	
	    SIP.Timers.clearTimeout(this.J);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code === 100) {
	    /* RFC 4320 4.1
	     * 'A SIP element MUST NOT
	     * send any provisional response with a
	     * Status-Code other than 100 to a non-INVITE request.'
	     */
	    switch(this.state) {
	      case C.STATUS_TRYING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        if(!this.transport.send(response))  {
	          this.onTransportError();
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.last_response = response;
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.last_response = response;
	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	* @augments SIP.Transactions
	* @class Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var InviteServerTransaction = function(request, ua) {
	  this.type = C.INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.ist', this.id);
	
	  this.state = C.STATUS_PROCEEDING;
	
	  ua.newTransaction(this);
	
	  this.resendProvisionalTimer = null;
	
	  request.reply(100);
	};
	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteServerTransaction.prototype.timer_H = function() {
	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_COMPLETED) {
	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
	  }
	
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	InviteServerTransaction.prototype.timer_I = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	// RFC 6026 7.1
	InviteServerTransaction.prototype.timer_L = function() {
	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);
	
	    if (this.resendProvisionalTimer !== null) {
	      SIP.Timers.clearInterval(this.resendProvisionalTimer);
	      this.resendProvisionalTimer = null;
	    }
	
	    SIP.Timers.clearTimeout(this.L);
	    SIP.Timers.clearTimeout(this.H);
	    SIP.Timers.clearTimeout(this.I);
	
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.resend_provisional = function() {
	  if(!this.transport.send(this.last_response)) {
	    this.onTransportError();
	  }
	};
	
	// INVITE Server Transaction RFC 3261 17.2.1
	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	        }
	        this.last_response = response;
	        break;
	    }
	  }
	
	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
	    if(this.resendProvisionalTimer === null) {
	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),
	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.last_response = response;
	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);
	
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	        /* falls through */
	        case C.STATUS_ACCEPTED:
	          // Note that this point will be reached for proceeding tr.state also.
	          if(!this.transport.send(response)) {
	            this.onTransportError();
	            deferred.reject();
	          } else {
	            deferred.resolve();
	          }
	          break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          this.stateChanged(C.STATUS_COMPLETED);
	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);
	          deferred.resolve();
	        }
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * @function
	 * @param {SIP.UA} ua
	 * @param {SIP.IncomingRequest} request
	 *
	 * @return {boolean}
	 * INVITE:
	 *  _true_ if retransmission
	 *  _false_ new request
	 *
	 * ACK:
	 *  _true_  ACK to non2xx response
	 *  _false_ ACK must be passed to TU (accepted state)
	 *          ACK to 2xx response
	 *
	 * CANCEL:
	 *  _true_  no matching invite transaction
	 *  _false_ matching invite transaction and no final response sent
	 *
	 * OTHER:
	 *  _true_  retransmission
	 *  _false_ new request
	 */
	var checkTransaction = function(ua, request) {
	  var tr;
	
	  switch(request.method) {
	    case SIP.C.INVITE:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_PROCEEDING:
	            tr.transport.send(tr.last_response);
	            break;
	
	            // RFC 6026 7.1 Invite retransmission
	            //received while in C.STATUS_ACCEPTED state. Absorb it.
	          case C.STATUS_ACCEPTED:
	            break;
	        }
	        return true;
	      }
	      break;
	    case SIP.C.ACK:
	      tr = ua.transactions.ist[request.via_branch];
	
	      // RFC 6026 7.1
	      if(tr) {
	        if(tr.state === C.STATUS_ACCEPTED) {
	          return false;
	        } else if(tr.state === C.STATUS_COMPLETED) {
	          tr.state = C.STATUS_CONFIRMED;
	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);
	          return true;
	        }
	      }
	
	      // ACK to 2XX Response.
	      else {
	        return false;
	      }
	      break;
	    case SIP.C.CANCEL:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        request.reply_sl(200);
	        if(tr.state === C.STATUS_PROCEEDING) {
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        request.reply_sl(481);
	        return true;
	      }
	      break;
	    default:
	
	      // Non-INVITE Server Transaction RFC 3261 17.2.2
	      tr = ua.transactions.nist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_TRYING:
	            break;
	          case C.STATUS_PROCEEDING:
	          case C.STATUS_COMPLETED:
	            tr.transport.send(tr.last_response);
	            break;
	        }
	        return true;
	      }
	      break;
	  }
	};
	
	SIP.Transactions = {
	  C: C,
	  checkTransaction: checkTransaction,
	  NonInviteClientTransaction: NonInviteClientTransaction,
	  InviteClientTransaction: InviteClientTransaction,
	  AckClientTransaction: AckClientTransaction,
	  NonInviteServerTransaction: NonInviteServerTransaction,
	  InviteServerTransaction: InviteServerTransaction
	};
	
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview SIP Dialog
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP dialog.
	 * @param {SIP.RTCSession} owner
	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
	 * @param {Enum} type UAC / UAS
	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
	 */
	module.exports = function (SIP) {
	
	var RequestSender = __webpack_require__(227)(SIP);
	
	var Dialog,
	  C = {
	    // Dialog states
	    STATUS_EARLY:       1,
	    STATUS_CONFIRMED:   2
	  };
	
	// RFC 3261 12.1
	Dialog = function(owner, message, type, state) {
	  var contact;
	
	  this.uac_pending_reply = false;
	  this.uas_pending_reply = false;
	
	  if(!message.hasHeader('contact')) {
	    return {
	      error: 'unable to create a Dialog without Contact header field'
	    };
	  }
	
	  if(message instanceof SIP.IncomingResponse) {
	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
	  } else {
	    // Create confirmed dialog if state is not defined
	    state = state || C.STATUS_CONFIRMED;
	  }
	
	  contact = message.parseHeader('contact');
	
	  // RFC 3261 12.1.1
	  if(type === 'UAS') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.to_tag,
	      remote_tag: message.from_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.remote_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('to').uri;
	    this.remote_uri = message.parseHeader('from').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route');
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	  }
	  // RFC 3261 12.1.2
	  else if(type === 'UAC') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.from_tag,
	      remote_tag: message.to_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('from').uri;
	    this.pracked = [];
	    this.remote_uri = message.parseHeader('to').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route').reverse();
	
	    //RENDERBODY
	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {
	      this.mediaHandler = owner.mediaHandlerFactory(owner);
	    }
	  }
	
	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());
	  this.owner = owner;
	  owner.ua.dialogs[this.id.toString()] = this;
	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
	  owner.emit('dialog', this);
	};
	
	Dialog.prototype = {
	  /**
	   * @param {SIP.IncomingMessage} message
	   * @param {Enum} UAC/UAS
	   */
	  update: function(message, type) {
	    this.state = C.STATUS_CONFIRMED;
	
	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');
	
	    if(type === 'UAC') {
	      // RFC 3261 13.2.2.4
	      this.route_set = message.getHeaders('record-route').reverse();
	    }
	  },
	
	  terminate: function() {
	    this.logger.log('dialog ' + this.id.toString() + ' deleted');
	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {
	      this.mediaHandler.peerConnection.close();
	    }
	    delete this.owner.ua.dialogs[this.id.toString()];
	  },
	
	  /**
	  * @param {String} method request method
	  * @param {Object} extraHeaders extra headers
	  * @returns {SIP.OutgoingRequest}
	  */
	
	  // RFC 3261 12.2.1.1
	  createRequest: function(method, extraHeaders, body) {
	    var cseq, request;
	    extraHeaders = (extraHeaders || []).slice();
	
	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }
	
	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;
	
	    request = new SIP.OutgoingRequest(
	      method,
	      this.remote_target,
	      this.owner.ua, {
	        'cseq': cseq,
	        'call_id': this.id.call_id,
	        'from_uri': this.local_uri,
	        'from_tag': this.id.local_tag,
	        'to_uri': this.remote_uri,
	        'to_tag': this.id.remote_tag,
	        'route_set': this.route_set
	      }, extraHeaders, body);
	
	    request.dialog = this;
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  * @returns {Boolean}
	  */
	
	  // RFC 3261 12.2.2
	  checkInDialogRequest: function(request) {
	    var self = this;
	
	    if(!this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    } else if(request.cseq < this.remote_seqnum) {
	        //Do not try to reply to an ACK request.
	        if (request.method !== SIP.C.ACK) {
	          request.reply(500);
	        }
	        if (request.cseq === this.invite_seqnum) {
	          return true;
	        }
	        return false;
	    } else if(request.cseq > this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    }
	
	    switch(request.method) {
	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
	      case SIP.C.INVITE:
	        if (this.uac_pending_reply === true) {
	          request.reply(491);
	        } else if (this.uas_pending_reply === true) {
	          var retryAfter = (Math.random() * 10 | 0) + 1;
	          request.reply(500, null, ['Retry-After:' + retryAfter]);
	          return false;
	        } else {
	          this.uas_pending_reply = true;
	          request.server_transaction.on('stateChanged', function stateChanged(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	              this.removeListener('stateChanged', stateChanged);
	              self.uas_pending_reply = false;
	
	              if (self.uac_pending_reply === false) {
	                self.owner.onReadyToReinvite();
	              }
	            }
	          });
	        }
	
	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	      case SIP.C.NOTIFY:
	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	    }
	
	    return true;
	  },
	
	  sendRequest: function(applicant, method, options) {
	    options = options || {};
	
	    var
	      extraHeaders = (options.extraHeaders || []).slice(),
	      body = options.body || null,
	      request = this.createRequest(method, extraHeaders, body),
	      request_sender = new RequestSender(this, applicant, request);
	
	    request_sender.send();
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  */
	  receiveRequest: function(request) {
	    //Check in-dialog request
	    if(!this.checkInDialogRequest(request)) {
	      return;
	    }
	
	    this.owner.receiveRequest(request);
	  }
	};
	
	Dialog.C = C;
	SIP.Dialog = Dialog;
	};


/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview In-Dialog Request Sender
	 */
	
	/**
	 * @augments SIP.Dialog
	 * @class Class creating an In-dialog request sender.
	 * @param {SIP.Dialog} dialog
	 * @param {Object} applicant
	 * @param {SIP.OutgoingRequest} request
	 */
	/**
	 * @fileoverview in-Dialog Request Sender
	 */
	
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(dialog, applicant, request) {
	
	  this.dialog = dialog;
	  this.applicant = applicant;
	  this.request = request;
	
	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
	  this.reattempt = false;
	  this.reattemptTimer = null;
	};
	
	RequestSender.prototype = {
	  send: function() {
	    var self = this,
	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);
	
	      request_sender.send();
	
	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      this.dialog.uac_pending_reply = true;
	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){
	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	          this.removeListener('stateChanged', stateChanged);
	          self.dialog.uac_pending_reply = false;
	
	          if (self.dialog.uas_pending_reply === false) {
	            self.dialog.owner.onReadyToReinvite();
	          }
	        }
	      });
	    }
	  },
	
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  receiveResponse: function(response) {
	    var self = this;
	
	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
	    if (response.status_code === 408 || response.status_code === 481) {
	      this.applicant.onDialogError(response);
	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {
	      if (this.reattempt) {
	        this.applicant.receiveResponse(response);
	      } else {
	        this.request.cseq.value = this.dialog.local_seqnum += 1;
	        this.reattemptTimer = SIP.Timers.setTimeout(
	          function() {
	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {
	              self.reattempt = true;
	              self.request_sender.send();
	            }
	          },
	          this.getReattemptTimeout()
	        );
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	return RequestSender;
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview Request Sender
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a request sender.
	 * @param {Object} applicant
	 * @param {SIP.UA} ua
	 */
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(applicant, ua) {
	  this.logger = ua.getLogger('sip.requestsender');
	  this.ua = ua;
	  this.applicant = applicant;
	  this.method = applicant.request.method;
	  this.request = applicant.request;
	  this.credentials = null;
	  this.challenged = false;
	  this.staled = false;
	
	  // If ua is in closing process or even closed just allow sending Bye and ACK
	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {
	    this.onTransportError();
	  }
	};
	
	/**
	* Create the client transaction and send the message.
	*/
	RequestSender.prototype = {
	  send: function() {
	    switch(this.method) {
	      case "INVITE":
	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
	        break;
	      case "ACK":
	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
	        break;
	      default:
	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
	    }
	    this.clientTransaction.send();
	
	    return this.clientTransaction;
	  },
	
	  /**
	  * Callback fired when receiving a request timeout error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  /**
	  * Callback fired when receiving a transport error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  /**
	  * Called from client transaction when receiving a correct response to the request.
	  * Authenticate request if needed or pass the response back to the applicant.
	  * @param {SIP.IncomingResponse} response
	  */
	  receiveResponse: function(response) {
	    var cseq, challenge, authorization_header_name,
	      status_code = response.status_code;
	
	    /*
	    * Authentication
	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
	    */
	    if (status_code === 401 || status_code === 407) {
	
	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
	      if (response.status_code === 401) {
	        challenge = response.parseHeader('www-authenticate');
	        authorization_header_name = 'authorization';
	      } else {
	        challenge = response.parseHeader('proxy-authenticate');
	        authorization_header_name = 'proxy-authorization';
	      }
	
	      // Verify it seems a valid challenge.
	      if (! challenge) {
	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
	        this.applicant.receiveResponse(response);
	        return;
	      }
	
	      if (!this.challenged || (!this.staled && challenge.stale === true)) {
	        if (!this.credentials) {
	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);
	        }
	
	        // Verify that the challenge is really valid.
	        if (!this.credentials.authenticate(this.request, challenge)) {
	          this.applicant.receiveResponse(response);
	          return;
	        }
	        this.challenged = true;
	
	        if (challenge.stale) {
	          this.staled = true;
	        }
	
	        if (response.method === SIP.C.REGISTER) {
	          cseq = this.applicant.cseq += 1;
	        } else if (this.request.dialog){
	          cseq = this.request.dialog.local_seqnum += 1;
	        } else {
	          cseq = this.request.cseq + 1;
	          this.request.cseq = cseq;
	        }
	        this.request.setHeader('cseq', cseq +' '+ this.method);
	
	        this.request.setHeader(authorization_header_name, this.credentials.toString());
	        this.send();
	      } else {
	        this.applicant.receiveResponse(response);
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	SIP.RequestSender = RequestSender;
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	
	var RegisterContext;
	
	RegisterContext = function (ua) {
	  var params = {},
	      regId = 1;
	
	  this.registrar = ua.configuration.registrarServer;
	  this.expires = ua.configuration.registerExpires;
	
	
	  // Contact header
	  this.contact = ua.contact.toString();
	
	  if(regId) {
	    this.contact += ';reg-id='+ regId;
	    this.contact += ';+sip.instance="<urn:uuid:'+ ua.configuration.instanceId+'>"';
	  }
	
	  // Call-ID and CSeq values RFC3261 10.2
	  this.call_id = SIP.Utils.createRandomToken(22);
	  this.cseq = 80;
	
	  this.to_uri = ua.configuration.uri;
	
	  params.to_uri = this.to_uri;
	  params.to_displayName = ua.configuration.displayName;
	  params.call_id = this.call_id;
	  params.cseq = this.cseq;
	
	  // Extends ClientContext
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);
	
	  this.registrationTimer = null;
	  this.registrationExpiredTimer = null;
	
	  // Set status
	  this.registered = false;
	
	  this.logger = ua.getLogger('sip.registercontext');
	};
	
	RegisterContext.prototype = {
	  register: function (options) {
	    var self = this, extraHeaders;
	
	    // Handle Options
	    this.options = options || {};
	    extraHeaders = (this.options.extraHeaders || []).slice();
	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);
	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	    // Save original extraHeaders to be used in .close
	    this.closeHeaders = this.options.closeWithHeaders ?
	      (this.options.extraHeaders || []).slice() : [];
	
	    this.receiveResponse = function(response) {
	      var contact, expires,
	        contacts = response.getHeaders('contact').length,
	        cause;
	
	      // Discard responses to older REGISTER/un-REGISTER requests.
	      if(response.cseq !== this.cseq) {
	        return;
	      }
	
	      // Clear registration timer
	      if (this.registrationTimer !== null) {
	        SIP.Timers.clearTimeout(this.registrationTimer);
	        this.registrationTimer = null;
	      }
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	
	          if(response.hasHeader('expires')) {
	            expires = response.getHeader('expires');
	          }
	
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	
	          // Search the Contact pointing to us and update the expires value accordingly.
	          if (!contacts) {
	            this.logger.warn('no Contact header in response to REGISTER, response ignored');
	            break;
	          }
	
	          while(contacts--) {
	            contact = response.parseHeader('contact', contacts);
	            if(contact.uri.user === this.ua.contact.uri.user) {
	              expires = contact.getParam('expires');
	              break;
	            } else {
	              contact = null;
	            }
	          }
	
	          if (!contact) {
	            this.logger.warn('no Contact header pointing to us, response ignored');
	            break;
	          }
	
	          if(!expires) {
	            expires = this.expires;
	          }
	
	          // Re-Register before the expiration interval has elapsed.
	          // For that, decrease the expires value. ie: 3 seconds
	          this.registrationTimer = SIP.Timers.setTimeout(function() {
	            self.registrationTimer = null;
	            self.register(self.options);
	          }, (expires * 1000) - 3000);
	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {
	            self.logger.warn('registration expired');
	            if (self.registered) {
	              self.unregistered(null, SIP.C.causes.EXPIRES);
	            }
	          }, expires * 1000);
	
	          //Save gruu values
	          if (contact.hasParam('temp-gruu')) {
	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/"/g,''));
	          }
	          if (contact.hasParam('pub-gruu')) {
	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/"/g,''));
	          }
	
	          this.registered = true;
	          this.emit('registered', response || null);
	          break;
	        // Interval too brief RFC3261 10.2.8
	        case /^423$/.test(response.status_code):
	          if(response.hasHeader('min-expires')) {
	            // Increase our registration interval to the suggested minimum
	            this.expires = response.getHeader('min-expires');
	            // Attempt the registration again immediately
	            this.register(this.options);
	          } else { //This response MUST contain a Min-Expires header field
	            this.logger.warn('423 response received for REGISTER without Min-Expires');
	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);
	          }
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.registrationFailure(response, cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	    this.send();
	  },
	
	  registrationFailure: function (response, cause) {
	    this.emit('failed', response || null, cause || null);
	  },
	
	  onTransportClosed: function() {
	    this.registered_before = this.registered;
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if (this.registrationExpiredTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	      this.registrationExpiredTimer = null;
	    }
	
	    if(this.registered) {
	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onTransportConnected: function() {
	    this.register(this.options);
	  },
	
	  close: function() {
	    var options = {
	      all: false,
	      extraHeaders: this.closeHeaders
	    };
	
	    this.registered_before = this.registered;
	    this.unregister(options);
	  },
	
	  unregister: function(options) {
	    var extraHeaders;
	
	    options = options || {};
	
	    if(!this.registered && !options.all) {
	      this.logger.warn('already unregistered');
	      return;
	    }
	
	    extraHeaders = (options.extraHeaders || []).slice();
	
	    this.registered = false;
	
	    // Clear the registration timer.
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if(options.all) {
	      extraHeaders.push('Contact: *');
	      extraHeaders.push('Expires: 0');
	    } else {
	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');
	    }
	
	
	    this.receiveResponse = function(response) {
	      var cause;
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	          this.unregistered(response);
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.unregistered(response,cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	
	    this.send();
	  },
	
	  unregistered: function(response, cause) {
	    this.registered = false;
	    this.emit('unregistered', response || null, cause || null);
	  }
	
	};
	
	
	SIP.RegisterContext = RegisterContext;
	};


/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	module.exports = function (EventEmitter) {
	var MediaHandler = function(session, options) {
	  // keep jshint happy
	  session = session;
	  options = options;
	};
	
	MediaHandler.prototype = Object.create(EventEmitter.prototype, {
	  isReady: {value: function isReady () {}},
	
	  close: {value: function close () {}},
	
	  /**
	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.
	   */
	  getDescription: {value: function getDescription (mediaHint) {
	    // keep jshint happy
	    mediaHint = mediaHint;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} description
	  */
	  setDescription: {value: function setDescription (description) {
	    // keep jshint happy
	    description = description;
	  }}
	});
	
	return MediaHandler;
	};


/***/ },
/* 231 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ClientContext;
	
	ClientContext = function (ua, method, target, options) {
	  var originalTarget = target;
	
	  // Validate arguments
	  if (target === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.clientcontext');
	  this.method = method;
	  target = ua.normalizeTarget(target);
	  if (!target) {
	    throw new TypeError('Invalid target: ' + originalTarget);
	  }
	
	  /* Options
	   * - extraHeaders
	   * - params
	   * - contentType
	   * - body
	   */
	  options = Object.create(options || Object.prototype);
	  options.extraHeaders = (options.extraHeaders || []).slice();
	
	  if (options.contentType) {
	    this.contentType = options.contentType;
	    options.extraHeaders.push('Content-Type: ' + this.contentType);
	  }
	
	  // Build the request
	  this.request = new SIP.OutgoingRequest(this.method,
	                                         target,
	                                         this.ua,
	                                         options.params,
	                                         options.extraHeaders);
	  if (options.body) {
	    this.body = options.body;
	    this.request.body = this.body;
	  }
	
	  /* Set other properties from the request */
	  this.localIdentity = this.request.from;
	  this.remoteIdentity = this.request.to;
	
	  this.data = {};
	};
	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ClientContext.prototype.send = function () {
	  (new SIP.RequestSender(this, this.ua)).send();
	  return this;
	};
	
	ClientContext.prototype.cancel = function (options) {
	  options = options || {};
	
	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	  this.request.cancel(cancel_reason);
	
	  this.emit('cancel');
	};
	
	ClientContext.prototype.receiveResponse = function (response) {
	  var cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      this.emit('progress', response, cause);
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('accepted', response, cause);
	      break;
	
	    default:
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('rejected', response, cause);
	      this.emit('failed', response, cause);
	      break;
	  }
	
	};
	
	ClientContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ClientContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ClientContext = ClientContext;
	};


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ServerContext;
	
	ServerContext = function (ua, request) {
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.servercontext');
	  this.request = request;
	  if (request.method === SIP.C.INVITE) {
	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);
	  } else {
	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);
	  }
	
	  if (request.body) {
	    this.body = request.body;
	  }
	  if (request.hasHeader('Content-Type')) {
	    this.contentType = request.getHeader('Content-Type');
	  }
	  this.method = request.method;
	
	  this.data = {};
	
	  this.localIdentity = request.to;
	  this.remoteIdentity = request.from;
	};
	
	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ServerContext.prototype.progress = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 180);
	  options.minCode = 100;
	  options.maxCode = 199;
	  options.events = ['progress'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.accept = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 200);
	  options.minCode = 200;
	  options.maxCode = 299;
	  options.events = ['accepted'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reject = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 480);
	  options.minCode = 300;
	  options.maxCode = 699;
	  options.events = ['rejected', 'failed'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reply = function (options) {
	  options = options || {}; // This is okay, so long as we treat options as read-only in this method
	  var
	    statusCode = options.statusCode || 100,
	    minCode = options.minCode || 100,
	    maxCode = options.maxCode || 699,
	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),
	    extraHeaders = options.extraHeaders || [],
	    body = options.body,
	    events = options.events || [],
	    response;
	
	  if (statusCode < minCode || statusCode > maxCode) {
	    throw new TypeError('Invalid statusCode: ' + statusCode);
	  }
	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	  events.forEach(function (event) {
	    this.emit(event, response, reasonPhrase);
	  }, this);
	
	  return this;
	};
	
	ServerContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ServerContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ServerContext = ServerContext;
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (SIP, environment) {
	
	var DTMF = __webpack_require__(234)(SIP);
	
	var Session, InviteServerContext, InviteClientContext,
	 C = {
	    //Session states
	    STATUS_NULL:                        0,
	    STATUS_INVITE_SENT:                 1,
	    STATUS_1XX_RECEIVED:                2,
	    STATUS_INVITE_RECEIVED:             3,
	    STATUS_WAITING_FOR_ANSWER:          4,
	    STATUS_ANSWERED:                    5,
	    STATUS_WAITING_FOR_PRACK:           6,
	    STATUS_WAITING_FOR_ACK:             7,
	    STATUS_CANCELED:                    8,
	    STATUS_TERMINATED:                  9,
	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,
	    STATUS_EARLY_MEDIA:                11,
	    STATUS_CONFIRMED:                  12
	  };
	
	/*
	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]
	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)
	 */
	Session = function (mediaHandlerFactory) {
	  this.status = C.STATUS_NULL;
	  this.dialog = null;
	  this.earlyDialogs = {};
	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;
	  // this.mediaHandler gets set by ICC/ISC constructors
	  this.hasOffer = false;
	  this.hasAnswer = false;
	
	  // Session Timers
	  this.timers = {
	    ackTimer: null,
	    expiresTimer: null,
	    invite2xxTimer: null,
	    userNoAnswerTimer: null,
	    rel1xxTimer: null,
	    prackTimer: null
	  };
	
	  // Session info
	  this.startTime = null;
	  this.endTime = null;
	  this.tones = null;
	
	  // Mute/Hold state
	  this.local_hold = false;
	  this.remote_hold = false;
	
	  this.pending_actions = {
	    actions: [],
	
	    length: function() {
	      return this.actions.length;
	    },
	
	    isPending: function(name){
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          return true;
	        }
	      }
	      return false;
	    },
	
	    shift: function() {
	      return this.actions.shift();
	    },
	
	    push: function(name) {
	      this.actions.push({
	        name: name
	      });
	    },
	
	    pop: function(name) {
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          this.actions.splice(idx,1);
	          length --;
	          idx--;
	        }
	      }
	    }
	   };
	
	  this.early_sdp = null;
	  this.rel100 = SIP.C.supported.UNSUPPORTED;
	};
	
	Session.prototype = {
	  dtmf: function(tones, options) {
	    var tone, dtmfs = [],
	        self = this;
	
	    options = options || {};
	
	    if (tones === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // Check tones
	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
	      throw new TypeError('Invalid tones: '+ tones);
	    }
	
	    tones = tones.toString().split('');
	
	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }
	
	    if (this.tones) {
	      // Tones are already queued, just add to the queue
	      this.tones =  this.tones.concat(dtmfs);
	      return this;
	    }
	
	    var sendDTMF = function () {
	      var dtmf, timeout;
	
	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {
	        // Stop sending DTMF
	        self.tones = null;
	        return this;
	      }
	
	      dtmf = self.tones.shift();
	
	      if (tone === ',') {
	        timeout = 2000;
	      } else {
	        dtmf.on('failed', function(){self.tones = null;});
	        dtmf.send(options);
	        timeout = dtmf.duration + dtmf.interToneGap;
	      }
	
	      // Set timeout for the next tone
	      SIP.Timers.setTimeout(sendDTMF, timeout);
	    };
	
	    this.tones = dtmfs;
	    sendDTMF();
	    return this;
	  },
	
	  bye: function(options) {
	    options = Object.create(options || Object.prototype);
	    var statusCode = options.statusCode;
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      this.logger.error('Error: Attempted to send BYE in a terminated session.');
	      return this;
	    }
	
	    this.logger.log('terminating Session');
	
	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {
	      throw new TypeError('Invalid statusCode: '+ statusCode);
	    }
	
	    options.receiveResponse = function () {};
	
	    return this.
	      sendRequest(SIP.C.BYE, options).
	      terminated();
	  },
	
	  refer: function(target, options) {
	    options = options || {};
	    var extraHeaders = (options.extraHeaders || []).slice(),
	        withReplaces =
	          target instanceof SIP.InviteServerContext ||
	          target instanceof SIP.InviteClientContext,
	        originalTarget = target;
	
	    if (target === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // transform `target` so that it can be a Refer-To header value
	    if (withReplaces) {
	      //Attended Transfer
	      // B.transfer(C)
	      target = '"' + target.remoteIdentity.friendlyName + '" ' +
	        '<' + target.dialog.remote_target.toString() +
	        '?Replaces=' + target.dialog.id.call_id +
	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +
	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';
	    } else {
	      //Blind Transfer
	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	      // so try to make one ahead of time
	      try {
	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	      } catch (e) {
	        this.logger.debug(".refer() cannot parse Refer_To from", target);
	        this.logger.debug("...falling through to normalizeTarget()");
	      }
	
	      // Check target validity
	      target = this.ua.normalizeTarget(target);
	      if (!target) {
	        throw new TypeError('Invalid target: ' + originalTarget);
	      }
	    }
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Refer-To: '+ target);
	
	    // Send the request
	    this.sendRequest(SIP.C.REFER, {
	      extraHeaders: extraHeaders,
	      body: options.body,
	      receiveResponse: function (response) {
	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {
	          return;
	        }
	        // hang up only if we transferred to a SIP address
	        if (withReplaces || (target.scheme && target.scheme.match("^sips?$"))) {
	          this.terminate();
	        }
	      }.bind(this)
	    });
	    return this;
	  },
	
	  followRefer: function followRefer (callback) {
	    return function referListener (callback, request) {
	      // open non-SIP URIs if possible and keep session open
	      var referTo = request.parseHeader('refer-to');
	      var target = referTo.uri;
	      if (!target.scheme.match("^sips?$")) {
	        var targetString = target.toString();
	        if (typeof environment.open === "function") {
	          environment.open(targetString);
	        } else {
	          this.logger.warn("referred to non-SIP URI but `open` isn't in the environment: " + targetString);
	        }
	        return;
	      }
	
	      var extraHeaders = [];
	
	      /* Copy the Replaces query into a Replaces header */
	      /* TODO - make sure we don't copy a poorly formatted header? */
	      var replaces = target.getHeader('Replaces');
	      if (replaces !== undefined) {
	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));
	      }
	
	      // don't embed headers into Request-URI of INVITE
	      target.clearHeaders();
	
	      /*
	        Harmless race condition.  Both sides of REFER
	        may send a BYE, but in the end the dialogs are destroyed.
	      */
	      var getReferMedia = this.mediaHandler.getReferMedia;
	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;
	
	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);
	
	      var referSession = this.ua.invite(target, {
	        media: mediaHint,
	        params: {
	          to_displayName: referTo.friendlyName
	        },
	        extraHeaders: extraHeaders
	      });
	
	      callback.call(this, request, referSession);
	
	      this.terminate();
	    }.bind(this, callback);
	  },
	
	  sendRequest: function(method,options) {
	    options = options || {};
	    var self = this;
	
	    var request = new SIP.OutgoingRequest(
	      method,
	      this.dialog.remote_target,
	      this.ua,
	      {
	        cseq: options.cseq || (this.dialog.local_seqnum += 1),
	        call_id: this.dialog.id.call_id,
	        from_uri: this.dialog.local_uri,
	        from_tag: this.dialog.id.local_tag,
	        to_uri: this.dialog.remote_uri,
	        to_tag: this.dialog.id.remote_tag,
	        route_set: this.dialog.route_set,
	        statusCode: options.statusCode,
	        reasonPhrase: options.reasonPhrase
	      },
	      options.extraHeaders || [],
	      options.body
	    );
	
	    new SIP.RequestSender({
	      request: request,
	      onRequestTimeout: function() {
	        self.onRequestTimeout();
	      },
	      onTransportError: function() {
	        self.onTransportError();
	      },
	      receiveResponse: options.receiveResponse || function(response) {
	        self.receiveNonInviteResponse(response);
	      }
	    }, this.ua).send();
	
	    // Emit the request event
	    this.emit(method.toLowerCase(), request);
	
	    return this;
	  },
	
	  close: function() {
	    var idx;
	
	    if(this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.logger.log('closing INVITE session ' + this.id);
	
	    // 1st Step. Terminate media.
	    if (this.mediaHandler){
	      this.mediaHandler.close();
	    }
	
	    // 2nd Step. Terminate signaling.
	
	    // Clear session timers
	    for(idx in this.timers) {
	      SIP.Timers.clearTimeout(this.timers[idx]);
	    }
	
	    // Terminate dialogs
	
	    // Terminate confirmed dialog
	    if(this.dialog) {
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	
	    // Terminate early dialogs
	    for(idx in this.earlyDialogs) {
	      this.earlyDialogs[idx].terminate();
	      delete this.earlyDialogs[idx];
	    }
	
	    this.status = C.STATUS_TERMINATED;
	
	    delete this.ua.sessions[this.id];
	    return this;
	  },
	
	  createDialog: function(message, type, early) {
	    var dialog, early_dialog,
	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],
	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],
	      id = message.call_id + local_tag + remote_tag;
	
	    early_dialog = this.earlyDialogs[id];
	
	    // Early Dialog
	    if (early) {
	      if (early_dialog) {
	        return true;
	      } else {
	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);
	
	        // Dialog has been successfully created.
	        if(early_dialog.error) {
	          this.logger.error(early_dialog.error);
	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	          return false;
	        } else {
	          this.earlyDialogs[id] = early_dialog;
	          return true;
	        }
	      }
	    }
	    // Confirmed Dialog
	    else {
	      // In case the dialog is in _early_ state, update it
	      if (early_dialog) {
	        early_dialog.update(message, type);
	        this.dialog = early_dialog;
	        delete this.earlyDialogs[id];
	        for (var dia in this.earlyDialogs) {
	          this.earlyDialogs[dia].terminate();
	          delete this.earlyDialogs[dia];
	        }
	        return true;
	      }
	
	      // Otherwise, create a _confirmed_ dialog
	      dialog = new SIP.Dialog(this, message, type);
	
	      if(dialog.error) {
	        this.logger.error(dialog.error);
	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	        return false;
	      } else {
	        this.to_tag = message.to_tag;
	        this.dialog = dialog;
	        return true;
	      }
	    }
	  },
	
	  /**
	  * Check if Session is ready for a re-INVITE
	  *
	  * @returns {Boolean}
	  */
	  isReadyToReinvite: function() {
	    return this.mediaHandler.isReady() &&
	      !this.dialog.uac_pending_reply &&
	      !this.dialog.uas_pending_reply;
	  },
	
	  /**
	   * Mute
	   */
	  mute: function(options) {
	    var ret = this.mediaHandler.mute(options);
	    if (ret) {
	      this.onmute(ret);
	    }
	  },
	
	  /**
	   * Unmute
	   */
	  unmute: function(options) {
	    var ret = this.mediaHandler.unmute(options);
	    if (ret) {
	      this.onunmute(ret);
	    }
	  },
	
	  /**
	   * Hold
	   */
	  hold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.hold();
	
	    // Check if RTCSession is ready to send a reINVITE
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'unhold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'hold' action, add this one to the queue
	       * Else, if there is already a 'hold' action, skip
	       */
	      if (this.pending_actions.isPending('unhold')) {
	        this.pending_actions.pop('unhold');
	      } else if (!this.pending_actions.isPending('hold')) {
	        this.pending_actions.push('hold');
	      }
	      return;
	    } else if (this.local_hold === true) {
	        return;
	    }
	
	    this.onhold('local');
	
	    options = options || {};
	    options.mangle = function(body){
	
	      // Don't receive media
	      // TODO - This will break for media streams with different directions.
	      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {
	        body = body.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
	      } else {
	        body = body.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
	        body = body.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
	      }
	
	      return body;
	    };
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * Unhold
	   */
	  unhold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.unhold();
	
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'hold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'unhold' action, add this one to the queue
	       * Else, if there is already a 'unhold' action, skip
	       */
	      if (this.pending_actions.isPending('hold')) {
	        this.pending_actions.pop('hold');
	      } else if (!this.pending_actions.isPending('unhold')) {
	        this.pending_actions.push('unhold');
	      }
	      return;
	    } else if (this.local_hold === false) {
	      return;
	    }
	
	    this.onunhold('local');
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * isOnHold
	   */
	  isOnHold: function() {
	    return {
	      local: this.local_hold,
	      remote: this.remote_hold
	    };
	  },
	
	  /**
	   * In dialog INVITE Reception
	   * @private
	   */
	  receiveReinvite: function(request) {
	    var self = this;
	
	    if (!request.body) {
	      return;
	    }
	
	    if (request.getHeader('Content-Type') !== 'application/sdp') {
	      this.logger.warn('invalid Content-Type');
	      request.reply(415);
	      return;
	    }
	
	    this.mediaHandler.setDescription(request.body)
	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	    .then(function(body) {
	      request.reply(200, null, ['Contact: ' + self.contact], body,
	        function() {
	          self.status = C.STATUS_WAITING_FOR_ACK;
	          self.setInvite2xxTimer(request, body);
	          self.setACKTimer();
	
	          // Are we holding?
	          var hold = (/a=(sendonly|inactive)/).test(request.body);
	
	          if (self.remote_hold && !hold) {
	            self.onunhold('remote');
	          } else if (!self.remote_hold && hold) {
	            self.onhold('remote');
	          }
	        });
	    })
	    .catch(function onFailure (e) {
	      var statusCode;
	      if (e instanceof SIP.Exceptions.GetDescriptionError) {
	        statusCode = 500;
	      } else {
	        self.logger.error(e);
	        statusCode = 488;
	      }
	      request.reply(statusCode);
	    });
	  },
	
	  sendReinvite: function(options) {
	    options = options || {};
	
	    var
	      self = this,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      eventHandlers = options.eventHandlers || {},
	      mangle = options.mangle || null,
	      succeeded;
	
	    if (eventHandlers.succeeded) {
	      succeeded = eventHandlers.succeeded;
	    }
	    this.reinviteSucceeded = function(){
	      SIP.Timers.clearTimeout(self.timers.ackTimer);
	      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	      self.status = C.STATUS_CONFIRMED;
	      succeeded && succeeded.apply(this, arguments);
	    };
	    if (eventHandlers.failed) {
	      this.reinviteFailed = eventHandlers.failed;
	    } else {
	      this.reinviteFailed = function(){};
	    }
	
	    extraHeaders.push('Contact: ' + this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Content-Type: application/sdp');
	
	    this.receiveResponse = this.receiveReinviteResponse;
	    //REVISIT
	    this.mediaHandler.getDescription(self.mediaHint)
	    .then(mangle)
	    .then(
	      function(body){
	        self.dialog.sendRequest(self, SIP.C.INVITE, {
	          extraHeaders: extraHeaders,
	          body: body
	        });
	      },
	      function() {
	        if (self.isReadyToReinvite()) {
	          self.onReadyToReinvite();
	        }
	        self.reinviteFailed();
	      }
	    );
	  },
	
	  receiveRequest: function (request) {
	    switch (request.method) {
	      case SIP.C.BYE:
	        request.reply(200);
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.emit('bye', request);
	          this.terminated(request, SIP.C.causes.BYE);
	        }
	        break;
	      case SIP.C.INVITE:
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.logger.log('re-INVITE received');
	          this.receiveReinvite(request);
	        }
	        break;
	      case SIP.C.INFO:
	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {
	          var body, tone, duration,
	              contentType = request.getHeader('content-type'),
	              reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
	              reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
	
	          if (contentType) {
	            if (contentType.match(/^application\/dtmf-relay/i)) {
	              if (request.body) {
	                body = request.body.split('\r\n', 2);
	                if (body.length === 2) {
	                  if (reg_tone.test(body[0])) {
	                    tone = body[0].replace(reg_tone,"$2");
	                  }
	                  if (reg_duration.test(body[1])) {
	                    duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
	                  }
	                }
	              }
	
	              new DTMF(this, tone, {duration: duration}).init_incoming(request);
	            } else {
	              request.reply(415, null, ["Accept: application/dtmf-relay"]);
	            }
	          }
	        }
	        break;
	      case SIP.C.REFER:
	        if(this.status ===  C.STATUS_CONFIRMED) {
	          this.logger.log('REFER received');
	          var hasReferListener = this.listeners('refer').length,
	              notifyBody;
	
	          if (hasReferListener) {
	            request.reply(202, 'Accepted');
	            notifyBody = 'SIP/2.0 100 Trying';
	
	            this.sendRequest(SIP.C.NOTIFY, {
	              extraHeaders:[
	                'Event: refer',
	                'Subscription-State: terminated',
	                'Content-Type: message/sipfrag'
	              ],
	              body: notifyBody,
	              receiveResponse: function() {}
	            });
	
	            this.emit('refer', request);
	          } else {
	            // RFC 3515.2.4.2: 'the UA MAY decline the request.'
	            request.reply(603, 'Declined');
	          }
	        }
	        break;
	      case SIP.C.NOTIFY:
	        request.reply(200, 'OK');
	        this.emit('notify', request);
	        break;
	    }
	  },
	
	  /**
	   * Reception of Response for in-dialog INVITE
	   * @private
	   */
	  receiveReinviteResponse: function(response) {
	    var self = this,
	        contentType = response.getHeader('Content-Type');
	
	    if (this.status === C.STATUS_TERMINATED) {
	      return;
	    }
	
	    switch(true) {
	      case /^1[0-9]{2}$/.test(response.status_code):
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        this.status = C.STATUS_CONFIRMED;
	
	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});
	
	        if(!response.body) {
	          this.reinviteFailed();
	          break;
	        } else if (contentType !== 'application/sdp') {
	          this.reinviteFailed();
	          break;
	        }
	
	        //REVISIT
	        this.mediaHandler.setDescription(response.body)
	        .then(
	          function onSuccess () {
	            self.reinviteSucceeded();
	          },
	          function onFailure () {
	            self.reinviteFailed();
	          }
	        );
	        break;
	      default:
	        this.reinviteFailed();
	    }
	  },
	
	  acceptAndTerminate: function(response, status_code, reason_phrase) {
	    var extraHeaders = [];
	
	    if (status_code) {
	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if (this.dialog || this.createDialog(response, 'UAC')) {
	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	      this.sendRequest(SIP.C.BYE, {
	        extraHeaders: extraHeaders
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * RFC3261 13.3.1.4
	   * Response retransmissions cannot be accomplished by transaction layer
	   *  since it is destroyed when receiving the first 2xx answer
	   */
	  setInvite2xxTimer: function(request, body) {
	    var self = this,
	        timeout = SIP.Timers.T1;
	
	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {
	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {
	        return;
	      }
	
	      self.logger.log('no ACK received, attempting to retransmit OK');
	
	      request.reply(200, null, ['Contact: ' + self.contact], body);
	
	      timeout = Math.min(timeout * 2, SIP.Timers.T2);
	
	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);
	    }, timeout);
	  },
	
	  /**
	   * RFC3261 14.2
	   * If a UAS generates a 2xx response and never receives an ACK,
	   *  it SHOULD generate a BYE to terminate the dialog.
	   */
	  setACKTimer: function() {
	    var self = this;
	
	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {
	      if(self.status === C.STATUS_WAITING_FOR_ACK) {
	        self.logger.log('no ACK received for an extended period of time, terminating the call');
	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	        self.sendRequest(SIP.C.BYE);
	        self.terminated(null, SIP.C.causes.NO_ACK);
	      }
	    }, SIP.Timers.TIMER_H);
	  },
	
	  /*
	   * @private
	   */
	  onReadyToReinvite: function() {
	    var action = this.pending_actions.shift();
	
	    if (!action || !this[action.name]) {
	      return;
	    }
	
	    this[action.name]();
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  },
	
	  onDialogError: function(response) {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(response, SIP.C.causes.DIALOG_ERROR);
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    }
	  },
	
	  /**
	   * @private
	   */
	  onhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;
	    this.emit('hold', { originator: originator });
	  },
	
	  /**
	   * @private
	   */
	  onunhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;
	    this.emit('unhold', { originator: originator });
	  },
	
	  /*
	   * @private
	   */
	  onmute: function(options) {
	    this.emit('muted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  /*
	   * @private
	   */
	  onunmute: function(options) {
	    this.emit('unmuted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  failed: function(response, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	    this.emit('failed', response || null, cause || null);
	    return this;
	  },
	
	  rejected: function(response, cause) {
	    this.emit('rejected',
	      response || null,
	      cause || null
	    );
	    return this;
	  },
	
	  canceled: function() {
	    this.emit('cancel');
	    return this;
	  },
	
	  accepted: function(response, cause) {
	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);
	
	    this.startTime = new Date();
	
	    if (this.replacee) {
	      this.replacee.emit('replaced', this);
	      this.replacee.terminate();
	    }
	    this.emit('accepted', response, cause);
	    return this;
	  },
	
	  terminated: function(message, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.endTime = new Date();
	
	    this.close();
	    this.emit('terminated',
	      message || null,
	      cause || null
	    );
	    return this;
	  },
	
	  connecting: function(request) {
	    this.emit('connecting', { request: request });
	    return this;
	  }
	};
	
	Session.desugar = function desugar(options) {
	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {
	    options = {
	      media: {
	        constraints: {
	          audio: true,
	          video: options.tagName === 'VIDEO'
	        },
	        render: {
	          remote: options
	        }
	      }
	    };
	  }
	  return options || {};
	};
	
	
	Session.C = C;
	SIP.Session = Session;
	
	
	InviteServerContext = function(ua, request) {
	  var expires,
	    self = this,
	    contentType = request.getHeader('Content-Type'),
	    contentDisp = request.parseHeader('Content-Disposition');
	
	  // Check body and content type
	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {
	    this.renderbody = request.body;
	    this.rendertype = contentType;
	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {
	    request.reply(415);
	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it
	    return;
	  }
	
	  //TODO: move this into media handler
	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	  SIP.Hacks.AllBrowsers.maskDtls(request);
	
	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);
	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);
	
	  this.status = C.STATUS_INVITE_RECEIVED;
	  this.from_tag = request.from_tag;
	  this.id = request.call_id + this.from_tag;
	  this.request = request;
	  this.contact = this.ua.contact.toString();
	
	  this.receiveNonInviteResponse = function () {}; // intentional no-op
	
	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);
	
	  //Save the session into the ua sessions collection.
	  this.ua.sessions[this.id] = this;
	
	  //Get the Expires header value if exists
	  if(request.hasHeader('expires')) {
	    expires = request.getHeader('expires') * 1000;
	  }
	
	  //Set 100rel if necessary
	  function set100rel(h,c) {
	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {
	      self.rel100 = c;
	    }
	  }
	  set100rel('require', SIP.C.supported.REQUIRED);
	  set100rel('supported', SIP.C.supported.SUPPORTED);
	
	  /* Set the to_tag before
	   * replying a response code that will create a dialog.
	   */
	  request.to_tag = SIP.Utils.newTag();
	
	  // An error on dialog creation will fire 'failed' event
	  if(!this.createDialog(request, 'UAS', true)) {
	    request.reply(500, 'Missing Contact header field');
	    return;
	  }
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: {"optional": [{'DtlsSrtpKeyAgreement': 'true'}]}
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  function fireNewSession() {
	    var options = {extraHeaders: ['Contact: ' + self.contact]};
	
	    if (self.rel100 !== SIP.C.supported.REQUIRED) {
	      self.progress(options);
	    }
	    self.status = C.STATUS_WAITING_FOR_ANSWER;
	
	    // Set userNoAnswerTimer
	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {
	      request.reply(408);
	      self.failed(request, SIP.C.causes.NO_ANSWER);
	      self.terminated(request, SIP.C.causes.NO_ANSWER);
	    }, self.ua.configuration.noAnswerTimeout);
	
	    /* Set expiresTimer
	     * RFC3261 13.3.1
	     */
	    if (expires) {
	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {
	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
	          request.reply(487);
	          self.failed(request, SIP.C.causes.EXPIRES);
	          self.terminated(request, SIP.C.causes.EXPIRES);
	        }
	      }, expires);
	    }
	
	    self.emit('invite',request);
	  }
	
	  if (!request.body || this.renderbody) {
	    SIP.Timers.setTimeout(fireNewSession, 0);
	  } else {
	    this.hasOffer = true;
	    this.mediaHandler.setDescription(request.body)
	    .then(
	      fireNewSession,
	      function onFailure (e) {
	        self.logger.warn('invalid SDP');
	        self.logger.warn(e);
	        request.reply(488);
	      }
	    );
	  }
	};
	
	InviteServerContext.prototype = {
	  reject: function(options) {
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('rejecting RTCSession');
	
	    SIP.ServerContext.prototype.reject.call(this, options);
	    return this.terminated();
	  },
	
	  terminate: function(options) {
	    options = options || {};
	
	    var
	    extraHeaders = (options.extraHeaders || []).slice(),
	    body = options.body,
	    dialog,
	    self = this;
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK &&
	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      dialog = this.dialog;
	
	      this.receiveRequest = function(request) {
	        if (request.method === SIP.C.ACK) {
	          this.request(SIP.C.BYE, {
	            extraHeaders: extraHeaders,
	            body: body
	          });
	          dialog.terminate();
	        }
	      };
	
	      this.request.server_transaction.on('stateChanged', function(){
	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	          this.request = new SIP.OutgoingRequest(
	            SIP.C.BYE,
	            this.dialog.remote_target,
	            this.ua,
	            {
	              'cseq': this.dialog.local_seqnum+=1,
	              'call_id': this.dialog.id.call_id,
	              'from_uri': this.dialog.local_uri,
	              'from_tag': this.dialog.id.local_tag,
	              'to_uri': this.dialog.remote_uri,
	              'to_tag': this.dialog.id.remote_tag,
	              'route_set': this.dialog.route_set
	            },
	            extraHeaders,
	            body
	          );
	
	          new SIP.RequestSender(
	            {
	              request: this.request,
	              onRequestTimeout: function() {
	                self.onRequestTimeout();
	              },
	              onTransportError: function() {
	                self.onTransportError();
	              },
	              receiveResponse: function() {
	                return;
	              }
	            },
	            this.ua
	          ).send();
	          dialog.terminate();
	        }
	      });
	
	      this.emit('bye', this.request);
	      this.terminated();
	
	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
	      this.dialog = dialog;
	
	      // Restore the dialog into 'ua' so the ACK can reach 'this' session
	      this.ua.dialogs[dialog.id.toString()] = dialog;
	
	    } else if (this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.reject(options);
	    }
	
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  progress: function (options) {
	    options = options || {};
	    var
	      statusCode = options.statusCode || 180,
	      reasonPhrase = options.reasonPhrase,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      body = options.body,
	      response;
	
	    if (statusCode < 100 || statusCode > 199) {
	      throw new TypeError('Invalid statusCode: ' + statusCode);
	    }
	
	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (stunServers || turnServers) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    function do100rel() {
	      /* jshint validthis: true */
	      statusCode = options.statusCode || 183;
	
	      // Set status and add extra headers
	      this.status = C.STATUS_WAITING_FOR_PRACK;
	      extraHeaders.push('Contact: '+ this.contact);
	      extraHeaders.push('Require: 100rel');
	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));
	
	      // Save media hint for later (referred sessions)
	      this.mediaHint = options.media;
	
	      // Get the session description to add to preaccept with
	      this.mediaHandler.getDescription(options.media)
	      .then(
	        function onSuccess (body) {
	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	            return;
	          }
	
	          this.early_sdp = body;
	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;
	
	          // Retransmit until we get a response or we time out (see prackTimer below)
	          var timeout = SIP.Timers.T1;
	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {
	            this.request.reply(statusCode, null, extraHeaders, body);
	            timeout *= 2;
	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);
	          }.bind(this), timeout);
	
	          // Timeout and reject INVITE if no response
	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {
	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {
	              return;
	            }
	
	            this.logger.log('no PRACK received, rejecting the call');
	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	            this.request.reply(504);
	            this.terminated(null, SIP.C.causes.NO_PRACK);
	          }.bind(this), SIP.Timers.T1 * 64);
	
	          // Send the initial response
	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	          this.emit('progress', response, reasonPhrase);
	        }.bind(this),
	
	        function onFailure () {
	          this.request.reply(480);
	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }.bind(this)
	      );
	    } // end do100rel
	
	    function normalReply() {
	      /* jshint validthis:true */
	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	      this.emit('progress', response, reasonPhrase);
	    }
	
	    if (options.statusCode !== 100 &&
	        (this.rel100 === SIP.C.supported.REQUIRED ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {
	      do100rel.apply(this);
	    } else {
	      normalReply.apply(this);
	    }
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  accept: function(options) {
	    options = Object.create(Session.desugar(options));
	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	    this.mediaHint = options.media;
	
	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21
	    var
	      //idx, length, hasAudio, hasVideo,
	      self = this,
	      request = this.request,
	      extraHeaders = (options.extraHeaders || []).slice(),
	    //mediaStream = options.mediaStream || null,
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      sdpCreationSucceeded = function(body) {
	        var
	          response,
	          // run for reply success callback
	          replySucceeded = function() {
	            self.status = C.STATUS_WAITING_FOR_ACK;
	
	            self.setInvite2xxTimer(request, body);
	            self.setACKTimer();
	          },
	
	          // run for reply failure callback
	          replyFailed = function() {
	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);
	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);
	          };
	
	        // Chrome might call onaddstream before accept() is called, which means
	        // mediaHandler.render() was called without a renderHint, so we need to
	        // re-render now that mediaHint.render has been set.
	        //
	        // Chrome seems to be in the right regarding this, see
	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream
	        self.mediaHandler.render();
	
	        extraHeaders.push('Contact: ' + self.contact);
	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	        if(!self.hasOffer) {
	          self.hasOffer = true;
	        } else {
	          self.hasAnswer = true;
	        }
	        response = request.reply(200, null, extraHeaders,
	                      body,
	                      replySucceeded,
	                      replyFailed
	                     );
	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail
	          self.accepted(response, SIP.Utils.getReasonPhrase(200));
	        }
	      },
	
	      sdpCreationFailed = function() {
	        if (self.status === C.STATUS_TERMINATED) {
	          return;
	        }
	        // TODO - fail out on error
	        self.request.reply(480);
	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	      };
	
	    // Check Session Status
	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {
	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;
	      return this;
	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {
	      this.status = C.STATUS_ANSWERED;
	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    if ((stunServers || turnServers) &&
	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if(!this.createDialog(request, 'UAS')) {
	      request.reply(500, 'Missing Contact header field');
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);
	
	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21
	    /*
	    length = this.getRemoteStreams().length;
	
	    for (idx = 0; idx < length; idx++) {
	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {
	        hasVideo = true;
	      }
	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {
	        hasAudio = true;
	      }
	    }
	
	    if (!hasAudio && this.mediaConstraints.audio === true) {
	      this.mediaConstraints.audio = false;
	      if (mediaStream) {
	        length = mediaStream.getAudioTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
	        }
	      }
	    }
	
	    if (!hasVideo && this.mediaConstraints.video === true) {
	      this.mediaConstraints.video = false;
	      if (mediaStream) {
	        length = mediaStream.getVideoTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
	        }
	      }
	    }
	    */
	
	    if (this.status === C.STATUS_EARLY_MEDIA) {
	      sdpCreationSucceeded();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        sdpCreationSucceeded,
	        sdpCreationFailed
	      );
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	
	    // ISC RECEIVE REQUEST
	
	    function confirmSession() {
	      /* jshint validthis:true */
	      var contentType;
	
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      // TODO - this logic assumes Content-Disposition defaults
	      contentType = request.getHeader('Content-Type');
	      if (contentType !== 'application/sdp') {
	        this.renderbody = request.body;
	        this.rendertype = contentType;
	      }
	    }
	
	    switch(request.method) {
	    case SIP.C.CANCEL:
	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
	       * was in progress and that the UAC MAY continue with the session established by
	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the
	       * established session. So the CANCEL is processed only if the session is not yet
	       * established.
	       */
	
	      /*
	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
	       *request opening the session.
	       */
	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||
	         this.status === C.STATUS_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_EARLY_MEDIA ||
	         this.status === C.STATUS_ANSWERED) {
	
	        this.status = C.STATUS_CANCELED;
	        this.request.reply(487);
	        this.canceled(request);
	        this.rejected(request, SIP.C.causes.CANCELED);
	        this.failed(request, SIP.C.causes.CANCELED);
	        this.terminated(request, SIP.C.causes.CANCELED);
	      }
	      break;
	    case SIP.C.ACK:
	      if(this.status === C.STATUS_WAITING_FOR_ACK) {
	        if (!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            // ACK contains answer to an INVITE w/o SDP negotiation
	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	            SIP.Hacks.AllBrowsers.maskDtls(request);
	
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              confirmSession.bind(this),
	              function onFailure (e) {
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else if (this.early_sdp) {
	            confirmSession.apply(this);
	          } else {
	            //TODO: Pass to mediahandler
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          confirmSession.apply(this);
	        }
	      }
	      break;
	    case SIP.C.PRACK:
	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	        //localMedia = session.mediaHandler.localMedia;
	        if(!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              function onSuccess () {
	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	                SIP.Timers.clearTimeout(this.timers.prackTimer);
	                request.reply(200);
	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                  this.status = C.STATUS_EARLY_MEDIA;
	                  this.accept();
	                }
	                this.status = C.STATUS_EARLY_MEDIA;
	                //REVISIT
	                this.mute();
	              }.bind(this),
	              function onFailure (e) {
	                //TODO: Send to media handler
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else {
	            this.terminate({
	              statusCode: '488',
	              reasonPhrase: 'Bad Media Description'
	            });
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	          SIP.Timers.clearTimeout(this.timers.prackTimer);
	          request.reply(200);
	
	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	            this.status = C.STATUS_EARLY_MEDIA;
	            this.accept();
	          }
	          this.status = C.STATUS_EARLY_MEDIA;
	          //REVISIT
	          this.mute();
	        }
	      } else if(this.status === C.STATUS_EARLY_MEDIA) {
	        request.reply(200);
	      }
	      break;
	    default:
	      Session.prototype.receiveRequest.apply(this, [request]);
	      break;
	    }
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteServerContext = InviteServerContext;
	
	InviteClientContext = function(ua, target, options) {
	  options = Object.create(Session.desugar(options));
	  options.params = Object.create(options.params || Object.prototype);
	
	  var iceServers,
	    extraHeaders = (options.extraHeaders || []).slice(),
	    stunServers = options.stunServers || null,
	    turnServers = options.turnServers || null,
	    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,
	    isMediaSupported = mediaHandlerFactory.isSupported;
	
	  // Check WebRTC support
	  if (isMediaSupported && !isMediaSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.RTCConstraints = options.RTCConstraints || {};
	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;
	
	  // Set anonymous property
	  this.anonymous = options.anonymous || false;
	
	  // Custom data to be sent either in INVITE or in ACK
	  this.renderbody = options.renderbody || null;
	  this.rendertype = options.rendertype || 'text/plain';
	
	  options.params.from_tag = this.from_tag;
	
	  /* Do not add ;ob in initial forming dialog requests if the registration over
	   *  the current connection got a GRUU URI.
	   */
	  this.contact = ua.contact.toString({
	    anonymous: this.anonymous,
	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu
	  });
	
	  if (this.anonymous) {
	    options.params.from_displayName = 'Anonymous';
	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';
	
	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());
	    extraHeaders.push('Privacy: id');
	  }
	  extraHeaders.push('Contact: '+ this.contact);
	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	  if (!this.inviteWithoutSdp) {
	    extraHeaders.push('Content-Type: application/sdp');
	  } else if (this.renderbody) {
	    extraHeaders.push('Content-Type: ' + this.rendertype);
	    extraHeaders.push('Content-Disposition: render;handling=optional');
	  }
	
	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: 100rel');
	  }
	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: replaces');
	  }
	
	  options.extraHeaders = extraHeaders;
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);
	  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);
	
	  // Check Session Status
	  if (this.status !== C.STATUS_NULL) {
	    throw new SIP.Exceptions.InvalidStateError(this.status);
	  }
	
	  // Session parameter initialization
	  this.from_tag = SIP.Utils.newTag();
	
	  // OutgoingSession specific parameters
	  this.isCanceled = false;
	  this.received_100 = false;
	
	  this.method = SIP.C.INVITE;
	
	  this.receiveNonInviteResponse = this.receiveResponse;
	  this.receiveResponse = this.receiveInviteResponse;
	
	  this.logger = ua.getLogger('sip.inviteclientcontext');
	
	  if (stunServers) {
	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid stunServers: '+ stunServers);
	    } else {
	      this.stunServers = iceServers;
	    }
	  }
	
	  if (turnServers) {
	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid turnServers: '+ turnServers);
	    } else {
	      this.turnServers = iceServers;
	    }
	  }
	
	  ua.applicants[this] = this;
	
	  this.id = this.request.call_id + this.from_tag;
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: this.RTCConstraints,
	    stunServers: this.stunServers,
	    turnServers: this.turnServers
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	  this.mediaHint = options.media;
	};
	
	InviteClientContext.prototype = {
	  invite: function () {
	    var self = this;
	
	    //Save the session into the ua sessions collection.
	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
	    this.ua.sessions[this.id] = this;
	
	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level
	    // and hand sip.js a stream as the mediaHint
	    if (this.inviteWithoutSdp) {
	      //just send an invite with no sdp...
	      this.request.body = self.renderbody;
	      this.status = C.STATUS_INVITE_SENT;
	      this.send();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        function onSuccess(offer) {
	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          self.hasOffer = true;
	          self.request.body = offer;
	          self.status = C.STATUS_INVITE_SENT;
	          self.send();
	        },
	        function onFailure() {
	          if (self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          // TODO...fail out
	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }
	      );
	    }
	
	    return this;
	  },
	
	  receiveInviteResponse: function(response) {
	    var cause, //localMedia,
	      session = this,
	      id = response.call_id + response.from_tag + response.to_tag,
	      extraHeaders = [],
	      options = {};
	
	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {
	      return;
	    }
	
	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {
	      if (id !== this.dialog.id.toString() ) {
	        if (!this.createDialog(response, 'UAC', true)) {
	          return;
	        }
	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,
	                                          {
	                                            body: SIP.Utils.generateFakeSDP(response.body)
	                                          });
	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);
	
	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
	         * leg (due to peerConnection limitations) has been answered first. If your forking
	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.
	         */
	        if(this.status !== C.STATUS_CONFIRMED) {
	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);
	        }
	        return;
	      } else if (this.status === C.STATUS_CONFIRMED) {
	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	        return;
	      } else if (!this.hasAnswer) {
	        // invite w/o sdp is waiting for callback
	        //an invite with sdp must go on, and hasAnswer is true
	        return;
	      }
	    }
	
	    if (this.dialog && response.status_code < 200) {
	      /*
	        Early media has been set up with at least one other different branch,
	        but a final 2xx response hasn't been received
	      */
	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {
	        return;
	      }
	
	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {
	        return;
	      }
	
	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	        return;
	      }
	
	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	
	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	        extraHeaders: extraHeaders,
	        body: SIP.Utils.generateFakeSDP(response.body)
	      });
	      return;
	    }
	
	    // Proceed to cancellation if the user requested.
	    if(this.isCanceled) {
	      if(response.status_code >= 100 && response.status_code < 200) {
	        this.request.cancel(this.cancelReason);
	        this.canceled(null);
	      } else if(response.status_code >= 200 && response.status_code < 299) {
	        this.acceptAndTerminate(response);
	        this.emit('bye', this.request);
	      } else if (response.status_code >= 300) {
	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	      }
	      return;
	    }
	
	    switch(true) {
	      case /^100$/.test(response.status_code):
	        this.received_100 = true;
	        this.emit('progress', response);
	        break;
	      case (/^1[0-9]{2}$/.test(response.status_code)):
	        // Do nothing with 1xx responses without To tag.
	        if(!response.to_tag) {
	          this.logger.warn('1xx response received without to tag');
	          break;
	        }
	
	        // Create Early Dialog if 1XX comes with contact
	        if(response.hasHeader('contact')) {
	          // An error on dialog creation will fire 'failed' event
	          if (!this.createDialog(response, 'UAC', true)) {
	            break;
	          }
	        }
	
	        this.status = C.STATUS_1XX_RECEIVED;
	
	        if(response.hasHeader('require') &&
	           response.getHeader('require').indexOf('100rel') !== -1) {
	
	          // Do nothing if this.dialog is already confirmed
	          if (this.dialog || !this.earlyDialogs[id]) {
	            break;
	          }
	
	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	            return;
	          }
	
	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	          SIP.Hacks.AllBrowsers.maskDtls(response);
	
	          if (!response.body) {
	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	              extraHeaders: extraHeaders
	            });
	            this.emit('progress', response);
	
	          } else if (this.hasOffer) {
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasAnswer = true;
	            this.dialog.pracked.push(response.getHeader('rseq'));
	
	            this.mediaHandler.setDescription(response.body)
	            .then(
	              function onSuccess () {
	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	
	                session.sendRequest(SIP.C.PRACK, {
	                  extraHeaders: extraHeaders,
	                  receiveResponse: function() {}
	                });
	                session.status = C.STATUS_EARLY_MEDIA;
	                session.mute();
	                session.emit('progress', response);
	                /*
	                if (session.status === C.STATUS_EARLY_MEDIA) {
	                  localMedia = session.mediaHandler.localMedia;
	                  if (localMedia.getAudioTracks().length > 0) {
	                    localMedia.getAudioTracks()[0].enabled = false;
	                  }
	                  if (localMedia.getVideoTracks().length > 0) {
	                    localMedia.getVideoTracks()[0].enabled = false;
	                  }
	                }*/
	              },
	              function onFailure (e) {
	                session.logger.warn(e);
	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }
	            );
	          } else {
	            var earlyDialog = this.earlyDialogs[id];
	            var earlyMedia = earlyDialog.mediaHandler;
	
	            earlyDialog.pracked.push(response.getHeader('rseq'));
	
	            earlyMedia.setDescription(response.body)
	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))
	            .then(function onSuccess(sdp) {
	              extraHeaders.push('Content-Type: application/sdp');
	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	              earlyDialog.sendRequest(session, SIP.C.PRACK, {
	                extraHeaders: extraHeaders,
	                body: sdp
	              });
	              session.status = C.STATUS_EARLY_MEDIA;
	              session.emit('progress', response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                earlyDialog.pracked.push(response.getHeader('rseq'));
	                if (session.status === C.STATUS_TERMINATED) {
	                  return;
	                }
	                // TODO - fail out on error
	                // session.failed(gum error);
	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);
	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	              } else {
	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);
	                // Could not set remote description
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	              }
	            });
	          }
	        } else {
	          this.emit('progress', response);
	        }
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        var cseq = this.request.cseq + ' ' + this.request.method;
	        if (cseq !== response.getHeader('cseq')) {
	          break;
	        }
	
	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {
	          this.status = C.STATUS_CONFIRMED;
	          this.unmute();
	          /*localMedia = this.mediaHandler.localMedia;
	          if (localMedia.getAudioTracks().length > 0) {
	            localMedia.getAudioTracks()[0].enabled = true;
	          }
	          if (localMedia.getVideoTracks().length > 0) {
	            localMedia.getVideoTracks()[0].enabled = true;
	          }*/
	          options = {};
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + this.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          options.cseq = response.cseq;
	          this.sendRequest(SIP.C.ACK, options);
	          this.accepted(response);
	          break;
	        }
	        // Do nothing if this.dialog is already confirmed
	        if (this.dialog) {
	          break;
	        }
	
	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	        SIP.Hacks.AllBrowsers.maskDtls(response);
	
	        // This is an invite without sdp
	        if (!this.hasOffer) {
	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {
	            //REVISIT
	            this.hasOffer = true;
	            this.hasAnswer = true;
	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.status = C.STATUS_CONFIRMED;
	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});
	
	            this.unmute();
	            /*
	            localMedia = session.mediaHandler.localMedia;
	            if (localMedia.getAudioTracks().length > 0) {
	              localMedia.getAudioTracks()[0].enabled = true;
	            }
	            if (localMedia.getVideoTracks().length > 0) {
	              localMedia.getVideoTracks()[0].enabled = true;
	            }*/
	            this.accepted(response);
	          } else {
	            if(!response.body) {
	              this.acceptAndTerminate(response, 400, 'Missing session description');
	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              break;
	            }
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasOffer = true;
	            this.mediaHandler.setDescription(response.body)
	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	            .then(function onSuccess(sdp) {
	              //var localMedia;
	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {
	                return;
	              }
	
	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);
	
	              session.status = C.STATUS_CONFIRMED;
	              session.hasAnswer = true;
	
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              session.sendRequest(SIP.C.ACK,{
	                body: sdp,
	                extraHeaders:['Content-Type: application/sdp'],
	                cseq:response.cseq
	              });
	              session.accepted(response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                // TODO do something here
	                session.logger.warn("there was a problem");
	              } else {
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	                response.reply(488);
	              }
	            });
	          }
	        } else if (this.hasAnswer){
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + session.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          this.sendRequest(SIP.C.ACK, options);
	        } else {
	          if(!response.body) {
	            this.acceptAndTerminate(response, 400, 'Missing session description');
	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            break;
	          }
	          if (!this.createDialog(response, 'UAC')) {
	            break;
	          }
	          this.hasAnswer = true;
	          this.mediaHandler.setDescription(response.body)
	          .then(
	            function onSuccess () {
	              var options = {};//,localMedia;
	              session.status = C.STATUS_CONFIRMED;
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              if (session.renderbody) {
	                extraHeaders.push('Content-Type: ' + session.rendertype);
	                options.extraHeaders = extraHeaders;
	                options.body = session.renderbody;
	              }
	              options.cseq = response.cseq;
	              session.sendRequest(SIP.C.ACK, options);
	              session.accepted(response);
	            },
	            function onFailure (e) {
	              session.logger.warn(e);
	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            }
	          );
	        }
	        break;
	      default:
	        cause = SIP.Utils.sipErrorCause(response.status_code);
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	    }
	  },
	
	  cancel: function(options) {
	    options = options || {};
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('canceling RTCSession');
	
	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	
	    // Check Session Status
	    if (this.status === C.STATUS_NULL ||
	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {
	      this.isCanceled = true;
	      this.cancelReason = cancel_reason;
	    } else if (this.status === C.STATUS_INVITE_SENT ||
	               this.status === C.STATUS_1XX_RECEIVED ||
	               this.status === C.STATUS_EARLY_MEDIA) {
	      this.request.cancel(cancel_reason);
	    }
	
	    return this.canceled();
	  },
	
	  terminate: function(options) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.cancel(options);
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	    // ICC RECEIVE REQUEST
	
	    // Reject CANCELs
	    if (request.method === SIP.C.CANCEL) {
	      // TODO; make this a switch when it gets added
	    }
	
	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      this.accepted();
	    }
	
	    return Session.prototype.receiveRequest.apply(this, [request]);
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteClientContext = InviteClientContext;
	
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview DTMF
	 */
	
	/**
	 * @class DTMF
	 * @param {SIP.Session} session
	 */
	module.exports = function (SIP) {
	
	var DTMF,
	  C = {
	    MIN_DURATION:            70,
	    MAX_DURATION:            6000,
	    DEFAULT_DURATION:        100,
	    MIN_INTER_TONE_GAP:      50,
	    DEFAULT_INTER_TONE_GAP:  500
	  };
	
	DTMF = function(session, tone, options) {
	  var duration, interToneGap;
	
	  if (tone === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);
	  this.owner = session;
	  this.direction = null;
	
	  options = options || {};
	  duration = options.duration || null;
	  interToneGap = options.interToneGap || null;
	
	  // Check tone type
	  if (typeof tone === 'string' ) {
	    tone = tone.toUpperCase();
	  } else if (typeof tone === 'number') {
	    tone = tone.toString();
	  } else {
	    throw new TypeError('Invalid tone: '+ tone);
	  }
	
	  // Check tone value
	  if (!tone.match(/^[0-9A-D#*]$/)) {
	    throw new TypeError('Invalid tone: '+ tone);
	  } else {
	    this.tone = tone;
	  }
	
	  // Check duration
	  if (duration && !SIP.Utils.isDecimal(duration)) {
	    throw new TypeError('Invalid tone duration: '+ duration);
	  } else if (!duration) {
	    duration = DTMF.C.DEFAULT_DURATION;
	  } else if (duration < DTMF.C.MIN_DURATION) {
	    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
	    duration = DTMF.C.MIN_DURATION;
	  } else if (duration > DTMF.C.MAX_DURATION) {
	    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
	    duration = DTMF.C.MAX_DURATION;
	  } else {
	    duration = Math.abs(duration);
	  }
	  this.duration = duration;
	
	  // Check interToneGap
	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {
	    throw new TypeError('Invalid interToneGap: '+ interToneGap);
	  } else if (!interToneGap) {
	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
	    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
	  } else {
	    interToneGap = Math.abs(interToneGap);
	  }
	  this.interToneGap = interToneGap;
	};
	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);
	
	
	DTMF.prototype.send = function(options) {
	  var extraHeaders, body;
	
	  this.direction = 'outgoing';
	
	  // Check RTCSession Status
	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&
	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);
	  }
	
	  // Get DTMF options
	  options = options || {};
	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
	
	  extraHeaders.push('Content-Type: application/dtmf-relay');
	
	  body = "Signal= " + this.tone + "\r\n";
	  body += "Duration= " + this.duration;
	
	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {
	    extraHeaders: extraHeaders,
	    body: body
	  });
	
	  this.owner.emit('dtmf', this.request, this);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.receiveResponse = function(response) {
	  var cause;
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      // Ignore provisional responses.
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      this.emit('succeeded', {
	        originator: 'remote',
	        response: response
	      });
	      break;
	
	    default:
	      cause = SIP.Utils.sipErrorCause(response.status_code);
	      this.emit('failed', response, cause);
	      break;
	  }
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onRequestTimeout = function() {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	  this.owner.onRequestTimeout();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onTransportError = function() {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	  this.owner.onTransportError();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onDialogError = function(response) {
	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);
	  this.owner.onDialogError(response);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.init_incoming = function(request) {
	  this.direction = 'incoming';
	  this.request = request;
	
	  request.reply(200);
	
	  if (!this.tone || !this.duration) {
	    this.logger.warn('invalid INFO DTMF received, discarded');
	  } else {
	    this.owner.emit('dtmf', request, this);
	  }
	};
	
	DTMF.C = C;
	return DTMF;
	};


/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP Subscription.
	 */
	module.exports = function (SIP) {
	SIP.Subscription = function (ua, target, event, options) {
	  options = Object.create(options || Object.prototype);
	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();
	
	  this.id = null;
	  this.state = 'init';
	
	  if (!event) {
	    throw new TypeError('Event necessary to create a subscription.');
	  } else {
	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
	    //The check may need to/should probably occur on the other side,
	    this.event = event;
	  }
	
	  if(typeof options.expires !== 'number'){
	    ua.logger.warn('expires must be a number. Using default of 3600.');
	    this.expires = 3600;
	  } else {
	    this.expires = options.expires;
	  }
	
	  options.extraHeaders.push('Event: ' + this.event);
	  options.extraHeaders.push('Expires: ' + this.expires);
	
	  if (options.body) {
	    this.body = options.body;
	  }
	
	  this.contact = ua.contact.toString();
	
	  options.extraHeaders.push('Contact: '+ this.contact);
	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);
	
	  this.logger = ua.getLogger('sip.subscription');
	
	  this.dialog = null;
	  this.timers = {N: null, sub_duration: null};
	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];
	};
	
	SIP.Subscription.prototype = {
	  subscribe: function() {
	    var sub = this;
	
	     //these states point to an existing subscription, no subscribe is necessary
	    if (this.state === 'active') {
	      this.refresh();
	      return this;
	    } else if (this.state === 'notify_wait') {
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	
	    this.send();
	
	    this.state = 'notify_wait';
	
	    return this;
	  },
	
	  refresh: function () {
	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {
	      return;
	    }
	
	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {
	      extraHeaders: this.extraHeaders,
	      body: this.body
	    });
	  },
	
	  receiveResponse: function(response) {
	    var expires, sub = this,
	        cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||
	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {
	      this.failed(response, null);
	    } else if (/^2[0-9]{2}$/.test(response.status_code)){
	      expires = response.getHeader('Expires');
	      SIP.Timers.clearTimeout(this.timers.N);
	
	      if (this.createConfirmedDialog(response,'UAC')) {
	        this.id = this.dialog.id.toString();
	        this.ua.subscriptions[this.id] = this;
	        this.emit('accepted', response, cause);
	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
	      }
	
	      if (expires && expires <= this.expires) {
	        // Preserve new expires value for subsequent requests
	        this.expires = expires;
	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);
	      } else {
	        if (!expires) {
	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');
	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);
	        } else {
	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');
	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);
	        }
	      }
	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx
	  },
	
	  unsubscribe: function() {
	    var extraHeaders = [], sub = this;
	
	    this.state = 'terminated';
	
	    extraHeaders.push('Event: ' + this.event);
	    extraHeaders.push('Expires: 0');
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	    //makes sure expires isn't set, and other typical resubscribe behavior
	    this.receiveResponse = function(){};
	
	    this.dialog.sendRequest(this, this.method, {
	      extraHeaders: extraHeaders,
	      body: this.body
	    });
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	  },
	
	  /**
	  * @private
	  */
	  timer_fire: function(){
	    if (this.state === 'terminated') {
	      this.terminateDialog();
	      SIP.Timers.clearTimeout(this.timers.N);
	      SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	      delete this.ua.subscriptions[this.id];
	    } else if (this.state === 'pending' || this.state === 'notify_wait') {
	      this.close();
	    } else {
	      this.refresh();
	    }
	  },
	
	  /**
	  * @private
	  */
	  close: function() {
	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {
	      this.unsubscribe();
	    }
	  },
	
	  /**
	  * @private
	  */
	  createConfirmedDialog: function(message, type) {
	    var dialog;
	
	    this.terminateDialog();
	    dialog = new SIP.Dialog(this, message, type);
	
	    if(!dialog.error) {
	      this.dialog = dialog;
	      return true;
	    }
	    // Dialog not created due to an error
	    else {
	      return false;
	    }
	  },
	
	  /**
	  * @private
	  */
	  terminateDialog: function() {
	    if(this.dialog) {
	      delete this.ua.subscriptions[this.id];
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	  },
	
	  /**
	  * @private
	  */
	  receiveRequest: function(request) {
	    var sub_state, sub = this;
	
	    function setExpiresTimeout() {
	      if (sub_state.expires) {
	        SIP.Timers.clearTimeout(sub.timers.sub_duration);
	        sub_state.expires = Math.min(sub.expires,
	                                     Math.max(sub_state.expires, 0));
	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),
	                                                    sub_state.expires * 900);
	      }
	    }
	
	    if (!this.matchEvent(request)) { //checks event and subscription_state headers
	      request.reply(489);
	      return;
	    }
	
	    sub_state = request.parseHeader('Subscription-State');
	
	    request.reply(200, SIP.C.REASON_200);
	
	    SIP.Timers.clearTimeout(this.timers.N);
	
	    this.emit('notify', {request: request});
	
	    // if we've set state to terminated, no further processing should take place
	    // and we are only interested in cleaning up after the appropriate NOTIFY
	    if (this.state === 'terminated') {
	      if (sub_state.state === 'terminated') {
	        this.terminateDialog();
	        SIP.Timers.clearTimeout(this.timers.N);
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	        delete this.ua.subscriptions[this.id];
	      }
	      return;
	    }
	
	    switch (sub_state.state) {
	      case 'active':
	        this.state = 'active';
	        setExpiresTimeout();
	        break;
	      case 'pending':
	        if (this.state === 'notify_wait') {
	          setExpiresTimeout();
	        }
	        this.state = 'pending';
	        break;
	      case 'terminated':
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	        if (sub_state.reason) {
	          this.logger.log('terminating subscription with reason '+ sub_state.reason);
	          switch (sub_state.reason) {
	            case 'deactivated':
	            case 'timeout':
	              this.subscribe();
	              return;
	            case 'probation':
	            case 'giveup':
	              if(sub_state.params && sub_state.params['retry-after']) {
	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);
	              } else {
	                this.subscribe();
	              }
	              return;
	            case 'rejected':
	            case 'noresource':
	            case 'invariant':
	              break;
	          }
	        }
	        this.close();
	        break;
	    }
	  },
	
	  failed: function(response, cause) {
	    this.close();
	    this.emit('failed', response, cause);
	    return this;
	  },
	
	  onDialogError: function(response) {
	    this.failed(response, SIP.C.causes.DIALOG_ERROR);
	  },
	
	  /**
	  * @private
	  */
	  matchEvent: function(request) {
	    var event;
	
	    // Check mandatory header Event
	    if (!request.hasHeader('Event')) {
	      this.logger.warn('missing Event header');
	      return false;
	    }
	    // Check mandatory header Subscription-State
	    if (!request.hasHeader('Subscription-State')) {
	      this.logger.warn('missing Subscription-State header');
	      return false;
	    }
	
	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE
	    event = request.parseHeader('event').event;
	
	    if (this.event !== event) {
	      this.logger.warn('event match failed');
	      request.reply(481, 'Event Match Failed');
	      return false;
	    } else {
	      return true;
	    }
	  }
	};
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview WebRTC
	 */
	
	module.exports = function (SIP, environment) {
	var WebRTC;
	
	WebRTC = {};
	
	WebRTC.MediaHandler = __webpack_require__(237)(SIP);
	WebRTC.MediaStreamManager = __webpack_require__(238)(SIP, environment);
	
	var _isSupported;
	
	WebRTC.isSupported = function () {
	  if (_isSupported !== undefined) {
	    return _isSupported;
	  }
	
	  WebRTC.MediaStream = environment.MediaStream;
	  WebRTC.getUserMedia = environment.getUserMedia;
	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;
	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;
	
	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
	    if (WebRTC.getUserMedia) {
	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');
	    }
	    _isSupported = true;
	  }
	  else {
	    _isSupported = false;
	  }
	  return _isSupported;
	};
	
	return WebRTC;
	};


/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]
	 *        The MediaStreamManager to acquire/release streams from/to.
	 *        If not provided, a default MediaStreamManager will be used.
	 */
	module.exports = function (SIP) {
	
	var MediaHandler = function(session, options) {
	  options = options || {};
	
	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);
	  this.session = session;
	  this.localMedia = null;
	  this.ready = true;
	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);
	  this.audioMuted = false;
	  this.videoMuted = false;
	
	  // old init() from here on
	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	  this.RTCConstraints = options.RTCConstraints || {};
	
	  this.initPeerConnection(servers, this.RTCConstraints);
	
	  function selfEmit(mh, event) {
	    if (mh.mediaStreamManager.on) {
	      mh.mediaStreamManager.on(event, function () {
	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));
	      });
	    }
	  }
	
	  selfEmit(this, 'userMediaRequest');
	  selfEmit(this, 'userMedia');
	  selfEmit(this, 'userMediaFailed');
	};
	
	MediaHandler.defaultFactory = function defaultFactory (session, options) {
	  return new MediaHandler(session, options);
	};
	MediaHandler.defaultFactory.isSupported = function () {
	  return SIP.WebRTC.isSupported();
	};
	
	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {
	// Functions the session can use
	  isReady: {writable: true, value: function isReady () {
	    return this.ready;
	  }},
	
	  close: {writable: true, value: function close () {
	    this.logger.log('closing PeerConnection');
	    this._remoteStreams = [];
	    // have to check signalingState since this.close() gets called multiple times
	    // TODO figure out why that happens
	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {
	      this.peerConnection.close();
	
	      if(this.localMedia) {
	        this.mediaStreamManager.release(this.localMedia);
	      }
	    }
	  }},
	
	  /**
	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]
	   *        the MediaStream (or the constraints describing it) to be used for the session
	   */
	  getDescription: {writable: true, value: function getDescription (mediaHint) {
	    var self = this;
	    var acquire = self.mediaStreamManager.acquire;
	    if (acquire.length > 1) {
	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);
	    }
	    mediaHint = mediaHint || {};
	    if (mediaHint.dataChannel === true) {
	      mediaHint.dataChannel = {};
	    }
	    this.mediaHint = mediaHint;
	
	    /*
	     * 1. acquire streams (skip if MediaStreams passed in)
	     * 2. addStreams
	     * 3. createOffer/createAnswer
	     */
	
	    var streamPromise;
	    if (self.localMedia) {
	      self.logger.log('already have local media');
	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);
	    }
	    else {
	      self.logger.log('acquiring local media');
	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)
	        .then(function acquireSucceeded(streams) {
	          self.logger.log('acquired local media streams');
	          self.localMedia = streams;
	          self.session.connecting();
	          return streams;
	        }, function acquireFailed(err) {
	          self.logger.error('unable to acquire streams');
	          self.logger.error(err);
	          self.session.connecting();
	          throw err;
	        })
	        .then(this.addStreams.bind(this))
	      ;
	    }
	
	    return streamPromise
	      .then(function streamAdditionSucceeded() {
	        if (self.hasOffer('remote')) {
	          self.peerConnection.ondatachannel = function (evt) {
	            self.dataChannel = evt.channel;
	            self.emit('dataChannel', self.dataChannel);
	          };
	        } else if (mediaHint.dataChannel &&
	                   self.peerConnection.createDataChannel) {
	          self.dataChannel = self.peerConnection.createDataChannel(
	            'sipjs',
	            mediaHint.dataChannel
	          );
	          self.emit('dataChannel', self.dataChannel);
	        }
	
	        self.render();
	        return self.createOfferOrAnswer(self.RTCConstraints);
	      })
	    ;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} sdp
	  */
	  setDescription: {writable: true, value: function setDescription (sdp) {
	    var rawDescription = {
	      type: this.hasOffer('local') ? 'answer' : 'offer',
	      sdp: sdp
	    };
	
	    this.emit('setDescription', rawDescription);
	
	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);
	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);
	  }},
	
	  /**
	   * If the Session associated with this MediaHandler were to be referred,
	   * what mediaHint should be provided to the UA's invite method?
	   */
	  getReferMedia: {writable: true, value: function getReferMedia () {
	    function hasTracks (trackGetter, stream) {
	      return stream[trackGetter]().length > 0;
	    }
	
	    function bothHaveTracks (trackGetter) {
	      /* jshint validthis:true */
	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&
	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));
	    }
	
	    return {
	      constraints: {
	        audio: bothHaveTracks.call(this, 'getAudioTracks'),
	        video: bothHaveTracks.call(this, 'getVideoTracks')
	      }
	    };
	  }},
	
	  updateIceServers: {writeable:true, value: function (options) {
	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;
	
	    this.initPeerConnection(servers, this.RTCConstraints);
	
	    /* once updateIce is implemented correctly, this is better than above
	    //no op if browser does not support this
	    if (!this.peerConnection.updateIce) {
	      return;
	    }
	
	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);
	    */
	  }},
	
	// Functions the session can use, but only because it's convenient for the application
	  isMuted: {writable: true, value: function isMuted () {
	    return {
	      audio: this.audioMuted,
	      video: this.videoMuted
	    };
	  }},
	
	  mute: {writable: true, value: function mute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioMuted = false,
	        videoMuted = false;
	
	    if (options.audio && !this.audioMuted) {
	      audioMuted = true;
	      this.audioMuted = true;
	      this.toggleMuteAudio(true);
	    }
	
	    if (options.video && !this.videoMuted) {
	      videoMuted = true;
	      this.videoMuted = true;
	      this.toggleMuteVideo(true);
	    }
	
	    //REVISIT
	    if (audioMuted || videoMuted) {
	      return {
	        audio: audioMuted,
	        video: videoMuted
	      };
	      /*this.session.onmute({
	        audio: audioMuted,
	        video: videoMuted
	      });*/
	    }
	  }},
	
	  unmute: {writable: true, value: function unmute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioUnMuted = false,
	        videoUnMuted = false;
	
	    if (options.audio && this.audioMuted) {
	      audioUnMuted = true;
	      this.audioMuted = false;
	      this.toggleMuteAudio(false);
	    }
	
	    if (options.video && this.videoMuted) {
	      videoUnMuted = true;
	      this.videoMuted = false;
	      this.toggleMuteVideo(false);
	    }
	
	    //REVISIT
	    if (audioUnMuted || videoUnMuted) {
	      return {
	        audio: audioUnMuted,
	        video: videoUnMuted
	      };
	      /*this.session.onunmute({
	        audio: audioUnMuted,
	        video: videoUnMuted
	      });*/
	    }
	  }},
	
	  hold: {writable: true, value: function hold () {
	    this.toggleMuteAudio(true);
	    this.toggleMuteVideo(true);
	  }},
	
	  unhold: {writable: true, value: function unhold () {
	    if (!this.audioMuted) {
	      this.toggleMuteAudio(false);
	    }
	
	    if (!this.videoMuted) {
	      this.toggleMuteVideo(false);
	    }
	  }},
	
	// Functions the application can use, but not the session
	  getLocalStreams: {writable: true, value: function getLocalStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');
	      return [];
	    }
	    return (pc.getLocalStreams && pc.getLocalStreams()) ||
	      pc.localStreams || [];
	  }},
	
	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');
	      return this._remoteStreams;
	    }
	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||
	      pc.remoteStreams || [];
	  }},
	
	  render: {writable: true, value: function render (renderHint) {
	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);
	    if (!renderHint) {
	      return false;
	    }
	    var streamGetters = {
	      local: 'getLocalStreams',
	      remote: 'getRemoteStreams'
	    };
	    Object.keys(streamGetters).forEach(function (loc) {
	      var streamGetter = streamGetters[loc];
	      var streams = this[streamGetter]();
	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);
	    }.bind(this));
	  }},
	
	// Internal functions
	  hasOffer: {writable: true, value: function hasOffer (where) {
	    var offerState = 'have-' + where + '-offer';
	    return this.peerConnection.signalingState === offerState;
	    // TODO consider signalingStates with 'pranswer'?
	  }},
	
	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {
	    var servers = [],
	      config = this.session.ua.configuration;
	
	    stunServers = stunServers || config.stunServers;
	    turnServers = turnServers || config.turnServers;
	
	    [].concat(stunServers).forEach(function (server) {
	      servers.push({'urls': server});
	    });
	
	    [].concat(turnServers).forEach(function (server) {
	      servers.push({
	        'urls': server.urls,
	        'username': server.username,
	        'credential': server.password
	      });
	    });
	
	    return servers;
	  }},
	
	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {
	    var self = this,
	      config = this.session.ua.configuration;
	
	    this.onIceCompleted = SIP.Utils.defer();
	    this.onIceCompleted.promise.then(function(pc) {
	      self.emit('iceGatheringComplete', pc);
	      if (self.iceCheckingTimer) {
	        SIP.Timers.clearTimeout(self.iceCheckingTimer);
	        self.iceCheckingTimer = null;
	      }
	    });
	
	    if (this.peerConnection) {
	      this.peerConnection.close();
	    }
	
	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);
	
	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams
	    // even if peerConnection.onaddstream was just called. In order to make
	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually
	    this._remoteStreams = [];
	
	    this.peerConnection.onaddstream = function(e) {
	      self.logger.log('stream added: '+ e.stream.id);
	      self._remoteStreams.push(e.stream);
	      self.render();
	      self.emit('addStream', e);
	    };
	
	    this.peerConnection.onremovestream = function(e) {
	      self.logger.log('stream removed: '+ e.stream.id);
	    };
	
	    this.startIceCheckingTimer = function () {
	      if (!self.iceCheckingTimer) {
	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {
	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');
	          self.onIceCompleted.resolve(this);
	        }.bind(this.peerConnection), config.iceCheckingTimeout);
	      }
	    };
	
	    this.peerConnection.onicecandidate = function(e) {
	      self.emit('iceCandidate', e);
	      if (e.candidate) {
	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
	        self.startIceCheckingTimer();
	      } else {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.onicegatheringstatechange = function () {
	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
	      if (this.iceGatheringState === 'gathering') {
	        self.emit('iceGathering', this);
	      }
	      if (this.iceGatheringState === 'complete') {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case
	      var stateEvent;
	
	      if (this.iceConnectionState === 'checking') {
	        self.startIceCheckingTimer();
	      }
	
	      switch (this.iceConnectionState) {
	      case 'new':
	        stateEvent = 'iceConnection';
	        break;
	      case 'checking':
	        stateEvent = 'iceConnectionChecking';
	        break;
	      case 'connected':
	        stateEvent = 'iceConnectionConnected';
	        break;
	      case 'completed':
	        stateEvent = 'iceConnectionCompleted';
	        break;
	      case 'failed':
	        stateEvent = 'iceConnectionFailed';
	        break;
	      case 'disconnected':
	        stateEvent = 'iceConnectionDisconnected';
	        break;
	      case 'closed':
	        stateEvent = 'iceConnectionClosed';
	        break;
	      default:
	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
	        return;
	      }
	      self.emit(stateEvent, this);
	
	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated
	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated
	      /*if (this.iceConnectionState === 'failed') {
	        self.session.terminate({
	        cause: SIP.C.causes.RTP_TIMEOUT,
	        status_code: 200,
	        reason_phrase: SIP.C.causes.RTP_TIMEOUT
	      });
	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
	      self.onIceCompleted(this);
	      }*/
	    };
	
	    this.peerConnection.onstatechange = function() {
	      self.logger.log('PeerConnection state changed to "'+ this.readyState +'"');
	    };
	  }},
	
	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {
	    var self = this;
	    var methodName;
	    var pc = self.peerConnection;
	
	    self.ready = false;
	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';
	
	    return SIP.Utils.promisify(pc, methodName, true)(constraints)
	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))
	      .then(function onSetLocalDescriptionSuccess() {
	        var deferred = SIP.Utils.defer();
	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
	          deferred.resolve();
	        } else {
	          self.onIceCompleted.promise.then(deferred.resolve);
	        }
	        return deferred.promise;
	      })
	      .then(function readySuccess () {
	        var sdp = pc.localDescription.sdp;
	
	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);
	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);
	
	        var sdpWrapper = {
	          type: methodName === 'createOffer' ? 'offer' : 'answer',
	          sdp: sdp
	        };
	
	        self.emit('getDescription', sdpWrapper);
	
	        self.ready = true;
	        return sdpWrapper.sdp;
	      })
	      .catch(function methodFailed (e) {
	        self.logger.error(e);
	        self.ready = true;
	        throw new SIP.Exceptions.GetDescriptionError(e);
	      })
	    ;
	  }},
	
	  addStreams: {writable: true, value: function addStreams (streams) {
	    try {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        this.peerConnection.addStream(stream);
	      }, this);
	    } catch(e) {
	      this.logger.error('error adding stream');
	      this.logger.error(e);
	      return SIP.Utils.Promise.reject(e);
	    }
	
	    return SIP.Utils.Promise.resolve();
	  }},
	
	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {
	    this.getLocalStreams().forEach(function (stream) {
	      stream[trackGetter]().forEach(function (track) {
	        track.enabled = !mute;
	      });
	    });
	  }},
	
	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {
	    this.toggleMuteHelper('getAudioTracks', mute);
	  }},
	
	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {
	    this.toggleMuteHelper('getVideoTracks', mute);
	  }}
	});
	
	// Return since it will be assigned to a variable.
	return MediaHandler;
	};


/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaStreamManager
	 */
	
	/* MediaStreamManager
	 * @class Manages the acquisition and release of MediaStreams.
	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()
	 */
	module.exports = function (SIP, environment) {
	
	// Default MediaStreamManager provides single-use streams created with getUserMedia
	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {
	  if (!SIP.WebRTC.isSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.mediaHint = defaultMediaHint || {
	    constraints: {audio: true, video: true}
	  };
	
	  // map of streams to acquisition manner:
	  // true -> passed in as mediaHint.stream
	  // false -> getUserMedia
	  this.acquisitions = {};
	};
	MediaStreamManager.streamId = function (stream) {
	  return stream.getAudioTracks().concat(stream.getVideoTracks())
	    .map(function trackId (track) {
	      return track.id;
	    })
	    .join('');
	};
	
	/**
	 * @param {(Array of) MediaStream} streams - The streams to render
	 *
	 * @param {(Array of) HTMLMediaElement} elements
	 *        - The <audio>/<video> element(s) that should render the streams
	 *
	 * Each stream in streams renders to the corresponding element in elements,
	 * wrapping around elements if needed.
	 */
	MediaStreamManager.render = function render (streams, elements) {
	  if (!elements) {
	    return false;
	  }
	  if (Array.isArray(elements) && !elements.length) {
	    throw new TypeError('elements must not be empty');
	  }
	
	  function attachMediaStream(element, stream) {
	    if (typeof element.src !== 'undefined') {
	      environment.revokeObjectURL(element.src);
	      element.src = environment.createObjectURL(stream);
	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {
	      element.srcObject = element.mozSrcObject = stream;
	    } else {
	      return false;
	    }
	
	    return true;
	  }
	
	  function ensureMediaPlaying (mediaElement) {
	    var interval = 100;
	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {
	      if (mediaElement.paused) {
	        mediaElement.play();
	      }
	      else {
	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);
	      }
	    }, interval);
	  }
	
	  function attachAndPlay (elements, stream, index) {
	    if (typeof elements === 'function') {
	      elements = elements();
	    }
	    var element = elements[index % elements.length];
	    (environment.attachMediaStream || attachMediaStream)(element, stream);
	    ensureMediaPlaying(element);
	  }
	
	  // [].concat "casts" `elements` into an array
	  // so forEach works even if `elements` was a single element
	  elements = [].concat(elements);
	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));
	};
	
	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {
	  'acquire': {writable: true, value: function acquire (mediaHint) {
	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;
	
	    var saveSuccess = function (isHintStream, streams) {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        var streamId = MediaStreamManager.streamId(stream);
	        this.acquisitions[streamId] = !!isHintStream;
	      }, this);
	      return SIP.Utils.Promise.resolve(streams);
	    }.bind(this);
	
	    if (mediaHint.stream) {
	      return saveSuccess(true, mediaHint.stream);
	    } else {
	      // Fallback to audio/video enabled if no mediaHint can be found.
	      var constraints = mediaHint.constraints ||
	        (this.mediaHint && this.mediaHint.constraints) ||
	        {audio: true, video: true};
	
	      var deferred = SIP.Utils.defer();
	
	      /*
	       * Make the call asynchronous, so that ICCs have a chance
	       * to define callbacks to `userMediaRequest`
	       */
	      SIP.Timers.setTimeout(function () {
	        this.emit('userMediaRequest', constraints);
	
	        var emitThenCall = function (eventName, callback) {
	          var callbackArgs = Array.prototype.slice.call(arguments, 2);
	          // Emit with all of the arguments from the real callback.
	          var newArgs = [eventName].concat(callbackArgs);
	
	          this.emit.apply(this, newArgs);
	
	          return callback.apply(null, callbackArgs);
	        }.bind(this);
	
	        if (constraints.audio || constraints.video) {
	          deferred.resolve(
	            SIP.WebRTC.getUserMedia(constraints)
	            .then(
	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),
	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})
	            )
	          );
	        } else {
	          // Local streams were explicitly excluded.
	          deferred.resolve([]);
	        }
	      }.bind(this), 0);
	
	      return deferred.promise;
	    }
	  }},
	
	  'release': {writable: true, value: function release (streams) {
	    streams = [].concat(streams);
	    streams.forEach(function (stream) {
	      var streamId = MediaStreamManager.streamId(stream);
	      if (this.acquisitions[streamId] === false) {
	        stream.getTracks().forEach(function (track) {
	          track.stop();
	        });
	      }
	      delete this.acquisitions[streamId];
	    }, this);
	  }},
	});
	
	// Return since it will be assigned to a variable.
	return MediaStreamManager;
	};


/***/ },
/* 239 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * @augments SIP
	 * @class Class creating a SIP User Agent.
	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]
	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.
	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.
	 *
	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 */
	module.exports = function (SIP, environment) {
	var UA,
	  C = {
	    // UA status codes
	    STATUS_INIT:                0,
	    STATUS_STARTING:            1,
	    STATUS_READY:               2,
	    STATUS_USER_CLOSED:         3,
	    STATUS_NOT_READY:           4,
	
	    // UA error codes
	    CONFIGURATION_ERROR:  1,
	    NETWORK_ERROR:        2,
	
	    ALLOWED_METHODS: [
	      'ACK',
	      'CANCEL',
	      'INVITE',
	      'MESSAGE',
	      'BYE',
	      'OPTIONS',
	      'INFO',
	      'NOTIFY',
	      'REFER'
	    ],
	
	    ACCEPTED_BODY_TYPES: [
	      'application/sdp',
	      'application/dtmf-relay'
	    ],
	
	    MAX_FORWARDS: 70,
	    TAG_LENGTH: 10
	  };
	
	UA = function(configuration) {
	  var self = this;
	
	  // Helper function for forwarding events
	  function selfEmit(type) {
	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments
	    return self.emit.bind(self, type);
	  }
	
	  // Set Accepted Body Types
	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();
	
	  this.log = new SIP.LoggerFactory();
	  this.logger = this.getLogger('sip.ua');
	
	  this.cache = {
	    credentials: {}
	  };
	
	  this.configuration = {};
	  this.dialogs = {};
	
	  //User actions outside any session/dialog (MESSAGE)
	  this.applicants = {};
	
	  this.data = {};
	  this.sessions = {};
	  this.subscriptions = {};
	  this.transport = null;
	  this.contact = null;
	  this.status = C.STATUS_INIT;
	  this.error = null;
	  this.transactions = {
	    nist: {},
	    nict: {},
	    ist: {},
	    ict: {}
	  };
	
	  this.transportRecoverAttempts = 0;
	  this.transportRecoveryTimer = null;
	
	  Object.defineProperties(this, {
	    transactionsCount: {
	      get: function() {
	        var type,
	          transactions = ['nist','nict','ist','ict'],
	          count = 0;
	
	        for (type in transactions) {
	          count += Object.keys(this.transactions[transactions[type]]).length;
	        }
	
	        return count;
	      }
	    },
	
	    nictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nict']).length;
	      }
	    },
	
	    nistTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nist']).length;
	      }
	    },
	
	    ictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ict']).length;
	      }
	    },
	
	    istTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ist']).length;
	      }
	    }
	  });
	
	  /**
	   * Load configuration
	   *
	   * @throws {SIP.Exceptions.ConfigurationError}
	   * @throws {TypeError}
	   */
	
	  if(configuration === undefined) {
	    configuration = {};
	  } else if (typeof configuration === 'string' || configuration instanceof String) {
	    configuration = {
	      uri: configuration
	    };
	  }
	
	  // Apply log configuration if present
	  if (configuration.log) {
	    if (configuration.log.hasOwnProperty('builtinEnabled')) {
	      this.log.builtinEnabled = configuration.log.builtinEnabled;
	    }
	
	    if (configuration.log.hasOwnProperty('level')) {
	      this.log.level = configuration.log.level;
	    }
	
	    if (configuration.log.hasOwnProperty('connector')) {
	      this.log.connector = configuration.log.connector;
	    }
	  }
	
	  try {
	    this.loadConfig(configuration);
	  } catch(e) {
	    this.status = C.STATUS_NOT_READY;
	    this.error = C.CONFIGURATION_ERROR;
	    throw e;
	  }
	
	  // Initialize registerContext
	  this.registerContext = new SIP.RegisterContext(this);
	  this.registerContext.on('failed', selfEmit('registrationFailed'));
	  this.registerContext.on('registered', selfEmit('registered'));
	  this.registerContext.on('unregistered', selfEmit('unregistered'));
	
	  if(this.configuration.autostart) {
	    this.start();
	  }
	
	  if (typeof environment.addEventListener === 'function') {
	    // Google Chrome Packaged Apps don't allow 'unload' listeners:
	    // unload is not available in packaged apps
	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {
	      environment.addEventListener('unload', this.stop.bind(this));
	    }
	  }
	};
	UA.prototype = Object.create(SIP.EventEmitter.prototype);
	
	//=================
	//  High Level API
	//=================
	
	UA.prototype.register = function(options) {
	  this.configuration.register = true;
	  this.registerContext.register(options);
	
	  return this;
	};
	
	/**
	 * Unregister.
	 *
	 * @param {Boolean} [all] unregister all user bindings.
	 *
	 */
	UA.prototype.unregister = function(options) {
	  this.configuration.register = false;
	
	  var context = this.registerContext;
	  this.afterConnected(context.unregister.bind(context, options));
	
	  return this;
	};
	
	UA.prototype.isRegistered = function() {
	  return this.registerContext.registered;
	};
	
	/**
	 * Connection state.
	 * @param {Boolean}
	 */
	UA.prototype.isConnected = function() {
	  return this.transport ? this.transport.connected : false;
	};
	
	UA.prototype.afterConnected = function afterConnected (callback) {
	  if (this.isConnected()) {
	    callback();
	  } else {
	    this.once('connected', callback);
	  }
	};
	
	/**
	 * Make an outgoing call.
	 *
	 * @param {String} target
	 * @param {Object} views
	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.invite = function(target, options) {
	  var context = new SIP.InviteClientContext(this, target, options);
	
	  this.afterConnected(context.invite.bind(context));
	  return context;
	};
	
	UA.prototype.subscribe = function(target, event, options) {
	  var sub = new SIP.Subscription(this, target, event, options);
	
	  this.afterConnected(sub.subscribe.bind(sub));
	  return sub;
	};
	
	/**
	 * Send a message.
	 *
	 * @param {String} target
	 * @param {String} body
	 * @param {Object} [options]
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.message = function(target, body, options) {
	  if (body === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  // There is no Message module, so it is okay that the UA handles defaults here.
	  options = Object.create(options || Object.prototype);
	  options.contentType || (options.contentType = 'text/plain');
	  options.body = body;
	
	  return this.request(SIP.C.MESSAGE, target, options);
	};
	
	UA.prototype.request = function (method, target, options) {
	  var req = new SIP.ClientContext(this, method, target, options);
	
	  this.afterConnected(req.send.bind(req));
	  return req;
	};
	
	/**
	 * Gracefully close.
	 *
	 */
	UA.prototype.stop = function() {
	  var session, subscription, applicant,
	    ua = this;
	
	  function transactionsListener() {
	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {
	        ua.removeListener('transactionDestroyed', transactionsListener);
	        ua.transport.disconnect();
	    }
	  }
	
	  this.logger.log('user requested closure...');
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.warn('UA already closed');
	    return this;
	  }
	
	  // Clear transportRecoveryTimer
	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);
	
	  // Close registerContext
	  this.logger.log('closing registerContext');
	  this.registerContext.close();
	
	  // Run  _terminate_ on every Session
	  for(session in this.sessions) {
	    this.logger.log('closing session ' + session);
	    this.sessions[session].terminate();
	  }
	
	  //Run _close_ on every Subscription
	  for(subscription in this.subscriptions) {
	    this.logger.log('unsubscribing from subscription ' + subscription);
	    this.subscriptions[subscription].close();
	  }
	
	  // Run  _close_ on every applicant
	  for(applicant in this.applicants) {
	    this.applicants[applicant].close();
	  }
	
	  this.status = C.STATUS_USER_CLOSED;
	
	  /*
	   * If the remaining transactions are all INVITE transactions, there is no need to
	   * wait anymore because every session has already been closed by this method.
	   * - locally originated sessions where terminated (CANCEL or BYE)
	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)
	   * Remaining INVITE transactions belong tho sessions that where answered. This are in
	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
	   */
	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {
	    this.transport.disconnect();
	  } else {
	    this.on('transactionDestroyed', transactionsListener);
	  }
	
	  return this;
	};
	
	/**
	 * Connect to the WS server if status = STATUS_INIT.
	 * Resume UA after being closed.
	 *
	 */
	UA.prototype.start = function() {
	  var server;
	
	  this.logger.log('user requested startup...');
	  if (this.status === C.STATUS_INIT) {
	    server = this.getNextWsServer();
	    this.status = C.STATUS_STARTING;
	    new SIP.Transport(this, server);
	  } else if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.log('resuming');
	    this.status = C.STATUS_READY;
	    this.transport.connect();
	  } else if (this.status === C.STATUS_STARTING) {
	    this.logger.log('UA is in STARTING status, not opening new connection');
	  } else if (this.status === C.STATUS_READY) {
	    this.logger.log('UA is in READY status, not resuming');
	  } else {
	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
	  }
	
	  return this;
	};
	
	/**
	 * Normalize a string into a valid SIP request URI
	 *
	 * @param {String} target
	 *
	 * @returns {SIP.URI|undefined}
	 */
	UA.prototype.normalizeTarget = function(target) {
	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);
	};
	
	
	//===============================
	//  Private (For internal use)
	//===============================
	
	UA.prototype.saveCredentials = function(credentials) {
	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
	
	  return this;
	};
	
	UA.prototype.getCredentials = function(request) {
	  var realm, credentials;
	
	  realm = request.ruri.host;
	
	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
	    credentials = this.cache.credentials[realm][request.ruri];
	    credentials.method = request.method;
	  }
	
	  return credentials;
	};
	
	UA.prototype.getLogger = function(category, label) {
	  return this.log.getLogger(category, label);
	};
	
	
	//==============================
	// Event Handlers
	//==============================
	
	/**
	 * Transport Close event
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportClosed = function(transport) {
	  // Run _onTransportError_ callback on every client transaction using _transport_
	  var type, idx, length,
	    client_transactions = ['nict', 'ict', 'nist', 'ist'];
	
	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);
	
	  length = client_transactions.length;
	  for (type = 0; type < length; type++) {
	    for(idx in this.transactions[client_transactions[type]]) {
	      this.transactions[client_transactions[type]][idx].onTransportError();
	    }
	  }
	
	  // Close sessions if GRUU is not being used
	  if (!this.contact.pub_gruu) {
	    this.closeSessionsOnTransportError();
	  }
	
	};
	
	/**
	 * Unrecoverable transport event.
	 * Connection reattempt logic has been done and didn't success.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportError = function(transport) {
	  var server;
	
	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);
	
	  // Close sessions.
	  //Mark this transport as 'down'
	  transport.server.status = SIP.Transport.C.STATUS_ERROR;
	
	  this.emit('disconnected', {
	    transport: transport
	  });
	
	  // try the next transport if the UA isn't closed
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  server = this.getNextWsServer();
	
	  if(server) {
	    new SIP.Transport(this, server);
	  }else {
	    this.closeSessionsOnTransportError();
	    if (!this.error || this.error !== C.NETWORK_ERROR) {
	      this.status = C.STATUS_NOT_READY;
	      this.error = C.NETWORK_ERROR;
	    }
	    // Transport Recovery process
	    this.recoverTransport();
	  }
	};
	
	/**
	 * Transport connection event.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportConnected = function(transport) {
	  this.transport = transport;
	
	  // Reset transport recovery counter
	  this.transportRecoverAttempts = 0;
	
	  transport.server.status = SIP.Transport.C.STATUS_READY;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  this.status = C.STATUS_READY;
	  this.error = null;
	
	  if(this.configuration.register) {
	    this.configuration.authenticationFactory.initialize().then(function () {
	      this.registerContext.onTransportConnected();
	    }.bind(this));
	  }
	
	  this.emit('connected', {
	    transport: transport
	  });
	};
	
	
	/**
	 * Transport connecting event
	 * @private
	 * @param {SIP.Transport} transport.
	 * #param {Integer} attempts.
	 */
	  UA.prototype.onTransportConnecting = function(transport, attempts) {
	    this.emit('connecting', {
	      transport: transport,
	      attempts: attempts
	    });
	  };
	
	
	/**
	 * new Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.newTransaction = function(transaction) {
	  this.transactions[transaction.type][transaction.id] = transaction;
	  this.emit('newTransaction', {transaction: transaction});
	};
	
	
	/**
	 * destroy Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.destroyTransaction = function(transaction) {
	  delete this.transactions[transaction.type][transaction.id];
	  this.emit('transactionDestroyed', {
	    transaction: transaction
	  });
	};
	
	
	//=========================
	// receiveRequest
	//=========================
	
	/**
	 * Request reception
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 */
	UA.prototype.receiveRequest = function(request) {
	  var dialog, session, message,
	    method = request.method,
	    transaction,
	    replaces,
	    replacedDialog,
	    self = this;
	
	  function ruriMatches (uri) {
	    return uri && uri.user === request.ruri.user;
	  }
	
	  // Check that request URI points to us
	  if(!(ruriMatches(this.configuration.uri) ||
	       ruriMatches(this.contact.uri) ||
	       ruriMatches(this.contact.pub_gruu) ||
	       ruriMatches(this.contact.temp_gruu))) {
	    this.logger.warn('Request-URI does not point to us');
	    if (request.method !== SIP.C.ACK) {
	      request.reply_sl(404);
	    }
	    return;
	  }
	
	  // Check request URI scheme
	  if(request.ruri.scheme === SIP.C.SIPS) {
	    request.reply_sl(416);
	    return;
	  }
	
	  // Check transaction
	  if(SIP.Transactions.checkTransaction(this, request)) {
	    return;
	  }
	
	  /* RFC3261 12.2.2
	   * Requests that do not change in any way the state of a dialog may be
	   * received within a dialog (for example, an OPTIONS request).
	   * They are processed as if they had been received outside the dialog.
	   */
	  if(method === SIP.C.OPTIONS) {
	    new SIP.Transactions.NonInviteServerTransaction(request, this);
	    request.reply(200, null, [
	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),
	      'Accept: '+ C.ACCEPTED_BODY_TYPES
	    ]);
	  } else if (method === SIP.C.MESSAGE) {
	    message = new SIP.ServerContext(this, request);
	    message.body = request.body;
	    message.content_type = request.getHeader('Content-Type') || 'text/plain';
	
	    request.reply(200, null);
	    this.emit('message', message);
	  } else if (method !== SIP.C.INVITE &&
	             method !== SIP.C.ACK) {
	    // Let those methods pass through to normal processing for now.
	    transaction = new SIP.ServerContext(this, request);
	  }
	
	  // Initial Request
	  if(!request.to_tag) {
	    switch(method) {
	      case SIP.C.INVITE:
	        replaces =
	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&
	          request.parseHeader('replaces');
	
	        if (replaces) {
	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
	
	          if (!replacedDialog) {
	            //Replaced header without a matching dialog, reject
	            request.reply_sl(481, null);
	            return;
	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {
	            request.reply_sl(603, null);
	            return;
	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {
	            request.reply_sl(486, null);
	            return;
	          }
	        }
	
	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;
	        if(!isMediaSupported || isMediaSupported()) {
	          session = new SIP.InviteServerContext(this, request);
	          session.replacee = replacedDialog && replacedDialog.owner;
	          session.on('invite', function() {
	            self.emit('invite', this);
	          });
	        } else {
	          this.logger.warn('INVITE received but WebRTC is not supported');
	          request.reply(488);
	        }
	        break;
	      case SIP.C.BYE:
	        // Out of dialog BYE received
	        request.reply(481);
	        break;
	      case SIP.C.CANCEL:
	        session = this.findSession(request);
	        if(session) {
	          session.receiveRequest(request);
	        } else {
	          this.logger.warn('received CANCEL request for a non existent session');
	        }
	        break;
	      case SIP.C.ACK:
	        /* Absorb it.
	         * ACK request without a corresponding Invite Transaction
	         * and without To tag.
	         */
	        break;
	      default:
	        request.reply(405);
	        break;
	    }
	  }
	  // In-dialog request
	  else {
	    dialog = this.findDialog(request);
	
	    if(dialog) {
	      if (method === SIP.C.INVITE) {
	        new SIP.Transactions.InviteServerTransaction(request, this);
	      }
	      dialog.receiveRequest(request);
	    } else if (method === SIP.C.NOTIFY) {
	      session = this.findSession(request);
	      if(session) {
	        session.receiveRequest(request);
	      } else {
	        this.logger.warn('received NOTIFY request for a non existent session');
	        request.reply(481, 'Subscription does not exist');
	      }
	    }
	    /* RFC3261 12.2.2
	     * Request with to tag, but no matching dialog found.
	     * Exception: ACK for an Invite request for which a dialog has not
	     * been created.
	     */
	    else {
	      if(method !== SIP.C.ACK) {
	        request.reply(481);
	      }
	    }
	  }
	};
	
	//=================
	// Utils
	//=================
	
	/**
	 * Get the session to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}
	 */
	UA.prototype.findSession = function(request) {
	  return this.sessions[request.call_id + request.from_tag] ||
	          this.sessions[request.call_id + request.to_tag] ||
	          null;
	};
	
	/**
	 * Get the dialog to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest}
	 * @returns {SIP.Dialog|null}
	 */
	UA.prototype.findDialog = function(request) {
	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||
	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||
	          null;
	};
	
	/**
	 * Retrieve the next server to which connect.
	 * @private
	 * @returns {Object} ws_server
	 */
	UA.prototype.getNextWsServer = function() {
	  // Order servers by weight
	  var idx, length, ws_server,
	    candidates = [];
	
	  length = this.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ws_server = this.configuration.wsServers[idx];
	
	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {
	      continue;
	    } else if (candidates.length === 0) {
	      candidates.push(ws_server);
	    } else if (ws_server.weight > candidates[0].weight) {
	      candidates = [ws_server];
	    } else if (ws_server.weight === candidates[0].weight) {
	      candidates.push(ws_server);
	    }
	  }
	
	  idx = Math.floor(Math.random() * candidates.length);
	
	  return candidates[idx];
	};
	
	/**
	 * Close all sessions on transport error.
	 * @private
	 */
	UA.prototype.closeSessionsOnTransportError = function() {
	  var idx;
	
	  // Run _transportError_ for every Session
	  for(idx in this.sessions) {
	    this.sessions[idx].onTransportError();
	  }
	  // Call registerContext _onTransportClosed_
	  this.registerContext.onTransportClosed();
	};
	
	UA.prototype.recoverTransport = function(ua) {
	  var idx, length, k, nextRetry, count, server;
	
	  ua = ua || this;
	  count = ua.transportRecoverAttempts;
	
	  length = ua.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ua.configuration.wsServers[idx].status = 0;
	  }
	
	  server = ua.getNextWsServer();
	
	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;
	
	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {
	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');
	    nextRetry = ua.configuration.connectionRecoveryMinInterval;
	    count = 0;
	  }
	
	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');
	
	  this.transportRecoveryTimer = SIP.Timers.setTimeout(
	    function(){
	      ua.transportRecoverAttempts = count + 1;
	      new SIP.Transport(ua, server);
	    }, nextRetry * 1000);
	};
	
	function checkAuthenticationFactory (authenticationFactory) {
	  if (!(authenticationFactory instanceof Function)) {
	    return;
	  }
	  if (!authenticationFactory.initialize) {
	    authenticationFactory.initialize = function initialize () {
	      return SIP.Utils.Promise.resolve();
	    };
	  }
	  return authenticationFactory;
	}
	
	/**
	 * Configuration load.
	 * @private
	 * returns {Boolean}
	 */
	UA.prototype.loadConfig = function(configuration) {
	  // Settings and default values
	  var parameter, value, checked_value, hostportParams, registrarServer,
	    settings = {
	      /* Host address
	      * Value to be set in Via sent_by and host part of Contact FQDN
	      */
	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',
	
	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),
	      wsServers: [{
	        scheme: 'WSS',
	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',
	        status: 0,
	        weight: 0,
	        ws_uri: 'wss://edge.sip.onsip.com'
	      }],
	
	      // Password
	      password: null,
	
	      // Registration parameters
	      registerExpires: 600,
	      register: true,
	      registrarServer: null,
	
	      // Transport related parameters
	      wsServerMaxReconnection: 3,
	      wsServerReconnectionTimeout: 4,
	
	      connectionRecoveryMinInterval: 2,
	      connectionRecoveryMaxInterval: 30,
	
	      keepAliveInterval: 0,
	
	      extraSupported: [],
	
	      usePreloadedRoute: false,
	
	      //string to be inserted into User-Agent request header
	      userAgentString: SIP.C.USER_AGENT,
	
	      // Session parameters
	      iceCheckingTimeout: 5000,
	      noAnswerTimeout: 60,
	      stunServers: ['stun:stun.l.google.com:19302'],
	      turnServers: [],
	
	      // Logging parameters
	      traceSip: false,
	
	      // Hacks
	      hackViaTcp: false,
	      hackIpInContact: false,
	      hackWssInTransport: false,
	      hackAllowUnregisteredOptionTags: false,
	
	      contactTransport: 'ws',
	      forceRport: false,
	
	      //autostarting
	      autostart: true,
	
	      //Reliable Provisional Responses
	      rel100: SIP.C.supported.UNSUPPORTED,
	
	      // Replaces header (RFC 3891)
	      // http://tools.ietf.org/html/rfc3891
	      replaces: SIP.C.supported.UNSUPPORTED,
	
	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,
	
	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {
	        return new SIP.DigestAuthentication(ua);
	      })
	    };
	
	  // Pre-Configuration
	  function aliasUnderscored (parameter, logger) {
	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {
	      return m[0] + '_' + m[1].toLowerCase();
	    });
	
	    if (parameter === underscored) {
	      return;
	    }
	
	    var hasParameter = configuration.hasOwnProperty(parameter);
	    if (configuration.hasOwnProperty(underscored)) {
	      logger.warn(underscored + ' is deprecated, please use ' + parameter);
	      if (hasParameter) {
	        logger.warn(parameter + ' overriding ' + underscored);
	      }
	    }
	
	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];
	  }
	
	  // Check Mandatory parameters
	  for(parameter in UA.configuration_check.mandatory) {
	    aliasUnderscored(parameter, this.logger);
	    if(!configuration.hasOwnProperty(parameter)) {
	      throw new SIP.Exceptions.ConfigurationError(parameter);
	    } else {
	      value = configuration[parameter];
	      checked_value = UA.configuration_check.mandatory[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);
	
	  var emptyArraysAllowed = ['stunServers', 'turnServers'];
	
	  // Check Optional parameters
	  for(parameter in UA.configuration_check.optional) {
	    aliasUnderscored(parameter, this.logger);
	    if(configuration.hasOwnProperty(parameter)) {
	      value = configuration[parameter];
	
	      // If the parameter value is an empty array, but shouldn't be, apply its default value.
	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }
	
	      // If the parameter value is null, empty string, or undefined then apply its default value.
	      if(value === null || value === "" || value === undefined) { continue; }
	      // If it's a number with NaN value then also apply its default value.
	      // NOTE: JS does not allow "value === NaN", the following does the work:
	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }
	
	      checked_value = UA.configuration_check.optional[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  // Sanity Checks
	
	  // Connection recovery intervals
	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {
	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);
	  }
	
	  // Post Configuration Process
	
	  // Allow passing 0 number as displayName.
	  if (settings.displayName === 0) {
	    settings.displayName = '0';
	  }
	
	  // Instance-id for GRUU
	  if (!settings.instanceId) {
	    settings.instanceId = SIP.Utils.newUUID();
	  }
	
	  // sipjsId instance parameter. Static random tag of length 5
	  settings.sipjsId = SIP.Utils.createRandomToken(5);
	
	  // String containing settings.uri without scheme and user.
	  hostportParams = settings.uri.clone();
	  hostportParams.user = null;
	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');
	
	  /* Check whether authorizationUser is explicitly defined.
	   * Take 'settings.uri.user' value if not.
	   */
	  if (!settings.authorizationUser) {
	    settings.authorizationUser = settings.uri.user;
	  }
	
	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */
	  if (!settings.registrarServer) {
	    registrarServer = settings.uri.clone();
	    registrarServer.user = null;
	    settings.registrarServer = registrarServer;
	  }
	
	  // User noAnswerTimeout
	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
	
	  // Via Host
	  if (settings.hackIpInContact) {
	    if (typeof settings.hackIpInContact === 'boolean') {
	      settings.viaHost = SIP.Utils.getRandomTestNetIP();
	    }
	    else if (typeof settings.hackIpInContact === 'string') {
	      settings.viaHost = settings.hackIpInContact;
	    }
	  }
	
	  // Contact transport parameter
	  if (settings.hackWssInTransport) {
	    settings.contactTransport = 'wss';
	  }
	
	  this.contact = {
	    pub_gruu: null,
	    temp_gruu: null,
	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),
	    toString: function(options){
	      options = options || {};
	
	      var
	        anonymous = options.anonymous || null,
	        outbound = options.outbound || null,
	        contact = '<';
	
	      if (anonymous) {
	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();
	      } else {
	        contact += (this.pub_gruu || this.uri).toString();
	      }
	
	      if (outbound) {
	        contact += ';ob';
	      }
	
	      contact += '>';
	
	      return contact;
	    }
	  };
	
	  // media overrides mediaConstraints
	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);
	
	  // Fill the value of the configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = settings[parameter];
	  }
	
	  Object.defineProperties(this.configuration, UA.configuration_skeleton);
	
	  // Clean UA.configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = '';
	  }
	
	  this.logger.log('configuration parameters after validation:');
	  for(parameter in settings) {
	    switch(parameter) {
	      case 'uri':
	      case 'registrarServer':
	      case 'mediaHandlerFactory':
	        this.logger.log(' ' + parameter + ': ' + settings[parameter]);
	        break;
	      case 'password':
	        this.logger.log(' ' + parameter + ': ' + 'NOT SHOWN');
	        break;
	      default:
	        this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));
	    }
	  }
	
	  return;
	};
	
	/**
	 * Configuration Object skeleton.
	 * @private
	 */
	UA.configuration_skeleton = (function() {
	  var idx,  parameter,
	    skeleton = {},
	    parameters = [
	      // Internal parameters
	      "sipjsId",
	      "hostportParams",
	
	      // Optional user configurable parameters
	      "uri",
	      "wsServers",
	      "authorizationUser",
	      "connectionRecoveryMaxInterval",
	      "connectionRecoveryMinInterval",
	      "keepAliveInterval",
	      "extraSupported",
	      "displayName",
	      "hackViaTcp", // false.
	      "hackIpInContact", //false
	      "hackWssInTransport", //false
	      "hackAllowUnregisteredOptionTags", //false
	      "contactTransport", // 'ws'
	      "forceRport", // false
	      "iceCheckingTimeout",
	      "instanceId",
	      "noAnswerTimeout", // 30 seconds.
	      "password",
	      "registerExpires", // 600 seconds.
	      "registrarServer",
	      "reliable",
	      "rel100",
	      "replaces",
	      "userAgentString", //SIP.C.USER_AGENT
	      "autostart",
	      "stunServers",
	      "traceSip",
	      "turnServers",
	      "usePreloadedRoute",
	      "wsServerMaxReconnection",
	      "wsServerReconnectionTimeout",
	      "mediaHandlerFactory",
	      "media",
	      "mediaConstraints",
	      "authenticationFactory",
	
	      // Post-configuration generated parameters
	      "via_core_value",
	      "viaHost"
	    ];
	
	  for(idx in parameters) {
	    parameter = parameters[idx];
	    skeleton[parameter] = {
	      value: '',
	      writable: false,
	      configurable: false
	    };
	  }
	
	  skeleton['register'] = {
	    value: '',
	    writable: true,
	    configurable: false
	  };
	
	  return skeleton;
	}());
	
	/**
	 * Configuration checker.
	 * @private
	 * @return {Boolean}
	 */
	UA.configuration_check = {
	  mandatory: {
	  },
	
	  optional: {
	
	    uri: function(uri) {
	      var parsed;
	
	      if (!(/^sip:/i).test(uri)) {
	        uri = SIP.C.SIP + ':' + uri;
	      }
	      parsed = SIP.URI.parse(uri);
	
	      if(!parsed) {
	        return;
	      } else if(!parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
	    wsServers: function(wsServers) {
	      var idx, length, url;
	
	      /* Allow defining wsServers parameter as:
	       *  String: "host"
	       *  Array of Strings: ["host1", "host2"]
	       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
	       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
	       */
	      if (typeof wsServers === 'string') {
	        wsServers = [{ws_uri: wsServers}];
	      } else if (wsServers instanceof Array) {
	        length = wsServers.length;
	        for (idx = 0; idx < length; idx++) {
	          if (typeof wsServers[idx] === 'string'){
	            wsServers[idx] = {ws_uri: wsServers[idx]};
	          }
	        }
	      } else {
	        return;
	      }
	
	      if (wsServers.length === 0) {
	        return false;
	      }
	
	      length = wsServers.length;
	      for (idx = 0; idx < length; idx++) {
	        if (!wsServers[idx].ws_uri) {
	          return;
	        }
	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {
	          return;
	        }
	
	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');
	
	        if(url === -1) {
	          return;
	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {
	          return;
	        } else {
	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';
	
	          if (!wsServers[idx].weight) {
	            wsServers[idx].weight = 0;
	          }
	
	          wsServers[idx].status = 0;
	          wsServers[idx].scheme = url.scheme.toUpperCase();
	        }
	      }
	      return wsServers;
	    },
	
	    authorizationUser: function(authorizationUser) {
	      if(SIP.Grammar.parse('"'+ authorizationUser +'"', 'quoted_string') === -1) {
	        return;
	      } else {
	        return authorizationUser;
	      }
	    },
	
	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {
	        value = Number(connectionRecoveryMaxInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {
	        value = Number(connectionRecoveryMinInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    displayName: function(displayName) {
	      if(SIP.Grammar.parse('"' + displayName + '"', 'displayName') === -1) {
	        return;
	      } else {
	        return displayName;
	      }
	    },
	
	    hackViaTcp: function(hackViaTcp) {
	      if (typeof hackViaTcp === 'boolean') {
	        return hackViaTcp;
	      }
	    },
	
	    hackIpInContact: function(hackIpInContact) {
	      if (typeof hackIpInContact === 'boolean') {
	        return hackIpInContact;
	      }
	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {
	        return hackIpInContact;
	      }
	    },
	
	    iceCheckingTimeout: function(iceCheckingTimeout) {
	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {
	        return Math.max(500, iceCheckingTimeout);
	      }
	    },
	
	    hackWssInTransport: function(hackWssInTransport) {
	      if (typeof hackWssInTransport === 'boolean') {
	        return hackWssInTransport;
	      }
	    },
	
	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {
	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {
	        return hackAllowUnregisteredOptionTags;
	      }
	    },
	
	    contactTransport: function(contactTransport) {
	      if (typeof contactTransport === 'string') {
	        return contactTransport;
	      }
	    },
	
	    forceRport: function(forceRport) {
	      if (typeof forceRport === 'boolean') {
	        return forceRport;
	      }
	    },
	
	    instanceId: function(instanceId) {
	      if(typeof instanceId !== 'string') {
	        return;
	      }
	
	      if ((/^uuid:/i.test(instanceId))) {
	        instanceId = instanceId.substr(5);
	      }
	
	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {
	        return;
	      } else {
	        return instanceId;
	      }
	    },
	
	    keepAliveInterval: function(keepAliveInterval) {
	      var value;
	      if (SIP.Utils.isDecimal(keepAliveInterval)) {
	        value = Number(keepAliveInterval);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    extraSupported: function(optionTags) {
	      var idx, length;
	
	      if (!(optionTags instanceof Array)) {
	        return;
	      }
	
	      length = optionTags.length;
	      for (idx = 0; idx < length; idx++) {
	        if (typeof optionTags[idx] !== 'string') {
	          return;
	        }
	      }
	
	      return optionTags;
	    },
	
	    noAnswerTimeout: function(noAnswerTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {
	        value = Number(noAnswerTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    password: function(password) {
	      return String(password);
	    },
	
	    rel100: function(rel100) {
	      if(rel100 === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (rel100 === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    replaces: function(replaces) {
	      if(replaces === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (replaces === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    register: function(register) {
	      if (typeof register === 'boolean') {
	        return register;
	      }
	    },
	
	    registerExpires: function(registerExpires) {
	      var value;
	      if (SIP.Utils.isDecimal(registerExpires)) {
	        value = Number(registerExpires);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    registrarServer: function(registrarServer) {
	      var parsed;
	
	      if(typeof registrarServer !== 'string') {
	        return;
	      }
	
	      if (!/^sip:/i.test(registrarServer)) {
	        registrarServer = SIP.C.SIP + ':' + registrarServer;
	      }
	      parsed = SIP.URI.parse(registrarServer);
	
	      if(!parsed) {
	        return;
	      } else if(parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    stunServers: function(stunServers) {
	      var idx, length, stun_server;
	
	      if (typeof stunServers === 'string') {
	        stunServers = [stunServers];
	      } else if (!(stunServers instanceof Array)) {
	        return;
	      }
	
	      length = stunServers.length;
	      for (idx = 0; idx < length; idx++) {
	        stun_server = stunServers[idx];
	        if (!(/^stuns?:/.test(stun_server))) {
	          stun_server = 'stun:' + stun_server;
	        }
	
	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
	          return;
	        } else {
	          stunServers[idx] = stun_server;
	        }
	      }
	      return stunServers;
	    },
	
	    traceSip: function(traceSip) {
	      if (typeof traceSip === 'boolean') {
	        return traceSip;
	      }
	    },
	
	    turnServers: function(turnServers) {
	      var idx, jdx, length, turn_server, num_turn_server_urls, url;
	
	      if (turnServers instanceof Array) {
	        // Do nothing
	      } else {
	        turnServers = [turnServers];
	      }
	
	      length = turnServers.length;
	      for (idx = 0; idx < length; idx++) {
	        turn_server = turnServers[idx];
	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.
	        if (turn_server.server) {
	          turn_server.urls = [turn_server.server];
	        }
	
	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {
	          return;
	        }
	
	        if (turn_server.urls instanceof Array) {
	          num_turn_server_urls = turn_server.urls.length;
	        } else {
	          turn_server.urls = [turn_server.urls];
	          num_turn_server_urls = 1;
	        }
	
	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {
	          url = turn_server.urls[jdx];
	
	          if (!(/^turns?:/.test(url))) {
	            url = 'turn:' + url;
	          }
	
	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {
	            return;
	          }
	        }
	      }
	      return turnServers;
	    },
	
	    userAgentString: function(userAgentString) {
	      if (typeof userAgentString === 'string') {
	        return userAgentString;
	      }
	    },
	
	    usePreloadedRoute: function(usePreloadedRoute) {
	      if (typeof usePreloadedRoute === 'boolean') {
	        return usePreloadedRoute;
	      }
	    },
	
	    wsServerMaxReconnection: function(wsServerMaxReconnection) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {
	        value = Number(wsServerMaxReconnection);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {
	        value = Number(wsServerReconnectionTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    autostart: function(autostart) {
	      if (typeof autostart === 'boolean') {
	        return autostart;
	      }
	    },
	
	    mediaHandlerFactory: function(mediaHandlerFactory) {
	      if (mediaHandlerFactory instanceof Function) {
	        var promisifiedFactory = function promisifiedFactory () {
	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);
	
	          function patchMethod (methodName) {
	            var method = mediaHandler[methodName];
	            if (method.length > 1) {
	              var callbacksFirst = methodName === 'getDescription';
	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);
	            }
	          }
	
	          patchMethod('getDescription');
	          patchMethod('setDescription');
	
	          return mediaHandler;
	        };
	
	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;
	        return promisifiedFactory;
	      }
	    },
	
	    authenticationFactory: checkAuthenticationFactory
	  }
	};
	
	UA.C = C;
	SIP.UA = UA;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Hacks - This file contains all of the things we
	 * wish we didn't have to do, just for interop.  It is similar to
	 * Utils, which provides actually useful and relevant functions for
	 * a SIP library. Methods in this file are grouped by vendor, so
	 * as to most easily track when particular hacks may not be necessary anymore.
	 */
	
	module.exports = function (SIP) {
	
	//keep to quiet jshint, and remain consistent with other files
	SIP = SIP;
	
	var Hacks = {
	  AllBrowsers: {
	    maskDtls: function (message) {
	      if (message.body) {
	        message.body = message.body.replace(/ UDP\/TLS\/RTP\/SAVP/gmi, " RTP/SAVP");
	      }
	    },
	    unmaskDtls: function (sdp) {
	      /**
	       * Chrome does not handle DTLS correctly (Canaray does, but not production)
	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)
	       *
	       * UPDATE: May 21, 2014
	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES
	       *
	       * UPDATE: 2014-09-24
	       * Opera now supports DTLS by default as well.
	       *
	       **/
	      return sdp.replace(/ RTP\/SAVP/gmi, " UDP/TLS/RTP/SAVP");
	    }
	  },
	  Firefox: {
	    /* Condition to detect if hacks are applicable */
	    isFirefox: function () {
	      return typeof mozRTCPeerConnection !== 'undefined';
	    },
	
	    cannotHandleExtraWhitespace: function (message) {
	      if (this.isFirefox() && message.body) {
	        message.body = message.body.replace(/ \r\n/g, "\r\n");
	      }
	    },
	
	    hasMissingCLineInSDP: function (sdp) {
	      /*
	       * This is a Firefox hack to insert valid sdp when getDescription is
	       * called with the constraint offerToReceiveVideo = false.
	       * We search for either a c-line at the top of the sdp above all
	       * m-lines. If that does not exist then we search for a c-line
	       * beneath each m-line. If it is missing a c-line, we insert
	       * a fake c-line with the ip address 0.0.0.0. This is then valid
	       * sdp and no media will be sent for that m-line.
	       *
	       * Valid SDP is:
	       * m=
	       * i=
	       * c=
	       */
	      var insertAt, mlines;
	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {
	
	        // Find all m= lines
	        mlines = sdp.match(/m=.*\r\n.*/g);
	        for (var i=0; i<mlines.length; i++) {
	
	          // If it has an i= line, check if the next line is the c= line
	          if (mlines[i].toString().search(/i=.*/) >= 0) {
	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;
	            if (sdp.substr(insertAt,2)!=='c=') {
	              sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	            }
	
	          // else add the C line if it's missing
	          } else if (mlines[i].toString().search(/c=.*/) < 0) {
	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;
	            sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	          }
	        }
	      }
	      return sdp;
	    },
	  },
	
	  Chrome: {
	    needsExplicitlyInactiveSDP: function (sdp) {
	      var sub, index;
	
	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending
	        index = sdp.indexOf('m=video 0');
	        if (index !== -1) {
	          sub = sdp.substr(index);
	          sub = sub.replace(/\r\nc=IN IP4.*\r\n$/,
	                            '\r\nc=IN IP4 0.0.0.0\r\na=inactive\r\n');
	          return sdp.substr(0, index) + sub;
	        }
	      }
	      return sdp;
	    },
	
	    getsConfusedAboutGUM: function (session) {
	      if (session.mediaHandler) {
	        session.mediaHandler.close();
	      }
	    }
	  }
	};
	return Hacks;
	};

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Incoming SIP Message Sanity Check
	 */
	
	/**
	 * SIP message sanity check.
	 * @augments SIP
	 * @function
	 * @param {SIP.IncomingMessage} message
	 * @param {SIP.UA} ua
	 * @param {SIP.Transport} transport
	 * @returns {Boolean}
	 */
	module.exports = function (SIP) {
	var sanityCheck,
	 logger,
	 message, ua, transport,
	 requests = [],
	 responses = [],
	 all = [];
	
	// Reply
	function reply(status_code) {
	  var to,
	    response = SIP.Utils.buildStatusLine(status_code),
	    vias = message.getHeaders('via'),
	    length = vias.length,
	    idx = 0;
	
	  for(idx; idx < length; idx++) {
	    response += "Via: " + vias[idx] + "\r\n";
	  }
	
	  to = message.getHeader('To');
	
	  if(!message.to_tag) {
	    to += ';tag=' + SIP.Utils.newTag();
	  }
	
	  response += "To: " + to + "\r\n";
	  response += "From: " + message.getHeader('From') + "\r\n";
	  response += "Call-ID: " + message.call_id + "\r\n";
	  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
	  response += "\r\n";
	
	  transport.send(response);
	}
	
	/*
	 * Sanity Check for incoming Messages
	 *
	 * Requests:
	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
	 *   Does not look at via sent-by but at sipjsId, which is inserted as
	 *   a prefix in all initial requests generated by the ua
	 *  - _rfc3261_18_3_request_ Body Content-Length
	 *  - _rfc3261_8_2_2_2_ Merged Requests
	 *
	 * Responses:
	 *  - _rfc3261_8_1_3_3_ Multiple Via headers
	 *  - _rfc3261_18_1_2_ sent-by mismatch
	 *  - _rfc3261_18_3_response_ Body Content-Length
	 *
	 * All:
	 *  - Minimum headers in a SIP message
	 */
	
	// Sanity Check functions for requests
	function rfc3261_8_2_2_1() {
	  if(!message.ruri || message.ruri.scheme !== 'sip') {
	    reply(416);
	    return false;
	  }
	}
	
	function rfc3261_16_3_4() {
	  if(!message.to_tag) {
	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {
	      reply(482);
	      return false;
	    }
	  }
	}
	
	function rfc3261_18_3_request() {
	  var len = SIP.Utils.str_utf8_length(message.body),
	  contentLength = message.getHeader('content-length');
	
	  if(len < contentLength) {
	    reply(400);
	    return false;
	  }
	}
	
	function rfc3261_8_2_2_2() {
	  var tr, idx,
	    fromTag = message.from_tag,
	    call_id = message.call_id,
	    cseq = message.cseq;
	
	  if(!message.to_tag) {
	    if(message.method === SIP.C.INVITE) {
	      tr = ua.transactions.ist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.ist) {
	          tr = ua.transactions.ist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    } else {
	      tr = ua.transactions.nist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.nist) {
	          tr = ua.transactions.nist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    }
	  }
	}
	
	// Sanity Check functions for responses
	function rfc3261_8_1_3_3() {
	  if(message.getHeaders('via').length > 1) {
	    logger.warn('More than one Via header field present in the response. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_1_2() {
	  var viaHost = ua.configuration.viaHost;
	  if(message.via.host !== viaHost || message.via.port !== undefined) {
	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_3_response() {
	  var
	    len = SIP.Utils.str_utf8_length(message.body),
	    contentLength = message.getHeader('content-length');
	
	    if(len < contentLength) {
	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
	      return false;
	    }
	}
	
	// Sanity Check functions for requests and responses
	function minimumHeaders() {
	  var
	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
	    idx = mandatoryHeaders.length;
	
	  while(idx--) {
	    if(!message.hasHeader(mandatoryHeaders[idx])) {
	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
	      return false;
	    }
	  }
	}
	
	requests.push(rfc3261_8_2_2_1);
	requests.push(rfc3261_16_3_4);
	requests.push(rfc3261_18_3_request);
	requests.push(rfc3261_8_2_2_2);
	
	responses.push(rfc3261_8_1_3_3);
	responses.push(rfc3261_18_1_2);
	responses.push(rfc3261_18_3_response);
	
	all.push(minimumHeaders);
	
	sanityCheck = function(m, u, t) {
	  var len, pass;
	
	  message = m;
	  ua = u;
	  transport = t;
	
	  logger = ua.getLogger('sip.sanitycheck');
	
	  len = all.length;
	  while(len--) {
	    pass = all[len](message);
	    if(pass === false) {
	      return false;
	    }
	  }
	
	  if(message instanceof SIP.IncomingRequest) {
	    len = requests.length;
	    while(len--) {
	      pass = requests[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  else if(message instanceof SIP.IncomingResponse) {
	    len = responses.length;
	    while(len--) {
	      pass = responses[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  //Everything is OK
	  return true;
	};
	
	SIP.sanityCheck = sanityCheck;
	};


/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Digest Authentication
	 */
	
	/**
	 * SIP Digest Authentication.
	 * @augments SIP.
	 * @function Digest Authentication
	 * @param {SIP.UA} ua
	 */
	module.exports = function (Utils) {
	var DigestAuthentication;
	
	DigestAuthentication = function(ua) {
	  this.logger = ua.getLogger('sipjs.digestauthentication');
	  this.username = ua.configuration.authorizationUser;
	  this.password = ua.configuration.password;
	  this.cnonce = null;
	  this.nc = 0;
	  this.ncHex = '00000000';
	  this.response = null;
	};
	
	
	/**
	* Performs Digest authentication given a SIP request and the challenge
	* received in a response to that request.
	* Returns true if credentials were successfully generated, false otherwise.
	*
	* @param {SIP.OutgoingRequest} request
	* @param {Object} challenge
	*/
	DigestAuthentication.prototype.authenticate = function(request, challenge) {
	  // Inspect and validate the challenge.
	
	  this.algorithm = challenge.algorithm;
	  this.realm = challenge.realm;
	  this.nonce = challenge.nonce;
	  this.opaque = challenge.opaque;
	  this.stale = challenge.stale;
	
	  if (this.algorithm) {
	    if (this.algorithm !== 'MD5') {
	      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
	      return false;
	    }
	  } else {
	    this.algorithm = 'MD5';
	  }
	
	  if (! this.realm) {
	    this.logger.warn('challenge without Digest realm, authentication aborted');
	    return false;
	  }
	
	  if (! this.nonce) {
	    this.logger.warn('challenge without Digest nonce, authentication aborted');
	    return false;
	  }
	
	  // 'qop' can contain a list of values (Array). Let's choose just one.
	  if (challenge.qop) {
	    if (challenge.qop.indexOf('auth') > -1) {
	      this.qop = 'auth';
	    } else if (challenge.qop.indexOf('auth-int') > -1) {
	      this.qop = 'auth-int';
	    } else {
	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
	      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
	      return false;
	    }
	  } else {
	    this.qop = null;
	  }
	
	  // Fill other attributes.
	
	  this.method = request.method;
	  this.uri = request.ruri;
	  this.cnonce = Utils.createRandomToken(12);
	  this.nc += 1;
	  this.updateNcHex();
	
	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
	  if (this.nc === 4294967296) {
	    this.nc = 1;
	    this.ncHex = '00000001';
	  }
	
	  // Calculate the Digest "response" value.
	  this.calculateResponse();
	
	  return true;
	};
	
	
	/**
	* Generate Digest 'response' value.
	* @private
	*/
	DigestAuthentication.prototype.calculateResponse = function() {
	  var ha1, ha2;
	
	  // HA1 = MD5(A1) = MD5(username:realm:password)
	  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);
	
	  if (this.qop === 'auth') {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
	
	  } else if (this.qop === 'auth-int') {
	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
	
	  } else if (this.qop === null) {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
	  }
	};
	
	
	/**
	* Return the Proxy-Authorization or WWW-Authorization header value.
	*/
	DigestAuthentication.prototype.toString = function() {
	  var auth_params = [];
	
	  if (! this.response) {
	    throw new Error('response field does not exist, cannot generate Authorization header');
	  }
	
	  auth_params.push('algorithm=' + this.algorithm);
	  auth_params.push('username="' + this.username + '"');
	  auth_params.push('realm="' + this.realm + '"');
	  auth_params.push('nonce="' + this.nonce + '"');
	  auth_params.push('uri="' + this.uri + '"');
	  auth_params.push('response="' + this.response + '"');
	  if (this.opaque) {
	    auth_params.push('opaque="' + this.opaque + '"');
	  }
	  if (this.qop) {
	    auth_params.push('qop=' + this.qop);
	    auth_params.push('cnonce="' + this.cnonce + '"');
	    auth_params.push('nc=' + this.ncHex);
	  }
	
	  return 'Digest ' + auth_params.join(', ');
	};
	
	
	/**
	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
	* @private
	*/
	DigestAuthentication.prototype.updateNcHex = function() {
	  var hex = Number(this.nc).toString(16);
	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
	};
	
	return DigestAuthentication;
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Grammar = __webpack_require__(244);
	
	module.exports = function (SIP) {
	
	return {
	  parse: function parseCustom (input, startRule) {
	    var options = {startRule: startRule, SIP: SIP};
	    try {
	      Grammar.parse(input, options);
	    } catch (e) {
	      options.data = -1;
	    }
	    return options.data;
	  }
	};
	
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = (function() {
	  /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.majda.cz/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function SyntaxError(message, expected, found, offset, line, column) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.offset   = offset;
	    this.line     = line;
	    this.column   = column;
	
	    this.name     = "SyntaxError";
	  }
	
	  peg$subclass(SyntaxError, Error);
	
	  function parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	
	        peg$FAILED = {},
	
	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },
	        peg$startRuleIndex   = 118,
	
	        peg$consts = [
	          "\r\n",
	          { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	          /^[0-9]/,
	          { type: "class", value: "[0-9]", description: "[0-9]" },
	          /^[a-zA-Z]/,
	          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
	          /^[0-9a-fA-F]/,
	          { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	          /^[\0-\xFF]/,
	          { type: "class", value: "[\\0-\\xFF]", description: "[\\0-\\xFF]" },
	          /^["]/,
	          { type: "class", value: "[\"]", description: "[\"]" },
	          " ",
	          { type: "literal", value: " ", description: "\" \"" },
	          "\t",
	          { type: "literal", value: "\t", description: "\"\\t\"" },
	          /^[a-zA-Z0-9]/,
	          { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
	          ";",
	          { type: "literal", value: ";", description: "\";\"" },
	          "/",
	          { type: "literal", value: "/", description: "\"/\"" },
	          "?",
	          { type: "literal", value: "?", description: "\"?\"" },
	          ":",
	          { type: "literal", value: ":", description: "\":\"" },
	          "@",
	          { type: "literal", value: "@", description: "\"@\"" },
	          "&",
	          { type: "literal", value: "&", description: "\"&\"" },
	          "=",
	          { type: "literal", value: "=", description: "\"=\"" },
	          "+",
	          { type: "literal", value: "+", description: "\"+\"" },
	          "$",
	          { type: "literal", value: "$", description: "\"$\"" },
	          ",",
	          { type: "literal", value: ",", description: "\",\"" },
	          "-",
	          { type: "literal", value: "-", description: "\"-\"" },
	          "_",
	          { type: "literal", value: "_", description: "\"_\"" },
	          ".",
	          { type: "literal", value: ".", description: "\".\"" },
	          "!",
	          { type: "literal", value: "!", description: "\"!\"" },
	          "~",
	          { type: "literal", value: "~", description: "\"~\"" },
	          "*",
	          { type: "literal", value: "*", description: "\"*\"" },
	          "'",
	          { type: "literal", value: "'", description: "\"'\"" },
	          "(",
	          { type: "literal", value: "(", description: "\"(\"" },
	          ")",
	          { type: "literal", value: ")", description: "\")\"" },
	          peg$FAILED,
	          "%",
	          { type: "literal", value: "%", description: "\"%\"" },
	          null,
	          [],
	          function() {return " "; },
	          function() {return ':'; },
	          /^[!-~]/,
	          { type: "class", value: "[!-~]", description: "[!-~]" },
	          /^[\x80-\uFFFF]/,
	          { type: "class", value: "[\\x80-\\uFFFF]", description: "[\\x80-\\uFFFF]" },
	          /^[\x80-\xBF]/,
	          { type: "class", value: "[\\x80-\\xBF]", description: "[\\x80-\\xBF]" },
	          /^[a-f]/,
	          { type: "class", value: "[a-f]", description: "[a-f]" },
	          "`",
	          { type: "literal", value: "`", description: "\"`\"" },
	          "<",
	          { type: "literal", value: "<", description: "\"<\"" },
	          ">",
	          { type: "literal", value: ">", description: "\">\"" },
	          "\\",
	          { type: "literal", value: "\\", description: "\"\\\\\"" },
	          "[",
	          { type: "literal", value: "[", description: "\"[\"" },
	          "]",
	          { type: "literal", value: "]", description: "\"]\"" },
	          "{",
	          { type: "literal", value: "{", description: "\"{\"" },
	          "}",
	          { type: "literal", value: "}", description: "\"}\"" },
	          function() {return "*"; },
	          function() {return "/"; },
	          function() {return "="; },
	          function() {return "("; },
	          function() {return ")"; },
	          function() {return ">"; },
	          function() {return "<"; },
	          function() {return ","; },
	          function() {return ";"; },
	          function() {return ":"; },
	          function() {return "\""; },
	          /^[!-']/,
	          { type: "class", value: "[!-']", description: "[!-']" },
	          /^[*-[]/,
	          { type: "class", value: "[*-[]", description: "[*-[]" },
	          /^[\]-~]/,
	          { type: "class", value: "[\\]-~]", description: "[\\]-~]" },
	          function(contents) {
	                                  return contents; },
	          /^[#-[]/,
	          { type: "class", value: "[#-[]", description: "[#-[]" },
	          /^[\0-\t]/,
	          { type: "class", value: "[\\0-\\t]", description: "[\\0-\\t]" },
	          /^[\x0B-\f]/,
	          { type: "class", value: "[\\x0B-\\f]", description: "[\\x0B-\\f]" },
	          /^[\x0E-]/,
	          { type: "class", value: "[\\x0E-]", description: "[\\x0E-]" },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	
	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}
	                                },
	          "sips",
	          { type: "literal", value: "sips", description: "\"sips\"" },
	          "sip",
	          { type: "literal", value: "sip", description: "\"sip\"" },
	          function(uri_scheme) {
	                              options.data.scheme = uri_scheme; },
	          function() {
	                              options.data.user = decodeURIComponent(text().slice(0, -1));},
	          function() {
	                              options.data.password = text(); },
	          function() {
	                              options.data.host = text();
	                              return options.data.host; },
	          function() {
	                            options.data.host_type = 'domain';
	                            return text(); },
	          /^[a-zA-Z0-9_\-]/,
	          { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
	          /^[a-zA-Z0-9\-]/,
	          { type: "class", value: "[a-zA-Z0-9\\-]", description: "[a-zA-Z0-9\\-]" },
	          function() {
	                              options.data.host_type = 'IPv6';
	                              return text(); },
	          "::",
	          { type: "literal", value: "::", description: "\"::\"" },
	          function() {
	                            options.data.host_type = 'IPv6';
	                            return text(); },
	          function() {
	                              options.data.host_type = 'IPv4';
	                              return text(); },
	          "25",
	          { type: "literal", value: "25", description: "\"25\"" },
	          /^[0-5]/,
	          { type: "class", value: "[0-5]", description: "[0-5]" },
	          "2",
	          { type: "literal", value: "2", description: "\"2\"" },
	          /^[0-4]/,
	          { type: "class", value: "[0-4]", description: "[0-4]" },
	          "1",
	          { type: "literal", value: "1", description: "\"1\"" },
	          /^[1-9]/,
	          { type: "class", value: "[1-9]", description: "[1-9]" },
	          function(port) {
	                              port = parseInt(port.join(''));
	                              options.data.port = port;
	                              return port; },
	          "transport=",
	          { type: "literal", value: "transport=", description: "\"transport=\"" },
	          "udp",
	          { type: "literal", value: "udp", description: "\"udp\"" },
	          "tcp",
	          { type: "literal", value: "tcp", description: "\"tcp\"" },
	          "sctp",
	          { type: "literal", value: "sctp", description: "\"sctp\"" },
	          "tls",
	          { type: "literal", value: "tls", description: "\"tls\"" },
	          function(transport) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['transport'] = transport.toLowerCase(); },
	          "user=",
	          { type: "literal", value: "user=", description: "\"user=\"" },
	          "phone",
	          { type: "literal", value: "phone", description: "\"phone\"" },
	          "ip",
	          { type: "literal", value: "ip", description: "\"ip\"" },
	          function(user) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['user'] = user.toLowerCase(); },
	          "method=",
	          { type: "literal", value: "method=", description: "\"method=\"" },
	          function(method) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['method'] = method; },
	          "ttl=",
	          { type: "literal", value: "ttl=", description: "\"ttl=\"" },
	          function(ttl) {
	                                if(!options.data.params) options.data.params={};
	                                options.data.params['ttl'] = ttl; },
	          "maddr=",
	          { type: "literal", value: "maddr=", description: "\"maddr=\"" },
	          function(maddr) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['maddr'] = maddr; },
	          "lr",
	          { type: "literal", value: "lr", description: "\"lr\"" },
	          function() {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['lr'] = undefined; },
	          function(param, value) {
	                                if(!options.data.uri_params) options.data.uri_params = {};
	                                if (value === null){
	                                  value = undefined;
	                                }
	                                else {
	                                  value = value[1];
	                                }
	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},
	          function(hname, hvalue) {
	                                hname = hname.join('').toLowerCase();
	                                hvalue = hvalue.join('');
	                                if(!options.data.uri_headers) options.data.uri_headers = {};
	                                if (!options.data.uri_headers[hname]) {
	                                  options.data.uri_headers[hname] = [hvalue];
	                                } else {
	                                  options.data.uri_headers[hname].push(hvalue);
	                                }},
	          function() {
	                                // lots of tests fail if this isn't guarded...
	                                if (options.startRule === 'Refer_To') {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	                                }
	                              },
	          "//",
	          { type: "literal", value: "//", description: "\"//\"" },
	          function() {
	                              options.data.scheme= text(); },
	          { type: "literal", value: "SIP", description: "\"SIP\"" },
	          function() {
	                              options.data.sip_version = text(); },
	          "INVITE",
	          { type: "literal", value: "INVITE", description: "\"INVITE\"" },
	          "ACK",
	          { type: "literal", value: "ACK", description: "\"ACK\"" },
	          "VXACH",
	          { type: "literal", value: "VXACH", description: "\"VXACH\"" },
	          "OPTIONS",
	          { type: "literal", value: "OPTIONS", description: "\"OPTIONS\"" },
	          "BYE",
	          { type: "literal", value: "BYE", description: "\"BYE\"" },
	          "CANCEL",
	          { type: "literal", value: "CANCEL", description: "\"CANCEL\"" },
	          "REGISTER",
	          { type: "literal", value: "REGISTER", description: "\"REGISTER\"" },
	          "SUBSCRIBE",
	          { type: "literal", value: "SUBSCRIBE", description: "\"SUBSCRIBE\"" },
	          "NOTIFY",
	          { type: "literal", value: "NOTIFY", description: "\"NOTIFY\"" },
	          "REFER",
	          { type: "literal", value: "REFER", description: "\"REFER\"" },
	          function() {
	
	                              options.data.method = text();
	                              return options.data.method; },
	          function(status_code) {
	                            options.data.status_code = parseInt(status_code.join('')); },
	          function() {
	                            options.data.reason_phrase = text(); },
	          function() {
	                        options.data = text(); },
	          function() {
	                                  var idx, length;
	                                  length = options.data.multi_header.length;
	                                  for (idx = 0; idx < length; idx++) {
	                                    if (options.data.multi_header[idx].parsed === null) {
	                                      options.data = null;
	                                      break;
	                                    }
	                                  }
	                                  if (options.data !== null) {
	                                    options.data = options.data.multi_header;
	                                  } else {
	                                    options.data = -1;
	                                  }},
	          function() {
	                                  var header;
	                                  if(!options.data.multi_header) options.data.multi_header = [];
	                                  try {
	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                    delete options.data.uri;
	                                    delete options.data.displayName;
	                                    delete options.data.params;
	                                  } catch(e) {
	                                    header = null;
	                                  }
	                                  options.data.multi_header.push( { 'position': peg$currPos,
	                                                            'offset': offset(),
	                                                            'parsed': header
	                                                          });},
	          function(displayName) {
	                                  displayName = text().trim();
	                                  if (displayName[0] === '\"') {
	                                    displayName = displayName.substring(1, displayName.length-1);
	                                  }
	                                  options.data.displayName = displayName; },
	          "q",
	          { type: "literal", value: "q", description: "\"q\"" },
	          function(q) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['q'] = q; },
	          "expires",
	          { type: "literal", value: "expires", description: "\"expires\"" },
	          function(expires) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['expires'] = expires; },
	          function(delta_seconds) {
	                                  return parseInt(delta_seconds.join('')); },
	          "0",
	          { type: "literal", value: "0", description: "\"0\"" },
	          function() {
	                                  return parseFloat(text()); },
	          function(param, value) {
	                                  if(!options.data.params) options.data.params = {};
	                                  if (value === null){
	                                    value = undefined;
	                                  }
	                                  else {
	                                    value = value[1];
	                                  }
	                                  options.data.params[param.toLowerCase()] = value;},
	          "render",
	          { type: "literal", value: "render", description: "\"render\"" },
	          "session",
	          { type: "literal", value: "session", description: "\"session\"" },
	          "icon",
	          { type: "literal", value: "icon", description: "\"icon\"" },
	          "alert",
	          { type: "literal", value: "alert", description: "\"alert\"" },
	          function() {
	                                      if (options.startRule === 'Content_Disposition') {
	                                        options.data.type = text().toLowerCase();
	                                      }
	                                    },
	          "handling",
	          { type: "literal", value: "handling", description: "\"handling\"" },
	          "optional",
	          { type: "literal", value: "optional", description: "\"optional\"" },
	          "required",
	          { type: "literal", value: "required", description: "\"required\"" },
	          function(length) {
	                                  options.data = parseInt(length.join('')); },
	          function() {
	                                  options.data = text(); },
	          "text",
	          { type: "literal", value: "text", description: "\"text\"" },
	          "image",
	          { type: "literal", value: "image", description: "\"image\"" },
	          "audio",
	          { type: "literal", value: "audio", description: "\"audio\"" },
	          "video",
	          { type: "literal", value: "video", description: "\"video\"" },
	          "application",
	          { type: "literal", value: "application", description: "\"application\"" },
	          "message",
	          { type: "literal", value: "message", description: "\"message\"" },
	          "multipart",
	          { type: "literal", value: "multipart", description: "\"multipart\"" },
	          "x-",
	          { type: "literal", value: "x-", description: "\"x-\"" },
	          function(cseq_value) {
	                            options.data.value=parseInt(cseq_value.join('')); },
	          function(expires) {options.data = expires; },
	          function(event_type) {
	                                 options.data.event = event_type.toLowerCase(); },
	          function() {
	                          var tag = options.data.tag;
	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                            if (tag) {options.data.setParam('tag',tag)}
	                          },
	          "tag",
	          { type: "literal", value: "tag", description: "\"tag\"" },
	          function(tag) {options.data.tag = tag; },
	          function(forwards) {
	                            options.data = parseInt(forwards.join('')); },
	          function(min_expires) {options.data = min_expires; },
	          function() {
	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                },
	          "digest",
	          { type: "literal", value: "Digest", description: "\"Digest\"" },
	          "realm",
	          { type: "literal", value: "realm", description: "\"realm\"" },
	          function(realm) { options.data.realm = realm; },
	          "domain",
	          { type: "literal", value: "domain", description: "\"domain\"" },
	          "nonce",
	          { type: "literal", value: "nonce", description: "\"nonce\"" },
	          function(nonce) { options.data.nonce=nonce; },
	          "opaque",
	          { type: "literal", value: "opaque", description: "\"opaque\"" },
	          function(opaque) { options.data.opaque=opaque; },
	          "stale",
	          { type: "literal", value: "stale", description: "\"stale\"" },
	          "true",
	          { type: "literal", value: "true", description: "\"true\"" },
	          function() { options.data.stale=true; },
	          "false",
	          { type: "literal", value: "false", description: "\"false\"" },
	          function() { options.data.stale=false; },
	          "algorithm",
	          { type: "literal", value: "algorithm", description: "\"algorithm\"" },
	          "md5",
	          { type: "literal", value: "MD5", description: "\"MD5\"" },
	          "md5-sess",
	          { type: "literal", value: "MD5-sess", description: "\"MD5-sess\"" },
	          function(algorithm) {
	                                options.data.algorithm=algorithm.toUpperCase(); },
	          "qop",
	          { type: "literal", value: "qop", description: "\"qop\"" },
	          "auth-int",
	          { type: "literal", value: "auth-int", description: "\"auth-int\"" },
	          "auth",
	          { type: "literal", value: "auth", description: "\"auth\"" },
	          function(qop_value) {
	                                  options.data.qop || (options.data.qop=[]);
	                                  options.data.qop.push(qop_value.toLowerCase()); },
	          function(rack_value) {
	                            options.data.value=parseInt(rack_value.join('')); },
	          function() {
	                            var idx, length;
	                            length = options.data.multi_header.length;
	                            for (idx = 0; idx < length; idx++) {
	                              if (options.data.multi_header[idx].parsed === null) {
	                                options.data = null;
	                                break;
	                              }
	                            }
	                            if (options.data !== null) {
	                              options.data = options.data.multi_header;
	                            } else {
	                              options.data = -1;
	                            }},
	          function() {
	                            var header;
	                            if(!options.data.multi_header) options.data.multi_header = [];
	                            try {
	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                              delete options.data.uri;
	                              delete options.data.displayName;
	                              delete options.data.params;
	                            } catch(e) {
	                              header = null;
	                            }
	                            options.data.multi_header.push( { 'position': peg$currPos,
	                                                      'offset': offset(),
	                                                      'parsed': header
	                                                    });},
	          function() {
	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                      },
	          function() {
	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
	                                  options.data = -1;
	                                }
	                              },
	          function() {
	                                options.data = {
	                                  call_id: options.data
	                                };
	                              },
	          "from-tag",
	          { type: "literal", value: "from-tag", description: "\"from-tag\"" },
	          function(from_tag) {
	                                options.data.replaces_from_tag = from_tag;
	                              },
	          "to-tag",
	          { type: "literal", value: "to-tag", description: "\"to-tag\"" },
	          function(to_tag) {
	                                options.data.replaces_to_tag = to_tag;
	                              },
	          "early-only",
	          { type: "literal", value: "early-only", description: "\"early-only\"" },
	          function() {
	                                options.data.early_only = true;
	                              },
	          function(r) {return r;},
	          function(first, rest) { return list(first, rest); },
	          function(value) {
	                          if (options.startRule === 'Require') {
	                            options.data = value || [];
	                          }
	                        },
	          function(rseq_value) {
	                            options.data.value=parseInt(rseq_value.join('')); },
	          "active",
	          { type: "literal", value: "active", description: "\"active\"" },
	          "pending",
	          { type: "literal", value: "pending", description: "\"pending\"" },
	          "terminated",
	          { type: "literal", value: "terminated", description: "\"terminated\"" },
	          function() {
	                                  options.data.state = text(); },
	          "reason",
	          { type: "literal", value: "reason", description: "\"reason\"" },
	          function(reason) {
	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },
	          function(expires) {
	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },
	          "retry_after",
	          { type: "literal", value: "retry_after", description: "\"retry_after\"" },
	          function(retry_after) {
	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },
	          "deactivated",
	          { type: "literal", value: "deactivated", description: "\"deactivated\"" },
	          "probation",
	          { type: "literal", value: "probation", description: "\"probation\"" },
	          "rejected",
	          { type: "literal", value: "rejected", description: "\"rejected\"" },
	          "timeout",
	          { type: "literal", value: "timeout", description: "\"timeout\"" },
	          "giveup",
	          { type: "literal", value: "giveup", description: "\"giveup\"" },
	          "noresource",
	          { type: "literal", value: "noresource", description: "\"noresource\"" },
	          "invariant",
	          { type: "literal", value: "invariant", description: "\"invariant\"" },
	          function(value) {
	                          if (options.startRule === 'Supported') {
	                            options.data = value || [];
	                          }
	                        },
	          function() {
	                        var tag = options.data.tag;
	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                          if (tag) {options.data.setParam('tag',tag)}
	                        },
	          "ttl",
	          { type: "literal", value: "ttl", description: "\"ttl\"" },
	          function(via_ttl_value) {
	                                options.data.ttl = via_ttl_value; },
	          "maddr",
	          { type: "literal", value: "maddr", description: "\"maddr\"" },
	          function(via_maddr) {
	                                options.data.maddr = via_maddr; },
	          "received",
	          { type: "literal", value: "received", description: "\"received\"" },
	          function(via_received) {
	                                options.data.received = via_received; },
	          "branch",
	          { type: "literal", value: "branch", description: "\"branch\"" },
	          function(via_branch) {
	                                options.data.branch = via_branch; },
	          "rport",
	          { type: "literal", value: "rport", description: "\"rport\"" },
	          function() {
	                                if(typeof response_port !== 'undefined')
	                                  options.data.rport = response_port.join(''); },
	          function(via_protocol) {
	                                options.data.protocol = via_protocol; },
	          { type: "literal", value: "UDP", description: "\"UDP\"" },
	          { type: "literal", value: "TCP", description: "\"TCP\"" },
	          { type: "literal", value: "TLS", description: "\"TLS\"" },
	          { type: "literal", value: "SCTP", description: "\"SCTP\"" },
	          function(via_transport) {
	                                options.data.transport = via_transport; },
	          function() {
	                                options.data.host = text(); },
	          function(via_sent_by_port) {
	                                options.data.port = parseInt(via_sent_by_port.join('')); },
	          function(ttl) {
	                                return parseInt(ttl.join('')); },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.deltaSeconds = deltaSeconds;
	                                }
	                              },
	          "refresher",
	          { type: "literal", value: "refresher", description: "\"refresher\"" },
	          "uas",
	          { type: "literal", value: "uas", description: "\"uas\"" },
	          "uac",
	          { type: "literal", value: "uac", description: "\"uac\"" },
	          function(endpoint) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.refresher = endpoint;
	                                }
	                              },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Min_SE') {
	                                  options.data = deltaSeconds;
	                                }
	                              },
	          "stuns",
	          { type: "literal", value: "stuns", description: "\"stuns\"" },
	          "stun",
	          { type: "literal", value: "stun", description: "\"stun\"" },
	          function(scheme) {
	                                options.data.scheme = scheme; },
	          function(host) {
	                                options.data.host = host; },
	          "?transport=",
	          { type: "literal", value: "?transport=", description: "\"?transport=\"" },
	          "turns",
	          { type: "literal", value: "turns", description: "\"turns\"" },
	          "turn",
	          { type: "literal", value: "turn", description: "\"turn\"" },
	          function() {
	                                options.data.transport = transport; },
	          function() {
	                            options.data = text(); }
	        ],
	
	        peg$bytecode = [
	          peg$decode(". \"\"2 3!"),
	          peg$decode("0\"\"\"1!3#"),
	          peg$decode("0$\"\"1!3%"),
	          peg$decode("0&\"\"1!3'"),
	          peg$decode("7'*# \"7("),
	          peg$decode("0(\"\"1!3)"),
	          peg$decode("0*\"\"1!3+"),
	          peg$decode(".,\"\"2,3-"),
	          peg$decode("..\"\"2.3/"),
	          peg$decode("00\"\"1!31"),
	          peg$decode(".2\"\"2233*\x89 \".4\"\"2435*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("7)*# \"7,"),
	          peg$decode(".F\"\"2F3G*} \".H\"\"2H3I*q \".J\"\"2J3K*e \".L\"\"2L3M*Y \".N\"\"2N3O*M \".P\"\"2P3Q*A \".R\"\"2R3S*5 \".T\"\"2T3U*) \".V\"\"2V3W"),
	          peg$decode("!!.Y\"\"2Y3Z+7$7#+-%7#+#%'#%$## X$\"# X\"# X+! (%"),
	          peg$decode("!! \\7$,#&7$\"+-$7 +#%'\"%$\"# X\"# X*# \" [+@$ \\7$+&$,#&7$\"\"\" X+'%4\"6]\" %$\"# X\"# X"),
	          peg$decode("7.*# \" ["),
	          peg$decode("! \\7'*# \"7(,)&7'*# \"7(\"+A$.8\"\"2839+1%7/+'%4#6^# %$## X$\"# X\"# X"),
	          peg$decode("!! \\72+&$,#&72\"\"\" X+o$ \\! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X,@&! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("0_\"\"1!3`*# \"73"),
	          peg$decode("0a\"\"1!3b"),
	          peg$decode("0c\"\"1!3d"),
	          peg$decode("7!*) \"0e\"\"1!3f"),
	          peg$decode("! \\7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x9E$,\x9B&7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode("! \\7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x92$,\x8F&7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode(".T\"\"2T3U*\xE3 \".V\"\"2V3W*\xD7 \".i\"\"2i3j*\xCB \".k\"\"2k3l*\xBF \".:\"\"2:3;*\xB3 \".D\"\"2D3E*\xA7 \".2\"\"2233*\x9B \".8\"\"2839*\x8F \".m\"\"2m3n*\x83 \"7&*} \".4\"\"2435*q \".o\"\"2o3p*e \".q\"\"2q3r*Y \".6\"\"2637*M \".>\"\"2>3?*A \".s\"\"2s3t*5 \".u\"\"2u3v*) \"7'*# \"7("),
	          peg$decode("! \\7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v+\u0134$,\u0131&7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v\"\"\" X+! (%"),
	          peg$decode("!7/+A$.P\"\"2P3Q+1%7/+'%4#6w# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.4\"\"2435+1%7/+'%4#6x# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.>\"\"2>3?+1%7/+'%4#6y# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.T\"\"2T3U+1%7/+'%4#6z# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.V\"\"2V3W+1%7/+'%4#6{# %$## X$\"# X\"# X"),
	          peg$decode("!.k\"\"2k3l+1$7/+'%4\"6|\" %$\"# X\"# X"),
	          peg$decode("!7/+7$.i\"\"2i3j+'%4\"6}\" %$\"# X\"# X"),
	          peg$decode("!7/+A$.D\"\"2D3E+1%7/+'%4#6~# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.2\"\"2233+1%7/+'%4#6# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.8\"\"2839+1%7/+'%4#6\x80# %$## X$\"# X\"# X"),
	          peg$decode("!7/+1$7&+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7&+1$7/+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7=+W$ \\7G*) \"7K*# \"7F,/&7G*) \"7K*# \"7F\"+-%7>+#%'#%$## X$\"# X\"# X"),
	          peg$decode("0\x82\"\"1!3\x83*A \"0\x84\"\"1!3\x85*5 \"0\x86\"\"1!3\x87*) \"73*# \"7."),
	          peg$decode("!!7/+U$7&+K% \\7J*# \"7K,)&7J*# \"7K\"+-%7&+#%'$%$$# X$## X$\"# X\"# X+! (%"),
	          peg$decode("!7/+`$7&+V%! \\7J*# \"7K,)&7J*# \"7K\"+! (%+2%7&+(%4$6\x88$!!%$$# X$## X$\"# X\"# X"),
	          peg$decode("7.*G \".L\"\"2L3M*; \"0\x89\"\"1!3\x8A*/ \"0\x86\"\"1!3\x87*# \"73"),
	          peg$decode("!.m\"\"2m3n+K$0\x8B\"\"1!3\x8C*5 \"0\x8D\"\"1!3\x8E*) \"0\x8F\"\"1!3\x90+#%'\"%$\"# X\"# X"),
	          peg$decode("!7N+Q$.8\"\"2839+A%7O*# \" [+1%7S+'%4$6\x91$ %$$# X$## X$\"# X\"# X"),
	          peg$decode("!7N+k$.8\"\"2839+[%7O*# \" [+K%7S+A%7_+7%7l*# \" [+'%4&6\x92& %$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x93\"\"1$3\x94*) \"/\x95\"\"1#3\x96+' 4!6\x97!! %"),
	          peg$decode("!7P+b$!.8\"\"2839+-$7R+#%'\"%$\"# X\"# X*# \" [+7%.:\"\"2:3;+'%4#6\x98# %$## X$\"# X\"# X"),
	          peg$decode(" \\7+*) \"7-*# \"7Q+2$,/&7+*) \"7-*# \"7Q\"\"\" X"),
	          peg$decode(".<\"\"2<3=*q \".>\"\"2>3?*e \".@\"\"2@3A*Y \".B\"\"2B3C*M \".D\"\"2D3E*A \".2\"\"2233*5 \".6\"\"2637*) \".4\"\"2435"),
	          peg$decode("! \\7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E,e&7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E\"+& 4!6\x99! %"),
	          peg$decode("!7T+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\x9A! %"),
	          peg$decode("! \\!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X,>&!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X\"+G$7W+=%.J\"\"2J3K*# \" [+'%4#6\x9B# %$## X$\"# X\"# X"),
	          peg$decode(" \\0\x9C\"\"1!3\x9D+,$,)&0\x9C\"\"1!3\x9D\"\"\" X"),
	          peg$decode("!0$\"\"1!3%+A$ \\0\x9E\"\"1!3\x9F,)&0\x9E\"\"1!3\x9F\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!.o\"\"2o3p+A$7Y+7%.q\"\"2q3r+'%4#6\xA0# %$## X$\"# X\"# X"),
	          peg$decode("!!7Z+\xBF$.8\"\"2839+\xAF%7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0838 \"!.\xA1\"\"2\xA13\xA2+\xAF$7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0795 \"!.\xA1\"\"2\xA13\xA2+\x95$7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u070C \"!.\xA1\"\"2\xA13\xA2+{$7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u069D \"!.\xA1\"\"2\xA13\xA2+a$7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X*\u0648 \"!.\xA1\"\"2\xA13\xA2+G$7Z+=%.8\"\"2839+-%7[+#%'$%$$# X$## X$\"# X\"# X*\u060D \"!.\xA1\"\"2\xA13\xA2+-$7[+#%'\"%$\"# X\"# X*\u05EC \"!.\xA1\"\"2\xA13\xA2+-$7Z+#%'\"%$\"# X\"# X*\u05CB \"!7Z+\xA5$.\xA1\"\"2\xA13\xA2+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0538 \"!7Z+\xB6$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x8B%.\xA1\"\"2\xA13\xA2+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0494 \"!7Z+\xC7$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x9C%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+q%.\xA1\"\"2\xA13\xA2+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u03DF \"!7Z+\xD8$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xAD%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x82%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+W%.\xA1\"\"2\xA13\xA2+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0319 \"!7Z+\xE9$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0242 \"!7Z+\u0114$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xE9%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0140 \"!7Z+\u0135$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\u010A%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xDF%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xB4%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x89%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+^%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+3%.\xA1\"\"2\xA13\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X+& 4!6\xA3! %"),
	          peg$decode("!7#+S$7#*# \" [+C%7#*# \" [+3%7#*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7Z+=$.8\"\"2839+-%7Z+#%'#%$## X$\"# X\"# X*# \"7\\"),
	          peg$decode("!7]+u$.J\"\"2J3K+e%7]+[%.J\"\"2J3K+K%7]+A%.J\"\"2J3K+1%7]+'%4'6\xA4' %$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!.\xA5\"\"2\xA53\xA6+3$0\xA7\"\"1!3\xA8+#%'\"%$\"# X\"# X*\xA0 \"!.\xA9\"\"2\xA93\xAA+=$0\xAB\"\"1!3\xAC+-%7!+#%'#%$## X$\"# X\"# X*o \"!.\xAD\"\"2\xAD3\xAE+7$7!+-%7!+#%'#%$## X$\"# X\"# X*D \"!0\xAF\"\"1!3\xB0+-$7!+#%'\"%$\"# X\"# X*# \"7!"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\xB1!! %"),
	          peg$decode(" \\!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X\""),
	          peg$decode("7a*A \"7b*; \"7c*5 \"7d*/ \"7e*) \"7f*# \"7g"),
	          peg$decode("!/\xB2\"\"1*3\xB3+b$/\xB4\"\"1#3\xB5*G \"/\xB6\"\"1#3\xB7*; \"/\xB8\"\"1$3\xB9*/ \"/\xBA\"\"1#3\xBB*# \"76+(%4\"6\xBC\"! %$\"# X\"# X"),
	          peg$decode("!/\xBD\"\"1%3\xBE+J$/\xBF\"\"1%3\xC0*/ \"/\xC1\"\"1\"3\xC2*# \"76+(%4\"6\xC3\"! %$\"# X\"# X"),
	          peg$decode("!/\xC4\"\"1'3\xC5+2$7\x8F+(%4\"6\xC6\"! %$\"# X\"# X"),
	          peg$decode("!/\xC7\"\"1$3\xC8+2$7\xEF+(%4\"6\xC9\"! %$\"# X\"# X"),
	          peg$decode("!/\xCA\"\"1&3\xCB+2$7T+(%4\"6\xCC\"! %$\"# X\"# X"),
	          peg$decode("!/\xCD\"\"1\"3\xCE+R$!.>\"\"2>3?+-$76+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xCF\" %$\"# X\"# X"),
	          peg$decode("!7h+T$!.>\"\"2>3?+-$7i+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xD0\"\"! %$\"# X\"# X"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("7k*) \"7+*# \"7-"),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".8\"\"2839*A \".<\"\"2<3=*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("!.6\"\"2637+u$7m+k% \\!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X,>&!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X\"+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7n+C$.>\"\"2>3?+3%7o+)%4#6\xD1#\"\" %$## X$\"# X\"# X"),
	          peg$decode(" \\7p*) \"7+*# \"7-+2$,/&7p*) \"7+*# \"7-\"\"\" X"),
	          peg$decode(" \\7p*) \"7+*# \"7-,/&7p*) \"7+*# \"7-\""),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".6\"\"2637*A \".8\"\"2839*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("7\x90*# \"7r"),
	          peg$decode("!7\x8F+K$7'+A%7s+7%7'+-%7\x84+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7M*# \"7t"),
	          peg$decode("!7+G$.8\"\"2839+7%7u*# \"7x+'%4#6\xD2# %$## X$\"# X\"# X"),
	          peg$decode("!7v*# \"7w+N$!.6\"\"2637+-$7\x83+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!.\xD3\"\"2\xD33\xD4+=$7\x80+3%7w*# \" [+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!.4\"\"2435+-$7{+#%'\"%$\"# X\"# X"),
	          peg$decode("!7z+5$ \\7y,#&7y\"+#%'\"%$\"# X\"# X"),
	          peg$decode("7**) \"7+*# \"7-"),
	          peg$decode("7+*\x8F \"7-*\x89 \".2\"\"2233*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7|+k$ \\!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X,>&!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7~,#&7~\"+k$ \\!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode(" \\7~,#&7~\""),
	          peg$decode("7+*w \"7-*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7\"+\x8D$ \\7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K,M&7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K\"+'%4\"6\xD5\" %$\"# X\"# X"),
	          peg$decode("7\x81*# \"7\x82"),
	          peg$decode("!!7O+3$.:\"\"2:3;+#%'\"%$\"# X\"# X*# \" [+-$7S+#%'\"%$\"# X\"# X*# \" ["),
	          peg$decode(" \\7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A+\x8C$,\x89&7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A\"\"\" X"),
	          peg$decode(" \\7y,#&7y\""),
	          peg$decode("!/\x95\"\"1#3\xD6+y$.4\"\"2435+i% \\7!+&$,#&7!\"\"\" X+P%.J\"\"2J3K+@% \\7!+&$,#&7!\"\"\" X+'%4%6\xD7% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode(".\xD8\"\"2\xD83\xD9"),
	          peg$decode(".\xDA\"\"2\xDA3\xDB"),
	          peg$decode(".\xDC\"\"2\xDC3\xDD"),
	          peg$decode(".\xDE\"\"2\xDE3\xDF"),
	          peg$decode(".\xE0\"\"2\xE03\xE1"),
	          peg$decode(".\xE2\"\"2\xE23\xE3"),
	          peg$decode(".\xE4\"\"2\xE43\xE5"),
	          peg$decode(".\xE6\"\"2\xE63\xE7"),
	          peg$decode(".\xE8\"\"2\xE83\xE9"),
	          peg$decode(".\xEA\"\"2\xEA3\xEB"),
	          peg$decode("!7\x85*S \"7\x86*M \"7\x88*G \"7\x89*A \"7\x8A*; \"7\x8B*5 \"7\x8C*/ \"7\x8D*) \"7\x8E*# \"76+& 4!6\xEC! %"),
	          peg$decode("!7\x84+K$7'+A%7\x91+7%7'+-%7\x93+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\x92+' 4!6\xED!! %"),
	          peg$decode("!7!+7$7!+-%7!+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(,G&7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(\"+& 4!6\xEE! %"),
	          peg$decode("!7\xB5+_$ \\!7A+-$7\xB5+#%'\"%$\"# X\"# X,8&!7A+-$7\xB5+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!79+R$!.:\"\"2:3;+-$79+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xEF\" %$\"# X\"# X"),
	          peg$decode("!7:*j \"!7\x97+_$ \\!7A+-$7\x97+#%'\"%$\"# X\"# X,8&!7A+-$7\x97+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+& 4!6\xF0! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\x9A+#%'\"%$\"# X\"# X,8&!7B+-$7\x9A+#%'\"%$\"# X\"# X\"+'%4\"6\xF1\" %$\"# X\"# X"),
	          peg$decode("!7\x99*# \" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!!76+_$ \\!7.+-$76+#%'\"%$\"# X\"# X,8&!7.+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X*# \"7H+' 4!6\xF2!! %"),
	          peg$decode("7\x9B*) \"7\x9C*# \"7\x9F"),
	          peg$decode("!/\xF3\"\"1!3\xF4+<$7<+2%7\x9E+(%4#6\xF5#! %$## X$\"# X\"# X"),
	          peg$decode("!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\xF8#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\xF9!! %"),
	          peg$decode("!.\xFA\"\"2\xFA3\xFB+x$!.J\"\"2J3K+S$7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'$%$$# X$## X$\"# X\"# X*# \" [+'%4\"6\xFC\" %$\"# X\"# X"),
	          peg$decode("!76+N$!7<+-$7\xA0+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xFD\"\"! %$\"# X\"# X"),
	          peg$decode("76*) \"7T*# \"7H"),
	          peg$decode("!7\xA2+_$ \\!7B+-$7\xA3+#%'\"%$\"# X\"# X,8&!7B+-$7\xA3+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\xFE\"\"1&3\xFF*G \"/\u0100\"\"1'3\u0101*; \"/\u0102\"\"1$3\u0103*/ \"/\u0104\"\"1%3\u0105*# \"76+& 4!6\u0106! %"),
	          peg$decode("7\xA4*# \"7\x9F"),
	          peg$decode("!/\u0107\"\"1(3\u0108+O$7<+E%/\u0109\"\"1(3\u010A*/ \"/\u010B\"\"1(3\u010C*# \"76+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u010D!! %"),
	          peg$decode("!7\xA8+& 4!6\u010E! %"),
	          peg$decode("!7\xA9+s$7;+i%7\xAE+_% \\!7B+-$7\xAF+#%'\"%$\"# X\"# X,8&!7B+-$7\xAF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xAA*# \"7\xAB"),
	          peg$decode("/\u010F\"\"1$3\u0110*S \"/\u0111\"\"1%3\u0112*G \"/\u0113\"\"1%3\u0114*; \"/\u0115\"\"1%3\u0116*/ \"/\u0117\"\"1+3\u0118*# \"7\xAC"),
	          peg$decode("/\u0119\"\"1'3\u011A*/ \"/\u011B\"\"1)3\u011C*# \"7\xAC"),
	          peg$decode("76*# \"7\xAD"),
	          peg$decode("!/\u011D\"\"1\"3\u011E+-$76+#%'\"%$\"# X\"# X"),
	          peg$decode("7\xAC*# \"76"),
	          peg$decode("!76+7$7<+-%7\xB0+#%'#%$## X$\"# X\"# X"),
	          peg$decode("76*# \"7H"),
	          peg$decode("!7\xB2+7$7.+-%7\x8F+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u011F!! %"),
	          peg$decode("!7\x9D+' 4!6\u0120!! %"),
	          peg$decode("!7\xB5+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u0121\"!!%$\"# X\"# X"),
	          peg$decode("!!77+k$ \\!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X,>&!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xB7+#%'\"%$\"# X\"# X,8&!7B+-$7\xB7+#%'\"%$\"# X\"# X\"+'%4\"6\u0122\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!/\u0123\"\"1#3\u0124+<$7<+2%76+(%4#6\u0125#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u0126!! %"),
	          peg$decode("!7\x9D+' 4!6\u0127!! %"),
	          peg$decode("! \\7\x99,#&7\x99\"+\x81$7@+w%7M+m%7?+c% \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4%6\u0128% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xBD"),
	          peg$decode("!/\u0129\"\"1&3\u012A+s$7.+i%7\xC0+_% \\!7A+-$7\xC0+#%'\"%$\"# X\"# X,8&!7A+-$7\xC0+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X*# \"7\xBE"),
	          peg$decode("!76+s$7.+i%7\xBF+_% \\!7A+-$7\xBF+#%'\"%$\"# X\"# X,8&!7A+-$7\xBF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!76+=$7<+3%76*# \"7H+#%'#%$## X$\"# X\"# X"),
	          peg$decode("7\xC1*G \"7\xC3*A \"7\xC5*; \"7\xC7*5 \"7\xC8*/ \"7\xC9*) \"7\xCA*# \"7\xBF"),
	          peg$decode("!/\u012B\"\"1%3\u012C+7$7<+-%7\xC2+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u012D!! %"),
	          peg$decode("!/\u012E\"\"1&3\u012F+\xA5$7<+\x9B%7D+\x91%7\xC4+\x87% \\! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X,G&! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7t*# \"7w"),
	          peg$decode("!/\u0130\"\"1%3\u0131+7$7<+-%7\xC6+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u0132!! %"),
	          peg$decode("!/\u0133\"\"1&3\u0134+<$7<+2%7I+(%4#6\u0135#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0136\"\"1%3\u0137+_$7<+U%!/\u0138\"\"1$3\u0139+& 4!6\u013A! %*4 \"!/\u013B\"\"1%3\u013C+& 4!6\u013D! %+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u013E\"\"1)3\u013F+T$7<+J%/\u0140\"\"1#3\u0141*/ \"/\u0142\"\"1(3\u0143*# \"76+(%4#6\u0144#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0145\"\"1#3\u0146+\x9E$7<+\x94%7D+\x8A%!7\xCB+k$ \\!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X,>&!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+-%7E+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u0147\"\"1(3\u0148*/ \"/\u0149\"\"1$3\u014A*# \"76+' 4!6\u014B!! %"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xCE+K$7.+A%7\xCE+7%7.+-%7\x8F+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u014C!! %"),
	          peg$decode("!7\xD0+c$ \\!7A+-$7\xD0+#%'\"%$\"# X\"# X,8&!7A+-$7\xD0+#%'\"%$\"# X\"# X\"+'%4\"6\u014D\" %$\"# X\"# X"),
	          peg$decode("!7\x98+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014E\" %$\"# X\"# X"),
	          peg$decode("!7L*T \"7\x98*N \"!7@*# \" [+=$7t+3%7?*# \" [+#%'#%$## X$\"# X\"# X+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014F\" %$\"# X\"# X"),
	          peg$decode("!7\xD3+c$ \\!7B+-$7\xD4+#%'\"%$\"# X\"# X,8&!7B+-$7\xD4+#%'\"%$\"# X\"# X\"+'%4\"6\u0150\" %$\"# X\"# X"),
	          peg$decode("!7\x95+& 4!6\u0151! %"),
	          peg$decode("!/\u0152\"\"1(3\u0153+<$7<+2%76+(%4#6\u0154#! %$## X$\"# X\"# X*j \"!/\u0155\"\"1&3\u0156+<$7<+2%76+(%4#6\u0157#! %$## X$\"# X\"# X*: \"!/\u0158\"\"1*3\u0159+& 4!6\u015A! %*# \"7\x9F"),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u015D!! %"),
	          peg$decode("!7\xD7+_$ \\!7A+-$7\xD7+#%'\"%$\"# X\"# X,8&!7A+-$7\xD7+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\x98+_$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u015E!! %"),
	          peg$decode("!7\xDA+_$ \\!7B+-$7\xDB+#%'\"%$\"# X\"# X,8&!7B+-$7\xDB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\u015F\"\"1&3\u0160*; \"/\u0161\"\"1'3\u0162*/ \"/\u0163\"\"1*3\u0164*# \"76+& 4!6\u0165! %"),
	          peg$decode("!/\u0166\"\"1&3\u0167+<$7<+2%7\xDC+(%4#6\u0168#! %$## X$\"# X\"# X*\x83 \"!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\u0169#! %$## X$\"# X\"# X*S \"!/\u016A\"\"1+3\u016B+<$7<+2%7\x9D+(%4#6\u016C#! %$## X$\"# X\"# X*# \"7\x9F"),
	          peg$decode("/\u016D\"\"1+3\u016E*k \"/\u016F\"\"1)3\u0170*_ \"/\u0171\"\"1(3\u0172*S \"/\u0173\"\"1'3\u0174*G \"/\u0175\"\"1&3\u0176*; \"/\u0177\"\"1*3\u0178*/ \"/\u0179\"\"1)3\u017A*# \"76"),
	          peg$decode("71*# \" ["),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u017B!! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xE0+#%'\"%$\"# X\"# X,8&!7B+-$7\xE0+#%'\"%$\"# X\"# X\"+'%4\"6\u017C\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!7\xE2+_$ \\!7A+-$7\xE2+#%'\"%$\"# X\"# X,8&!7A+-$7\xE2+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xE9+s$7.+i%7\xEC+_% \\!7B+-$7\xE3+#%'\"%$\"# X\"# X,8&!7B+-$7\xE3+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xE4*; \"7\xE5*5 \"7\xE6*/ \"7\xE7*) \"7\xE8*# \"7\x9F"),
	          peg$decode("!/\u017D\"\"1#3\u017E+<$7<+2%7\xEF+(%4#6\u017F#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0180\"\"1%3\u0181+<$7<+2%7T+(%4#6\u0182#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0183\"\"1(3\u0184+B$7<+8%7\\*# \"7Y+(%4#6\u0185#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0186\"\"1&3\u0187+<$7<+2%76+(%4#6\u0188#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0189\"\"1%3\u018A+T$!7<+5$ \\7!,#&7!\"+#%'\"%$\"# X\"# X*# \" [+'%4\"6\u018B\" %$\"# X\"# X"),
	          peg$decode("!7\xEA+K$7;+A%76+7%7;+-%7\xEB+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x95\"\"1#3\xD6*# \"76+' 4!6\u018C!! %"),
	          peg$decode("!/\xB4\"\"1#3\u018D*G \"/\xB6\"\"1#3\u018E*; \"/\xBA\"\"1#3\u018F*/ \"/\xB8\"\"1$3\u0190*# \"76+' 4!6\u0191!! %"),
	          peg$decode("!7\xED+H$!7C+-$7\xEE+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\u0192! %"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\u0193!! %"),
	          peg$decode("!!7!+C$7!*# \" [+3%7!*# \" [+#%'#%$## X$\"# X\"# X+' 4!6\u0194!! %"),
	          peg$decode("7\xBD"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\xF2+#%'\"%$\"# X\"# X,8&!7B+-$7\xF2+#%'\"%$\"# X\"# X\"+(%4\"6\u0195\"!!%$\"# X\"# X"),
	          peg$decode("7\xF3*# \"7\x9F"),
	          peg$decode("!.\u0196\"\"2\u01963\u0197+N$7<+D%.\u0198\"\"2\u01983\u0199*) \".\u019A\"\"2\u019A3\u019B+(%4#6\u019C#! %$## X$\"# X\"# X"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u019D\"!!%$\"# X\"# X"),
	          peg$decode("!76+7$70+-%7\xF6+#%'#%$## X$\"# X\"# X"),
	          peg$decode(" \\72*) \"74*# \"7.,/&72*) \"74*# \"7.\""),
	          peg$decode(" \\7%,#&7%\""),
	          peg$decode("!7\xF9+=$.8\"\"2839+-%7\xFA+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u019E\"\"1%3\u019F*) \"/\u01A0\"\"1$3\u01A1+' 4!6\u01A2!! %"),
	          peg$decode("!7\xFB+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\\*) \"7X*# \"7\x82+' 4!6\u01A3!! %"),
	          peg$decode("! \\7\xFD*) \"7-*# \"7\xFE,/&7\xFD*) \"7-*# \"7\xFE\"+! (%"),
	          peg$decode("7\"*S \"7!*M \".F\"\"2F3G*A \".J\"\"2J3K*5 \".H\"\"2H3I*) \".N\"\"2N3O"),
	          peg$decode(".L\"\"2L3M*\x95 \".B\"\"2B3C*\x89 \".<\"\"2<3=*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".P\"\"2P3Q*M \".@\"\"2@3A*A \".D\"\"2D3E*5 \".2\"\"2233*) \".>\"\"2>3?"),
	          peg$decode("!7\u0100+h$.8\"\"2839+X%7\xFA+N%!.\u01A4\"\"2\u01A43\u01A5+-$7\xEB+#%'\"%$\"# X\"# X*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u01A6\"\"1%3\u01A7*) \"/\u01A8\"\"1$3\u01A9+' 4!6\u01A2!! %"),
	          peg$decode("!7\xEB+Q$/\xB4\"\"1#3\xB5*7 \"/\xB6\"\"1#3\xB7*+ \" \\7+,#&7+\"+'%4\"6\u01AA\" %$\"# X\"# X"),
	          peg$decode("!7\u0104+\x8F$.F\"\"2F3G+%7\u0103+u%.F\"\"2F3G+e%7\u0103+[%.F\"\"2F3G+K%7\u0103+A%.F\"\"2F3G+1%7\u0105+'%4)6\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\u0103+-$7\u0103+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\u0103+7$7\u0103+-%7\u0103+#%'#%$## X$\"# X\"# X")
	        ],
	
	        peg$currPos          = 0,
	        peg$reportedPos      = 0,
	        peg$cachedPos        = 0,
	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleIndices)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$reportedPos, peg$currPos);
	    }
	
	    function offset() {
	      return peg$reportedPos;
	    }
	
	    function line() {
	      return peg$computePosDetails(peg$reportedPos).line;
	    }
	
	    function column() {
	      return peg$computePosDetails(peg$reportedPos).column;
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        peg$reportedPos
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(message, null, peg$reportedPos);
	    }
	
	    function peg$computePosDetails(pos) {
	      function advance(details, startPos, endPos) {
	        var p, ch;
	
	        for (p = startPos; p < endPos; p++) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	        }
	      }
	
	      if (peg$cachedPos !== pos) {
	        if (peg$cachedPos > pos) {
	          peg$cachedPos = 0;
	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	        }
	        advance(peg$cachedPosDetails, peg$cachedPos, pos);
	        peg$cachedPos = pos;
	      }
	
	      return peg$cachedPosDetails;
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, pos) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      var posDetails = peg$computePosDetails(pos),
	          found      = pos < input.length ? input.charAt(pos) : null;
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        pos,
	        posDetails.line,
	        posDetails.column
	      );
	    }
	
	    function peg$decode(s) {
	      var bc = new Array(s.length), i;
	
	      for (i = 0; i < s.length; i++) {
	        bc[i] = s.charCodeAt(i) - 32;
	      }
	
	      return bc;
	    }
	
	    function peg$parseRule(index) {
	      var bc    = peg$bytecode[index],
	          ip    = 0,
	          ips   = [],
	          end   = bc.length,
	          ends  = [],
	          stack = [],
	          params, i;
	
	      function protect(object) {
	        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
	      }
	
	      while (true) {
	        while (ip < end) {
	          switch (bc[ip]) {
	            case 0:
	              stack.push(protect(peg$consts[bc[ip + 1]]));
	              ip += 2;
	              break;
	
	            case 1:
	              stack.push(peg$currPos);
	              ip++;
	              break;
	
	            case 2:
	              stack.pop();
	              ip++;
	              break;
	
	            case 3:
	              peg$currPos = stack.pop();
	              ip++;
	              break;
	
	            case 4:
	              stack.length -= bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 5:
	              stack.splice(-2, 1);
	              ip++;
	              break;
	
	            case 6:
	              stack[stack.length - 2].push(stack.pop());
	              ip++;
	              break;
	
	            case 7:
	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 8:
	              stack.pop();
	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
	              ip++;
	              break;
	
	            case 9:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1]) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 10:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] === peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 11:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 12:
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                ends.push(end);
	                ips.push(ip);
	
	                end = ip + 2 + bc[ip + 1];
	                ip += 2;
	              } else {
	                ip += 2 + bc[ip + 1];
	              }
	
	              break;
	
	            case 13:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (input.length > peg$currPos) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 14:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 15:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 16:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 17:
	              stack.push(input.substr(peg$currPos, bc[ip + 1]));
	              peg$currPos += bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 18:
	              stack.push(peg$consts[bc[ip + 1]]);
	              peg$currPos += peg$consts[bc[ip + 1]].length;
	              ip += 2;
	              break;
	
	            case 19:
	              stack.push(peg$FAILED);
	              if (peg$silentFails === 0) {
	                peg$fail(peg$consts[bc[ip + 1]]);
	              }
	              ip += 2;
	              break;
	
	            case 20:
	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
	              ip += 2;
	              break;
	
	            case 21:
	              peg$reportedPos = peg$currPos;
	              ip++;
	              break;
	
	            case 22:
	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
	              for (i = 0; i < bc[ip + 3]; i++) {
	                params[i] = stack[stack.length - 1 - params[i]];
	              }
	
	              stack.splice(
	                stack.length - bc[ip + 2],
	                bc[ip + 2],
	                peg$consts[bc[ip + 1]].apply(null, params)
	              );
	
	              ip += 4 + bc[ip + 3];
	              break;
	
	            case 23:
	              stack.push(peg$parseRule(bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 24:
	              peg$silentFails++;
	              ip++;
	              break;
	
	            case 25:
	              peg$silentFails--;
	              ip++;
	              break;
	
	            default:
	              throw new Error("Invalid opcode: " + bc[ip] + ".");
	          }
	        }
	
	        if (ends.length > 0) {
	          end = ends.pop();
	          ip = ips.pop();
	        } else {
	          break;
	        }
	      }
	
	      return stack[0];
	    }
	
	
	      options.data = {}; // Object to which header attributes will be assigned during parsing
	
	      function list (first, rest) {
	        return [first].concat(rest);
	      }
	
	
	    peg$result = peg$parseRule(peg$startRuleIndex);
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	    }
	  }
	
	  return {
	    SyntaxError: SyntaxError,
	    parse:       parse
	  };
	})();


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var toplevel = global.window || global;
	
	function getPrefixedProperty (object, name) {
	  if (object == null) {
	    return;
	  }
	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];
	  for (var i in prefixedNames) {
	    var property = object[prefixedNames[i]];
	    if (property) {
	      return property.bind(object);
	    }
	  }
	}
	
	module.exports = {
	  WebSocket: toplevel.WebSocket,
	  Transport: __webpack_require__(246),
	  open: toplevel.open,
	  Promise: toplevel.Promise,
	  timers: toplevel,
	
	  // Console is not defined in ECMAScript, so just in case...
	  console: toplevel.console || {
	    debug: function () {},
	    log: function () {},
	    warn: function () {},
	    error: function () {}
	  },
	
	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),
	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),
	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),
	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),
	
	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),
	  HTMLMediaElement: toplevel.HTMLMediaElement,
	
	  attachMediaStream: toplevel.attachMediaStream,
	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,
	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 246 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Transport
	 */
	
	/**
	 * @augments SIP
	 * @class Transport
	 * @param {SIP.UA} ua
	 * @param {Object} server ws_server Object
	 */
	module.exports = function (SIP, WebSocket) {
	var Transport,
	  C = {
	    // Transport status codes
	    STATUS_READY:        0,
	    STATUS_DISCONNECTED: 1,
	    STATUS_ERROR:        2
	  };
	
	/**
	 * Compute an amount of time in seconds to wait before sending another
	 * keep-alive.
	 * @returns {Number}
	 */
	function computeKeepAliveTimeout(upperBound) {
	  var lowerBound = upperBound * 0.8;
	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
	}
	
	Transport = function(ua, server) {
	
	  this.logger = ua.getLogger('sip.transport');
	  this.ua = ua;
	  this.ws = null;
	  this.server = server;
	  this.reconnection_attempts = 0;
	  this.closed = false;
	  this.connected = false;
	  this.reconnectTimer = null;
	  this.lastTransportError = {};
	
	  this.keepAliveInterval = ua.configuration.keepAliveInterval;
	  this.keepAliveTimeout = null;
	  this.keepAliveTimer = null;
	
	  this.ua.transport = this;
	
	  // Connect
	  this.connect();
	};
	
	Transport.prototype = {
	  /**
	   * Send a message.
	   * @param {SIP.OutgoingRequest|String} msg
	   * @returns {Boolean}
	   */
	  send: function(msg) {
	    var message = msg.toString();
	
	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('sending WebSocket message:\n\n' + message + '\n');
	      }
	      this.ws.send(message);
	      return true;
	    } else {
	      this.logger.warn('unable to send message, WebSocket is not open');
	      return false;
	    }
	  },
	
	  /**
	   * Send a keep-alive (a double-CRLF sequence).
	   * @private
	   * @returns {Boolean}
	   */
	  sendKeepAlive: function() {
	    if(this.keepAliveTimeout) { return; }
	
	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {
	      this.ua.emit('keepAliveTimeout');
	    }.bind(this), 10000);
	
	    return this.send('\r\n\r\n');
	  },
	
	  /**
	   * Start sending keep-alives.
	   * @private
	   */
	  startSendingKeepAlives: function() {
	    if (this.keepAliveInterval && !this.keepAliveTimer) {
	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {
	        this.sendKeepAlive();
	        this.keepAliveTimer = null;
	        this.startSendingKeepAlives();
	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));
	    }
	  },
	
	  /**
	   * Stop sending keep-alives.
	   * @private
	   */
	  stopSendingKeepAlives: function() {
	    SIP.Timers.clearTimeout(this.keepAliveTimer);
	    SIP.Timers.clearTimeout(this.keepAliveTimeout);
	    this.keepAliveTimer = null;
	    this.keepAliveTimeout = null;
	  },
	
	  /**
	  * Disconnect socket.
	  */
	  disconnect: function() {
	    if(this.ws) {
	      // Clear reconnectTimer
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	
	      this.stopSendingKeepAlives();
	
	      this.closed = true;
	      this.logger.log('closing WebSocket ' + this.server.ws_uri);
	      this.ws.close();
	    }
	
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	      this.ua.emit('disconnected', {
	        transport: this,
	        code: this.lastTransportError.code,
	        reason: this.lastTransportError.reason
	      });
	    }
	  },
	
	  /**
	  * Connect socket.
	  */
	  connect: function() {
	    var transport = this;
	
	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
	      return false;
	    }
	
	    if(this.ws) {
	      this.ws.close();
	    }
	
	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
	    this.ua.onTransportConnecting(this,
	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);
	
	    try {
	      this.ws = new WebSocket(this.server.ws_uri, 'sip');
	    } catch(e) {
	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
	    }
	
	    this.ws.binaryType = 'arraybuffer';
	
	    this.ws.onopen = function() {
	      transport.onOpen();
	    };
	
	    this.ws.onclose = function(e) {
	      transport.onClose(e);
	    };
	
	    this.ws.onmessage = function(e) {
	      transport.onMessage(e);
	    };
	
	    this.ws.onerror = function(e) {
	      transport.onError(e);
	    };
	  },
	
	  // Transport Event Handlers
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onOpen: function() {
	    this.connected = true;
	
	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');
	    // Clear reconnectTimer since we are not disconnected
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	    }
	    // Reset reconnection_attempts
	    this.reconnection_attempts = 0;
	    // Disable closed
	    this.closed = false;
	    // Trigger onTransportConnected callback
	    this.ua.onTransportConnected(this);
	    // Start sending keep-alives
	    this.startSendingKeepAlives();
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onClose: function(e) {
	    var connected_before = this.connected;
	
	    this.lastTransportError.code = e.code;
	    this.lastTransportError.reason = e.reason;
	
	    this.stopSendingKeepAlives();
	
	    if (this.reconnection_attempts > 0) {
	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	      this.reconnect();
	    } else {
	      this.connected = false;
	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	
	      if(e.wasClean === false) {
	        this.logger.warn('WebSocket abrupt disconnection');
	      }
	      // Transport was connected
	      if(connected_before === true) {
	        this.ua.onTransportClosed(this);
	        // Check whether the user requested to close.
	        if(!this.closed) {
	          this.reconnect();
	        } else {
	          this.ua.emit('disconnected', {
	            transport: this,
	            code: this.lastTransportError.code,
	            reason: this.lastTransportError.reason
	          });
	
	        }
	      } else {
	        // This is the first connection attempt
	        //Network error
	        this.ua.onTransportError(this);
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onMessage: function(e) {
	    var message, transaction,
	      data = e.data;
	
	    // CRLF Keep Alive response from server. Ignore it.
	    if(data === '\r\n') {
	      SIP.Timers.clearTimeout(this.keepAliveTimeout);
	      this.keepAliveTimeout = null;
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket message with CRLF Keep Alive response');
	      }
	
	      return;
	    }
	
	    // WebSocket binary message.
	    else if (typeof data !== 'string') {
	      try {
	        data = String.fromCharCode.apply(null, new Uint8Array(data));
	      } catch(evt) {
	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
	        return;
	      }
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket binary message:\n\n' + data + '\n');
	      }
	    }
	
	    // WebSocket text message.
	    else {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket text message:\n\n' + data + '\n');
	      }
	    }
	
	    message = SIP.Parser.parseMessage(data, this.ua);
	
	    if (!message) {
	      return;
	    }
	
	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {
	      return;
	    }
	
	    // Do some sanity check
	    if(SIP.sanityCheck(message, this.ua, this)) {
	      if(message instanceof SIP.IncomingRequest) {
	        message.transport = this;
	        this.ua.receiveRequest(message);
	      } else if(message instanceof SIP.IncomingResponse) {
	        /* Unike stated in 18.1.2, if a response does not match
	        * any transaction, it is discarded here and no passed to the core
	        * in order to be discarded there.
	        */
	        switch(message.method) {
	          case SIP.C.INVITE:
	            transaction = this.ua.transactions.ict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	          case SIP.C.ACK:
	            // Just in case ;-)
	            break;
	          default:
	            transaction = this.ua.transactions.nict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	        }
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onError: function(e) {
	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));
	  },
	
	  /**
	  * Reconnection attempt logic.
	  * @private
	  */
	  reconnect: function() {
	    var transport = this;
	
	    this.reconnection_attempts += 1;
	
	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {
	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
	      this.ua.onTransportError(this);
	    } else if (this.reconnection_attempts === 1) {
	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');
	      transport.connect();
	    } else {
	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');
	
	      this.reconnectTimer = SIP.Timers.setTimeout(function() {
	        transport.connect();
	        transport.reconnectTimer = null;
	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);
	    }
	  }
	};
	
	Transport.C = C;
	return Transport;
	};


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlYTFkOGMwOTkwYTdmZjVkZTVlYyIsIndlYnBhY2s6Ly8vLi9zcmMvcmMtcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2FkZC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yaW5nY2VudHJhbC9idWlsZC9yaW5nY2VudHJhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsLWNsaWVudC9idWlsZC9yaW5nY2VudHJhbC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yYy1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zeW1ib2wtbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlZHV4LWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc2V0dGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2xvZ2luLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9zdWJzY3JpcHRpb24tYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdXNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL3dlYnBob25lLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9jYWxsLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzIiwid2VicGFjazovLy8uL34vcmluZ2NlbnRyYWwtd2ViLXBob25lL3NyYy9yaW5nY2VudHJhbC13ZWItcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9TSVAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9UaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU0lQTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVVJJLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVnaXN0ZXJDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0NsaWVudENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1NlcnZlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9XZWJSVEMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1VBLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9IYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU2FuaXR5Q2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLEtBQU0sVUFBVSx1QkFBaEI7O0FBRUEsVUFBUywyQkFBVCxHQUF1QztBQUNyQyxPQUFNLFdBQVcsbUJBQWpCO0FBQ0EsVUFBTyxDQUNMLFVBQUMsRUFBRDtBQUFBLFlBQVEsU0FBUyxHQUFULENBQWEsRUFBYixDQUFSO0FBQUEsSUFESyxFQUVMLFVBQUMsS0FBRDtBQUFBLFlBQVcsU0FBUyxPQUFULENBQWlCO0FBQUEsY0FBTSxHQUFHLEtBQUgsQ0FBTjtBQUFBLE1BQWpCLENBQVg7QUFBQSxJQUZLLENBQVA7QUFJRDs7S0FFb0IsTzs7O0FBQ25CLDBCQU9HO0FBQUEsU0FORCxvQkFNQyxRQU5ELG9CQU1DO0FBQUEsU0FMRCxRQUtDLFFBTEQsUUFLQztBQUFBLFNBSkQsWUFJQyxRQUpELFdBSUM7QUFBQSw0QkFIRCxNQUdDO0FBQUEsU0FIRCxNQUdDLCtCQUhRLElBR1I7QUFBQSxTQUZELFdBRUMsUUFGRCxXQUVD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTRCLDRCQUE0QixhQUFhLEVBQUU7O0FBRXZFLFFBQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFHQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsa0dBQWtHOztBQUU5TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQSwrQ0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLHdIQUF1SDs7QUFFdkg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsNEJBQTRCLGFBQWEsRUFBRTs7QUFFdkUsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSCxxQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7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QSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUN0SHRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0Esd0NBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNnREE7O0FBRUEsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQyw2QkFBcUQ7Ozs7Ozs7QUMzSHREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFNBQVEsVUFBVTs7QUFFbEI7QUFDQTs7Ozs7OztBQ25GQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7OzsrQ0NKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkdBQTBHOztBQUUxRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixzQkFBc0I7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLCtCQUErQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Qsd0JBQXVCLFFBQVE7QUFDL0I7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFrRSxRQUFROztBQUUxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFFBQVE7QUFDMUU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFxQyxRQUFROztBQUU3Qzs7QUFFQSxzQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQSwwQkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQSxlQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFD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Q0E7QUFDQSx3REFBdUQ7QUFDdkQsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQSx3Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0IsMEJBQTBCLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBLE9BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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T0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLE9BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyxtRUFBbUU7QUFDcEc7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFNBQVE7QUFDUjtBQUNBLE9BQU07O0FBRU47QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLG1FQUFtRTtBQUNwRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQSxTQUFRO0FBQ1I7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxP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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsMERBQTBEO0FBQ3BGLE9BQU07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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUEyRSxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsZUFBZSxjQUFjO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyw4RkFBOEY7QUFDL0Y7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtB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O0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxZQUFZLFlBQVk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkUsVUFBVSxZQUFZLFlBQVk7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWSxXQUFXLGFBQWE7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxZQUFZLFlBQVk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztB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QW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXNGLFdBQVc7QUFDakc7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQSw2RkFBNEYsYUFBYSxnQ0FBZ0MsaUZBQWlGO0FBQzFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLFVBQVUsWUFBWSxZQUFZO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxZQUFZLFlBQVksVUFBVSxVQUFVO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkUsVUFBVSxZQUFZLFlBQVksVUFBVSxVQUFVO0FBQ25JO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNC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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQzVTRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsRzs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztB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QSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNqSEE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFHO0FBQ0gscUJBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QzlCLFdBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsa0JBQWtCO0FBQzVCLFdBQVUsb0JBQW9CO0FBQzlCLFdBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsa0JBQWtCO0FBQzdCLFlBQVcsb0JBQW9CO0FBQy9CLFlBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxvQkFBb0I7QUFDL0I7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pzQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLFlBQVcseUNBQXlDO0FBQ3BELFlBQVcsS0FBSztBQUNoQixZQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxvQkFBb0I7QUFDakMsY0FBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsZUFBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE0Qix1REFBdUQ7O0FBRW5GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGFBQVksb0JBQW9CO0FBQ2hDLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqUUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsV0FBVztBQUN0QixZQUFXLE9BQU87QUFDbEIsWUFBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdGQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0I7QUFDdEIsdUJBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUErRSxlQUFlOztBQUU5RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCLEVBQUU7QUFDeEI7QUFDQTtBQUNBLHVCQUFzQixFQUFFO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCx1REFBc0Q7QUFDdEQ7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0EsdUJBQXNCLEVBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7Ozs7OztBQzNSQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxZQUFZO0FBQ3ZCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVksOEJBQThCOztBQUUxQyxXQUFVLDRCQUE0Qjs7QUFFdEM7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkI7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLEVBQUU7QUFDcEI7QUFDQTs7QUFFQSxtQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN6RkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxvQ0FBb0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQThCLG9EQUFvRDs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUCxzQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxRQUFPOztBQUVQOztBQUVBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixFQUFFO0FBQ3BCO0FBQ0E7O0FBRUEsbUJBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbExBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCx1RUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLG1CQUFtQixFQUFFO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUssNkNBQTZDO0FBQ2xELElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQW9DO0FBQ3BDO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLHNCQUFxQiw0QkFBNEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5akRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixpQkFBaUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsb0JBQW9CO0FBQy9CLFlBQVcsT0FBTztBQUNsQixZQUFXLGNBQWM7QUFDekIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbk9BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6InJpbmdjZW50cmFsLWpzLWludGVncmF0aW9uLWNvbW1vbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSY1Bob25lXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJjUGhvbmVcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGVhMWQ4YzA5OTBhN2ZmNWRlNWVjXG4gKiovIiwiaW1wb3J0IGFkZE1vZHVsZSBmcm9tICcuL2xpYi9hZGQtbW9kdWxlJztcbmltcG9ydCBSaW5nQ2VudHJhbCBmcm9tICdyaW5nY2VudHJhbCc7XG5pbXBvcnQgUmluZ0NlbnRyYWxDbGllbnQgZnJvbSAncmluZ2NlbnRyYWwtY2xpZW50JztcblxuaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4vbGliL3JjLW1vZHVsZSc7XG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuL21vZHVsZXMvc2V0dGluZ3MnO1xuaW1wb3J0IEJyYW5kIGZyb20gJy4vbW9kdWxlcy9icmFuZCc7XG5pbXBvcnQgQXV0aCBmcm9tICcuL21vZHVsZXMvYXV0aCc7XG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4vbW9kdWxlcy9zdWJzY3JpcHRpb24nO1xuaW1wb3J0IFVzZXIgZnJvbSAnLi9tb2R1bGVzL3VzZXInO1xuaW1wb3J0IFdlYnBob25lIGZyb20gJy4vbW9kdWxlcy93ZWJwaG9uZSc7XG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMsIGNyZWF0ZVN0b3JlIH0gZnJvbSAncmVkdXgnO1xuXG5jb25zdCBSRURVQ0VSID0gU3ltYm9sKCk7XG5cbmZ1bmN0aW9uIGdldFN0b3JlUmVnaXN0ZXJBbmRSZXNvbHZlcigpIHtcbiAgY29uc3QgaGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBbXG4gICAgKGZuKSA9PiBoYW5kbGVycy5hZGQoZm4pLFxuICAgIChzdG9yZSkgPT4gaGFuZGxlcnMuZm9yRWFjaChmbiA9PiBmbihzdG9yZSkpLFxuICBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSY1Bob25lIGV4dGVuZHMgUmNNb2R1bGUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXIsXG4gICAgZ2V0U3RvcmUsXG4gICAgc3RhdGVNYXBwZXIsXG4gICAgcHJlZml4ID0gJ3JjJyxcbiAgICBzZGtTZXR0aW5ncyxcbiAgICBkZWZhdWx0QnJhbmQsXG4gIH0pIHtcbiAgICBsZXQgcmVnaXN0ZXIgPSByZWdpc3RlclN0b3JlSGFuZGxlcjtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBpZiAoIXJlZ2lzdGVyKSB7XG4gICAgICBbcmVnaXN0ZXIsIHJlc29sdmVdID0gZ2V0U3RvcmVSZWdpc3RlckFuZFJlc29sdmVyKCk7XG4gICAgfVxuXG4gICAgc3VwZXIoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgc3RhdGVNYXBwZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3NkaycsIG5ldyBSaW5nQ2VudHJhbCh7XG5cbiAgICAgIGNhY2hlUHJlZml4OiBgJHtwcmVmaXh9LWAsXG4gICAgICAuLi5zZGtTZXR0aW5ncyxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3BsYXRmb3JtJywgdGhpcy5zZGsucGxhdGZvcm0oKSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ2FwaScsIG5ldyBSaW5nQ2VudHJhbENsaWVudCh0aGlzLnNkaykpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdhdXRoJywgbmV3IEF1dGgoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS5hdXRoLFxuICAgICAgcHJlZml4LFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdzZXR0aW5ncycsIG5ldyBTZXR0aW5ncyh7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLnNldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnZGVmYXVsdEJyYW5kJywgbmV3IEJyYW5kKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHByZWZpeDogYCR7cHJlZml4fS1kZWZhdWx0YCxcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuZGVmYXVsdEJyYW5kLFxuICAgICAgLi4uZGVmYXVsdEJyYW5kLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnc3Vic2NyaXB0aW9uJywgbmV3IFN1YnNjcmlwdGlvbih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLnN1YnNjcmlwdGlvbixcbiAgICAgIHByZWZpeCxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHNkazogdGhpcy5zZGssXG4gICAgICBhdXRoOiB0aGlzLmF1dGgsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCd1c2VyJywgbmV3IFVzZXIoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS51c2VyLFxuICAgICAgcHJlZml4LFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCd3ZWJwaG9uZScsIG5ldyBXZWJwaG9uZSh7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogKHN0YXRlKSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkud2VicGhvbmUsXG4gICAgICBwcmVmaXgsXG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICB9KSk7XG5cbiAgICAvLyBjb21iaW5lIHJlZHVjZXJzXG4gICAgdGhpc1tSRURVQ0VSXSA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gICAgICBhdXRoOiB0aGlzLmF1dGgucmVkdWNlcixcbiAgICAgIGRlZmF1bHRCcmFuZDogdGhpcy5kZWZhdWx0QnJhbmQucmVkdWNlcixcbiAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5zdWJzY3JpcHRpb24ucmVkdWNlcixcbiAgICAgIHVzZXI6IHRoaXMudXNlci5yZWR1Y2VyLFxuICAgICAgd2VicGhvbmU6IHRoaXMud2VicGhvbmUucmVkdWNlcixcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLnJlZHVjZXIsXG4gICAgfSk7XG5cbiAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShnZXRTdG9yZSh0aGlzLnJlZHVjZXIpKTtcbiAgICAgIC8vIHJlc29sdmUoY3JlYXRlU3RvcmUodGhpcy5yZWR1Y2VyKSk7XG4gICAgfVxuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiB0aGlzW1JFRFVDRVJdO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9yYy1waG9uZS5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcclxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XHJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxyXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxyXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcclxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XHJcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXHJcbiAgICAsIGkgICAgICA9IDBcclxuICAgICwgcmVzdWx0ID0gW11cclxuICAgICwga2V5O1xyXG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcclxuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXHJcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xyXG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcclxubW9kdWxlLmV4cG9ydHMgPSAoXHJcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcclxuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXHJcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XHJcbiAgTyA9IHRvT2JqZWN0KE8pO1xyXG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xyXG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xyXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pc0l0ZXJhYmxlMiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2lzLWl0ZXJhYmxlXCIpO1xuXG52YXIgX2lzSXRlcmFibGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJdGVyYWJsZTIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKTtcblxudmFyIF9nZXRJdGVyYXRvcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKGFyciksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pc0l0ZXJhYmxlMy5kZWZhdWx0KShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZihwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxyXG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcclxuXHJcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcclxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xyXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXHJcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcclxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXHJcbiAgICAsIGd0ICAgICA9ICc+J1xyXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcclxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcclxuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBpZihPICE9PSBudWxsKXtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxyXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XHJcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcclxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcclxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcclxuICBhbk9iamVjdChPKTtcclxuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxyXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgLCBpID0gMFxyXG4gICAgLCBQO1xyXG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcclxuICByZXR1cm4gTztcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5pc0l0ZXJhYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SXSAhPT0gdW5kZWZpbmVkXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICB8fCBJdGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2xhc3NvZihPKSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXHJcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxyXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcclxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXHJcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxyXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xyXG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XHJcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXHJcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xyXG5cclxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcclxuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcclxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXHJcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcclxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xyXG4gIE8gPSB0b0lPYmplY3QoTyk7XHJcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xyXG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XHJcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcclxuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XHJcbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxyXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3NldFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBoaWRlICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYyl7XG4gICAgaWYoc2FmZSAmJiB0YXJnZXRba2V5XSl0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICwgQlJFQUsgICAgICAgPSB7fVxuICAsIFJFVFVSTiAgICAgID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUil7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZihERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKWRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG1ldGEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZm9yT2YgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBlYWNoICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgaWYoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FLCAnX2MnKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlO1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgZWFjaCgnYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OJy5zcGxpdCgnLCcpLGZ1bmN0aW9uKEtFWSl7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCBLRVkpO1xuICAgICAgICBpZighSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY1tLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZignc2l6ZScgaW4gcHJvdG8pZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcclxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxyXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XHJcbiAgdmFyIEM7XHJcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xyXG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xyXG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcclxuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xyXG4gICAgaWYoaXNPYmplY3QoQykpe1xyXG4gICAgICBDID0gQ1tTUEVDSUVTXTtcclxuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIGZyb20gICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRNb2R1bGUobmFtZSwgbW9kdWxlKSB7XG4gIGlmICh0aGlzOjpPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtb2R1bGUgJyR7bmFtZX0nIGFscmVhZHkgZXhpc3RzLi4uYCk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICB9KTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9hZGQtbW9kdWxlLmpzXG4gKiovIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiZXM2LXByb21pc2VcIiksIHJlcXVpcmUoXCJub2RlLWZldGNoXCIpLCByZXF1aXJlKFwicHVibnViXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFssICwgXCJwdWJudWJcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiU0RLXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiZXM2LXByb21pc2VcIiksIHJlcXVpcmUoXCJub2RlLWZldGNoXCIpLCByZXF1aXJlKFwicHVibnViXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSaW5nQ2VudHJhbFwiXSA9IHJvb3RbXCJSaW5nQ2VudHJhbFwiXSB8fCB7fSwgcm9vdFtcIlJpbmdDZW50cmFsXCJdW1wiU0RLXCJdID0gZmFjdG9yeShyb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvYnVpbGQvXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX1V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1V0aWxzKTtcblxudmFyIF9DYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfQ2FjaGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2FjaGUpO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBFeHRlcm5hbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfRXh0ZXJuYWxzKTtcblxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX0NsaWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DbGllbnQpO1xuXG52YXIgX0FwaVJlc3BvbnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfQXBpUmVzcG9uc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBpUmVzcG9uc2UpO1xuXG52YXIgX0NsaWVudE1vY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIF9DbGllbnRNb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsaWVudE1vY2spO1xuXG52YXIgX01vY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIF9Nb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vY2spO1xuXG52YXIgX1JlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfUmVnaXN0cnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVnaXN0cnkpO1xuXG52YXIgX1BsYXRmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfUGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGxhdGZvcm0pO1xuXG52YXIgX0F1dGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9BdXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0F1dGgpO1xuXG52YXIgX1B1Ym51YkZhY3RvcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9QdWJudWJGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1B1Ym51YkZhY3RvcnkpO1xuXG52YXIgX1N1YnNjcmlwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgX1N1YnNjcmlwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJzY3JpcHRpb24pO1xuXG52YXIgX0NhY2hlZFN1YnNjcmlwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgX0NhY2hlZFN1YnNjcmlwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWNoZWRTdWJzY3JpcHRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU0RLID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBSaW5nQ2VudHJhbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VydmVyXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jYWNoZVByZWZpeF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwU2VjcmV0XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBLZXldXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcE5hbWVdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcFZlcnNpb25dXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnB1Ym51YkZhY3RvcnldXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsaWVudF1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNESyhvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTREspO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICghRXh0ZXJuYWxzLmZldGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBGZXRjaCBpcyBtaXNzaW5nLCBzZXQgUmluZ0NlbnRyYWwuU0RLLmNvcmUuRXh0ZXJuYWxzLmZldGNoIHRvIHlvdXIgZmF2b3JpdGUgYWx0ZXJuYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghRXh0ZXJuYWxzLlByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIFByb21pc2UgaXMgbWlzc2luZywgc2V0IFJpbmdDZW50cmFsLlNESy5jb3JlLkV4dGVybmFscy5Qcm9taXNlIHRvIHlvdXIgZmF2b3JpdGUgYWx0ZXJuYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IF9DYWNoZTIuZGVmYXVsdChFeHRlcm5hbHMubG9jYWxTdG9yYWdlLCBvcHRpb25zLmNhY2hlUHJlZml4KTtcblxuICAgICAgICB0aGlzLl9jbGllbnQgPSBvcHRpb25zLmNsaWVudCB8fCBuZXcgX0NsaWVudDIuZGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gbmV3IF9QbGF0Zm9ybTIuZGVmYXVsdCh0aGlzLl9jbGllbnQsIHRoaXMuX2NhY2hlLCBvcHRpb25zLnNlcnZlciwgb3B0aW9ucy5hcHBLZXksIG9wdGlvbnMuYXBwU2VjcmV0LCBvcHRpb25zLmFwcE5hbWUsIG9wdGlvbnMuYXBwVmVyc2lvbiwgU0RLLnZlcnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3B1Ym51YkZhY3RvcnkgPSBvcHRpb25zLnB1Ym51YkZhY3RvcnkgfHwgRXh0ZXJuYWxzLlBVQk5VQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtQbGF0Zm9ybX1cbiAgICAgKi9cblxuXG4gICAgU0RLLnByb3RvdHlwZS5wbGF0Zm9ybSA9IGZ1bmN0aW9uIHBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgU0RLLnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1N1YnNjcmlwdGlvbjIuZGVmYXVsdCh0aGlzLl9wdWJudWJGYWN0b3J5LCB0aGlzLl9wbGF0Zm9ybSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0NhY2hlZFN1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgU0RLLnByb3RvdHlwZS5jcmVhdGVDYWNoZWRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBjcmVhdGVDYWNoZWRTdWJzY3JpcHRpb24oY2FjaGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ2FjaGVkU3Vic2NyaXB0aW9uMi5kZWZhdWx0KHRoaXMuX3B1Ym51YkZhY3RvcnksIHRoaXMuX3BsYXRmb3JtLCB0aGlzLl9jYWNoZSwgY2FjaGVLZXkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtDYWNoZX1cbiAgICAgKi9cblxuXG4gICAgU0RLLnByb3RvdHlwZS5jYWNoZSA9IGZ1bmN0aW9uIGNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfTtcblxuICAgIFNESy5oYW5kbGVMb2dpblJlZGlyZWN0ID0gZnVuY3Rpb24gaGFuZGxlTG9naW5SZWRpcmVjdChvcmlnaW4pIHtcbiAgICAgICAgd2luZG93Lm9wZW5lci5wb3N0TWVzc2FnZSh7IFJDQXV0aG9yaXphdGlvbkNvZGU6IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfSwgb3JpZ2luIHx8IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU0RLO1xufSgpO1xuXG5TREsudmVyc2lvbiA9ICB0cnVlID8gKFwiMy4wLjAtcmMxXCIpIDogJ3gueC54JztcblNESy5zZXJ2ZXIgPSB7XG4gICAgc2FuZGJveDogJ2h0dHBzOi8vcGxhdGZvcm0uZGV2dGVzdC5yaW5nY2VudHJhbC5jb20nLFxuICAgIHByb2R1Y3Rpb246ICdodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbSdcbn07XG5TREsuY29yZSA9IHtcbiAgICBDYWNoZTogX0NhY2hlMi5kZWZhdWx0LFxuICAgIEV2ZW50RW1pdHRlcjogX2V2ZW50czIuZGVmYXVsdCxcbiAgICBVdGlsczogVXRpbHMsXG4gICAgRXh0ZXJuYWxzOiBFeHRlcm5hbHNcbn07XG5TREsuaHR0cCA9IHtcbiAgICBDbGllbnQ6IF9DbGllbnQyLmRlZmF1bHQsXG4gICAgQXBpUmVzcG9uc2U6IF9BcGlSZXNwb25zZTIuZGVmYXVsdFxufTtcblNESy5wbGF0Zm9ybSA9IHtcbiAgICBBdXRoOiBfQXV0aDIuZGVmYXVsdCxcbiAgICBQbGF0Zm9ybTogX1BsYXRmb3JtMi5kZWZhdWx0XG59O1xuU0RLLnN1YnNjcmlwdGlvbiA9IHtcbiAgICBTdWJzY3JpcHRpb246IF9TdWJzY3JpcHRpb24yLmRlZmF1bHRcbn07XG5TREsubW9ja3MgPSB7XG4gICAgQ2xpZW50OiBfQ2xpZW50TW9jazIuZGVmYXVsdCxcbiAgICBSZWdpc3RyeTogX1JlZ2lzdHJ5Mi5kZWZhdWx0LFxuICAgIE1vY2s6IF9Nb2NrMi5kZWZhdWx0XG59O1xuU0RLLnB1Ym51YiA9IHtcbiAgICBQdWJudWJNb2NrRmFjdG9yeTogX1B1Ym51YkZhY3RvcnkyLmRlZmF1bHRcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTREs7XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIC8vIFRoaXMgaW52b2tlIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gaW4gYSBzdHlsZSB0aGF0IGFzc3VtZXMgc29tZVxuICAgIC8vIGNhbGxpbmcgZnVuY3Rpb24gKG9yIFByb21pc2UpIHdpbGwgaGFuZGxlIGV4Y2VwdGlvbnMuXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2VuZXJhdG9yW21ldGhvZF0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgaW52b2tlTmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIHZhciBpbnZva2VUaHJvdyA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJ0aHJvd1wiKTtcbiAgICB2YXIgaW52b2tlUmV0dXJuID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInJldHVyblwiKTtcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLnF1ZXJ5U3RyaW5naWZ5ID0gcXVlcnlTdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzT2JqZWN0T2JqZWN0ID0gaXNPYmplY3RPYmplY3Q7XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuZXhwb3J0cy5pc05vZGVKUyA9IGlzTm9kZUpTO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuLyoqXG4gKiBUT0RPIFJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgYmV0dGVyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL21hc3Rlci9saWIvcXVlcnlzdHJpbmcuanNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBxdWVyeVN0cmluZ2lmeShwYXJhbWV0ZXJzKSB7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgT2JqZWN0LmtleXMocGFyYW1ldGVycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXG4gICAgICAgIHZhciB2ID0gcGFyYW1ldGVyc1trXTtcblxuICAgICAgICBpZiAoaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdi5mb3JFYWNoKGZ1bmN0aW9uICh2dikge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGspICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZ2KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGspICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBUT0RPIFJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgYmV0dGVyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL21hc3Rlci9saWIvcXVlcnlzdHJpbmcuanNcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVN0cmluZ1xuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZykge1xuXG4gICAgdmFyIGFyZ3NQYXJzZWQgPSB7fTtcblxuICAgIHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG5cbiAgICAgICAgYXJnID0gZGVjb2RlVVJJQ29tcG9uZW50KGFyZyk7XG5cbiAgICAgICAgaWYgKGFyZy5pbmRleE9mKCc9JykgPT0gLTEpIHtcblxuICAgICAgICAgICAgYXJnc1BhcnNlZFthcmcudHJpbSgpXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBwYWlyID0gYXJnLnNwbGl0KCc9JyksXG4gICAgICAgICAgICAgICAga2V5ID0gcGFpclswXS50cmltKCksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYWlyWzFdLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKGtleSBpbiBhcmdzUGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBhcmdzUGFyc2VkICYmICFpc0FycmF5KGFyZ3NQYXJzZWRba2V5XSkpIGFyZ3NQYXJzZWRba2V5XSA9IFthcmdzUGFyc2VkW2tleV1dO1xuICAgICAgICAgICAgICAgIGFyZ3NQYXJzZWRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnc1BhcnNlZFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcmdzUGFyc2VkO1xufVxuXG4vKipcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogdHlwZW9mIG9iaiA9PT0gXCJhcnJheVwiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG8pKSA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkobyk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0T2JqZWN0KG8pIHtcbiAgICByZXR1cm4gaXNPYmplY3QobykgPT09IHRydWUgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gICAgdmFyIGN0b3IsIHByb3Q7XG5cbiAgICBpZiAoaXNPYmplY3RPYmplY3QobykgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiBoYXMgbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcbiAgICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gICAgaWYgKGlzT2JqZWN0T2JqZWN0KHByb3QpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kXG4gICAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUpTKCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGRlbGF5KHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfSk7XG59XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1widXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb2NhbFN0b3JhZ2UgPSBleHBvcnRzLlBVQk5VQiA9IGV4cG9ydHMuSGVhZGVycyA9IGV4cG9ydHMuUmVzcG9uc2UgPSBleHBvcnRzLlJlcXVlc3QgPSBleHBvcnRzLmZldGNoID0gZXhwb3J0cy5Qcm9taXNlID0gdW5kZWZpbmVkO1xuXG52YXIgX2VzNlByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2VzNlByb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXM2UHJvbWlzZSk7XG5cbnZhciBfbm9kZUZldGNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9ub2RlRmV0Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUZldGNoKTtcblxudmFyIF9wdWJudWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3B1Ym51YjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wdWJudWIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93IHx8IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXM7XCIpKCk7XG5cbnZhciBQcm9taXNlID0gX2VzNlByb21pc2UyLmRlZmF1bHQgJiYgX2VzNlByb21pc2UyLmRlZmF1bHQuUHJvbWlzZSB8fCByb290LlByb21pc2U7XG5cbnZhciBmZXRjaCA9IF9ub2RlRmV0Y2gyLmRlZmF1bHQgJiYgdHlwZW9mIF9ub2RlRmV0Y2gyLmRlZmF1bHQgPT0gJ2Z1bmN0aW9uJyA/IF9ub2RlRmV0Y2gyLmRlZmF1bHQgOiByb290LmZldGNoO1xudmFyIFJlcXVlc3QgPSBmZXRjaC5SZXF1ZXN0IHx8IHJvb3QuUmVxdWVzdDtcbnZhciBSZXNwb25zZSA9IGZldGNoLlJlc3BvbnNlIHx8IHJvb3QuUmVzcG9uc2U7XG52YXIgSGVhZGVycyA9IGZldGNoLkhlYWRlcnMgfHwgcm9vdC5IZWFkZXJzO1xuXG52YXIgUFVCTlVCID0gX3B1Ym51YjIuZGVmYXVsdCB8fCByb290LlBVQk5VQjtcblxudmFyIGxvY2FsU3RvcmFnZSA9IHR5cGVvZiByb290LmxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgPyByb290LmxvY2FsU3RvcmFnZSA6IHt9O1xuXG5leHBvcnRzLlByb21pc2UgPSBQcm9taXNlO1xuZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbmV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG5leHBvcnRzLlBVQk5VQiA9IFBVQk5VQjtcbmV4cG9ydHMubG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X187XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fO1xuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhY2hlKHN0b3JhZ2UsIHByZWZpeCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FjaGUpO1xuXG4gICAgICAgIHRoaXMuc2V0UHJlZml4KHByZWZpeCk7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIH1cblxuICAgIENhY2hlLnByb3RvdHlwZS5zZXRQcmVmaXggPSBmdW5jdGlvbiBzZXRQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIHRoaXMuX3ByZWZpeCA9IHByZWZpeCB8fCBDYWNoZS5kZWZhdWx0UHJlZml4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQ2FjaGUucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbiBzZXRJdGVtKGtleSwgZGF0YSkge1xuICAgICAgICB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQ2FjaGUucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmFnZVt0aGlzLl9wcmVmaXhLZXkoa2V5KV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fc3RvcmFnZVt0aGlzLl9wcmVmaXhLZXkoa2V5KV07XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGl0ZW0pO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbiBjbGVhbigpIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0b3JhZ2UuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLl9wcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0b3JhZ2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuX3ByZWZpeEtleSA9IGZ1bmN0aW9uIF9wcmVmaXhLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXggKyBrZXk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWNoZTtcbn0oKTtcblxuQ2FjaGUuZGVmYXVsdFByZWZpeCA9ICdyYy0nO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2FjaGU7XG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5maW5kSGVhZGVyTmFtZSA9IGZpbmRIZWFkZXJOYW1lO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoQ2xpZW50LCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIENsaWVudCgpIHtcbiAgICAgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpZW50KTtcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsLmFwcGx5KF9FdmVudEVtaXR0ZXIsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0OiAnYmVmb3JlUmVxdWVzdCcsXG4gICAgICAgICAgICByZXF1ZXN0U3VjY2VzczogJ3JlcXVlc3RTdWNjZXNzJyxcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvcjogJ3JlcXVlc3RFcnJvcidcbiAgICAgICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cbiAgICBDbGllbnQucHJvdG90eXBlLnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIGFwaVJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlID0gbmV3IF9BcGlSZXNwb25zZTIuZGVmYXVsdChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFN0b3AgcmVxdWVzdCBpZiBsaXN0ZW5lcnMgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZVJlcXVlc3QsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkUmVzcG9uc2UocmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZXNwb25zZS5fcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGlSZXNwb25zZS5faW5pdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlLm9rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGhhcyB1bnN1Y2Nlc3NmdWwgc3RhdHVzJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMucmVxdWVzdFN1Y2Nlc3MsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2NvbnRleHQudDAuYXBpUmVzcG9uc2UpIF9jb250ZXh0LnQwID0gdGhpcy5tYWtlRXJyb3IoX2NvbnRleHQudDAsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZXF1ZXN0RXJyb3IsIF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEsIDE0XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZFJlcXVlc3QoX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZFJlcXVlc3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgQ2xpZW50LnByb3RvdHlwZS5fbG9hZFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX0V4dGVybmFscy5mZXRjaC5jYWxsKG51bGwsIHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfbG9hZFJlc3BvbnNlKF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xvYWRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0aGUgSlMgRXJyb3Igb2JqZWN0IHdpdGggdHJhbnNhY3Rpb24gaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge0Vycm9yfElBcGlFcnJvcn0gZVxuICAgICAqIEBwYXJhbSB7QXBpUmVzcG9uc2V9IGFwaVJlc3BvbnNlXG4gICAgICogQHJldHVybiB7SUFwaUVycm9yfVxuICAgICAqL1xuXG5cbiAgICBDbGllbnQucHJvdG90eXBlLm1ha2VFcnJvciA9IGZ1bmN0aW9uIG1ha2VFcnJvcihlLCBhcGlSZXNwb25zZSkge1xuXG4gICAgICAgIC8vIFdyYXAgb25seSBpZiByZWd1bGFyIGVycm9yXG4gICAgICAgIGlmICghZS5oYXNPd25Qcm9wZXJ0eSgnYXBpUmVzcG9uc2UnKSAmJiAhZS5oYXNPd25Qcm9wZXJ0eSgnb3JpZ2luYWxNZXNzYWdlJykpIHtcblxuICAgICAgICAgICAgZS5hcGlSZXNwb25zZSA9IGFwaVJlc3BvbnNlO1xuICAgICAgICAgICAgZS5vcmlnaW5hbE1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICBlLm1lc3NhZ2UgPSBhcGlSZXNwb25zZSAmJiBhcGlSZXNwb25zZS5lcnJvcih0cnVlKSB8fCBlLm9yaWdpbmFsTWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbml0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtpbml0LnVybF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2luaXQuYm9keV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2luaXQubWV0aG9kXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5xdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2luaXQuaGVhZGVyc11cbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICAgICAqL1xuXG5cbiAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KGluaXQpIHtcblxuICAgICAgICBpbml0ID0gaW5pdCB8fCB7fTtcbiAgICAgICAgaW5pdC5oZWFkZXJzID0gaW5pdC5oZWFkZXJzIHx8IHt9O1xuXG4gICAgICAgIC8vIFNhbml0eSBjaGVja3NcbiAgICAgICAgaWYgKCFpbml0LnVybCkgdGhyb3cgbmV3IEVycm9yKCdVcmwgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgaWYgKCFpbml0Lm1ldGhvZCkgaW5pdC5tZXRob2QgPSAnR0VUJztcbiAgICAgICAgaWYgKGluaXQubWV0aG9kICYmIENsaWVudC5fYWxsb3dlZE1ldGhvZHMuaW5kZXhPZihpbml0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGhhcyB3cm9uZyB2YWx1ZTogJyArIGluaXQubWV0aG9kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgIGluaXQuY3JlZGVudGlhbHMgPSBpbml0LmNyZWRlbnRpYWxzIHx8ICdpbmNsdWRlJztcbiAgICAgICAgaW5pdC5tb2RlID0gaW5pdC5tb2RlIHx8ICdjb3JzJztcblxuICAgICAgICAvLyBBcHBlbmQgUXVlcnkgU3RyaW5nXG4gICAgICAgIGlmIChpbml0LnF1ZXJ5KSB7XG4gICAgICAgICAgICBpbml0LnVybCA9IGluaXQudXJsICsgKGluaXQudXJsLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nKSArICgwLCBfVXRpbHMucXVlcnlTdHJpbmdpZnkpKGluaXQucXVlcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmaW5kSGVhZGVyTmFtZSgnQWNjZXB0JywgaW5pdC5oZWFkZXJzKSkge1xuICAgICAgICAgICAgaW5pdC5oZWFkZXJzWydBY2NlcHQnXSA9IF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fanNvbkNvbnRlbnRUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGJvZHlcbiAgICAgICAgaWYgKCgwLCBfVXRpbHMuaXNQbGFpbk9iamVjdCkoaW5pdC5ib2R5KSB8fCAhaW5pdC5ib2R5KSB7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlck5hbWUgPSBmaW5kSGVhZGVyTmFtZShfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2NvbnRlbnRUeXBlLCBpbml0LmhlYWRlcnMpO1xuXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlSGVhZGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlSGVhZGVyTmFtZSA9IF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgaW5pdC5oZWFkZXJzW2NvbnRlbnRUeXBlSGVhZGVyTmFtZV0gPSBfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX2pzb25Db250ZW50VHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaW5pdC5oZWFkZXJzW2NvbnRlbnRUeXBlSGVhZGVyTmFtZV07XG5cbiAgICAgICAgICAgIC8vIEFzc2lnbiBhIG5ldyBlbmNvZGVkIGJvZHlcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5pbmRleE9mKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fanNvbkNvbnRlbnRUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoaW5pdC5ib2R5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUuaW5kZXhPZihfQXBpUmVzcG9uc2UyLmRlZmF1bHQuX3VybGVuY29kZWRDb250ZW50VHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGluaXQuYm9keSA9ICgwLCBfVXRpbHMucXVlcnlTdHJpbmdpZnkpKGluaXQuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSByZXF1ZXN0IHdpdGggZW5jb2RlZCBib2R5XG4gICAgICAgIHZhciByZXEgPSBuZXcgX0V4dGVybmFscy5SZXF1ZXN0KGluaXQudXJsLCBpbml0KTtcblxuICAgICAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCBib2R5IGFjY2Vzc2libGUgZGlyZWN0bHkgKGZvciBtb2NrcylcbiAgICAgICAgcmVxLm9yaWdpbmFsQm9keSA9IGluaXQuYm9keTtcblxuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2xpZW50O1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuQ2xpZW50Ll9hbGxvd2VkTWV0aG9kcyA9IFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURScsICdQQVRDSCcsICdPUFRJT05TJywgJ0hFQUQnXTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsaWVudDtcbmZ1bmN0aW9uIGZpbmRIZWFkZXJOYW1lKG5hbWUsIGhlYWRlcnMpIHtcbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhoZWFkZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKHJlcywga2V5KSB7XG4gICAgICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgICAgIGlmIChuYW1lID09IGtleS50b0xvd2VyQ2FzZSgpKSByZXR1cm4ga2V5O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIG51bGwpO1xufVxuXG4vKipcbiAqIEBuYW1lIElBcGlFcnJvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YWNrXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luYWxNZXNzYWdlXG4gKiBAcHJvcGVydHkge0FwaVJlc3BvbnNlfSBhcGlSZXNwb25zZVxuICovXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQXBpUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVRleHRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEFwaVJlc3BvbnNlKHJlcXVlc3QsIHJlc3BvbnNlLCByZXNwb25zZVRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFwaVJlc3BvbnNlKTtcblxuICAgICAgICAvKiogQHR5cGUge1JlcXVlc3R9ICovXG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xuXG4gICAgICAgIC8qKiBAdHlwZSB7UmVzcG9uc2V9ICovXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlID0gcmVzcG9uc2U7XG5cbiAgICAgICAgdGhpcy5fdGV4dCA9IHJlc3BvbnNlVGV4dDtcbiAgICAgICAgdGhpcy5fanNvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX211bHRpcGFydCA9IFtdO1xuICAgIH1cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX2lzTXVsdGlwYXJ0KCkgfHwgdGhpcy5faXNKc29uKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZSgpLnRleHQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9pbml0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1Jlc3BvbnNlfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUucmVzcG9uc2UgPSBmdW5jdGlvbiByZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbiBvaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlICYmIHRoaXMuX3Jlc3BvbnNlLm9rO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0pzb24oKSAmJiAhdGhpcy5faXNNdWx0aXBhcnQoKSkgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgdGV4dCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uIGpzb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNKc29uKCkpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IEpTT04nKTtcbiAgICAgICAgaWYgKCF0aGlzLl9qc29uKSB7XG4gICAgICAgICAgICB0aGlzLl9qc29uID0gdGhpcy5fdGV4dCA/IEpTT04ucGFyc2UodGhpcy5fdGV4dCkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9qc29uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gW3NraXBPS0NoZWNrXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3Ioc2tpcE9LQ2hlY2spIHtcblxuICAgICAgICBpZiAodGhpcy5vaygpICYmICFza2lwT0tDaGVjaykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAodGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5fcmVzcG9uc2Uuc3RhdHVzICsgJyAnIDogJycpICsgKHRoaXMuX3Jlc3BvbnNlICYmIHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1RleHQgPyB0aGlzLl9yZXNwb25zZS5zdGF0dXNUZXh0IDogJycpO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmpzb24oKS5tZXNzYWdlKSBtZXNzYWdlID0gdGhpcy5qc29uKCkubWVzc2FnZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmpzb24oKS5lcnJvcl9kZXNjcmlwdGlvbikgbWVzc2FnZSA9IHRoaXMuanNvbigpLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLmRlc2NyaXB0aW9uKSBtZXNzYWdlID0gdGhpcy5qc29uKCkuZGVzY3JpcHRpb247XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FwaVJlc3BvbnNlW119XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5tdWx0aXBhcnQgPSBmdW5jdGlvbiBtdWx0aXBhcnQoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc011bHRpcGFydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCBtdWx0aXBhcnQnKTtcblxuICAgICAgICBpZiAoIXRoaXMuX211bHRpcGFydC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgLy8gU3RlcCAxLiBTcGxpdCBtdWx0aXBhcnQgcmVzcG9uc2VcblxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHQoKTtcblxuICAgICAgICAgICAgaWYgKCF0ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknKTtcblxuICAgICAgICAgICAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5fZ2V0Q29udGVudFR5cGUoKS5tYXRjaCgvYm91bmRhcnk9KFteO10rKS9pKVsxXTtcblxuICAgICAgICAgICAgaWYgKCFib3VuZGFyeSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBib3VuZGFyeScpO1xuXG4gICAgICAgICAgICB2YXIgcGFydHMgPSB0ZXh0LnRvU3RyaW5nKCkuc3BsaXQoQXBpUmVzcG9uc2UuX2JvdW5kYXJ5U2VwYXJhdG9yICsgYm91bmRhcnkpO1xuXG4gICAgICAgICAgICBpZiAocGFydHNbMF0udHJpbSgpID09PSAnJykgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50cmltKCkgPT0gQXBpUmVzcG9uc2UuX2JvdW5kYXJ5U2VwYXJhdG9yKSBwYXJ0cy5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcignTm8gcGFydHMgaW4gYm9keScpO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDIuIFBhcnNlIHN0YXR1cyBpbmZvXG5cbiAgICAgICAgICAgIHZhciBzdGF0dXNJbmZvID0gQXBpUmVzcG9uc2UuY3JlYXRlKHBhcnRzLnNoaWZ0KCksIHRoaXMuX3Jlc3BvbnNlLnN0YXR1cywgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzVGV4dCkuanNvbigpO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDMuIFBhcnNlIGFsbCBvdGhlciBwYXJ0c1xuXG4gICAgICAgICAgICB0aGlzLl9tdWx0aXBhcnQgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQsIGkpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBzdGF0dXNJbmZvLnJlc3BvbnNlW2ldLnN0YXR1cztcblxuICAgICAgICAgICAgICAgIHJldHVybiBBcGlSZXNwb25zZS5jcmVhdGUocGFydCwgc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpcGFydDtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc0NvbnRlbnRUeXBlID0gZnVuY3Rpb24gX2lzQ29udGVudFR5cGUoY29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRlbnRUeXBlKCkuaW5kZXhPZihjb250ZW50VHlwZSkgPiAtMTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZSA9IGZ1bmN0aW9uIF9nZXRDb250ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KEFwaVJlc3BvbnNlLl9jb250ZW50VHlwZSkgfHwgJyc7XG4gICAgfTtcblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5faXNNdWx0aXBhcnQgPSBmdW5jdGlvbiBfaXNNdWx0aXBhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NvbnRlbnRUeXBlKEFwaVJlc3BvbnNlLl9tdWx0aXBhcnRDb250ZW50VHlwZSk7XG4gICAgfTtcblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5faXNVcmxFbmNvZGVkID0gZnVuY3Rpb24gX2lzVXJsRW5jb2RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29udGVudFR5cGUoQXBpUmVzcG9uc2UuX3VybGVuY29kZWRDb250ZW50VHlwZSk7XG4gICAgfTtcblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5faXNKc29uID0gZnVuY3Rpb24gX2lzSnNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29udGVudFR5cGUoQXBpUmVzcG9uc2UuX2pzb25Db250ZW50VHlwZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBBcGlSZXNwb25zZSBvYmplY3QgZnJvbSBzdHJpbmcgcGFydHMgb2YgbXVsdGlwYXJ0L21peGVkIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhdHVzXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RhdHVzVGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcGlSZXNwb25zZX1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHRleHQsIHN0YXR1cywgc3RhdHVzVGV4dCkge1xuXG4gICAgICAgIHRleHQgPSB0ZXh0IHx8ICcnO1xuICAgICAgICBzdGF0dXMgPSBzdGF0dXMgfHwgMjAwO1xuICAgICAgICBzdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCAnT0snO1xuXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcci9nLCAnJyk7XG5cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBuZXcgX0V4dGVybmFscy5IZWFkZXJzKCksXG4gICAgICAgICAgICBoZWFkZXJzQW5kQm9keSA9IHRleHQuc3BsaXQoQXBpUmVzcG9uc2UuX2JvZHlTZXBhcmF0b3IpLFxuICAgICAgICAgICAgaGVhZGVyc1RleHQgPSBoZWFkZXJzQW5kQm9keS5sZW5ndGggPiAxID8gaGVhZGVyc0FuZEJvZHkuc2hpZnQoKSA6ICcnO1xuXG4gICAgICAgIHRleHQgPSBoZWFkZXJzQW5kQm9keS5sZW5ndGggPiAwID8gaGVhZGVyc0FuZEJvZHkuam9pbihBcGlSZXNwb25zZS5fYm9keVNlcGFyYXRvcikgOiBudWxsO1xuXG4gICAgICAgIChoZWFkZXJzVGV4dCB8fCAnJykuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBoZWFkZXIudHJpbSgpLnNwbGl0KEFwaVJlc3BvbnNlLl9oZWFkZXJTZXBhcmF0b3IpLFxuICAgICAgICAgICAgICAgIGtleSA9IHNwbGl0LnNoaWZ0KCkudHJpbSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3BsaXQuam9pbihBcGlSZXNwb25zZS5faGVhZGVyU2VwYXJhdG9yKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmIChrZXkpIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IEFwaVJlc3BvbnNlKG51bGwsIG5ldyBfRXh0ZXJuYWxzLlJlc3BvbnNlKHRleHQgPyB0ZXh0IDogdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0XG4gICAgICAgIH0pLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFwaVJlc3BvbnNlO1xufSgpO1xuXG5BcGlSZXNwb25zZS5fY29udGVudFR5cGUgPSAnQ29udGVudC1UeXBlJztcbkFwaVJlc3BvbnNlLl9qc29uQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG5BcGlSZXNwb25zZS5fbXVsdGlwYXJ0Q29udGVudFR5cGUgPSAnbXVsdGlwYXJ0L21peGVkJztcbkFwaVJlc3BvbnNlLl91cmxlbmNvZGVkQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbkFwaVJlc3BvbnNlLl9oZWFkZXJTZXBhcmF0b3IgPSAnOic7XG5BcGlSZXNwb25zZS5fYm9keVNlcGFyYXRvciA9ICdcXG5cXG4nO1xuQXBpUmVzcG9uc2UuX2JvdW5kYXJ5U2VwYXJhdG9yID0gJy0tJztcbmV4cG9ydHMuZGVmYXVsdCA9IEFwaVJlc3BvbnNlO1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9SZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWdpc3RyeSk7XG5cbnZhciBfQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfQ2xpZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsaWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24gKF9IdHRwQ2xpZW50KSB7XG4gICAgX2luaGVyaXRzKENsaWVudCwgX0h0dHBDbGllbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpZW50KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfSHR0cENsaWVudC5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5fcmVnaXN0cnkgPSBuZXcgX1JlZ2lzdHJ5Mi5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBDbGllbnQucHJvdG90eXBlLnJlZ2lzdHJ5ID0gZnVuY3Rpb24gcmVnaXN0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RyeTtcbiAgICB9O1xuXG4gICAgQ2xpZW50LnByb3RvdHlwZS5fbG9hZFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIG1vY2s7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9jayA9IHRoaXMuX3JlZ2lzdHJ5LmZpbmQocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vY2suZ2V0UmVzcG9uc2UocmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfbG9hZFJlc3BvbnNlKF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sb2FkUmVzcG9uc2U7XG4gICAgfSgpO1xuXG4gICAgcmV0dXJuIENsaWVudDtcbn0oX0NsaWVudDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENsaWVudDtcblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX01vY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIF9Nb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vY2spO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVnaXN0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnaXN0cnkoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWdpc3RyeSk7XG5cbiAgICAgICAgdGhpcy5fbW9ja3MgPSBbXTtcbiAgICB9XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG1vY2spIHtcbiAgICAgICAgdGhpcy5fbW9ja3MucHVzaChtb2NrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tb2NrcyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kKHJlcXVlc3QpIHtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdSZWdpc3RyeSBpcyBsb29raW5nIGZvcicsIHJlcXVlc3QpO1xuXG4gICAgICAgIHZhciBtb2NrID0gdGhpcy5fbW9ja3Muc2hpZnQoKTtcblxuICAgICAgICBpZiAoIW1vY2spIHRocm93IG5ldyBFcnJvcignTm8gbW9jayBpbiByZWdpc3RyeSBmb3IgcmVxdWVzdCAnICsgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnVybCk7XG5cbiAgICAgICAgaWYgKCFtb2NrLnRlc3QocmVxdWVzdCkpIHRocm93IG5ldyBFcnJvcignV3JvbmcgcmVxdWVzdCAnICsgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnVybCArICcgZm9yIGV4cGVjdGVkIG1vY2sgJyArIG1vY2subWV0aG9kKCkgKyAnICcgKyBtb2NrLnBhdGgoKSk7XG5cbiAgICAgICAgcmV0dXJuIG1vY2s7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5hcGlDYWxsID0gZnVuY3Rpb24gYXBpQ2FsbChtZXRob2QsIHBhdGgsIHJlc3BvbnNlLCBzdGF0dXMsIHN0YXR1c1RleHQsIGRlbGF5KSB7XG5cbiAgICAgICAgdGhpcy5hZGQobmV3IF9Nb2NrMi5kZWZhdWx0KG1ldGhvZCwgcGF0aCwgcmVzcG9uc2UsIHN0YXR1cywgc3RhdHVzVGV4dCwgZGVsYXkpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gYXV0aGVudGljYXRpb24oKSB7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL29hdXRoL3Rva2VuJywge1xuICAgICAgICAgICAgJ2FjY2Vzc190b2tlbic6ICdBQ0NFU1NfVE9LRU4nLFxuICAgICAgICAgICAgJ3Rva2VuX3R5cGUnOiAnYmVhcmVyJyxcbiAgICAgICAgICAgICdleHBpcmVzX2luJzogMzYwMCxcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJzogJ1JFRlJFU0hfVE9LRU4nLFxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW5fZXhwaXJlc19pbic6IDYwNDgwLFxuICAgICAgICAgICAgJ3Njb3BlJzogJ1NNUyBSQ00gRm9vIEJvbycsXG4gICAgICAgICAgICAnZXhwaXJlVGltZSc6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgMzYwMDAwMFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uIGxvZ291dCgpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvcmV2b2tlJywge30pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUucHJlc2VuY2VMb2FkID0gZnVuY3Rpb24gcHJlc2VuY2VMb2FkKGlkKSB7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uLycgKyBpZCArICcvcHJlc2VuY2UnLCB7XG4gICAgICAgICAgICBcInVyaVwiOiBcImh0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tL3Jlc3RhcGkvdjEuMC9hY2NvdW50LzEyMy9leHRlbnNpb24vXCIgKyBpZCArIFwiL3ByZXNlbmNlXCIsXG4gICAgICAgICAgICBcImV4dGVuc2lvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL3YxLjAvYWNjb3VudC8xMjMvZXh0ZW5zaW9uL1wiICsgaWQsXG4gICAgICAgICAgICAgICAgXCJpZFwiOiBpZCxcbiAgICAgICAgICAgICAgICBcImV4dGVuc2lvbk51bWJlclwiOiBcIjEwMVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhY3RpdmVDYWxsc1wiOiBbXSxcbiAgICAgICAgICAgIFwicHJlc2VuY2VTdGF0dXNcIjogXCJBdmFpbGFibGVcIixcbiAgICAgICAgICAgIFwidGVsZXBob255U3RhdHVzXCI6IFwiUmluZ2luZ1wiLFxuICAgICAgICAgICAgXCJ1c2VyU3RhdHVzXCI6IFwiQXZhaWxhYmxlXCIsXG4gICAgICAgICAgICBcImRuZFN0YXR1c1wiOiBcIlRha2VBbGxDYWxsc1wiLFxuICAgICAgICAgICAgXCJleHRlbnNpb25JZFwiOiBpZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLnN1YnNjcmliZUdlbmVyaWMgPSBmdW5jdGlvbiBzdWJzY3JpYmVHZW5lcmljKGV4cGlyZXNJbikge1xuXG4gICAgICAgIGV4cGlyZXNJbiA9IGV4cGlyZXNJbiB8fCAxNSAqIDYwICogNjA7XG5cbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbicsIHtcbiAgICAgICAgICAgICdldmVudEZpbHRlcnMnOiBbJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlJ10sXG4gICAgICAgICAgICAnZXhwaXJhdGlvblRpbWUnOiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIGV4cGlyZXNJbiAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAnZXhwaXJlc0luJzogZXhwaXJlc0luLFxuICAgICAgICAgICAgJ2RlbGl2ZXJ5TW9kZSc6IHtcbiAgICAgICAgICAgICAgICAndHJhbnNwb3J0VHlwZSc6ICdQdWJOdWInLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2FkZHJlc3MnOiAnMTIzX2ZvbycsXG4gICAgICAgICAgICAgICAgJ3N1YnNjcmliZXJLZXknOiAnc3ViLWMtZm9vJyxcbiAgICAgICAgICAgICAgICAnc2VjcmV0S2V5JzogJ3NlYy1jLWJhcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaWQnOiAnZm9vLWJhci1iYXonLFxuICAgICAgICAgICAgJ2NyZWF0aW9uVGltZSc6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnQWN0aXZlJyxcbiAgICAgICAgICAgICd1cmknOiAnaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi9mb28tYmFyLWJheidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5zdWJzY3JpYmVPblByZXNlbmNlID0gZnVuY3Rpb24gc3Vic2NyaWJlT25QcmVzZW5jZShpZCwgZGV0YWlsZWQpIHtcblxuICAgICAgICBpZCA9IGlkIHx8ICcxJztcblxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uJywge1xuICAgICAgICAgICAgJ2V2ZW50RmlsdGVycyc6IFsnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uLycgKyBpZCArICcvcHJlc2VuY2UnICsgKGRldGFpbGVkID8gJz9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUnIDogJycpXSxcbiAgICAgICAgICAgICdleHBpcmF0aW9uVGltZSc6IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgMTUgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICdkZWxpdmVyeU1vZGUnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zcG9ydFR5cGUnOiAnUHViTnViJyxcbiAgICAgICAgICAgICAgICAnZW5jcnlwdGlvbic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2FkZHJlc3MnOiAnMTIzX2ZvbycsXG4gICAgICAgICAgICAgICAgJ3N1YnNjcmliZXJLZXknOiAnc3ViLWMtZm9vJyxcbiAgICAgICAgICAgICAgICAnc2VjcmV0S2V5JzogJ3NlYy1jLWJhcicsXG4gICAgICAgICAgICAgICAgJ2VuY3J5cHRpb25BbGdvcml0aG0nOiAnQUVTJyxcbiAgICAgICAgICAgICAgICAnZW5jcnlwdGlvbktleSc6ICdWUXdiNkVWTmNRUEJoRS9KZ0ZaMnp3PT0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2NyZWF0aW9uVGltZSc6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICdpZCc6ICdmb28tYmFyLWJheicsXG4gICAgICAgICAgICAnc3RhdHVzJzogJ0FjdGl2ZScsXG4gICAgICAgICAgICAndXJpJzogJ2h0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24vZm9vLWJhci1iYXonXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUudG9rZW5SZWZyZXNoID0gZnVuY3Rpb24gdG9rZW5SZWZyZXNoKGZhaWx1cmUpIHtcblxuICAgICAgICBpZiAoIWZhaWx1cmUpIHtcblxuICAgICAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL29hdXRoL3Rva2VuJywge1xuICAgICAgICAgICAgICAgICdhY2Nlc3NfdG9rZW4nOiAnQUNDRVNTX1RPS0VOX0ZST01fUkVGUkVTSCcsXG4gICAgICAgICAgICAgICAgJ3Rva2VuX3R5cGUnOiAnYmVhcmVyJyxcbiAgICAgICAgICAgICAgICAnZXhwaXJlc19pbic6IDM2MDAsXG4gICAgICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiAnUkVGUkVTSF9UT0tFTl9GUk9NX1JFRlJFU0gnLFxuICAgICAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4nOiA2MDQ4MCxcbiAgICAgICAgICAgICAgICAnc2NvcGUnOiAnU01TIFJDTSBGb28gQm9vJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS9vYXV0aC90b2tlbicsIHtcbiAgICAgICAgICAgICAgICAnbWVzc2FnZSc6ICdXcm9uZyB0b2tlbicsXG4gICAgICAgICAgICAgICAgJ2Vycm9yX2Rlc2NyaXB0aW9uJzogJ1dyb25nIHRva2VuJyxcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiAnV3JvbmcgdG9rZW4nXG4gICAgICAgICAgICB9LCA0MDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBSZWdpc3RyeTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVnaXN0cnk7XG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX0FwaVJlc3BvbnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfQXBpUmVzcG9uc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXBpUmVzcG9uc2UpO1xuXG52YXIgX1V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gX0V4dGVybmFscy5Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1vY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9jayhtZXRob2QsIHBhdGgsIGpzb24sIHN0YXR1cywgc3RhdHVzVGV4dCwgZGVsYXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vY2spO1xuXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fanNvbiA9IGpzb24gfHwge307XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gZGVsYXkgfHwgMTA7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cyB8fCAyMDA7XG4gICAgICAgIHRoaXMuX3N0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8ICdPSyc7XG4gICAgfVxuXG4gICAgTW9jay5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICAgIH07XG5cbiAgICBNb2NrLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiBtZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2Q7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHJlcXVlc3QpIHtcblxuICAgICAgICByZXR1cm4gcmVxdWVzdC51cmwuaW5kZXhPZih0aGlzLl9wYXRoKSA+IC0xICYmIHJlcXVlc3QubWV0aG9kLnRvVXBwZXJDYXNlKCkgPT0gdGhpcy5fbWV0aG9kO1xuICAgIH07XG5cbiAgICBNb2NrLnByb3RvdHlwZS5nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9VdGlscy5kZWxheSkodGhpcy5fZGVsYXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgdGhpcy5jcmVhdGVSZXNwb25zZSh0aGlzLl9qc29uKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVzcG9uc2UoX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0UmVzcG9uc2U7XG4gICAgfSgpO1xuXG4gICAgTW9jay5wcm90b3R5cGUuY3JlYXRlUmVzcG9uc2UgPSBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZShqc29uLCBpbml0KSB7XG5cbiAgICAgICAgaW5pdCA9IGluaXQgfHwge307XG5cbiAgICAgICAgaW5pdC5zdGF0dXMgPSBpbml0LnN0YXR1cyB8fCB0aGlzLl9zdGF0dXM7XG4gICAgICAgIGluaXQuc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dCB8fCB0aGlzLl9zdGF0dXNUZXh0O1xuXG4gICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShqc29uKSxcbiAgICAgICAgICAgIHJlcyA9IG5ldyBfRXh0ZXJuYWxzLlJlc3BvbnNlKHN0ciwgaW5pdCk7XG5cbiAgICAgICAgcmVzLmhlYWRlcnMuc2V0KF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fY29udGVudFR5cGUsIF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fanNvbkNvbnRlbnRUeXBlKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gTW9jaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTW9jaztcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX0F1dGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9BdXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0F1dGgpO1xuXG52YXIgX1V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gX0V4dGVybmFscy5Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUGxhdGZvcm0gPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhQbGF0Zm9ybSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICBmdW5jdGlvbiBQbGF0Zm9ybShjbGllbnQsIGNhY2hlLCBzZXJ2ZXIsIGFwcEtleSwgYXBwU2VjcmV0LCBhcHBOYW1lLCBhcHBWZXJzaW9uLCBzZGtWZXJzaW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF0Zm9ybSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgICBiZWZvcmVMb2dpbjogJ2JlZm9yZUxvZ2luJyxcbiAgICAgICAgICAgIGxvZ2luU3VjY2VzczogJ2xvZ2luU3VjY2VzcycsXG4gICAgICAgICAgICBsb2dpbkVycm9yOiAnbG9naW5FcnJvcicsXG4gICAgICAgICAgICBiZWZvcmVSZWZyZXNoOiAnYmVmb3JlUmVmcmVzaCcsXG4gICAgICAgICAgICByZWZyZXNoU3VjY2VzczogJ3JlZnJlc2hTdWNjZXNzJyxcbiAgICAgICAgICAgIHJlZnJlc2hFcnJvcjogJ3JlZnJlc2hFcnJvcicsXG4gICAgICAgICAgICBiZWZvcmVMb2dvdXQ6ICdiZWZvcmVMb2dvdXQnLFxuICAgICAgICAgICAgbG9nb3V0U3VjY2VzczogJ2xvZ291dFN1Y2Nlc3MnLFxuICAgICAgICAgICAgbG9nb3V0RXJyb3I6ICdsb2dvdXRFcnJvcidcbiAgICAgICAgfTtcblxuXG4gICAgICAgIF90aGlzLl9zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIF90aGlzLl9hcHBLZXkgPSBhcHBLZXk7XG4gICAgICAgIF90aGlzLl9hcHBTZWNyZXQgPSBhcHBTZWNyZXQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtDYWNoZX0gKi9cbiAgICAgICAgX3RoaXMuX2NhY2hlID0gY2FjaGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtDbGllbnR9ICovXG4gICAgICAgIF90aGlzLl9jbGllbnQgPSBjbGllbnQ7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtQcm9taXNlPEFwaVJlc3BvbnNlPn0gKi9cbiAgICAgICAgX3RoaXMuX3JlZnJlc2hQcm9taXNlID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5fYXV0aCA9IG5ldyBfQXV0aDIuZGVmYXVsdChfdGhpcy5fY2FjaGUsIFBsYXRmb3JtLl9jYWNoZUlkKTtcblxuICAgICAgICBfdGhpcy5fdXNlckFnZW50ID0gKGFwcE5hbWUgPyBhcHBOYW1lICsgKGFwcFZlcnNpb24gPyAnLycgKyBhcHBWZXJzaW9uIDogJycpICsgJyAnIDogJycpICsgJ1JDSlNTREsvJyArIHNka1ZlcnNpb247XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0F1dGh9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24gYXV0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0NsaWVudH1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmNsaWVudCA9IGZ1bmN0aW9uIGNsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRTZXJ2ZXJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFkZE1ldGhvZF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZFRva2VuXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmNyZWF0ZVVybCA9IGZ1bmN0aW9uIGNyZWF0ZVVybChwYXRoLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcGF0aCA9IHBhdGggfHwgJyc7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBidWlsdFVybCA9ICcnLFxuICAgICAgICAgICAgaGFzSHR0cCA9IHBhdGguaW5kZXhPZignaHR0cDovLycpICE9IC0xIHx8IHBhdGguaW5kZXhPZignaHR0cHM6Ly8nKSAhPSAtMTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hZGRTZXJ2ZXIgJiYgIWhhc0h0dHApIGJ1aWx0VXJsICs9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKFBsYXRmb3JtLl91cmxQcmVmaXgpID09IC0xICYmICFoYXNIdHRwKSBidWlsdFVybCArPSBQbGF0Zm9ybS5fdXJsUHJlZml4ICsgJy8nICsgUGxhdGZvcm0uX2FwaVZlcnNpb247XG5cbiAgICAgICAgYnVpbHRVcmwgKz0gcGF0aDtcblxuICAgICAgICBpZiAob3B0aW9ucy5hZGRNZXRob2QgfHwgb3B0aW9ucy5hZGRUb2tlbikgYnVpbHRVcmwgKz0gcGF0aC5pbmRleE9mKCc/JykgPiAtMSA/ICcmJyA6ICc/JztcblxuICAgICAgICBpZiAob3B0aW9ucy5hZGRNZXRob2QpIGJ1aWx0VXJsICs9ICdfbWV0aG9kPScgKyBvcHRpb25zLmFkZE1ldGhvZDtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkVG9rZW4pIGJ1aWx0VXJsICs9IChvcHRpb25zLmFkZE1ldGhvZCA/ICcmJyA6ICcnKSArICdhY2Nlc3NfdG9rZW49JyArIHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKTtcblxuICAgICAgICByZXR1cm4gYnVpbHRVcmw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3RhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5icmFuZElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGlzcGxheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnByb21wdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dpblVybCA9IGZ1bmN0aW9uIGxvZ2luVXJsKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVcmwoUGxhdGZvcm0uX2F1dGhvcml6ZUVuZHBvaW50ICsgJz8nICsgKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoe1xuICAgICAgICAgICAgJ3Jlc3BvbnNlX3R5cGUnOiAnY29kZScsXG4gICAgICAgICAgICAncmVkaXJlY3RfdXJpJzogb3B0aW9ucy5yZWRpcmVjdFVyaSB8fCAnJyxcbiAgICAgICAgICAgICdjbGllbnRfaWQnOiB0aGlzLl9hcHBLZXksXG4gICAgICAgICAgICAnc3RhdGUnOiBvcHRpb25zLnN0YXRlIHx8ICcnLFxuICAgICAgICAgICAgJ2JyYW5kX2lkJzogb3B0aW9ucy5icmFuZElkIHx8ICcnLFxuICAgICAgICAgICAgJ2Rpc3BsYXknOiBvcHRpb25zLmRpc3BsYXkgfHwgJycsXG4gICAgICAgICAgICAncHJvbXB0Jzogb3B0aW9ucy5wcm9tcHQgfHwgJydcbiAgICAgICAgfSksIHsgYWRkU2VydmVyOiB0cnVlIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUucGFyc2VMb2dpblJlZGlyZWN0VXJsID0gZnVuY3Rpb24gcGFyc2VMb2dpblJlZGlyZWN0VXJsKHVybCkge1xuXG4gICAgICAgIHZhciBxcyA9ICgwLCBfVXRpbHMucGFyc2VRdWVyeVN0cmluZykodXJsLnNwbGl0KCc/JykucmV2ZXJzZSgpWzBdKSxcbiAgICAgICAgICAgIGVycm9yID0gcXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcXMuZXJyb3I7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBlLmVycm9yID0gcXMuZXJyb3I7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHFzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gaGFuZGxlIDMtbGVnZ2VkIE9BdXRoXG4gICAgICpcbiAgICAgKiBBdHRlbnRpb24hIFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIG1ldGhvZCBhbmQgaXQncyBzaWduYXR1cmUgYW5kIGJlaGF2aW9yIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmxvZ2luXSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvZ2luKClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub3JpZ2luXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcm9wZXJ0eV0gbmFtZSBvZiB3aW5kb3cucG9zdE1lc3NhZ2UncyBldmVudCBkYXRhIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRhcmdldF0gdGFyZ2V0IGZvciB3aW5kb3cub3BlbigpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ2luV2luZG93ID0gZnVuY3Rpb24gbG9naW5XaW5kb3cob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIGlmICghKDAsIF9VdGlscy5pc0Jyb3dzZXIpKCkpIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgb25seSBpbiBicm93c2VyJyk7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51cmwpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBtYW5kYXRvcnkgVVJMIHBhcmFtZXRlcicpO1xuXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgfHwgNDAwO1xuICAgICAgICAgICAgb3B0aW9ucy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgNDAwO1xuICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCA2MDA7XG4gICAgICAgICAgICBvcHRpb25zLm9yaWdpbiA9IG9wdGlvbnMub3JpZ2luIHx8IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgICAgICBvcHRpb25zLnByb3BlcnR5ID0gb3B0aW9ucy5wcm9wZXJ0eSB8fCAnUkNBdXRob3JpemF0aW9uQ29kZSc7XG4gICAgICAgICAgICBvcHRpb25zLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8ICdfYmxhbmsnO1xuXG4gICAgICAgICAgICB2YXIgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCAhPSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuTGVmdCA6IHNjcmVlbi5sZWZ0O1xuICAgICAgICAgICAgdmFyIGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wICE9IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiBzY3JlZW4udG9wO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDogc2NyZWVuLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IDogc2NyZWVuLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSB3aWR0aCAvIDIgLSBvcHRpb25zLndpZHRoIC8gMiArIGR1YWxTY3JlZW5MZWZ0O1xuICAgICAgICAgICAgdmFyIHRvcCA9IGhlaWdodCAvIDIgLSBvcHRpb25zLmhlaWdodCAvIDIgKyBkdWFsU2NyZWVuVG9wO1xuICAgICAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKG9wdGlvbnMudXJsLCAnX2JsYW5rJywgb3B0aW9ucy50YXJnZXQgPT0gJ19ibGFuaycgPyAnc2Nyb2xsYmFycz15ZXMsIHN0YXR1cz15ZXMsIHdpZHRoPScgKyBvcHRpb25zLndpZHRoICsgJywgaGVpZ2h0PScgKyBvcHRpb25zLmhlaWdodCArICcsIGxlZnQ9JyArIGxlZnQgKyAnLCB0b3A9JyArIHRvcCA6ICcnKTtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5mb2N1cykgd2luLmZvY3VzKCk7XG5cbiAgICAgICAgICAgIHZhciBldmVudE1ldGhvZCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50JztcbiAgICAgICAgICAgIHZhciBldmVudFJlbW92ZU1ldGhvZCA9IGV2ZW50TWV0aG9kID09ICdhZGRFdmVudExpc3RlbmVyJyA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdkZXRhY2hFdmVudCc7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZUV2ZW50ID0gZXZlbnRNZXRob2QgPT0gJ2FkZEV2ZW50TGlzdGVuZXInID8gJ21lc3NhZ2UnIDogJ29ubWVzc2FnZSc7XG5cbiAgICAgICAgICAgIHZhciBldmVudExpc3RlbmVyID0gZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcihlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gIT0gb3B0aW9ucy5vcmlnaW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIWUuZGF0YSB8fCAhZS5kYXRhW29wdGlvbnMucHJvcGVydHldKSByZXR1cm47IC8vIGtlZXAgd2FpdGluZ1xuXG4gICAgICAgICAgICAgICAgd2luLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgd2luZG93W2V2ZW50UmVtb3ZlTWV0aG9kXShtZXNzYWdlRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9naW5PcHRpb25zID0gX3RoaXMyLnBhcnNlTG9naW5SZWRpcmVjdFVybChlLmRhdGFbb3B0aW9ucy5wcm9wZXJ0eV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9naW5PcHRpb25zLmNvZGUpIHRocm93IG5ldyBFcnJvcignTm8gYXV0aG9yaXphdGlvbiBjb2RlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShsb2dpbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdpbmRvd1tldmVudE1ldGhvZF0obWVzc2FnZUV2ZW50LCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9nZ2VkSW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVMb2dnZWRJbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDZdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2dnZWRJbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9nZ2VkSW47XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXNlcm5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5wYXNzd29yZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmV4dGVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNvZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZWRpcmVjdFVyaVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmVuZHBvaW50SWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZW1lbWJlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFjY2Vzc1Rva2VuVHRsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVmcmVzaFRva2VuVHRsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9naW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBib2R5LCBhcGlSZXNwb25zZSwganNvbjtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5iZWZvcmVMb2dpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0ge307XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jb2RlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5ncmFudF90eXBlID0gJ3Bhc3N3b3JkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS51c2VybmFtZSA9IG9wdGlvbnMudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkucGFzc3dvcmQgPSBvcHRpb25zLnBhc3N3b3JkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmV4dGVuc2lvbiA9IG9wdGlvbnMuZXh0ZW5zaW9uIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jb2RlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5ncmFudF90eXBlID0gJ2F1dGhvcml6YXRpb25fY29kZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuY29kZSA9IG9wdGlvbnMuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5yZWRpcmVjdF91cmkgPSBvcHRpb25zLnJlZGlyZWN0VXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JvZHkuY2xpZW50X2lkID0gdGhpcy5nZXRDcmVkZW50aWFscygpLmtleTsgLy8gbm90IG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuZHBvaW50SWQpIGJvZHkuZW5kcG9pbnRfaWQgPSBvcHRpb25zLmVuZHBvaW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWNjZXNzVG9rZW5UdGwpIGJvZHkuYWNjZXNzVG9rZW5UdGwgPSBvcHRpb25zLmFjY2Vzc1Rva2VuVHRsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZnJlc2hUb2tlblR0bCkgYm9keS5yZWZyZXNoVG9rZW5UdGwgPSBvcHRpb25zLnJlZnJlc2hUb2tlblR0bDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuUmVxdWVzdChQbGF0Zm9ybS5fdG9rZW5FbmRwb2ludCwgYm9keSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gYXBpUmVzcG9uc2UuanNvbigpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRoLnNldERhdGEoanNvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubG9naW5TdWNjZXNzLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5sb2dpbkVycm9yLCBfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMCwgMTddXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2dpbihfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9naW47XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5fcmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgICB2YXIgcmVzLCBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5iZWZvcmVSZWZyZXNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9VdGlscy5kZWxheSkoUGxhdGZvcm0uX3JlZnJlc2hEZWxheU1zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdXRoLnJlZnJlc2hUb2tlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZyZXNoIHRva2VuIGlzIG1pc3NpbmcnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdXRoLnJlZnJlc2hUb2tlblZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZnJlc2ggdG9rZW4gaGFzIGV4cGlyZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuUmVxdWVzdChQbGF0Zm9ybS5fdG9rZW5FbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdyYW50X3R5cGVcIjogXCJyZWZyZXNoX3Rva2VuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVmcmVzaF90b2tlblwiOiB0aGlzLl9hdXRoLnJlZnJlc2hUb2tlbigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFjY2Vzc190b2tlbl90dGxcIjogdGhpcy5fYXV0aC5kYXRhKCkuZXhwaXJlc19pbiArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVmcmVzaF90b2tlbl90dGxcIjogdGhpcy5fYXV0aC5kYXRhKCkucmVmcmVzaF90b2tlbl9leHBpcmVzX2luICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSByZXMuanNvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NsaWVudC5tYWtlRXJyb3IobmV3IEVycm9yKCdNYWxmb3JtZWQgT0F1dGggcmVzcG9uc2UnKSwgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguc2V0RGF0YShqc29uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZWZyZXNoU3VjY2VzcywgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gdGhpcy5fY2xpZW50Lm1ha2VFcnJvcihfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFBsYXRmb3JtLl9jbGVhckNhY2hlT25SZWZyZXNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMucmVmcmVzaEVycm9yLCBfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzLnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMCwgMTldXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZWZyZXNoO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWZyZXNoUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX3JlZnJlc2hQcm9taXNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMjtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFByb21pc2UgPSB0aGlzLl9yZWZyZXNoKCkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fcmVmcmVzaFByb21pc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDIpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ0LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMiwgN11dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZyZXNoO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY1ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoKSB7XG4gICAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5iZWZvcmVMb2dvdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlblJlcXVlc3QoUGxhdGZvcm0uX3Jldm9rZUVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLl9hdXRoLmFjY2Vzc1Rva2VuKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0NS5zZW50O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ291dFN1Y2Nlc3MsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5sb2dvdXRFcnJvciwgX2NvbnRleHQ1LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NS50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzAsIDEwXV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9nb3V0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxSZXF1ZXN0Pn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmluZmxhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNihyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcEF1dGhDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUxvZ2dlZEluKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ1gtVXNlci1BZ2VudCcsIHRoaXMuX3VzZXJBZ2VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnQ2xpZW50LUlkJywgdGhpcy5fYXBwS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgdGhpcy5fYXV0aEhlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlcXVlc3QudXJsID0gdGhpcy5jcmVhdGVVcmwocmVxdWVzdC51cmwsIHthZGRTZXJ2ZXI6IHRydWV9KTsgLy9GSVhNRSBTcGVjIHByZXZlbnRzIHRoaXMuLi5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBpbmZsYXRlUmVxdWVzdChfeDIsIF94Mykge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5mbGF0ZVJlcXVlc3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjcgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZVJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDcuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcucHJldiA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISghX2NvbnRleHQ3LnQwLmFwaVJlc3BvbnNlIHx8ICFfY29udGV4dDcudDAuYXBpUmVzcG9uc2UucmVzcG9uc2UoKSB8fCBfY29udGV4dDcudDAuYXBpUmVzcG9uc2UucmVzcG9uc2UoKS5zdGF0dXMgIT0gNDAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDcudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRoLmNhbmNlbEFjY2Vzc1Rva2VuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ny5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzLCBbWzAsIDldXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kUmVxdWVzdChfeDQsIF94NSkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZFJlcXVlc3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhbCBwdXJwb3NlIGZ1bmN0aW9uIHRvIHNlbmQgYW55dGhpbmcgdG8gc2VydmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmJvZHldXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1ldGhvZF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucXVlcnldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY4ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRklYTUUgaHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoL2lzc3Vlcy80M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdGhpcy5jcmVhdGVVcmwob3B0aW9ucy51cmwsIHsgYWRkU2VydmVyOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHRoaXMuX2NsaWVudC5jcmVhdGVSZXF1ZXN0KG9wdGlvbnMpLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0OC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VuZChfeDYpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmOC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbmQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcXVlcnldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY5ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkodXJsLCBxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0OS5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0KF94OCwgX3g5LCBfeDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYxMCA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMCh1cmwsIGJvZHksIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBwb3N0KF94MTEsIF94MTIsIF94MTMsIF94MTQpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMTAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2JvZHldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjExID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHVybCwgYm9keSwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BVVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0MTEuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcHV0KF94MTUsIF94MTYsIF94MTcsIF94MTgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMTEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcXVlcnldXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYxMiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMih1cmwsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEyJChfY29udGV4dDEyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMi5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxMiwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfZGVsZXRlKF94MTksIF94MjAsIF94MjEpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZGVsZXRlO1xuICAgIH0oKTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5fdG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEzID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEzKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEF1dGhDaGVjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyB0aGlzLl9hcGlLZXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMy5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxMywgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfdG9rZW5SZXF1ZXN0KF94MjIsIF94MjMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMTMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdG9rZW5SZXF1ZXN0O1xuICAgIH0oKTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5lbnN1cmVMb2dnZWRJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYxNCA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MTQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNBY2Nlc3NUb2tlblZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxNC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxNCwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBlbnN1cmVMb2dnZWRJbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMTQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnN1cmVMb2dnZWRJbjtcbiAgICB9KCk7XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX2lzQWNjZXNzVG9rZW5WYWxpZCA9IGZ1bmN0aW9uIF9pc0FjY2Vzc1Rva2VuVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRoLmFjY2Vzc1Rva2VuVmFsaWQoKTtcbiAgICB9O1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9hcGlLZXkgPSBmdW5jdGlvbiBfYXBpS2V5KCkge1xuICAgICAgICB2YXIgYXBpS2V5ID0gdGhpcy5fYXBwS2V5ICsgJzonICsgdGhpcy5fYXBwU2VjcmV0O1xuICAgICAgICByZXR1cm4gdHlwZW9mIGJ0b2EgPT0gJ2Z1bmN0aW9uJyA/IGJ0b2EoYXBpS2V5KSA6IG5ldyBCdWZmZXIoYXBpS2V5KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5fYXV0aEhlYWRlciA9IGZ1bmN0aW9uIF9hdXRoSGVhZGVyKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLl9hdXRoLmFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRoLnRva2VuVHlwZSgpICsgKHRva2VuID8gJyAnICsgdG9rZW4gOiAnJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBQbGF0Zm9ybTtcbn0oX2V2ZW50czIuZGVmYXVsdCk7XG5cblBsYXRmb3JtLl91cmxQcmVmaXggPSAnL3Jlc3RhcGknO1xuUGxhdGZvcm0uX2FwaVZlcnNpb24gPSAndjEuMCc7XG5QbGF0Zm9ybS5fdG9rZW5FbmRwb2ludCA9ICcvcmVzdGFwaS9vYXV0aC90b2tlbic7XG5QbGF0Zm9ybS5fcmV2b2tlRW5kcG9pbnQgPSAnL3Jlc3RhcGkvb2F1dGgvcmV2b2tlJztcblBsYXRmb3JtLl9hdXRob3JpemVFbmRwb2ludCA9ICcvcmVzdGFwaS9vYXV0aC9hdXRob3JpemUnO1xuUGxhdGZvcm0uX3JlZnJlc2hEZWxheU1zID0gMTAwO1xuUGxhdGZvcm0uX2NhY2hlSWQgPSAncGxhdGZvcm0nO1xuUGxhdGZvcm0uX2NsZWFyQ2FjaGVPblJlZnJlc2hFcnJvciA9IGZhbHNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGxhdGZvcm07XG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEF1dGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0aChjYWNoZSwgY2FjaGVJZCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXV0aCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtDYWNoZX0gKi9cbiAgICAgICAgdGhpcy5fY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5fY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgfSAvLyAxIG1pbnV0ZVxuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5hY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIGFjY2Vzc1Rva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCkuYWNjZXNzX3Rva2VuO1xuICAgIH07XG5cbiAgICBBdXRoLnByb3RvdHlwZS5yZWZyZXNoVG9rZW4gPSBmdW5jdGlvbiByZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5yZWZyZXNoX3Rva2VuO1xuICAgIH07XG5cbiAgICBBdXRoLnByb3RvdHlwZS50b2tlblR5cGUgPSBmdW5jdGlvbiB0b2tlblR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS50b2tlbl90eXBlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHt7dG9rZW5fdHlwZTogc3RyaW5nLCBhY2Nlc3NfdG9rZW46IHN0cmluZywgZXhwaXJlc19pbjogbnVtYmVyLCByZWZyZXNoX3Rva2VuOiBzdHJpbmcsIHJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbjogbnVtYmVyfX1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIGRhdGEoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmdldEl0ZW0odGhpcy5fY2FjaGVJZCkgfHwge1xuICAgICAgICAgICAgdG9rZW5fdHlwZTogJycsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46ICcnLFxuICAgICAgICAgICAgZXhwaXJlc19pbjogMCxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46ICcnLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiAwXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdEYXRhXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEobmV3RGF0YSkge1xuXG4gICAgICAgIG5ld0RhdGEgPSBuZXdEYXRhIHx8IHt9O1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobmV3RGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSBuZXdEYXRhW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhdGEuZXhwaXJlX3RpbWUgPSBEYXRlLm5vdygpICsgZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgZGF0YS5yZWZyZXNoX3Rva2VuX2V4cGlyZV90aW1lID0gRGF0ZS5ub3coKSArIGRhdGEucmVmcmVzaF90b2tlbl9leHBpcmVzX2luICogMTAwMDtcblxuICAgICAgICB0aGlzLl9jYWNoZS5zZXRJdGVtKHRoaXMuX2NhY2hlSWQsIGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBpcyBhIHZhbGlkIChub3QgZXhwaXJlZCkgYWNjZXNzIHRva2VuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuYWNjZXNzVG9rZW5WYWxpZCA9IGZ1bmN0aW9uIGFjY2Vzc1Rva2VuVmFsaWQoKSB7XG5cbiAgICAgICAgdmFyIGF1dGhEYXRhID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIHJldHVybiBhdXRoRGF0YS50b2tlbl90eXBlID09PSBBdXRoLmZvcmNlZFRva2VuVHlwZSB8fCBhdXRoRGF0YS5leHBpcmVfdGltZSAtIEF1dGgucmVmcmVzaEhhbmRpY2FwTXMgPiBEYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBpcyBhIHZhbGlkIChub3QgZXhwaXJlZCkgYWNjZXNzIHRva2VuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUucmVmcmVzaFRva2VuVmFsaWQgPSBmdW5jdGlvbiByZWZyZXNoVG9rZW5WYWxpZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCkucmVmcmVzaF90b2tlbl9leHBpcmVfdGltZSA+IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0F1dGh9XG4gICAgICovXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmNhbmNlbEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gY2FuY2VsQWNjZXNzVG9rZW4oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RGF0YSh7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46ICcnLFxuICAgICAgICAgICAgZXhwaXJlc19pbjogMFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyBhIHNwZWNpYWwgYXV0aGVudGljYXRpb24gbW9kZSB1c2VkIGluIFNlcnZpY2UgV2ViXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuZm9yY2VBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uIGZvcmNlQXV0aGVudGljYXRpb24oKSB7XG5cbiAgICAgICAgdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgIHRva2VuX3R5cGU6IEF1dGguZm9yY2VkVG9rZW5UeXBlLFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiAnJyxcbiAgICAgICAgICAgIGV4cGlyZXNfaW46IDAsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiAnJyxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbjogMFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF1dGg7XG59KCk7XG5cbi8vZXhwb3J0IGludGVyZmFjZSBJQXV0aERhdGEge1xuLy8gICAgcmVtZW1iZXI/OmJvb2xlYW47XG4vLyAgICB0b2tlbl90eXBlPzpzdHJpbmc7XG4vLyAgICBhY2Nlc3NfdG9rZW4/OnN0cmluZztcbi8vICAgIGV4cGlyZXNfaW4/Om51bWJlcjsgLy8gYWN0dWFsbHkgaXQncyBzdHJpbmdcbi8vICAgIGV4cGlyZV90aW1lPzpudW1iZXI7XG4vLyAgICByZWZyZXNoX3Rva2VuPzpzdHJpbmc7XG4vLyAgICByZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4/Om51bWJlcjsgLy8gYWN0dWFsbHkgaXQncyBzdHJpbmdcbi8vICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlX3RpbWU/Om51bWJlcjtcbi8vICAgIHNjb3BlPzpzdHJpbmc7XG4vL31cblxuXG5BdXRoLnJlZnJlc2hIYW5kaWNhcE1zID0gNjAgKiAxMDAwO1xuQXV0aC5mb3JjZWRUb2tlblR5cGUgPSAnZm9yY2VkJztcbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGg7XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QdWJudWJNb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfUHVibnViTW9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QdWJudWJNb2NrKTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUHVibnViTW9ja0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVibnViTW9ja0ZhY3RvcnkoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJudWJNb2NrRmFjdG9yeSk7XG5cbiAgICAgICAgdGhpcy5jcnlwdG9fb2JqID0gX0V4dGVybmFscy5QVUJOVUIuY3J5cHRvX29iajtcbiAgICB9XG5cbiAgICBQdWJudWJNb2NrRmFjdG9yeS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IF9QdWJudWJNb2NrMi5kZWZhdWx0KG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHVibnViTW9ja0ZhY3Rvcnk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFB1Ym51Yk1vY2tGYWN0b3J5O1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFB1Ym51Yk1vY2sgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhQdWJudWJNb2NrLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFB1Ym51Yk1vY2sob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVibnViTW9jayk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMuY3J5cHRvX29iaiA9IF9FeHRlcm5hbHMuUFVCTlVCLmNyeXB0b19vYmo7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfTtcblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoKSB7fTtcblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub24oJ21lc3NhZ2UtJyArIG9wdGlvbnMuY2hhbm5lbCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICB9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdtZXNzYWdlLScgKyBvcHRpb25zLmNoYW5uZWwpO1xuICAgIH07XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS5yZWNlaXZlTWVzc2FnZSA9IGZ1bmN0aW9uIHJlY2VpdmVNZXNzYWdlKG1zZywgY2hhbm5lbCkge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UtJyArIGNoYW5uZWwsIG1zZywgJ2VudicsIGNoYW5uZWwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHVibnViTW9jaztcbn0oX2V2ZW50czIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFB1Ym51Yk1vY2s7XG5cbi8qKiovIH0sXG4vKiAxOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFN1YnNjcmlwdGlvbiwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24ocHVibnViRmFjdG9yeSwgcGxhdGZvcm0pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNjcmlwdGlvbik7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb246ICdub3RpZmljYXRpb24nLFxuICAgICAgICAgICAgcmVtb3ZlU3VjY2VzczogJ3JlbW92ZVN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVtb3ZlRXJyb3I6ICdyZW1vdmVFcnJvcicsXG4gICAgICAgICAgICByZW5ld1N1Y2Nlc3M6ICdyZW5ld1N1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVuZXdFcnJvcjogJ3JlbmV3RXJyb3InLFxuICAgICAgICAgICAgc3Vic2NyaWJlU3VjY2VzczogJ3N1YnNjcmliZVN1Y2Nlc3MnLFxuICAgICAgICAgICAgc3Vic2NyaWJlRXJyb3I6ICdzdWJzY3JpYmVFcnJvcidcbiAgICAgICAgfTtcblxuXG4gICAgICAgIF90aGlzLl9wdWJudWJGYWN0b3J5ID0gcHVibnViRmFjdG9yeTtcbiAgICAgICAgX3RoaXMuX3BsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIF90aGlzLl9wdWJudWIgPSBudWxsO1xuICAgICAgICBfdGhpcy5fcHVibnViTGFzdENoYW5uZWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZWQgPSBmdW5jdGlvbiBzdWJzY3JpYmVkKCkge1xuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbigpO1xuXG4gICAgICAgIHJldHVybiAhIShzdWJzY3JpcHRpb24uaWQgJiYgc3Vic2NyaXB0aW9uLmRlbGl2ZXJ5TW9kZSAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlLnN1YnNjcmliZXJLZXkgJiYgc3Vic2NyaXB0aW9uLmRlbGl2ZXJ5TW9kZS5hZGRyZXNzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hbGl2ZSA9IGZ1bmN0aW9uIGFsaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVkKCkgJiYgRGF0ZS5ub3coKSA8IHRoaXMuZXhwaXJhdGlvblRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5leHBpcmVkID0gZnVuY3Rpb24gZXhwaXJlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZWQoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhdGhpcy5zdWJzY3JpYmVkKCkgfHwgRGF0ZS5ub3coKSA+IHRoaXMuc3Vic2NyaXB0aW9uKCkuZXhwaXJhdGlvblRpbWU7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZXhwaXJhdGlvblRpbWUgPSBmdW5jdGlvbiBleHBpcmF0aW9uVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuc3Vic2NyaXB0aW9uKCkuZXhwaXJhdGlvblRpbWUgfHwgMCkuZ2V0VGltZSgpIC0gU3Vic2NyaXB0aW9uLl9yZW5ld0hhbmRpY2FwTXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc2V0U3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbiB8fCB7fTtcblxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUF0UHVibnViKCk7XG4gICAgICAgIHRoaXMuX3NldFRpbWVvdXQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBzdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb24gfHwge307XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgdXBkYXRlcyBzdWJzY3JpcHRpb24gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIG9uZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5ldygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdpc3RlcjtcbiAgICB9KCk7XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIGV2ZW50RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uKCkuZXZlbnRGaWx0ZXJzIHx8IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudHNcbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkRXZlbnRGaWx0ZXJzID0gZnVuY3Rpb24gYWRkRXZlbnRGaWx0ZXJzKGV2ZW50cykge1xuICAgICAgICB0aGlzLnNldEV2ZW50RmlsdGVycyh0aGlzLmV2ZW50RmlsdGVycygpLmNvbmNhdChldmVudHMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zZXRFdmVudEZpbHRlcnMgPSBmdW5jdGlvbiBzZXRFdmVudEZpbHRlcnMoZXZlbnRzKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbigpO1xuICAgICAgICBzdWJzY3JpcHRpb24uZXZlbnRGaWx0ZXJzID0gZXZlbnRzO1xuICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudHMgYXJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybS5wb3N0KCcvc3Vic2NyaXB0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEZpbHRlcnM6IHRoaXMuX2dldEZ1bGxFdmVudEZpbHRlcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaXZlcnlNb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRUeXBlOiAnUHViTnViJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSByZXNwb25zZS5qc29uKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uKGpzb24pLmVtaXQodGhpcy5ldmVudHMuc3Vic2NyaWJlU3VjY2VzcywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoJ3JldHVybicsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MlsnY2F0Y2gnXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gdGhpcy5fcGxhdGZvcm0uY2xpZW50KCkubWFrZUVycm9yKF9jb250ZXh0Mi50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCkuZW1pdCh0aGlzLmV2ZW50cy5zdWJzY3JpYmVFcnJvciwgX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Mi50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxMl1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVuZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlLCBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWJzY3JpcHRpb24nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RmlsdGVycygpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRzIGFyZSB1bmRlZmluZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm0ucHV0KCcvc3Vic2NyaXB0aW9uLycgKyB0aGlzLnN1YnNjcmlwdGlvbigpLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RmlsdGVyczogdGhpcy5fZ2V0RnVsbEV2ZW50RmlsdGVycygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSByZXNwb25zZS5qc29uKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uKGpzb24pLmVtaXQodGhpcy5ldmVudHMucmVuZXdTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzWydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKS5lbWl0KHRoaXMuZXZlbnRzLnJlbmV3RXJyb3IsIF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMsIFtbMCwgMTRdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiByZW5ldygpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmV3O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybS5kZWxldGUoJy9zdWJzY3JpcHRpb24vJyArIHRoaXMuc3Vic2NyaXB0aW9uKCkuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDQuc2VudDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpLmVtaXQodGhpcy5ldmVudHMucmVtb3ZlU3VjY2VzcywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoJ3JldHVybicsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFsnY2F0Y2gnXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gdGhpcy5fcGxhdGZvcm0uY2xpZW50KCkubWFrZUVycm9yKF9jb250ZXh0NC50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMucmVtb3ZlRXJyb3IsIF9jb250ZXh0NC50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMsIFtbMCwgMTBdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlc3Vic2NyaWJlID0gZnVuY3Rpb24gcmVzdWJzY3JpYmUoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5ldmVudEZpbHRlcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKS5zZXRFdmVudEZpbHRlcnMoZmlsdGVycykuc3Vic2NyaWJlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzdWJzY3JpcHRpb24gYW5kIGRpc2Nvbm5lY3QgZnJvbSBQVUJOVUJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldHMgc3Vic2NyaXB0aW9uIGF0IGNsaWVudCBzaWRlIGJ1dCBiYWNrZW5kIGlzIG5vdCBub3RpZmllZFxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKCkgJiYgdGhpcy5fcHVibnViKSB0aGlzLl9wdWJudWIudW5zdWJzY3JpYmUoeyBjaGFubmVsOiB0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5hZGRyZXNzIH0pO1xuICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24obnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9zZXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBfc2V0U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2dldEZ1bGxFdmVudEZpbHRlcnMgPSBmdW5jdGlvbiBfZ2V0RnVsbEV2ZW50RmlsdGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRGaWx0ZXJzKCkubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fcGxhdGZvcm0uY3JlYXRlVXJsKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFRpbWVvdXQgPSBmdW5jdGlvbiBfc2V0VGltZW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFsaXZlKCkpIHRocm93IG5ldyBFcnJvcignU3Vic2NyaXB0aW9uIGlzIG5vdCBhbGl2ZScpO1xuXG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuYWxpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmV4cGlyZWQoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnJlbmV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFN1YnNjcmlwdGlvbi5fcG9sbEludGVydmFsKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2RlY3J5cHQgPSBmdW5jdGlvbiBfZGVjcnlwdChtZXNzYWdlKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZWQoKSkgdGhyb3cgbmV3IEVycm9yKCdObyBzdWJzY3JpcHRpb24nKTtcblxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24oKS5kZWxpdmVyeU1vZGUuZW5jcnlwdGlvbktleSkge1xuXG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5fcHVibnViRmFjdG9yeS5jcnlwdG9fb2JqLmRlY3J5cHQobWVzc2FnZSwgdGhpcy5zdWJzY3JpcHRpb24oKS5kZWxpdmVyeU1vZGUuZW5jcnlwdGlvbktleSwge1xuICAgICAgICAgICAgICAgIGVuY3J5cHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtleUVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgICAgICAgICBrZXlMZW5ndGg6IDEyOCxcbiAgICAgICAgICAgICAgICBtb2RlOiAnZWNiJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fbm90aWZ5ID0gZnVuY3Rpb24gX25vdGlmeShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5ub3RpZmljYXRpb24sIHRoaXMuX2RlY3J5cHQobWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fc3Vic2NyaWJlQXRQdWJudWIgPSBmdW5jdGlvbiBfc3Vic2NyaWJlQXRQdWJudWIoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFsaXZlKCkpIHRocm93IG5ldyBFcnJvcignU3Vic2NyaXB0aW9uIGlzIG5vdCBhbGl2ZScpO1xuXG4gICAgICAgIHZhciBkZWxpdmVyeU1vZGUgPSB0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZTtcblxuICAgICAgICBpZiAodGhpcy5fcHVibnViKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCA9PSBkZWxpdmVyeU1vZGUuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gdXBkYXRlLCBrZWVwIGxpc3RlbmluZyB0byBzYW1lIGNoYW5uZWxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHVibnViTGFzdENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHN1YnNjcmliZSB0byBuZXcgY2hhbm5lbFxuICAgICAgICAgICAgICAgIHRoaXMuX3B1Ym51Yi51bnN1YnNjcmliZSh7IGNoYW5uZWw6IHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZS1pbml0IGZvciBuZXcgZGF0YVxuICAgICAgICAgICAgdGhpcy5fcHVibnViID0gdGhpcy5fcHVibnViLmluaXQoe1xuICAgICAgICAgICAgICAgIHNzbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVfa2V5OiBkZWxpdmVyeU1vZGUuc3Vic2NyaWJlcktleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEluaXQgZnJvbSBzY3JhdGNoXG4gICAgICAgICAgICB0aGlzLl9wdWJudWIgPSB0aGlzLl9wdWJudWJGYWN0b3J5LmluaXQoe1xuICAgICAgICAgICAgICAgIHNzbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVfa2V5OiBkZWxpdmVyeU1vZGUuc3Vic2NyaWJlcktleVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3B1Ym51Yi5yZWFkeSgpOyAvL1RPRE8gVGhpcyBtYXkgYmUgbm90IG5lZWRlZCBhbnltb3JlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCA9IGRlbGl2ZXJ5TW9kZS5hZGRyZXNzO1xuXG4gICAgICAgIHRoaXMuX3B1Ym51Yi5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgY2hhbm5lbDogZGVsaXZlcnlNb2RlLmFkZHJlc3MsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLl9ub3RpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7fVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oX2V2ZW50czIuZGVmYXVsdCk7XG5cbi8vZXhwb3J0IGludGVyZmFjZSBJU3Vic2NyaXB0aW9uIHtcbi8vICAgIGlkPzpzdHJpbmc7XG4vLyAgICB1cmk/OiBzdHJpbmc7XG4vLyAgICBldmVudEZpbHRlcnM/OnN0cmluZ1tdO1xuLy8gICAgZXhwaXJhdGlvblRpbWU/OnN0cmluZzsgLy8gMjAxNC0wMy0xMlQxOTo1NDozNS42MTNaXG4vLyAgICBleHBpcmVzSW4/Om51bWJlcjtcbi8vICAgIGRlbGl2ZXJ5TW9kZT86IHtcbi8vICAgICAgICB0cmFuc3BvcnRUeXBlPzpzdHJpbmc7XG4vLyAgICAgICAgZW5jcnlwdGlvbj86Ym9vbGVhbjtcbi8vICAgICAgICBhZGRyZXNzPzpzdHJpbmc7XG4vLyAgICAgICAgc3Vic2NyaWJlcktleT86c3RyaW5nO1xuLy8gICAgICAgIGVuY3J5cHRpb25LZXk/OnN0cmluZztcbi8vICAgICAgICBzZWNyZXRLZXk/OnN0cmluZztcbi8vICAgIH07XG4vLyAgICBjcmVhdGlvblRpbWU/OnN0cmluZzsgLy8gMjAxNC0wMy0xMlQxOTo1NDozNS42MTNaXG4vLyAgICBzdGF0dXM/OnN0cmluZzsgLy8gQWN0aXZlXG4vL31cblxuXG5TdWJzY3JpcHRpb24uX3JlbmV3SGFuZGljYXBNcyA9IDIgKiA2MCAqIDEwMDA7XG5TdWJzY3JpcHRpb24uX3BvbGxJbnRlcnZhbCA9IDEwICogMTAwMDtcbmV4cG9ydHMuZGVmYXVsdCA9IFN1YnNjcmlwdGlvbjtcblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfU3Vic2NyaXB0aW9uMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgX1N1YnNjcmlwdGlvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdWJzY3JpcHRpb24yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ2FjaGVkU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9TdWJzY3JpcHRpb24pIHtcbiAgICBfaW5oZXJpdHMoQ2FjaGVkU3Vic2NyaXB0aW9uLCBfU3Vic2NyaXB0aW9uKTtcblxuICAgIGZ1bmN0aW9uIENhY2hlZFN1YnNjcmlwdGlvbihwdWJudWJGYWN0b3J5LCBwbGF0Zm9ybSwgY2FjaGUsIGNhY2hlS2V5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZWRTdWJzY3JpcHRpb24pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Q2FjaGV9ICovXG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIHB1Ym51YkZhY3RvcnksIHBsYXRmb3JtKSk7XG5cbiAgICAgICAgX3RoaXMuX2NhY2hlID0gY2FjaGU7XG4gICAgICAgIF90aGlzLl9jYWNoZUtleSA9IGNhY2hlS2V5O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBDYWNoZWRTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIHN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmdldEl0ZW0odGhpcy5fY2FjaGVLZXkpIHx8IHt9O1xuICAgIH07XG5cbiAgICBDYWNoZWRTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9zZXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBfc2V0U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuc2V0SXRlbSh0aGlzLl9jYWNoZUtleSwgc3Vic2NyaXB0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjaGVja3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IHByZS1kZWZpbmVkIGV2ZW50RmlsdGVycyBpbiBjYWNoZSBhbmQgaWYgbm90IC0tIHVzZXMgcHJvdmlkZWQgYXMgZGVmYXVsdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudHNcbiAgICAgKiBAcmV0dXJuIHtDYWNoZWRTdWJzY3JpcHRpb259XG4gICAgICovXG5cblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoZXZlbnRzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50RmlsdGVycygpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRFdmVudEZpbHRlcnMoZXZlbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FjaGVkU3Vic2NyaXB0aW9uO1xufShfU3Vic2NyaXB0aW9uMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FjaGVkU3Vic2NyaXB0aW9uO1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaW5nY2VudHJhbC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC9idWlsZC9yaW5nY2VudHJhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn0gZWxzZSB7XG4gIC8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG4gIEJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG4gIEJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2J1ZmZlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYXNlNjQtanMvbGliL2I2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qYWtlYXJjaGliYWxkL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMi4xXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheSA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm47XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuXSA9IGNhbGxiYWNrO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKz0gMjtcbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID09PSAyKSB7XG4gICAgICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcChhc2FwRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gYXNhcEZuO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgfHwge307XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4gICAgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpIHtcbiAgICAgIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdmVydHhcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2ViIHdvcmtlclxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuOyBpKz0yKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgdmFyIGFyZyA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByID0gcmVxdWlyZTtcbiAgICAgICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaDtcbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdGhlbiQkdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoY2hpbGRbbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZShjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkdGhlbiQkdGhlbjtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlKG9iamVjdCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmU7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCgpIHt9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAgPSAyO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbikge1xuICAgICAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiZcbiAgICAgICAgICB0aGVuID09PSBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCAmJlxuICAgICAgICAgIGNvbnN0cnVjdG9yLnJlc29sdmUgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQ7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICAgICAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFsdWUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpZCA9IDA7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbmV4dElkKCkge1xuICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbWFrZVByb21pc2UocHJvbWlzZSkge1xuICAgICAgcHJvbWlzZVtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkKys7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGwoZW50cmllcykge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGw7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKCFsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2U7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3QocmVhc29uKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0O1xuXG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlO1xuICAgIC8qKlxuICAgICAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICAgICAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIFRlcm1pbm9sb2d5XG4gICAgICAtLS0tLS0tLS0tLVxuXG4gICAgICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAgICAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAgICAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gICAgICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gICAgICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICAgICAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gICAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICAgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICAgICAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgICAgIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICAgICAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICAgICAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gICAgICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gICAgICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gICAgICBCYXNpYyBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBgYGBqc1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gb24gc3VjY2Vzc1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgICAgICAvLyBvbiBmYWlsdXJlXG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICAgICAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gICAgICBgYGBqc1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICAgICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgICAgIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICAgICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgICAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBjbGFzcyBQcm9taXNlXG4gICAgICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgdGhpc1tsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5leHRJZCgpO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIHRoaXMgaW5zdGFuY2VvZiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSA/IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yYWNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZXNvbHZlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldFNjaGVkdWxlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXI7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldEFzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fYXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwO1xuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLFxuXG4gICAgLyoqXG4gICAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQ2hhaW5pbmdcbiAgICAgIC0tLS0tLS0tXG5cbiAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgICAgfSk7XG5cbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICAgIH0pO1xuICAgICAgYGBgXG4gICAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBc3NpbWlsYXRpb25cbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgU2ltcGxlIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgYXV0aG9yLCBib29rcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG5cbiAgICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuXG4gICAgICB9XG5cbiAgICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZEF1dGhvcigpLlxuICAgICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIHRoZW5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICB0aGVuOiBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCxcblxuICAgIC8qKlxuICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN5bmNocm9ub3VzXG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQXV0aG9yKCk7XG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfVxuXG4gICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgY2F0Y2hcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoIXRoaXMucHJvbWlzZVtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGlucHV0KSkge1xuICAgICAgICB0aGlzLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QodGhpcy5wcm9taXNlLCBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCR2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCAgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBpbnB1dCAgID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgICAgdmFyIHJlc29sdmUgPSBjLnJlc29sdmU7XG5cbiAgICAgIGlmIChyZXNvbHZlID09PSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0KSB7XG4gICAgICAgIHZhciB0aGVuID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihlbnRyeSk7XG5cbiAgICAgICAgaWYgKHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ICYmXG4gICAgICAgICAgICBlbnRyeS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0KSB7XG4gICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCB0aGVuKTtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uKHJlc29sdmUpIHsgcmVzb2x2ZShlbnRyeSk7IH0pLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsKCkge1xuICAgICAgdmFyIGxvY2FsO1xuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgICBpZiAoUCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsLlByb21pc2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGw7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQsXG4gICAgICAncG9seWZpbGwnOiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHRcbiAgICB9O1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZTp0cnVlIG1vZHVsZTp0cnVlIHdpbmRvdzogdHJ1ZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQoKTtcbn0pLmNhbGwodGhpcyk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogdmVydHggKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW25hbWVdXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW11cbiAgICAgIHRoaXMubWFwW25hbWVdID0gbGlzdFxuICAgIH1cbiAgICBsaXN0LnB1c2godmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gICAgcmV0dXJuIHZhbHVlcyA/IHZhbHVlc1swXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gfHwgW11cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBbbm9ybWFsaXplVmFsdWUodmFsdWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5tYXApLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5tYXBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgICAgfSwgdGhpcylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgICAgfSBlbHNlIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgLy8gT25seSBzdXBwb3J0IEFycmF5QnVmZmVycyBmb3IgUE9TVCBtZXRob2QuXG4gICAgICAgIC8vIFJlY2VpdmluZyBBcnJheUJ1ZmZlcnMgaGFwcGVucyB2aWEgQmxvYnMsIGluc3RlYWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQgOiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG4gICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpKSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gaW5wdXRcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgIGJvZHkudHJpbSgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gaGVhZGVycyh4aHIpIHtcbiAgICB2YXIgaGVhZCA9IG5ldyBIZWFkZXJzKClcbiAgICB2YXIgcGFpcnMgPSAoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKS50cmltKCkuc3BsaXQoJ1xcbicpXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHNwbGl0LnNoaWZ0KCkudHJpbSgpXG4gICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc6JykudHJpbSgpXG4gICAgICBoZWFkLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1c1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHRcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gb3B0aW9ucy5oZWFkZXJzIDogbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdFxuICAgICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpICYmICFpbml0KSB7XG4gICAgICAgIHJlcXVlc3QgPSBpbnB1dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgZnVuY3Rpb24gcmVzcG9uc2VVUkwoKSB7XG4gICAgICAgIGlmICgncmVzcG9uc2VVUkwnIGluIHhocikge1xuICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VVUkxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIHNlY3VyaXR5IHdhcm5pbmdzIG9uIGdldFJlc3BvbnNlSGVhZGVyIHdoZW4gbm90IGFsbG93ZWQgYnkgQ09SU1xuICAgICAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzKSA/IDIwNCA6IHhoci5zdGF0dXNcbiAgICAgICAgaWYgKHN0YXR1cyA8IDEwMCB8fCBzdGF0dXMgPiA1OTkpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMoeGhyKSxcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlVVJMKClcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmluZ2NlbnRyYWwvfi93aGF0d2ctZmV0Y2gvZmV0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qISAzLjE1LjIgLyBtb2Rlcm4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlBVQk5VQlwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQVUJOVUJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogZ2xvYmFscyAnTW9kZXJuJyAqL1xuXHQvKiBlc2xpbnQgY3VybHk6IDAsIGNhbWVsY2FzZTogMCwgZG90LW5vdGF0aW9uOiAwICovXG5cblx0dmFyIHBhY2thZ2VKU09OID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0dmFyIHB1Yk51YkNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgY3J5cHRvX29iaiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBDcnlwdG9KUyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBXUyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cblx0LyoqXG5cdCAqIFVUSUwgTE9DQUxTXG5cdCAqL1xuXHR2YXIgUE5TREsgPSAnUHViTnViLUpTLScgKyAnTW9kZXJuJyArICcvJyArIHBhY2thZ2VKU09OLnZlcnNpb247XG5cblx0LyoqXG5cdCAqIExPQ0FMIFNUT1JBR0Vcblx0ICovXG5cdHZhciBkYiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGxzID0gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYWxTdG9yYWdlO1xuXHQgIHJldHVybiB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAobHMpIHJldHVybiBscy5nZXRJdGVtKGtleSk7XG5cdCAgICAgICAgaWYgKGRvY3VtZW50LmNvb2tpZS5pbmRleE9mKGtleSkgPT09IC0xKSByZXR1cm4gbnVsbDtcblx0ICAgICAgICByZXR1cm4gKChkb2N1bWVudC5jb29raWUgfHwgJycpLm1hdGNoKFxuXHQgICAgICAgICAgICBSZWdFeHAoa2V5ICsgJz0oW147XSspJylcblx0ICAgICAgICAgICkgfHwgW10pWzFdIHx8IG51bGw7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKGxzKSByZXR1cm4gbHMuc2V0SXRlbShrZXksIHZhbHVlKSAmJiAwO1xuXHQgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGtleSArICc9JyArIHZhbHVlICtcblx0ICAgICAgICAgICc7IGV4cGlyZXM9VGh1LCAxIEF1ZyAyMDMwIDIwOjAwOjAwIFVUQzsgcGF0aD0vJztcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdH0pKCk7XG5cblxuXHQvKipcblx0ICogQ09SUyBYSFIgUmVxdWVzdFxuXHQgKiA9PT09PT09PT09PT09PT09XG5cdCAqICB4ZHIoe1xuXHQgKiAgICAgdXJsICAgICA6IFsnaHR0cDovL3d3dy5ibGFoLmNvbS91cmwnXSxcblx0ICogICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbihyZXNwb25zZSkge30sXG5cdCAqICAgICBmYWlsICAgIDogZnVuY3Rpb24oKSB7fVxuXHQgKiAgfSk7XG5cdCAqL1xuXHRmdW5jdGlvbiB4ZHIoc2V0dXApIHtcblx0ICB2YXIgeGhyO1xuXHQgIHZhciB0aW1lcjtcblx0ICB2YXIgY29tcGxldGUgPSAwO1xuXHQgIHZhciBsb2FkZWQgPSAwO1xuXHQgIHZhciBhc3luYyA9IHRydWU7IC8qIGRvIG5vdCBhbGxvdyBzeW5jIG9wZXJhdGlvbnMgaW4gbW9kZXJuIGJ1aWxkcyAqL1xuXHQgIHZhciB4aHJ0bWUgPSBzZXR1cC50aW1lb3V0IHx8IHB1Yk51YkNvcmUuREVGX1RJTUVPVVQ7XG5cdCAgdmFyIGRhdGEgPSBzZXR1cC5kYXRhIHx8IHt9O1xuXHQgIHZhciBmYWlsID0gc2V0dXAuZmFpbCB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICB2YXIgc3VjY2VzcyA9IHNldHVwLnN1Y2Nlc3MgfHwgZnVuY3Rpb24gKCkge307XG5cblx0ICB2YXIgZG9uZSA9IGZ1bmN0aW9uIChmYWlsZWQsIHJlc3BvbnNlKSB7XG5cdCAgICBpZiAoY29tcGxldGUpIHJldHVybjtcblx0ICAgIGNvbXBsZXRlID0gMTtcblxuXHQgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHQgICAgaWYgKHhocikge1xuXHQgICAgICB4aHIub25lcnJvciA9IHhoci5vbmxvYWQgPSBudWxsO1xuXHQgICAgICBpZiAoeGhyLmFib3J0KSB4aHIuYWJvcnQoKTtcblx0ICAgICAgeGhyID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZhaWxlZCkgZmFpbChyZXNwb25zZSk7XG5cdCAgfTtcblxuXHQgIHZhciBmaW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChsb2FkZWQpIHJldHVybjtcblx0ICAgIHZhciByZXNwb25zZTtcblx0ICAgIGxvYWRlZCA9IDE7XG5cblx0ICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcblx0ICAgIH0gY2F0Y2ggKHIpIHtcblx0ICAgICAgcmV0dXJuIGRvbmUoMSk7XG5cdCAgICB9XG5cblx0ICAgIHN1Y2Nlc3MocmVzcG9uc2UpO1xuXHQgIH07XG5cblx0ICB0aW1lciA9IHB1Yk51YkNvcmUudGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICBkb25lKDEpO1xuXHQgIH0sIHhocnRtZSk7XG5cblx0ICAvLyBTZW5kXG5cdCAgdHJ5IHtcblx0ICAgIHhociA9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgbmV3IFhEb21haW5SZXF1ZXN0KCkgfHxcblx0ICAgICAgbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0ICAgIHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGRvbmUoMSwgeGhyLnJlc3BvbnNlVGV4dCB8fCB7IGVycm9yOiAnTmV0d29yayBDb25uZWN0aW9uIEVycm9yJyB9KTtcblx0ICAgIH07XG5cdCAgICB4aHIub25sb2FkID0geGhyLm9ubG9hZGVuZCA9IGZpbmlzaGVkO1xuXG5cdCAgICBkYXRhLnBuc2RrID0gUE5TREs7XG5cdCAgICB2YXIgdXJsID0gcHViTnViQ29yZS5idWlsZF91cmwoc2V0dXAudXJsLCBkYXRhKTtcblx0ICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcblx0ICAgIGlmIChhc3luYykgeGhyLnRpbWVvdXQgPSB4aHJ0bWU7XG5cdCAgICB4aHIuc2VuZCgpO1xuXHQgIH0gY2F0Y2ggKGVlZSkge1xuXHQgICAgZG9uZSgxLCB7IGVycm9yOiAnWEhSIEZhaWxlZCcsIHN0YWNrdHJhY2U6IGVlZSB9KTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gJ2RvbmUnXG5cdCAgcmV0dXJuIGRvbmU7XG5cdH1cblxuXHQvKipcblx0ICogQklORFxuXHQgKiA9PT09XG5cdCAqIGJpbmQoICdrZXlkb3duJywgc2VhcmNoKCdhJylbMF0sIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICogICAgIC4uLlxuXHQgKiB9ICk7XG5cdCAqL1xuXHRmdW5jdGlvbiBiaW5kKHR5cGUsIGVsLCBmdW4pIHtcblx0ICBwdWJOdWJDb3JlLmVhY2godHlwZS5zcGxpdCgnLCcpLCBmdW5jdGlvbiAoZXR5cGUpIHtcblx0ICAgIHZhciByYXBmdW4gPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoIWUpIGUgPSB3aW5kb3cuZXZlbnQ7XG5cdCAgICAgIGlmICghZnVuKGUpKSB7XG5cdCAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHQgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0ICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXR5cGUsIHJhcGZ1biwgZmFsc2UpO1xuXHQgICAgZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldHlwZSwgcmFwZnVuKTtcblx0ICAgIGVsc2UgZWxbJ29uJyArIGV0eXBlXSA9IHJhcGZ1bjtcblx0ICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFUlJPUlxuXHQgKiA9PT1cblx0ICogZXJyb3IoJ21lc3NhZ2UnKTtcblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcblx0ICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0fVxuXG5cdC8qKlxuXHQgKiBFVkVOVFNcblx0ICogPT09PT09XG5cdCAqIFBVQk5VQi5ldmVudHMuYmluZCggJ3lvdS1zdGVwcGVkLW9uLWZsb3dlcicsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0ICogICAgIC8vIERvIFN0dWZmIHdpdGggbWVzc2FnZVxuXHQgKiB9ICk7XG5cdCAqXG5cdCAqIFBVQk5VQi5ldmVudHMuZmlyZSggJ3lvdS1zdGVwcGVkLW9uLWZsb3dlcicsIFwibWVzc2FnZS1kYXRhXCIgKTtcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywge21lc3NhZ2U6XCJkYXRhXCJ9ICk7XG5cdCAqIFBVQk5VQi5ldmVudHMuZmlyZSggJ3lvdS1zdGVwcGVkLW9uLWZsb3dlcicsIFsxLDIsM10gKTtcblx0ICpcblx0ICovXG5cdHZhciBldmVudHMgPSB7XG5cdCAgbGlzdDoge30sXG5cdCAgdW5iaW5kOiBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgZXZlbnRzLmxpc3RbbmFtZV0gPSBbXTtcblx0ICB9LFxuXHQgIGJpbmQ6IGZ1bmN0aW9uIChuYW1lLCBmdW4pIHtcblx0ICAgIChldmVudHMubGlzdFtuYW1lXSA9IGV2ZW50cy5saXN0W25hbWVdIHx8IFtdKS5wdXNoKGZ1bik7XG5cdCAgfSxcblx0ICBmaXJlOiBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuXHQgICAgcHViTnViQ29yZS5lYWNoKFxuXHQgICAgICBldmVudHMubGlzdFtuYW1lXSB8fCBbXSxcblx0ICAgICAgZnVuY3Rpb24gKGZ1bikge1xuXHQgICAgICAgIGZ1bihkYXRhKTtcblx0ICAgICAgfVxuXHQgICAgKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFUVFJcblx0ICogPT09PVxuXHQgKiB2YXIgYXR0cmlidXRlID0gYXR0ciggbm9kZSwgJ2F0dHJpYnV0ZScgKTtcblx0ICovXG5cdGZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHQgIGlmICh2YWx1ZSkgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG5cdCAgZWxzZSByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqICRcblx0ICogPVxuXHQgKiB2YXIgZGl2ID0gJCgnZGl2aWQnKTtcblx0ICovXG5cdGZ1bmN0aW9uICQoaWQpIHtcblx0ICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHR9XG5cblxuXHQvKipcblx0ICogU0VBUkNIXG5cdCAqID09PT09PVxuXHQgKiB2YXIgZWxlbWVudHMgPSBzZWFyY2goJ2EgZGl2IHNwYW4nKTtcblx0ICovXG5cdGZ1bmN0aW9uIHNlYXJjaChlbGVtZW50cywgc3RhcnQpIHtcblx0ICB2YXIgbGlzdCA9IFtdO1xuXHQgIHB1Yk51YkNvcmUuZWFjaChlbGVtZW50cy5zcGxpdCgvXFxzKy8pLCBmdW5jdGlvbiAoZWwpIHtcblx0ICAgIHB1Yk51YkNvcmUuZWFjaCgoc3RhcnQgfHwgZG9jdW1lbnQpLmdldEVsZW1lbnRzQnlUYWdOYW1lKGVsKSwgZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgbGlzdC5wdXNoKG5vZGUpO1xuXHQgICAgfSk7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Q7XG5cdH1cblxuXHQvKipcblx0ICogQ1NTXG5cdCAqID09PVxuXHQgKiB2YXIgb2JqID0gY3JlYXRlKCdkaXYnKTtcblx0ICovXG5cdGZ1bmN0aW9uIGNzcyhlbGVtZW50LCBzdHlsZXMpIHtcblx0ICBmb3IgKHZhciBzdHlsZSBpbiBzdHlsZXMpIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKVxuXHQgICAgdHJ5IHtcblx0ICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZV0gPSBzdHlsZXNbc3R5bGVdICsgKFxuXHQgICAgICAgICAgJ3x3aWR0aHxoZWlnaHR8dG9wfGxlZnR8Jy5pbmRleE9mKHN0eWxlKSA+IDAgJiZcblx0ICAgICAgICAgIHR5cGVvZiBzdHlsZXNbc3R5bGVdID09PSAnbnVtYmVyJ1xuXHQgICAgICAgICAgICA/ICdweCcgOiAnJ1xuXHQgICAgICAgICk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDUkVBVEVcblx0ICogPT09PT09XG5cdCAqIHZhciBvYmogPSBjcmVhdGUoJ2RpdicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcblx0ICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0X2htYWNfU0hBMjU2KGRhdGEsIGtleSkge1xuXHQgIHZhciBoYXNoID0gQ3J5cHRvSlNbJ0htYWNTSEEyNTYnXShkYXRhLCBrZXkpO1xuXHQgIHJldHVybiBoYXNoLnRvU3RyaW5nKENyeXB0b0pTWydlbmMnXVsnQmFzZTY0J10pO1xuXHR9XG5cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT0gICAgIFBVQk5VQiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXG5cdGZ1bmN0aW9uIENSRUFURV9QVUJOVUIoc2V0dXApIHtcblx0ICBzZXR1cC5kYiA9IGRiO1xuXHQgIHNldHVwLnhkciA9IHhkcjtcblx0ICBzZXR1cC5lcnJvciA9IHNldHVwLmVycm9yIHx8IGVycm9yO1xuXHQgIHNldHVwLmhtYWNfU0hBMjU2ID0gZ2V0X2htYWNfU0hBMjU2O1xuXHQgIHNldHVwLmNyeXB0b19vYmogPSBjcnlwdG9fb2JqKCk7XG5cdCAgc2V0dXAuV1MgPSBXUztcblx0ICBzZXR1cC5wYXJhbXMgPSB7IHBuc2RrOiBQTlNESyB9O1xuXG5cdCAgdmFyIFNFTEYgPSBmdW5jdGlvbiAoc2V0dXApIHtcblx0ICAgIHJldHVybiBDUkVBVEVfUFVCTlVCKHNldHVwKTtcblx0ICB9O1xuXG5cdCAgdmFyIFBOID0gcHViTnViQ29yZS5QTl9BUEkoc2V0dXApO1xuXHQgIGZvciAodmFyIHByb3AgaW4gUE4pIHtcblx0ICAgIGlmIChQTi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHQgICAgICBTRUxGW3Byb3BdID0gUE5bcHJvcF07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgU0VMRi5pbml0ID0gU0VMRjtcblx0ICBTRUxGLiQgPSAkO1xuXHQgIFNFTEYuYXR0ciA9IGF0dHI7XG5cdCAgU0VMRi5zZWFyY2ggPSBzZWFyY2g7XG5cdCAgU0VMRi5iaW5kID0gYmluZDtcblx0ICBTRUxGLmNzcyA9IGNzcztcblx0ICBTRUxGLmNyZWF0ZSA9IGNyZWF0ZTtcblx0ICBTRUxGLmNyeXB0b19vYmogPSBjcnlwdG9fb2JqKCk7XG5cdCAgU0VMRi5XUyA9IFdTO1xuXHQgIFNFTEYuUE5tZXNzYWdlID0gcHViTnViQ29yZS5QTm1lc3NhZ2U7XG5cdCAgU0VMRi5zdXBwbGFudCA9IHB1Yk51YkNvcmUuc3VwcGxhbnQ7XG5cblx0ICBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICBiaW5kKCdiZWZvcmV1bmxvYWQnLCB3aW5kb3csIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgU0VMRlsnZWFjaC1jaGFubmVsJ10oZnVuY3Rpb24gKGNoKSB7XG5cdCAgICAgICAgU0VMRlsnTEVBVkUnXShjaC5uYW1lLCAxKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgU0VMRi5yZWFkeSgpO1xuXG5cdCAgLy8gUmV0dXJuIHdpdGhvdXQgVGVzdGluZ1xuXHQgIGlmIChzZXR1cC5ub3Rlc3QpIHJldHVybiBTRUxGO1xuXG5cdCAgaWYgKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgYmluZCgnb2ZmbGluZScsIHdpbmRvdywgU0VMRlsnb2ZmbGluZSddKTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mKGRvY3VtZW50KSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGJpbmQoJ29mZmxpbmUnLCBkb2N1bWVudCwgU0VMRlsnb2ZmbGluZSddKTtcblx0ICB9XG5cblx0ICByZXR1cm4gU0VMRjtcblx0fVxuXG5cdENSRUFURV9QVUJOVUIuaW5pdCA9IENSRUFURV9QVUJOVUI7XG5cdENSRUFURV9QVUJOVUIuc2VjdXJlID0gQ1JFQVRFX1BVQk5VQjtcblx0Q1JFQVRFX1BVQk5VQi5jcnlwdG9fb2JqID0gY3J5cHRvX29iaigpO1xuXHRDUkVBVEVfUFVCTlVCLldTID0gV1M7XG5cdENSRUFURV9QVUJOVUIuZGIgPSBkYjtcblx0Q1JFQVRFX1BVQk5VQi5QTm1lc3NhZ2UgPSBwdWJOdWJDb3JlLlBObWVzc2FnZTtcblx0Q1JFQVRFX1BVQk5VQi51dWlkID0gcHViTnViQ29yZS51dWlkO1xuXG5cdENSRUFURV9QVUJOVUIuY3NzID0gY3NzO1xuXHRDUkVBVEVfUFVCTlVCLiQgPSAkO1xuXHRDUkVBVEVfUFVCTlVCLmNyZWF0ZSA9ICQ7XG5cdENSRUFURV9QVUJOVUIuYmluZCA9IGJpbmQ7XG5cdENSRUFURV9QVUJOVUIuc2VhcmNoID0gc2VhcmNoO1xuXHRDUkVBVEVfUFVCTlVCLmF0dHIgPSBhdHRyO1xuXHRDUkVBVEVfUFVCTlVCLmV2ZW50cyA9IGV2ZW50cztcblxuXHRDUkVBVEVfUFVCTlVCLm1hcCA9IHB1Yk51YkNvcmUubWFwO1xuXHRDUkVBVEVfUFVCTlVCLmVhY2ggPSBwdWJOdWJDb3JlLmVhY2g7XG5cdENSRUFURV9QVUJOVUIuZ3JlcCA9IHB1Yk51YkNvcmUuZ3JlcDtcblx0Q1JFQVRFX1BVQk5VQi5zdXBwbGFudCA9IHB1Yk51YkNvcmUuc3VwcGxhbnQ7XG5cdENSRUFURV9QVUJOVUIubm93ID0gcHViTnViQ29yZS5ub3c7XG5cdENSRUFURV9QVUJOVUIudW5pcXVlID0gcHViTnViQ29yZS51bmlxdWU7XG5cdENSRUFURV9QVUJOVUIudXBkYXRlciA9IHB1Yk51YkNvcmUudXBkYXRlcjtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IENSRUFURV9QVUJOVUI7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHRcdFwibmFtZVwiOiBcInB1Ym51YlwiLFxuXHRcdFwicHJlZmVyR2xvYmFsXCI6IGZhbHNlLFxuXHRcdFwidmVyc2lvblwiOiBcIjMuMTUuMlwiLFxuXHRcdFwiYXV0aG9yXCI6IFwiUHViTnViIDxzdXBwb3J0QHB1Ym51Yi5jb20+XCIsXG5cdFx0XCJkZXNjcmlwdGlvblwiOiBcIlB1Ymxpc2ggJiBTdWJzY3JpYmUgUmVhbC10aW1lIE1lc3NhZ2luZyB3aXRoIFB1Yk51YlwiLFxuXHRcdFwiY29udHJpYnV0b3JzXCI6IFtcblx0XHRcdHtcblx0XHRcdFx0XCJuYW1lXCI6IFwiU3RlcGhlbiBCbHVtXCIsXG5cdFx0XHRcdFwiZW1haWxcIjogXCJzdGVwaGVuQHB1Ym51Yi5jb21cIlxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0XCJiaW5cIjoge30sXG5cdFx0XCJzY3JpcHRzXCI6IHtcblx0XHRcdFwidGVzdFwiOiBcImdydW50IHRlc3QgLS1mb3JjZVwiXG5cdFx0fSxcblx0XHRcIm1haW5cIjogXCIuL25vZGUuanMvcHVibnViLmpzXCIsXG5cdFx0XCJicm93c2VyXCI6IFwiLi9tb2Rlcm4vZGlzdC9wdWJudWIuanNcIixcblx0XHRcInJlcG9zaXRvcnlcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiZ2l0XCIsXG5cdFx0XHRcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vcHVibnViL2phdmFzY3JpcHQuZ2l0XCJcblx0XHR9LFxuXHRcdFwia2V5d29yZHNcIjogW1xuXHRcdFx0XCJjbG91ZFwiLFxuXHRcdFx0XCJwdWJsaXNoXCIsXG5cdFx0XHRcInN1YnNjcmliZVwiLFxuXHRcdFx0XCJ3ZWJzb2NrZXRzXCIsXG5cdFx0XHRcImNvbWV0XCIsXG5cdFx0XHRcImJvc2hcIixcblx0XHRcdFwieG1wcFwiLFxuXHRcdFx0XCJyZWFsLXRpbWVcIixcblx0XHRcdFwibWVzc2FnaW5nXCJcblx0XHRdLFxuXHRcdFwiZGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcdFwiYWdlbnRrZWVwYWxpdmVcIjogXCJ+MC4yXCIsXG5cdFx0XHRcImxvZGFzaFwiOiBcIl40LjEuMFwiXG5cdFx0fSxcblx0XHRcIm5vQW5hbHl6ZVwiOiBmYWxzZSxcblx0XHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XHRcImNoYWlcIjogXCJeMy41LjBcIixcblx0XHRcdFwiZXNsaW50XCI6IFwiMi40LjBcIixcblx0XHRcdFwiZXNsaW50LWNvbmZpZy1haXJibmJcIjogXCJeNi4wLjJcIixcblx0XHRcdFwiZXNsaW50LXBsdWdpbi1mbG93dHlwZVwiOiBcIl4yLjEuMFwiLFxuXHRcdFx0XCJlc2xpbnQtcGx1Z2luLW1vY2hhXCI6IFwiXjIuMC4wXCIsXG5cdFx0XHRcImVzbGludC1wbHVnaW4tcmVhY3RcIjogXCJeNC4xLjBcIixcblx0XHRcdFwiZmxvdy1iaW5cIjogXCJeMC4yMi4wXCIsXG5cdFx0XHRcImdydW50XCI6IFwiXjAuNC41XCIsXG5cdFx0XHRcImdydW50LWNvbnRyaWItY2xlYW5cIjogXCJeMS4wLjBcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi1jb3B5XCI6IFwiXjAuOC4yXCIsXG5cdFx0XHRcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwiXjAuMTEuMVwiLFxuXHRcdFx0XCJncnVudC1lbnZcIjogXCJeMC40LjRcIixcblx0XHRcdFwiZ3J1bnQtZXNsaW50XCI6IFwiXjE4LjAuMFwiLFxuXHRcdFx0XCJncnVudC1mbG93XCI6IFwiXjEuMC4zXCIsXG5cdFx0XHRcImdydW50LWthcm1hXCI6IFwiXjAuMTIuMVwiLFxuXHRcdFx0XCJncnVudC1tb2NoYS1pc3RhbmJ1bFwiOiBcIl4zLjAuMVwiLFxuXHRcdFx0XCJncnVudC10ZXh0LXJlcGxhY2VcIjogXCJeMC40LjBcIixcblx0XHRcdFwiZ3J1bnQtd2VicGFja1wiOiBcIl4xLjAuMTFcIixcblx0XHRcdFwiaW1wb3J0cy1sb2FkZXJcIjogXCJeMC42LjVcIixcblx0XHRcdFwiaXNwYXJ0YVwiOiBcIl40LjAuMFwiLFxuXHRcdFx0XCJqc29uLWxvYWRlclwiOiBcIl4wLjUuNFwiLFxuXHRcdFx0XCJrYXJtYVwiOiBcIl4wLjEzLjIxXCIsXG5cdFx0XHRcImthcm1hLWNoYWlcIjogXCJeMC4xLjBcIixcblx0XHRcdFwia2FybWEtbW9jaGFcIjogXCJeMC4yLjFcIixcblx0XHRcdFwia2FybWEtcGhhbnRvbWpzLWxhdW5jaGVyXCI6IFwiXjEuMC4wXCIsXG5cdFx0XHRcImthcm1hLXNwZWMtcmVwb3J0ZXJcIjogXCIwLjAuMjRcIixcblx0XHRcdFwibG9hZC1ncnVudC10YXNrc1wiOiBcIl4zLjQuMFwiLFxuXHRcdFx0XCJtb2NoYVwiOiBcIl4yLjQuNVwiLFxuXHRcdFx0XCJub2NrXCI6IFwiXjEuMS4wXCIsXG5cdFx0XHRcIm5vZGUtdXVpZFwiOiBcIl4xLjQuN1wiLFxuXHRcdFx0XCJub2RldW5pdFwiOiBcIl4wLjkuMFwiLFxuXHRcdFx0XCJwaGFudG9tanMtcHJlYnVpbHRcIjogXCJeMi4xLjRcIixcblx0XHRcdFwicHJveHlxdWlyZVwiOiBcIl4xLjcuNFwiLFxuXHRcdFx0XCJzaW5vblwiOiBcIl4xLjE3LjJcIixcblx0XHRcdFwidWdsaWZ5LWpzXCI6IFwiXjIuNi4xXCIsXG5cdFx0XHRcInVuZGVyc2NvcmVcIjogXCJeMS43LjBcIixcblx0XHRcdFwid2VicGFja1wiOiBcIl4xLjEyLjEzXCIsXG5cdFx0XHRcIndlYnBhY2stZGV2LXNlcnZlclwiOiBcIl4xLjE0LjFcIlxuXHRcdH0sXG5cdFx0XCJidW5kbGVEZXBlbmRlbmNpZXNcIjogW10sXG5cdFx0XCJsaWNlbnNlXCI6IFwiTUlUXCIsXG5cdFx0XCJlbmdpbmVcIjoge1xuXHRcdFx0XCJub2RlXCI6IFwiPj0wLjhcIlxuXHRcdH0sXG5cdFx0XCJmaWxlc1wiOiBbXG5cdFx0XHRcImNvcmVcIixcblx0XHRcdFwibm9kZS5qc1wiLFxuXHRcdFx0XCJtb2Rlcm5cIixcblx0XHRcdFwiQ0hBTkdFTE9HXCIsXG5cdFx0XHRcIkZVVFVSRS5tZFwiLFxuXHRcdFx0XCJMSUNFTlNFXCIsXG5cdFx0XHRcIlJFQURNRS5tZFwiXG5cdFx0XVxuXHR9O1xuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogZXNsaW50IGNhbWVsY2FzZTogMCwgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IDAsIG5vLXVudXNlZC1leHByZXNzaW9uczogMCAgKi9cblx0LyogZXNsaW50IGVxZXFlcTogMCwgb25lLXZhcjogMCAqL1xuXHQvKiBlc2xpbnQgbm8tcmVkZWNsYXJlOiAwICovXG5cdC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cblx0LyogZXNsaW50IGJsb2NrLXNjb3BlZC12YXI6IDAgc3BhY2UtcmV0dXJuLXRocm93LWNhc2U6IDAsIG5vLXVudXNlZC12YXJzOiAwICovXG5cblx0dmFyIHBhY2thZ2VKU09OID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0dmFyIGRlZmF1bHRDb25maWd1cmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHR2YXIgTk9XID0gMTtcblx0dmFyIFJFQURZID0gZmFsc2U7XG5cdHZhciBSRUFEWV9CVUZGRVIgPSBbXTtcblx0dmFyIFBSRVNFTkNFX1NVRkZJWCA9ICctcG5wcmVzJztcblx0dmFyIERFRl9XSU5ET1dJTkcgPSAxMDsgLy8gTUlMTElTRUNPTkRTLlxuXHR2YXIgREVGX1RJTUVPVVQgPSAxNTAwMDsgLy8gTUlMTElTRUNPTkRTLlxuXHR2YXIgREVGX1NVQl9USU1FT1VUID0gMzEwOyAvLyBTRUNPTkRTLlxuXHR2YXIgREVGX0tFRVBBTElWRSA9IDYwOyAvLyBTRUNPTkRTIChGT1IgVElNRVNZTkMpLlxuXHR2YXIgU0VDT05EID0gMTAwMDsgLy8gQSBUSE9VU0FORCBNSUxMSVNFQ09ORFMuXG5cdHZhciBQUkVTRU5DRV9IQl9USFJFU0hPTEQgPSA1O1xuXHR2YXIgUFJFU0VOQ0VfSEJfREVGQVVMVCA9IDMwO1xuXHR2YXIgU0RLX1ZFUiA9IHBhY2thZ2VKU09OLnZlcnNpb247XG5cblx0LyoqXG5cdCAqIFVUSUxJVElFU1xuXHQgKi9cblx0ZnVuY3Rpb24gdW5pcXVlKCkge1xuXHQgIHJldHVybiAneCcgKyArK05PVyArICcnICsgKCtuZXcgRGF0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogTkVYVE9SSUdJTlxuXHQgKiA9PT09PT09PT09XG5cdCAqIHZhciBuZXh0X29yaWdpbiA9IG5leHRvcmlnaW4oKTtcblx0ICovXG5cdHZhciBuZXh0b3JpZ2luID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgbWF4ID0gMjA7XG5cdCAgdmFyIG9yaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChvcmlnaW4sIGZhaWxvdmVyKSB7XG5cdCAgICByZXR1cm4gb3JpZ2luLmluZGV4T2YoJ3B1YnN1Yi4nKSA+IDBcblx0ICAgICAgJiYgb3JpZ2luLnJlcGxhY2UoXG5cdCAgICAgICAgJ3B1YnN1YicsICdwcycgKyAoXG5cdCAgICAgICAgICBmYWlsb3ZlciA/IHV0aWxzLmdlbmVyYXRlVVVJRCgpLnNwbGl0KCctJylbMF0gOlxuXHQgICAgICAgICAgICAoKytvcmkgPCBtYXggPyBvcmkgOiBvcmkgPSAxKVxuXHQgICAgICAgICkpIHx8IG9yaWdpbjtcblx0ICB9O1xuXHR9KSgpO1xuXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIFN1YnNjcmlwdGlvbiBDaGFubmVsIExpc3Rcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoY2hhbm5lbHNfb2JqZWN0KTtcblx0ICovXG5cdGZ1bmN0aW9uIGdlbmVyYXRlX2NoYW5uZWxfbGlzdChjaGFubmVscywgbm9wcmVzZW5jZSkge1xuXHQgIHZhciBsaXN0ID0gW107XG5cdCAgdXRpbHMuZWFjaChjaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwsIHN0YXR1cykge1xuXHQgICAgaWYgKG5vcHJlc2VuY2UpIHtcblx0ICAgICAgaWYgKGNoYW5uZWwuc2VhcmNoKCctcG5wcmVzJykgPCAwKSB7XG5cdCAgICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChzdGF0dXMuc3Vic2NyaWJlZCkgbGlzdC5wdXNoKGNoYW5uZWwpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiBsaXN0LnNvcnQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBTdWJzY3JpcHRpb24gQ2hhbm5lbCBHcm91cHMgTGlzdFxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChjaGFubmVsc19ncm91cHMgb2JqZWN0KTtcblx0ICovXG5cdGZ1bmN0aW9uIGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChjaGFubmVsX2dyb3Vwcywgbm9wcmVzZW5jZSkge1xuXHQgIHZhciBsaXN0ID0gW107XG5cdCAgdXRpbHMuZWFjaChjaGFubmVsX2dyb3VwcywgZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXAsIHN0YXR1cykge1xuXHQgICAgaWYgKG5vcHJlc2VuY2UpIHtcblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAuc2VhcmNoKCctcG5wcmVzJykgPCAwKSB7XG5cdCAgICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChzdGF0dXMuc3Vic2NyaWJlZCkgbGlzdC5wdXNoKGNoYW5uZWxfZ3JvdXApO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiBsaXN0LnNvcnQoKTtcblx0fVxuXG5cdC8vIFBVQk5VQiBSRUFEWSBUTyBDT05ORUNUXG5cdGZ1bmN0aW9uIHJlYWR5KCkge1xuXHQgIGlmIChSRUFEWSkgcmV0dXJuO1xuXHQgIFJFQURZID0gMTtcblx0ICB1dGlscy5lYWNoKFJFQURZX0JVRkZFUiwgZnVuY3Rpb24gKGNvbm5lY3QpIHtcblx0ICAgIGNvbm5lY3QoKTtcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIFBObWVzc2FnZShhcmdzKSB7XG5cdCAgdmFyIG1zZyA9IGFyZ3MgfHwgeyBhcG5zOiB7fSB9O1xuXG5cdCAgbXNnWydnZXRQdWJudWJNZXNzYWdlJ10gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgbSA9IHt9O1xuXG5cdCAgICBpZiAoT2JqZWN0LmtleXMobXNnWydhcG5zJ10pLmxlbmd0aCkge1xuXHQgICAgICBtWydwbl9hcG5zJ10gPSB7XG5cdCAgICAgICAgYXBzOiB7XG5cdCAgICAgICAgICBhbGVydDogbXNnWydhcG5zJ11bJ2FsZXJ0J10sXG5cdCAgICAgICAgICBiYWRnZTogbXNnWydhcG5zJ11bJ2JhZGdlJ11cblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIGZvciAodmFyIGsgaW4gbXNnWydhcG5zJ10pIHtcblx0ICAgICAgICBtWydwbl9hcG5zJ11ba10gPSBtc2dbJ2FwbnMnXVtrXTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgZXhjbHVkZTEgPSBbJ2JhZGdlJywgJ2FsZXJ0J107XG5cdCAgICAgIGZvciAodmFyIGsgaW4gZXhjbHVkZTEpIHtcblx0ICAgICAgICBkZWxldGUgbVsncG5fYXBucyddW2V4Y2x1ZGUxW2tdXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAobXNnWydnY20nXSkge1xuXHQgICAgICBtWydwbl9nY20nXSA9IHtcblx0ICAgICAgICBkYXRhOiBtc2dbJ2djbSddXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGsgaW4gbXNnKSB7XG5cdCAgICAgIG1ba10gPSBtc2dba107XG5cdCAgICB9XG5cdCAgICB2YXIgZXhjbHVkZSA9IFsnYXBucycsICdnY20nLCAncHVibGlzaCcsICdjaGFubmVsJywgJ2NhbGxiYWNrJywgJ2Vycm9yJ107XG5cdCAgICBmb3IgKHZhciBrIGluIGV4Y2x1ZGUpIHtcblx0ICAgICAgZGVsZXRlIG1bZXhjbHVkZVtrXV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtO1xuXHQgIH07XG5cdCAgbXNnWydwdWJsaXNoJ10gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgbSA9IG1zZy5nZXRQdWJudWJNZXNzYWdlKCk7XG5cblx0ICAgIGlmIChtc2dbJ3B1Ym51YiddICYmIG1zZ1snY2hhbm5lbCddKSB7XG5cdCAgICAgIG1zZ1sncHVibnViJ10ucHVibGlzaCh7XG5cdCAgICAgICAgbWVzc2FnZTogbSxcblx0ICAgICAgICBjaGFubmVsOiBtc2dbJ2NoYW5uZWwnXSxcblx0ICAgICAgICBjYWxsYmFjazogbXNnWydjYWxsYmFjayddLFxuXHQgICAgICAgIGVycm9yOiBtc2dbJ2Vycm9yJ11cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICByZXR1cm4gbXNnO1xuXHR9XG5cblx0ZnVuY3Rpb24gUE5fQVBJKHNldHVwKSB7XG5cdCAgdmFyIFNVQl9XSU5ET1dJTkcgPSArc2V0dXBbJ3dpbmRvd2luZyddIHx8IERFRl9XSU5ET1dJTkc7XG5cdCAgdmFyIFNVQl9USU1FT1VUID0gKCtzZXR1cFsndGltZW91dCddIHx8IERFRl9TVUJfVElNRU9VVCkgKiBTRUNPTkQ7XG5cdCAgdmFyIEtFRVBBTElWRSA9ICgrc2V0dXBbJ2tlZXBhbGl2ZSddIHx8IERFRl9LRUVQQUxJVkUpICogU0VDT05EO1xuXHQgIHZhciBUSU1FX0NIRUNLID0gc2V0dXBbJ3RpbWVjaGVjayddIHx8IDA7XG5cdCAgdmFyIE5PTEVBVkUgPSBzZXR1cFsnbm9sZWF2ZSddIHx8IDA7XG5cdCAgdmFyIFBVQkxJU0hfS0VZID0gc2V0dXBbJ3B1Ymxpc2hfa2V5J107XG5cdCAgdmFyIFNVQlNDUklCRV9LRVkgPSBzZXR1cFsnc3Vic2NyaWJlX2tleSddO1xuXHQgIHZhciBBVVRIX0tFWSA9IHNldHVwWydhdXRoX2tleSddIHx8ICcnO1xuXHQgIHZhciBTRUNSRVRfS0VZID0gc2V0dXBbJ3NlY3JldF9rZXknXSB8fCAnJztcblx0ICB2YXIgaG1hY19TSEEyNTYgPSBzZXR1cFsnaG1hY19TSEEyNTYnXTtcblx0ICB2YXIgU1NMID0gc2V0dXBbJ3NzbCddID8gJ3MnIDogJyc7XG5cdCAgdmFyIE9SSUdJTiA9ICdodHRwJyArIFNTTCArICc6Ly8nICsgKHNldHVwWydvcmlnaW4nXSB8fCAncHVic3ViLnB1Ym51Yi5jb20nKTtcblx0ICB2YXIgU1REX09SSUdJTiA9IG5leHRvcmlnaW4oT1JJR0lOKTtcblx0ICB2YXIgU1VCX09SSUdJTiA9IG5leHRvcmlnaW4oT1JJR0lOKTtcblx0ICB2YXIgQ09OTkVDVCA9IGZ1bmN0aW9uICgpIHtcblx0ICB9O1xuXHQgIHZhciBQVUJfUVVFVUUgPSBbXTtcblx0ICB2YXIgQ0xPQUsgPSB0cnVlO1xuXHQgIHZhciBUSU1FX0RSSUZUID0gMDtcblx0ICB2YXIgU1VCX0NBTExCQUNLID0gMDtcblx0ICB2YXIgU1VCX0NIQU5ORUwgPSAwO1xuXHQgIHZhciBTVUJfUkVDRUlWRVIgPSAwO1xuXHQgIHZhciBTVUJfUkVTVE9SRSA9IHNldHVwWydyZXN0b3JlJ10gfHwgMDtcblx0ICB2YXIgU1VCX0JVRkZfV0FJVCA9IDA7XG5cdCAgdmFyIFRJTUVUT0tFTiA9IDA7XG5cdCAgdmFyIFJFU1VNRUQgPSBmYWxzZTtcblx0ICB2YXIgQ0hBTk5FTFMgPSB7fTtcblx0ICB2YXIgQ0hBTk5FTF9HUk9VUFMgPSB7fTtcblx0ICB2YXIgU1VCX0VSUk9SID0gZnVuY3Rpb24gKCkge1xuXHQgIH07XG5cdCAgdmFyIFNUQVRFID0ge307XG5cdCAgdmFyIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSBudWxsO1xuXHQgIHZhciBQUkVTRU5DRV9IQiA9IHZhbGlkYXRlX3ByZXNlbmNlX2hlYXJ0YmVhdChcblx0ICAgIHNldHVwWydoZWFydGJlYXQnXSB8fCBzZXR1cFsncG5leHBpcmVzJ10gfHwgMCwgc2V0dXBbJ2Vycm9yJ11cblx0ICApO1xuXHQgIHZhciBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IHNldHVwWydoZWFydGJlYXRfaW50ZXJ2YWwnXSB8fCAoUFJFU0VOQ0VfSEIgLyAyKSAtIDE7XG5cdCAgdmFyIFBSRVNFTkNFX0hCX1JVTk5JTkcgPSBmYWxzZTtcblx0ICB2YXIgTk9fV0FJVF9GT1JfUEVORElORyA9IHNldHVwWydub193YWl0X2Zvcl9wZW5kaW5nJ107XG5cdCAgdmFyIENPTVBBVElCTEVfMzUgPSBzZXR1cFsnY29tcGF0aWJsZV8zLjUnXSB8fCBmYWxzZTtcblx0ICB2YXIgeGRyID0gc2V0dXBbJ3hkciddO1xuXHQgIHZhciBwYXJhbXMgPSBzZXR1cFsncGFyYW1zJ10gfHwge307XG5cdCAgdmFyIGVycm9yID0gc2V0dXBbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgdmFyIF9pc19vbmxpbmUgPSBzZXR1cFsnX2lzX29ubGluZSddIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7fTtcblx0ICB2YXIganNvbnBfY2IgPSBzZXR1cFsnanNvbnBfY2InXSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuXHQgIHZhciBkYiA9IHNldHVwWydkYiddIHx8IHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSwgc2V0OiBmdW5jdGlvbiAoKSB7fSB9O1xuXHQgIHZhciBDSVBIRVJfS0VZID0gc2V0dXBbJ2NpcGhlcl9rZXknXTtcblx0ICB2YXIgVVVJRCA9IHNldHVwWyd1dWlkJ10gfHwgKCFzZXR1cFsndW5pcXVlX3V1aWQnXSAmJiBkYiAmJiBkYlsnZ2V0J10oU1VCU0NSSUJFX0tFWSArICd1dWlkJykgfHwgJycpO1xuXHQgIHZhciBVU0VfSU5TVEFOQ0VJRCA9IHNldHVwWydpbnN0YW5jZV9pZCddIHx8IGZhbHNlO1xuXHQgIHZhciBJTlNUQU5DRUlEID0gJyc7XG5cdCAgdmFyIHNodXRkb3duID0gc2V0dXBbJ3NodXRkb3duJ107XG5cdCAgdmFyIHVzZV9zZW5kX2JlYWNvbiA9ICh0eXBlb2Ygc2V0dXBbJ3VzZV9zZW5kX2JlYWNvbiddICE9ICd1bmRlZmluZWQnKSA/IHNldHVwWyd1c2Vfc2VuZF9iZWFjb24nXSA6IHRydWU7XG5cdCAgdmFyIHNlbmRCZWFjb24gPSAodXNlX3NlbmRfYmVhY29uKSA/IHNldHVwWydzZW5kQmVhY29uJ10gOiBudWxsO1xuXHQgIHZhciBfcG9sbF90aW1lcjtcblx0ICB2YXIgX3BvbGxfdGltZXIyO1xuXG5cdCAgaWYgKFBSRVNFTkNFX0hCID09PSAyKSBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IDE7XG5cblx0ICB2YXIgY3J5cHRvX29iaiA9IHNldHVwWydjcnlwdG9fb2JqJ10gfHwge1xuXHQgICAgZW5jcnlwdDogZnVuY3Rpb24gKGEsIGtleSkge1xuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH0sXG5cdCAgICBkZWNyeXB0OiBmdW5jdGlvbiAoYiwga2V5KSB7XG5cdCAgICAgIHJldHVybiBiO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBfZ2V0X3VybF9wYXJhbXMoZGF0YSkge1xuXHQgICAgaWYgKCFkYXRhKSBkYXRhID0ge307XG5cdCAgICB1dGlscy5lYWNoKHBhcmFtcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgaWYgKCEoa2V5IGluIGRhdGEpKSBkYXRhW2tleV0gPSB2YWx1ZTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX29iamVjdF90b19rZXlfbGlzdChvKSB7XG5cdCAgICB2YXIgbCA9IFtdO1xuXHQgICAgdXRpbHMuZWFjaChvLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBsLnB1c2goa2V5KTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGw7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX29iamVjdF90b19rZXlfbGlzdF9zb3J0ZWQobykge1xuXHQgICAgcmV0dXJuIF9vYmplY3RfdG9fa2V5X2xpc3Qobykuc29ydCgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9nZXRfcGFtX3NpZ25faW5wdXRfZnJvbV9wYXJhbXMocGFyYW1zKSB7XG5cdCAgICB2YXIgc2kgPSAnJztcblx0ICAgIHZhciBsID0gX29iamVjdF90b19rZXlfbGlzdF9zb3J0ZWQocGFyYW1zKTtcblxuXHQgICAgZm9yICh2YXIgaSBpbiBsKSB7XG5cdCAgICAgIHZhciBrID0gbFtpXTtcblx0ICAgICAgc2kgKz0gayArICc9JyArIHV0aWxzLnBhbUVuY29kZShwYXJhbXNba10pO1xuXHQgICAgICBpZiAoaSAhPSBsLmxlbmd0aCAtIDEpIHNpICs9ICcmJztcblx0ICAgIH1cblx0ICAgIHJldHVybiBzaTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB2YWxpZGF0ZV9wcmVzZW5jZV9oZWFydGJlYXQoaGVhcnRiZWF0LCBjdXJfaGVhcnRiZWF0LCBlcnJvcikge1xuXHQgICAgdmFyIGVyciA9IGZhbHNlO1xuXG5cdCAgICBpZiAodHlwZW9mIGhlYXJ0YmVhdCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIGN1cl9oZWFydGJlYXQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgaGVhcnRiZWF0ID09PSAnbnVtYmVyJykge1xuXHQgICAgICBpZiAoaGVhcnRiZWF0ID4gUFJFU0VOQ0VfSEJfVEhSRVNIT0xEIHx8IGhlYXJ0YmVhdCA9PSAwKSB7XG5cdCAgICAgICAgZXJyID0gZmFsc2U7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZXJyID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgaGVhcnRiZWF0ID09PSAnYm9vbGVhbicpIHtcblx0ICAgICAgaWYgKCFoZWFydGJlYXQpIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gUFJFU0VOQ0VfSEJfREVGQVVMVDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZXJyID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGVycikge1xuXHQgICAgICBlcnJvciAmJiBlcnJvcignUHJlc2VuY2UgSGVhcnRiZWF0IHZhbHVlIGludmFsaWQuIFZhbGlkIHJhbmdlICggeCA+ICcgKyBQUkVTRU5DRV9IQl9USFJFU0hPTEQgKyAnIG9yIHggPSAwKS4gQ3VycmVudCBWYWx1ZSA6ICcgKyAoY3VyX2hlYXJ0YmVhdCB8fCBQUkVTRU5DRV9IQl9USFJFU0hPTEQpKTtcblx0ICAgICAgcmV0dXJuIGN1cl9oZWFydGJlYXQgfHwgUFJFU0VOQ0VfSEJfVEhSRVNIT0xEO1xuXHQgICAgfSBlbHNlIHJldHVybiBoZWFydGJlYXQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW5jcnlwdChpbnB1dCwga2V5KSB7XG5cdCAgICByZXR1cm4gY3J5cHRvX29ialsnZW5jcnlwdCddKGlucHV0LCBrZXkgfHwgQ0lQSEVSX0tFWSkgfHwgaW5wdXQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVjcnlwdChpbnB1dCwga2V5KSB7XG5cdCAgICByZXR1cm4gY3J5cHRvX29ialsnZGVjcnlwdCddKGlucHV0LCBrZXkgfHwgQ0lQSEVSX0tFWSkgfHxcblx0ICAgICAgY3J5cHRvX29ialsnZGVjcnlwdCddKGlucHV0LCBDSVBIRVJfS0VZKSB8fFxuXHQgICAgICBpbnB1dDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlcnJvcl9jb21tb24obWVzc2FnZSwgY2FsbGJhY2spIHtcblx0ICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHsgZXJyb3I6IG1lc3NhZ2UgfHwgJ2Vycm9yIG9jY3VycmVkJyB9KTtcblx0ICAgIGVycm9yICYmIGVycm9yKG1lc3NhZ2UpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9wcmVzZW5jZV9oZWFydGJlYXQoKSB7XG5cdCAgICBjbGVhclRpbWVvdXQoUFJFU0VOQ0VfSEJfVElNRU9VVCk7XG5cblx0ICAgIGlmICghUFJFU0VOQ0VfSEJfSU5URVJWQUwgfHwgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPj0gNTAwIHx8XG5cdCAgICAgIFBSRVNFTkNFX0hCX0lOVEVSVkFMIDwgMSB8fFxuXHQgICAgICAoIWdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUywgdHJ1ZSkubGVuZ3RoICYmICFnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoQ0hBTk5FTF9HUk9VUFMsIHRydWUpLmxlbmd0aCkpIHtcblx0ICAgICAgUFJFU0VOQ0VfSEJfUlVOTklORyA9IGZhbHNlO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIFBSRVNFTkNFX0hCX1JVTk5JTkcgPSB0cnVlO1xuXHQgICAgU0VMRlsncHJlc2VuY2VfaGVhcnRiZWF0J10oe1xuXHQgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKHIpIHtcblx0ICAgICAgICBQUkVTRU5DRV9IQl9USU1FT1VUID0gdXRpbHMudGltZW91dChfcHJlc2VuY2VfaGVhcnRiZWF0LCAoUFJFU0VOQ0VfSEJfSU5URVJWQUwpICogU0VDT05EKTtcblx0ICAgICAgfSxcblx0ICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgZXJyb3IgJiYgZXJyb3IoJ1ByZXNlbmNlIEhlYXJ0YmVhdCB1bmFibGUgdG8gcmVhY2ggUHVibnViIHNlcnZlcnMuJyArIEpTT04uc3RyaW5naWZ5KGUpKTtcblx0ICAgICAgICBQUkVTRU5DRV9IQl9USU1FT1VUID0gdXRpbHMudGltZW91dChfcHJlc2VuY2VfaGVhcnRiZWF0LCAoUFJFU0VOQ0VfSEJfSU5URVJWQUwpICogU0VDT05EKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc3RhcnRfcHJlc2VuY2VfaGVhcnRiZWF0KCkge1xuXHQgICAgIVBSRVNFTkNFX0hCX1JVTk5JTkcgJiYgX3ByZXNlbmNlX2hlYXJ0YmVhdCgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHB1Ymxpc2gobmV4dCkge1xuXHQgICAgaWYgKE5PX1dBSVRfRk9SX1BFTkRJTkcpIHtcblx0ICAgICAgaWYgKCFQVUJfUVVFVUUubGVuZ3RoKSByZXR1cm47XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAobmV4dCkgUFVCX1FVRVVFLnNlbmRpbmcgPSAwO1xuXHQgICAgICBpZiAoUFVCX1FVRVVFLnNlbmRpbmcgfHwgIVBVQl9RVUVVRS5sZW5ndGgpIHJldHVybjtcblx0ICAgICAgUFVCX1FVRVVFLnNlbmRpbmcgPSAxO1xuXHQgICAgfVxuXG5cdCAgICB4ZHIoUFVCX1FVRVVFLnNoaWZ0KCkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVhY2hfY2hhbm5lbF9ncm91cChjYWxsYmFjaykge1xuXHQgICAgdmFyIGNvdW50ID0gMDtcblxuXHQgICAgdXRpbHMuZWFjaChnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoQ0hBTk5FTF9HUk9VUFMpLCBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICB2YXIgY2hhbmcgPSBDSEFOTkVMX0dST1VQU1tjaGFubmVsX2dyb3VwXTtcblxuXHQgICAgICBpZiAoIWNoYW5nKSByZXR1cm47XG5cblx0ICAgICAgY291bnQrKztcblx0ICAgICAgKGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgfSkoY2hhbmcpO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBjb3VudDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlYWNoX2NoYW5uZWwoY2FsbGJhY2spIHtcblx0ICAgIHZhciBjb3VudCA9IDA7XG5cblx0ICAgIHV0aWxzLmVhY2goZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTKSwgZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgdmFyIGNoYW4gPSBDSEFOTkVMU1tjaGFubmVsXTtcblxuXHQgICAgICBpZiAoIWNoYW4pIHJldHVybjtcblxuXHQgICAgICBjb3VudCsrO1xuXHQgICAgICAoY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB9KShjaGFuKTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gY291bnQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycikge1xuXHQgICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PSAnb2JqZWN0Jykge1xuXHQgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgICB2YXIgY2FsbGJhY2tfZGF0YSA9IHt9O1xuXG5cdCAgICAgICAgaWYgKHJlc3BvbnNlWydtZXNzYWdlJ10pIHtcblx0ICAgICAgICAgIGNhbGxiYWNrX2RhdGFbJ21lc3NhZ2UnXSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHJlc3BvbnNlWydwYXlsb2FkJ10pIHtcblx0ICAgICAgICAgIGNhbGxiYWNrX2RhdGFbJ3BheWxvYWQnXSA9IHJlc3BvbnNlWydwYXlsb2FkJ107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZXJyICYmIGVycihjYWxsYmFja19kYXRhKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlc3BvbnNlWydwYXlsb2FkJ10pIHtcblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ25leHRfcGFnZSddKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZVsncGF5bG9hZCddLCByZXNwb25zZVsnbmV4dF9wYWdlJ10pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZVsncGF5bG9hZCddKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwb25zZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKSB7XG5cdCAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdvYmplY3QnICYmIHJlc3BvbnNlWydlcnJvciddKSB7XG5cdCAgICAgIHZhciBjYWxsYmFja19kYXRhID0ge307XG5cblx0ICAgICAgaWYgKHJlc3BvbnNlWydtZXNzYWdlJ10pIHtcblx0ICAgICAgICBjYWxsYmFja19kYXRhWydtZXNzYWdlJ10gPSByZXNwb25zZVsnbWVzc2FnZSddO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHJlc3BvbnNlWydwYXlsb2FkJ10pIHtcblx0ICAgICAgICBjYWxsYmFja19kYXRhWydwYXlsb2FkJ10gPSByZXNwb25zZVsncGF5bG9hZCddO1xuXHQgICAgICB9XG5cblx0ICAgICAgZXJyICYmIGVycihjYWxsYmFja19kYXRhKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZXJyICYmIGVycihyZXNwb25zZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gQ1IoYXJncywgY2FsbGJhY2ssIHVybDEsIGRhdGEpIHtcblx0ICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBlcnJvcjtcblx0ICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG5cdCAgICBpZiAoIWRhdGFbJ2F1dGgnXSkge1xuXHQgICAgICBkYXRhWydhdXRoJ10gPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdXJsID0gW1xuXHQgICAgICBTVERfT1JJR0lOLCAndjEnLCAnY2hhbm5lbC1yZWdpc3RyYXRpb24nLFxuXHQgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVlcblx0ICAgIF07XG5cblx0ICAgIHVybC5wdXNoLmFwcGx5KHVybCwgdXJsMSk7XG5cblx0ICAgIGlmIChqc29ucCkgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXG5cdCAgICB4ZHIoe1xuXHQgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgIH0sXG5cdCAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgIH0sXG5cdCAgICAgIHVybDogdXJsXG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICAvLyBBbm5vdW5jZSBMZWF2ZSBFdmVudFxuXHQgIHZhciBTRUxGID0ge1xuXHQgICAgTEVBVkU6IGZ1bmN0aW9uIChjaGFubmVsLCBibG9ja2luZywgYXV0aF9rZXksIGNhbGxiYWNrLCBlcnJvcikge1xuXHQgICAgICB2YXIgZGF0YSA9IHsgdXVpZDogVVVJRCwgYXV0aDogYXV0aF9rZXkgfHwgQVVUSF9LRVkgfTtcblx0ICAgICAgdmFyIG9yaWdpbiA9IG5leHRvcmlnaW4oT1JJR0lOKTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBlcnIgPSBlcnJvciB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHVybDtcblx0ICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgICAvLyBQcmV2ZW50IExlYXZpbmcgYSBQcmVzZW5jZSBDaGFubmVsXG5cdCAgICAgIGlmIChjaGFubmVsLmluZGV4T2YoUFJFU0VOQ0VfU1VGRklYKSA+IDApIHJldHVybiB0cnVlO1xuXG5cblx0ICAgICAgaWYgKENPTVBBVElCTEVfMzUpIHtcblx0ICAgICAgICBpZiAoIVNTTCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIGlmIChqc29ucCA9PSAnMCcpIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChOT0xFQVZFKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgb3JpZ2luLCAndjInLCAncHJlc2VuY2UnLCAnc3ViX2tleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoY2hhbm5lbCksICdsZWF2ZSdcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSBfZ2V0X3VybF9wYXJhbXMoZGF0YSk7XG5cblxuXHQgICAgICBpZiAoc2VuZEJlYWNvbikge1xuXHQgICAgICAgIHZhciB1cmxfc3RyaW5nID0gdXRpbHMuYnVpbGRVUkwodXJsLCBwYXJhbXMpO1xuXHQgICAgICAgIGlmIChzZW5kQmVhY29uKHVybF9zdHJpbmcpKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh7IHN0YXR1czogMjAwLCBhY3Rpb246ICdsZWF2ZScsIG1lc3NhZ2U6ICdPSycsIHNlcnZpY2U6ICdQcmVzZW5jZScgfSk7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgYmxvY2tpbmc6IGJsb2NraW5nIHx8IFNTTCxcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogcGFyYW1zLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IHVybFxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9LFxuXG5cdCAgICBMRUFWRV9HUk9VUDogZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXAsIGJsb2NraW5nLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycm9yKSB7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB8fCBBVVRIX0tFWSB9O1xuXHQgICAgICB2YXIgb3JpZ2luID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgICAgICB2YXIgdXJsO1xuXHQgICAgICB2YXIgcGFyYW1zO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGVycm9yIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIFByZXZlbnQgTGVhdmluZyBhIFByZXNlbmNlIENoYW5uZWwgR3JvdXBcblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAuaW5kZXhPZihQUkVTRU5DRV9TVUZGSVgpID4gMCkgcmV0dXJuIHRydWU7XG5cblx0ICAgICAgaWYgKENPTVBBVElCTEVfMzUpIHtcblx0ICAgICAgICBpZiAoIVNTTCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIGlmIChqc29ucCA9PSAnMCcpIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChOT0xFQVZFKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwICYmIGNoYW5uZWxfZ3JvdXAubGVuZ3RoID4gMCkgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgdXJsID0gW1xuXHQgICAgICAgIG9yaWdpbiwgJ3YyJywgJ3ByZXNlbmNlJywgJ3N1Yl9rZXknLFxuXHQgICAgICAgIFNVQlNDUklCRV9LRVksICdjaGFubmVsJywgdXRpbHMuZW5jb2RlKCcsJyksICdsZWF2ZSdcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSBfZ2V0X3VybF9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgaWYgKHNlbmRCZWFjb24pIHtcblx0ICAgICAgICB2YXIgdXJsX3N0cmluZyA9IHV0aWxzLmJ1aWxkVVJMKHVybCwgcGFyYW1zKTtcblx0ICAgICAgICBpZiAoc2VuZEJlYWNvbih1cmxfc3RyaW5nKSkge1xuXHQgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soeyBzdGF0dXM6IDIwMCwgYWN0aW9uOiAnbGVhdmUnLCBtZXNzYWdlOiAnT0snLCBzZXJ2aWNlOiAnUHJlc2VuY2UnIH0pO1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBibG9ja2luZzogYmxvY2tpbmcgfHwgU1NMLFxuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBwYXJhbXMsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0sXG5cblx0ICAgIHNldF9yZXN1bWVkOiBmdW5jdGlvbiAocmVzdW1lZCkge1xuXHQgICAgICBSRVNVTUVEID0gcmVzdW1lZDtcblx0ICAgIH0sXG5cblx0ICAgIGdldF9jaXBoZXJfa2V5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBDSVBIRVJfS0VZO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X2NpcGhlcl9rZXk6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgQ0lQSEVSX0tFWSA9IGtleTtcblx0ICAgIH0sXG5cblx0ICAgIHJhd19lbmNyeXB0OiBmdW5jdGlvbiAoaW5wdXQsIGtleSkge1xuXHQgICAgICByZXR1cm4gZW5jcnlwdChpbnB1dCwga2V5KTtcblx0ICAgIH0sXG5cblx0ICAgIHJhd19kZWNyeXB0OiBmdW5jdGlvbiAoaW5wdXQsIGtleSkge1xuXHQgICAgICByZXR1cm4gZGVjcnlwdChpbnB1dCwga2V5KTtcblx0ICAgIH0sXG5cblx0ICAgIGdldF9oZWFydGJlYXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFBSRVNFTkNFX0hCO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X2hlYXJ0YmVhdDogZnVuY3Rpb24gKGhlYXJ0YmVhdCwgaGVhcnRiZWF0X2ludGVydmFsKSB7XG5cdCAgICAgIFBSRVNFTkNFX0hCID0gdmFsaWRhdGVfcHJlc2VuY2VfaGVhcnRiZWF0KGhlYXJ0YmVhdCwgUFJFU0VOQ0VfSEIsIGVycm9yKTtcblx0ICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSBoZWFydGJlYXRfaW50ZXJ2YWwgfHwgKFBSRVNFTkNFX0hCIC8gMikgLSAxO1xuXHQgICAgICBpZiAoUFJFU0VOQ0VfSEIgPT0gMikge1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gMTtcblx0ICAgICAgfVxuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICAgIF9wcmVzZW5jZV9oZWFydGJlYXQoKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldF9oZWFydGJlYXRfaW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFBSRVNFTkNFX0hCX0lOVEVSVkFMO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X2hlYXJ0YmVhdF9pbnRlcnZhbDogZnVuY3Rpb24gKGhlYXJ0YmVhdF9pbnRlcnZhbCkge1xuXHQgICAgICBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IGhlYXJ0YmVhdF9pbnRlcnZhbDtcblx0ICAgICAgX3ByZXNlbmNlX2hlYXJ0YmVhdCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X3ZlcnNpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFNES19WRVI7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRHY21NZXNzYWdlT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGF0YTogb2JqXG5cdCAgICAgIH07XG5cdCAgICB9LFxuXG5cdCAgICBnZXRBcG5zTWVzc2FnZU9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICB2YXIgeCA9IHtcblx0ICAgICAgICBhcHM6IHsgYmFkZ2U6IDEsIGFsZXJ0OiAnJyB9XG5cdCAgICAgIH07XG5cdCAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG5cdCAgICAgICAga1t4XSA9IG9ialtrXTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4geDtcblx0ICAgIH0sXG5cblx0ICAgIF9hZGRfcGFyYW06IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuXHQgICAgICBwYXJhbXNba2V5XSA9IHZhbDtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXA6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgbnNfY2ggPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGFyZ3NbJ2NhbGxiYWNrJ107XG5cdCAgICAgIHZhciBjaGFubmVscyA9IGFyZ3NbJ2NoYW5uZWxzJ10gfHwgYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2xvYWsgPSBhcmdzWydjbG9hayddO1xuXHQgICAgICB2YXIgbmFtZXNwYWNlO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cDtcblx0ICAgICAgdmFyIHVybCA9IFtdO1xuXHQgICAgICB2YXIgZGF0YSA9IHt9O1xuXHQgICAgICB2YXIgbW9kZSA9IGFyZ3NbJ21vZGUnXSB8fCAnYWRkJztcblxuXG5cdCAgICAgIGlmIChuc19jaCkge1xuXHQgICAgICAgIHZhciBuc19jaF9hID0gbnNfY2guc3BsaXQoJzonKTtcblxuXHQgICAgICAgIGlmIChuc19jaF9hLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgIG5hbWVzcGFjZSA9IChuc19jaF9hWzBdID09PSAnKicpID8gbnVsbCA6IG5zX2NoX2FbMF07XG5cblx0ICAgICAgICAgIGNoYW5uZWxfZ3JvdXAgPSBuc19jaF9hWzFdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjaGFubmVsX2dyb3VwID0gbnNfY2hfYVswXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBuYW1lc3BhY2UgJiYgdXJsLnB1c2goJ25hbWVzcGFjZScpICYmIHVybC5wdXNoKHV0aWxzLmVuY29kZShuYW1lc3BhY2UpKTtcblxuXHQgICAgICB1cmwucHVzaCgnY2hhbm5lbC1ncm91cCcpO1xuXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwICYmIGNoYW5uZWxfZ3JvdXAgIT09ICcqJykge1xuXHQgICAgICAgIHVybC5wdXNoKGNoYW5uZWxfZ3JvdXApO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNoYW5uZWxzKSB7XG5cdCAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoY2hhbm5lbHMpKSB7XG5cdCAgICAgICAgICBjaGFubmVscyA9IGNoYW5uZWxzLmpvaW4oJywnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZGF0YVttb2RlXSA9IGNoYW5uZWxzO1xuXHQgICAgICAgIGRhdGFbJ2Nsb2FrJ10gPSAoQ0xPQUspID8gJ3RydWUnIDogJ2ZhbHNlJztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAobW9kZSA9PT0gJ3JlbW92ZScpIHVybC5wdXNoKCdyZW1vdmUnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2YgY2xvYWsgIT0gJ3VuZGVmaW5lZCcpIGRhdGFbJ2Nsb2FrJ10gPSAoY2xvYWspID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuXHQgICAgICBDUihhcmdzLCBjYWxsYmFjaywgdXJsLCBkYXRhKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfbGlzdF9ncm91cHM6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgbmFtZXNwYWNlO1xuXG5cdCAgICAgIG5hbWVzcGFjZSA9IGFyZ3NbJ25hbWVzcGFjZSddIHx8IGFyZ3NbJ25zJ10gfHwgYXJnc1snY2hhbm5lbF9ncm91cCddIHx8IG51bGw7XG5cdCAgICAgIGlmIChuYW1lc3BhY2UpIHtcblx0ICAgICAgICBhcmdzWydjaGFubmVsX2dyb3VwJ10gPSBuYW1lc3BhY2UgKyAnOionO1xuXHQgICAgICB9XG5cblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfbGlzdF9jaGFubmVsczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbF9ncm91cCddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCBHcm91cCcpO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9yZW1vdmVfY2hhbm5lbDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbF9ncm91cCddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCBHcm91cCcpO1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWwnXSAmJiAhYXJnc1snY2hhbm5lbHMnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblxuXHQgICAgICBhcmdzWydtb2RlJ10gPSAncmVtb3ZlJztcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfcmVtb3ZlX2dyb3VwOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIGlmIChhcmdzWydjaGFubmVsJ10pIHJldHVybiBlcnJvcignVXNlIGNoYW5uZWxfZ3JvdXBfcmVtb3ZlX2NoYW5uZWwgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIGEgY2hhbm5lbCBmcm9tIGEgZ3JvdXAuJyk7XG5cblx0ICAgICAgYXJnc1snbW9kZSddID0gJ3JlbW92ZSc7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2FkZF9jaGFubmVsOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbCddICYmICFhcmdzWydjaGFubmVscyddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9jbG9hazogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgYXJnc1snY2xvYWsnXSA9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIGNhbGxiYWNrKENMT0FLKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgQ0xPQUsgPSBhcmdzWydjbG9hayddO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X25hbWVzcGFjZXM6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgdXJsID0gWyduYW1lc3BhY2UnXTtcblx0ICAgICAgQ1IoYXJncywgY2FsbGJhY2ssIHVybCk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX3JlbW92ZV9uYW1lc3BhY2U6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgdXJsID0gWyduYW1lc3BhY2UnLCBhcmdzWyduYW1lc3BhY2UnXSwgJ3JlbW92ZSddO1xuXHQgICAgICBDUihhcmdzLCBjYWxsYmFjaywgdXJsKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLmhpc3Rvcnkoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXRfY2hhbm5lbCcsXG5cdCAgICAgbGltaXQgICAgOiAxMDAsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW5jdGlvbihoaXN0b3J5KSB7IH1cblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgaGlzdG9yeTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBjb3VudCA9IGFyZ3NbJ2NvdW50J10gfHwgYXJnc1snbGltaXQnXSB8fCAxMDA7XG5cdCAgICAgIHZhciByZXZlcnNlID0gYXJnc1sncmV2ZXJzZSddIHx8ICdmYWxzZSc7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgY2lwaGVyX2tleSA9IGFyZ3NbJ2NpcGhlcl9rZXknXTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgc3RhcnQgPSBhcmdzWydzdGFydCddO1xuXHQgICAgICB2YXIgZW5kID0gYXJnc1snZW5kJ107XG5cdCAgICAgIHZhciBpbmNsdWRlX3Rva2VuID0gYXJnc1snaW5jbHVkZV90b2tlbiddO1xuXHQgICAgICB2YXIgc3RyaW5nX21zZ190b2tlbiA9IGFyZ3NbJ3N0cmluZ19tZXNzYWdlX3Rva2VuJ10gfHwgZmFsc2U7XG5cdCAgICAgIHZhciBwYXJhbXMgPSB7fTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjaGFubmVsICYmICFjaGFubmVsX2dyb3VwKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXHQgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2FsbGJhY2snKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIHBhcmFtc1snc3RyaW5ndG9rZW4nXSA9ICd0cnVlJztcblx0ICAgICAgcGFyYW1zWydjb3VudCddID0gY291bnQ7XG5cdCAgICAgIHBhcmFtc1sncmV2ZXJzZSddID0gcmV2ZXJzZTtcblx0ICAgICAgcGFyYW1zWydhdXRoJ10gPSBhdXRoX2tleTtcblxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgIHBhcmFtc1snY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblx0ICAgICAgICBpZiAoIWNoYW5uZWwpIHtcblx0ICAgICAgICAgIGNoYW5uZWwgPSAnLCc7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChqc29ucCkgcGFyYW1zWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIGlmIChzdGFydCkgcGFyYW1zWydzdGFydCddID0gc3RhcnQ7XG5cdCAgICAgIGlmIChlbmQpIHBhcmFtc1snZW5kJ10gPSBlbmQ7XG5cdCAgICAgIGlmIChpbmNsdWRlX3Rva2VuKSBwYXJhbXNbJ2luY2x1ZGVfdG9rZW4nXSA9ICd0cnVlJztcblx0ICAgICAgaWYgKHN0cmluZ19tc2dfdG9rZW4pIHBhcmFtc1snc3RyaW5nX21lc3NhZ2VfdG9rZW4nXSA9ICd0cnVlJztcblxuXHQgICAgICAvLyBTZW5kIE1lc3NhZ2Vcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHBhcmFtcyksXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdvYmplY3QnICYmIHJlc3BvbnNlWydlcnJvciddKSB7XG5cdCAgICAgICAgICAgIGVycih7IG1lc3NhZ2U6IHJlc3BvbnNlWydtZXNzYWdlJ10sIHBheWxvYWQ6IHJlc3BvbnNlWydwYXlsb2FkJ10gfSk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHZhciBtZXNzYWdlcyA9IHJlc3BvbnNlWzBdO1xuXHQgICAgICAgICAgdmFyIGRlY3J5cHRlZF9tZXNzYWdlcyA9IFtdO1xuXHQgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBtZXNzYWdlcy5sZW5ndGg7IGErKykge1xuXHQgICAgICAgICAgICBpZiAoaW5jbHVkZV90b2tlbikge1xuXHQgICAgICAgICAgICAgIHZhciBuZXdfbWVzc2FnZSA9IGRlY3J5cHQobWVzc2FnZXNbYV1bJ21lc3NhZ2UnXSwgY2lwaGVyX2tleSk7XG5cdCAgICAgICAgICAgICAgdmFyIHRpbWV0b2tlbiA9IG1lc3NhZ2VzW2FdWyd0aW1ldG9rZW4nXTtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVjcnlwdGVkX21lc3NhZ2VzWydwdXNoJ10oeyBtZXNzYWdlOiBKU09OWydwYXJzZSddKG5ld19tZXNzYWdlKSwgdGltZXRva2VuOiB0aW1ldG9rZW4gfSk7XG5cdCAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgZGVjcnlwdGVkX21lc3NhZ2VzWydwdXNoJ10oKHsgbWVzc2FnZTogbmV3X21lc3NhZ2UsIHRpbWV0b2tlbjogdGltZXRva2VuIH0pKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5ld19tZXNzYWdlID0gZGVjcnlwdChtZXNzYWdlc1thXSwgY2lwaGVyX2tleSk7XG5cdCAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGRlY3J5cHRlZF9tZXNzYWdlc1sncHVzaCddKEpTT05bJ3BhcnNlJ10obmV3X21lc3NhZ2UpKTtcblx0ICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSgobmV3X21lc3NhZ2UpKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGNhbGxiYWNrKFtkZWNyeXB0ZWRfbWVzc2FnZXMsIHJlc3BvbnNlWzFdLCByZXNwb25zZVsyXV0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAnaGlzdG9yeScsICdzdWIta2V5Jyxcblx0ICAgICAgICAgIFNVQlNDUklCRV9LRVksICdjaGFubmVsJywgdXRpbHMuZW5jb2RlKGNoYW5uZWwpXG5cdCAgICAgICAgXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnJlcGxheSh7XG5cdCAgICAgc291cmNlICAgICAgOiAnbXlfY2hhbm5lbCcsXG5cdCAgICAgZGVzdGluYXRpb24gOiAnbmV3X2NoYW5uZWwnXG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIHJlcGxheTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBzb3VyY2UgPSBhcmdzWydzb3VyY2UnXTtcblx0ICAgICAgdmFyIGRlc3RpbmF0aW9uID0gYXJnc1snZGVzdGluYXRpb24nXTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHN0b3AgPSBhcmdzWydzdG9wJ107XG5cdCAgICAgIHZhciBzdGFydCA9IGFyZ3NbJ3N0YXJ0J107XG5cdCAgICAgIHZhciBlbmQgPSBhcmdzWydlbmQnXTtcblx0ICAgICAgdmFyIHJldmVyc2UgPSBhcmdzWydyZXZlcnNlJ107XG5cdCAgICAgIHZhciBsaW1pdCA9IGFyZ3NbJ2xpbWl0J107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBkYXRhID0ge307XG5cdCAgICAgIHZhciB1cmw7XG5cblx0ICAgICAgLy8gQ2hlY2sgVXNlciBJbnB1dFxuXHQgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFNvdXJjZSBDaGFubmVsJyk7XG5cdCAgICAgIGlmICghZGVzdGluYXRpb24pIHJldHVybiBlcnJvcignTWlzc2luZyBEZXN0aW5hdGlvbiBDaGFubmVsJyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgLy8gU2V0dXAgVVJMIFBhcmFtc1xuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIGlmIChzdG9wKSBkYXRhWydzdG9wJ10gPSAnYWxsJztcblx0ICAgICAgaWYgKHJldmVyc2UpIGRhdGFbJ3JldmVyc2UnXSA9ICd0cnVlJztcblx0ICAgICAgaWYgKHN0YXJ0KSBkYXRhWydzdGFydCddID0gc3RhcnQ7XG5cdCAgICAgIGlmIChlbmQpIGRhdGFbJ2VuZCddID0gZW5kO1xuXHQgICAgICBpZiAobGltaXQpIGRhdGFbJ2NvdW50J10gPSBsaW1pdDtcblxuXHQgICAgICBkYXRhWydhdXRoJ10gPSBhdXRoX2tleTtcblxuXHQgICAgICAvLyBDb21wb3NlIFVSTCBQYXJ0c1xuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3YxJywgJ3JlcGxheScsXG5cdCAgICAgICAgUFVCTElTSF9LRVksIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgc291cmNlLCBkZXN0aW5hdGlvblxuXHQgICAgICBdO1xuXG5cdCAgICAgIC8vIFN0YXJ0IChvciBTdG9wKSBSZXBsYXkhXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayhbMCwgJ0Rpc2Nvbm5lY3RlZCddKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLmF1dGgoJ0FKRkxLQUpTREtMQScpO1xuXHQgICAgICovXG5cdCAgICBhdXRoOiBmdW5jdGlvbiAoYXV0aCkge1xuXHQgICAgICBBVVRIX0tFWSA9IGF1dGg7XG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnRpbWUoZnVuY3Rpb24odGltZSl7IH0pO1xuXHQgICAgICovXG5cdCAgICB0aW1lOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgICB2YXIgZGF0YSA9IHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfTtcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICAgIHVybDogW1NURF9PUklHSU4sICd0aW1lJywganNvbnBdLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2VbMF0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgY2FsbGJhY2soMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnB1Ymxpc2goe1xuXHQgICAgIGNoYW5uZWwgOiAnbXlfY2hhdF9jaGFubmVsJyxcblx0ICAgICBtZXNzYWdlIDogJ2hlbGxvISdcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgcHVibGlzaDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBtc2cgPSBhcmdzWydtZXNzYWdlJ107XG5cdCAgICAgIGlmICghbXNnKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgTWVzc2FnZScpO1xuXG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgbXNnWydjYWxsYmFjayddIHx8IGFyZ3NbJ3N1Y2Nlc3MnXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ10gfHwgbXNnWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBtZXRhID0gYXJnc1snbWV0YSddIHx8IGFyZ3NbJ21ldGFkYXRhJ107XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gYXJnc1snY2lwaGVyX2tleSddO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBtc2dbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBwb3N0ID0gYXJnc1sncG9zdCddIHx8IGZhbHNlO1xuXHQgICAgICB2YXIgc3RvcmUgPSAoJ3N0b3JlX2luX2hpc3RvcnknIGluIGFyZ3MpID8gYXJnc1snc3RvcmVfaW5faGlzdG9yeSddIDogdHJ1ZTtcblx0ICAgICAgdmFyIHJlcGxpY2F0ZSA9ICgncmVwbGljYXRlJyBpbiBhcmdzKSA/IGFyZ3NbJ3JlcGxpY2F0ZSddIDogdHJ1ZTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGFkZF9tc2cgPSAncHVzaCc7XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciB1cmw7XG5cblx0ICAgICAgaWYgKGFyZ3NbJ3ByZXBlbmQnXSkgYWRkX21zZyA9ICd1bnNoaWZ0JztcblxuXHQgICAgICBpZiAoIWNoYW5uZWwpIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgaWYgKG1zZ1snZ2V0UHVibnViTWVzc2FnZSddKSB7XG5cdCAgICAgICAgbXNnID0gbXNnWydnZXRQdWJudWJNZXNzYWdlJ10oKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIElmIHRyeWluZyB0byBzZW5kIE9iamVjdFxuXHQgICAgICBtc2cgPSBKU09OWydzdHJpbmdpZnknXShlbmNyeXB0KG1zZywgY2lwaGVyX2tleSkpO1xuXG5cdCAgICAgIC8vIENyZWF0ZSBVUkxcblx0ICAgICAgdXJsID0gW1xuXHQgICAgICAgIFNURF9PUklHSU4sICdwdWJsaXNoJyxcblx0ICAgICAgICBQVUJMSVNIX0tFWSwgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICAwLCB1dGlscy5lbmNvZGUoY2hhbm5lbCksXG5cdCAgICAgICAganNvbnAsIHV0aWxzLmVuY29kZShtc2cpXG5cdCAgICAgIF07XG5cblx0ICAgICAgcGFyYW1zID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB9O1xuXG5cdCAgICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHBhcmFtc1snbWV0YSddID0gSlNPTi5zdHJpbmdpZnkobWV0YSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIXN0b3JlKSBwYXJhbXNbJ3N0b3JlJ10gPSAnMCc7XG5cdCAgICAgIGlmICghcmVwbGljYXRlKSBwYXJhbXNbJ25vcmVwJ10gPSAndHJ1ZSc7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBwYXJhbXNbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgLy8gUXVldWUgTWVzc2FnZSBTZW5kXG5cdCAgICAgIFBVQl9RVUVVRVthZGRfbXNnXSh7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIHVybDogdXJsLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhwYXJhbXMpLFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICAgIHB1Ymxpc2goMSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgICAgcHVibGlzaCgxKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG1vZGU6IChwb3N0KSA/ICdQT1NUJyA6ICdHRVQnXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIC8vIFNlbmQgTWVzc2FnZVxuXHQgICAgICBwdWJsaXNoKCk7XG5cdCAgICB9LFxuXG5cdCAgICBmaXJlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgYXJncy5zdG9yZV9pbl9oaXN0b3J5ID0gZmFsc2U7XG5cdCAgICAgIGFyZ3MucmVwbGljYXRlID0gZmFsc2U7XG5cdCAgICAgIFNFTEZbJ3B1Ymxpc2gnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi51bnN1YnNjcmliZSh7IGNoYW5uZWwgOiAnbXlfY2hhdCcgfSk7XG5cdCAgICAgKi9cblx0ICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNoYW5uZWxBcmcgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsR3JvdXBBcmcgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5cdCAgICAgIGlmICghY2hhbm5lbEFyZyAmJiAhY2hhbm5lbEdyb3VwQXJnKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCBvciBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAoY2hhbm5lbEFyZykge1xuXHQgICAgICAgIHZhciBjaGFubmVscyA9IHV0aWxzLmlzQXJyYXkoY2hhbm5lbEFyZykgPyBjaGFubmVsQXJnIDogKCcnICsgY2hhbm5lbEFyZykuc3BsaXQoJywnKTtcblx0ICAgICAgICB2YXIgZXhpc3RpbmdDaGFubmVscyA9IFtdO1xuXHQgICAgICAgIHZhciBwcmVzZW5jZUNoYW5uZWxzID0gW107XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgaWYgKENIQU5ORUxTW2NoYW5uZWxdKSBleGlzdGluZ0NoYW5uZWxzLnB1c2goY2hhbm5lbCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvLyBpZiB3ZSBkbyBub3QgaGF2ZSBhbnkgY2hhbm5lbHMgdG8gdW5zdWJzY3JpYmUgZnJvbSwgdHJpZ2dlciBhIGNhbGxiYWNrLlxuXHQgICAgICAgIGlmIChleGlzdGluZ0NoYW5uZWxzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBQcmVwYXJlIHByZXNlbmNlIGNoYW5uZWxzXG5cdCAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ0NoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgcHJlc2VuY2VDaGFubmVscy5wdXNoKGNoYW5uZWwgKyBQUkVTRU5DRV9TVUZGSVgpO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ0NoYW5uZWxzLmNvbmNhdChwcmVzZW5jZUNoYW5uZWxzKSwgZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgIGlmIChjaGFubmVsIGluIENIQU5ORUxTKSBkZWxldGUgQ0hBTk5FTFNbY2hhbm5lbF07XG5cdCAgICAgICAgICBpZiAoY2hhbm5lbCBpbiBTVEFURSkgZGVsZXRlIFNUQVRFW2NoYW5uZWxdO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKENIQU5ORUxTLmxlbmd0aCA9PT0gMCAmJiBDSEFOTkVMX0dST1VQUy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgIFRJTUVUT0tFTiA9IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIENCX0NBTExFRCA9IHRydWU7XG5cdCAgICAgICAgaWYgKFJFQURZKSB7XG5cdCAgICAgICAgICBDQl9DQUxMRUQgPSBTRUxGWydMRUFWRSddKGV4aXN0aW5nQ2hhbm5lbHMuam9pbignLCcpLCAwLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghQ0JfQ0FMTEVEKSBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjaGFubmVsR3JvdXBBcmcpIHtcblx0ICAgICAgICB2YXIgY2hhbm5lbEdyb3VwcyA9IHV0aWxzLmlzQXJyYXkoY2hhbm5lbEdyb3VwQXJnKSA/IGNoYW5uZWxHcm91cEFyZyA6ICgnJyArIGNoYW5uZWxHcm91cEFyZykuc3BsaXQoJywnKTtcblx0ICAgICAgICB2YXIgZXhpc3RpbmdDaGFubmVsR3JvdXBzID0gW107XG5cdCAgICAgICAgdmFyIHByZXNlbmNlQ2hhbm5lbEdyb3VwcyA9IFtdO1xuXG5cdCAgICAgICAgdXRpbHMuZWFjaChjaGFubmVsR3JvdXBzLCBmdW5jdGlvbiAoY2hhbm5lbEdyb3VwKSB7XG5cdCAgICAgICAgICBpZiAoQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbEdyb3VwXSkgZXhpc3RpbmdDaGFubmVsR3JvdXBzLnB1c2goY2hhbm5lbEdyb3VwKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGFueSBjaGFubmVsIGdyb3VwcyB0byB1bnN1YnNjcmliZSBmcm9tLCB0cmlnZ2VyIGEgY2FsbGJhY2suXG5cdCAgICAgICAgaWYgKGV4aXN0aW5nQ2hhbm5lbEdyb3Vwcy5sZW5ndGggPT0gMCkge1xuXHQgICAgICAgICAgY2FsbGJhY2soeyBhY3Rpb246ICdsZWF2ZScgfSk7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gUHJlcGFyZSBwcmVzZW5jZSBjaGFubmVsc1xuXHQgICAgICAgIHV0aWxzLmVhY2goZXhpc3RpbmdDaGFubmVsR3JvdXBzLCBmdW5jdGlvbiAoY2hhbm5lbEdyb3VwKSB7XG5cdCAgICAgICAgICBwcmVzZW5jZUNoYW5uZWxHcm91cHMucHVzaChjaGFubmVsR3JvdXAgKyBQUkVTRU5DRV9TVUZGSVgpO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ0NoYW5uZWxHcm91cHMuY29uY2F0KHByZXNlbmNlQ2hhbm5lbEdyb3VwcyksIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIGlmIChjaGFubmVsR3JvdXAgaW4gQ0hBTk5FTF9HUk9VUFMpIGRlbGV0ZSBDSEFOTkVMX0dST1VQU1tjaGFubmVsR3JvdXBdO1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWxHcm91cCBpbiBTVEFURSkgZGVsZXRlIFNUQVRFW2NoYW5uZWxHcm91cF07XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoQ0hBTk5FTFMubGVuZ3RoID09PSAwICYmIENIQU5ORUxfR1JPVVBTLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgVElNRVRPS0VOID0gMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgQ0JfQ0FMTEVEID0gdHJ1ZTtcblx0ICAgICAgICBpZiAoUkVBRFkpIHtcblx0ICAgICAgICAgIENCX0NBTExFRCA9IFNFTEZbJ0xFQVZFX0dST1VQJ10oZXhpc3RpbmdDaGFubmVsR3JvdXBzLmpvaW4oJywnKSwgMCwgYXV0aF9rZXksIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIUNCX0NBTExFRCkgY2FsbGJhY2soeyBhY3Rpb246ICdsZWF2ZScgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBSZXNldCBDb25uZWN0aW9uIGlmIENvdW50IExlc3Ncblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuc3Vic2NyaWJlKHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0J1xuXHQgICAgIGNhbGxiYWNrIDogZnVuY3Rpb24obWVzc2FnZSkgeyB9XG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblx0ICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snbWVzc2FnZSddO1xuXHQgICAgICB2YXIgY29ubmVjdCA9IGFyZ3NbJ2Nvbm5lY3QnXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHJlY29ubmVjdCA9IGFyZ3NbJ3JlY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZGlzY29ubmVjdCA9IGFyZ3NbJ2Rpc2Nvbm5lY3QnXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIFNVQl9FUlJPUiA9IGFyZ3NbJ2Vycm9yJ10gfHwgU1VCX0VSUk9SIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgaWRsZWNiID0gYXJnc1snaWRsZSddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgcHJlc2VuY2UgPSBhcmdzWydwcmVzZW5jZSddIHx8IDA7XG5cdCAgICAgIHZhciBub2hlcmVzeW5jID0gYXJnc1snbm9oZXJlc3luYyddIHx8IDA7XG5cdCAgICAgIHZhciBiYWNrZmlsbCA9IGFyZ3NbJ2JhY2tmaWxsJ10gfHwgMDtcblx0ICAgICAgdmFyIHRpbWV0b2tlbiA9IGFyZ3NbJ3RpbWV0b2tlbiddIHx8IDA7XG5cdCAgICAgIHZhciBzdWJfdGltZW91dCA9IGFyZ3NbJ3RpbWVvdXQnXSB8fCBTVUJfVElNRU9VVDtcblx0ICAgICAgdmFyIHdpbmRvd2luZyA9IGFyZ3NbJ3dpbmRvd2luZyddIHx8IFNVQl9XSU5ET1dJTkc7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciBoZWFydGJlYXQgPSBhcmdzWydoZWFydGJlYXQnXSB8fCBhcmdzWydwbmV4cGlyZXMnXTtcblx0ICAgICAgdmFyIGhlYXJ0YmVhdF9pbnRlcnZhbCA9IGFyZ3NbJ2hlYXJ0YmVhdF9pbnRlcnZhbCddO1xuXHQgICAgICB2YXIgcmVzdG9yZSA9IGFyZ3NbJ3Jlc3RvcmUnXSB8fCBTVUJfUkVTVE9SRTtcblxuXHQgICAgICBBVVRIX0tFWSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cblx0ICAgICAgLy8gUmVzdG9yZSBFbmFibGVkP1xuXHQgICAgICBTVUJfUkVTVE9SRSA9IHJlc3RvcmU7XG5cblx0ICAgICAgLy8gQWx3YXlzIFJlc2V0IHRoZSBUVFxuXHQgICAgICBUSU1FVE9LRU4gPSB0aW1ldG9rZW47XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2hhbm5lbCAmJiAhY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2FsbGJhY2snKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIGlmIChoZWFydGJlYXQgfHwgaGVhcnRiZWF0ID09PSAwIHx8IGhlYXJ0YmVhdF9pbnRlcnZhbCB8fCBoZWFydGJlYXRfaW50ZXJ2YWwgPT09IDApIHtcblx0ICAgICAgICBTRUxGWydzZXRfaGVhcnRiZWF0J10oaGVhcnRiZWF0LCBoZWFydGJlYXRfaW50ZXJ2YWwpO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gU2V0dXAgQ2hhbm5lbChzKVxuXHQgICAgICBpZiAoY2hhbm5lbCkge1xuXHQgICAgICAgIHV0aWxzLmVhY2goKGNoYW5uZWwuam9pbiA/IGNoYW5uZWwuam9pbignLCcpIDogJycgKyBjaGFubmVsKS5zcGxpdCgnLCcpLFxuXHQgICAgICAgICAgZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gQ0hBTk5FTFNbY2hhbm5lbF0gfHwge307XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgQ2hhbm5lbCBTdGF0ZVxuXHQgICAgICAgICAgICBDSEFOTkVMU1tTVUJfQ0hBTk5FTCA9IGNoYW5uZWxdID0ge1xuXHQgICAgICAgICAgICAgIG5hbWU6IGNoYW5uZWwsXG5cdCAgICAgICAgICAgICAgY29ubmVjdGVkOiBzZXR0aW5ncy5jb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdGVkOiBzZXR0aW5ncy5kaXNjb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgc3Vic2NyaWJlZDogMSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogU1VCX0NBTExCQUNLID0gY2FsbGJhY2ssXG5cdCAgICAgICAgICAgICAgY2lwaGVyX2tleTogYXJnc1snY2lwaGVyX2tleSddLFxuXHQgICAgICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdDogZGlzY29ubmVjdCxcblx0ICAgICAgICAgICAgICByZWNvbm5lY3Q6IHJlY29ubmVjdFxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuXHQgICAgICAgICAgICAgIGlmIChjaGFubmVsIGluIHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICBTVEFURVtjaGFubmVsXSA9IHN0YXRlW2NoYW5uZWxdO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBTVEFURVtjaGFubmVsXSA9IHN0YXRlO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIEVuYWJsZWQ/XG5cdCAgICAgICAgICAgIGlmICghcHJlc2VuY2UpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTdWJzY3JpYmUgUHJlc2VuY2UgQ2hhbm5lbFxuXHQgICAgICAgICAgICBTRUxGWydzdWJzY3JpYmUnXSh7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCArIFBSRVNFTkNFX1NVRkZJWCxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogcHJlc2VuY2UsXG5cdCAgICAgICAgICAgICAgcmVzdG9yZTogcmVzdG9yZVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAvLyBQcmVzZW5jZSBTdWJzY3JpYmVkP1xuXHQgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3Vic2NyaWJlZCkgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIC8vIFNlZSBXaG8ncyBIZXJlIE5vdz9cblx0ICAgICAgICAgICAgaWYgKG5vaGVyZXN5bmMpIHJldHVybjtcblx0ICAgICAgICAgICAgU0VMRlsnaGVyZV9ub3cnXSh7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcblx0ICAgICAgICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoeyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9KSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGhlcmUpIHtcblx0ICAgICAgICAgICAgICAgIHV0aWxzLmVhY2goJ3V1aWRzJyBpbiBoZXJlID8gaGVyZVsndXVpZHMnXSA6IFtdLCBmdW5jdGlvbiAodWlkKSB7XG5cdCAgICAgICAgICAgICAgICAgIHByZXNlbmNlKHtcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdqb2luJyxcblx0ICAgICAgICAgICAgICAgICAgICB1dWlkOiB1aWQsXG5cdCAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKHV0aWxzLnJub3coKSAvIDEwMDApLFxuXHQgICAgICAgICAgICAgICAgICAgIG9jY3VwYW5jeTogaGVyZVsnb2NjdXBhbmN5J10gfHwgMVxuXHQgICAgICAgICAgICAgICAgICB9LCBoZXJlLCBjaGFubmVsKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIFNldHVwIENoYW5uZWwgR3JvdXBzXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgdXRpbHMuZWFjaCgoY2hhbm5lbF9ncm91cC5qb2luID8gY2hhbm5lbF9ncm91cC5qb2luKCcsJykgOiAnJyArIGNoYW5uZWxfZ3JvdXApLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBDSEFOTkVMX0dST1VQU1tjaGFubmVsX2dyb3VwXSB8fCB7fTtcblxuXHQgICAgICAgICAgICBDSEFOTkVMX0dST1VQU1tjaGFubmVsX2dyb3VwXSA9IHtcblx0ICAgICAgICAgICAgICBuYW1lOiBjaGFubmVsX2dyb3VwLFxuXHQgICAgICAgICAgICAgIGNvbm5lY3RlZDogc2V0dGluZ3MuY29ubmVjdGVkLFxuXHQgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZDogc2V0dGluZ3MuZGlzY29ubmVjdGVkLFxuXHQgICAgICAgICAgICAgIHN1YnNjcmliZWQ6IDEsXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IFNVQl9DQUxMQkFDSyA9IGNhbGxiYWNrLFxuXHQgICAgICAgICAgICAgIGNpcGhlcl9rZXk6IGFyZ3NbJ2NpcGhlcl9rZXknXSxcblx0ICAgICAgICAgICAgICBjb25uZWN0OiBjb25uZWN0LFxuXHQgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IGRpc2Nvbm5lY3QsXG5cdCAgICAgICAgICAgICAgcmVjb25uZWN0OiByZWNvbm5lY3Rcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAvLyBQcmVzZW5jZSBFbmFibGVkP1xuXHQgICAgICAgICAgICBpZiAoIXByZXNlbmNlKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgLy8gU3Vic2NyaWJlIFByZXNlbmNlIENoYW5uZWxcblx0ICAgICAgICAgICAgU0VMRlsnc3Vic2NyaWJlJ10oe1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXA6IGNoYW5uZWxfZ3JvdXAgKyBQUkVTRU5DRV9TVUZGSVgsXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IHByZXNlbmNlLFxuXHQgICAgICAgICAgICAgIHJlc3RvcmU6IHJlc3RvcmUsXG5cdCAgICAgICAgICAgICAgYXV0aF9rZXk6IEFVVEhfS0VZXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIFN1YnNjcmliZWQ/XG5cdCAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdWJzY3JpYmVkKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgLy8gU2VlIFdobydzIEhlcmUgTm93P1xuXHQgICAgICAgICAgICBpZiAobm9oZXJlc3luYykgcmV0dXJuO1xuXHQgICAgICAgICAgICBTRUxGWydoZXJlX25vdyddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsX2dyb3VwOiBjaGFubmVsX2dyb3VwLFxuXHQgICAgICAgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyh7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH0pLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoaGVyZSkge1xuXHQgICAgICAgICAgICAgICAgdXRpbHMuZWFjaCgndXVpZHMnIGluIGhlcmUgPyBoZXJlWyd1dWlkcyddIDogW10sIGZ1bmN0aW9uICh1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgcHJlc2VuY2Uoe1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2pvaW4nLFxuXHQgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHVpZCxcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3IodXRpbHMucm5vdygpIC8gMTAwMCksXG5cdCAgICAgICAgICAgICAgICAgICAgb2NjdXBhbmN5OiBoZXJlWydvY2N1cGFuY3knXSB8fCAxXG5cdCAgICAgICAgICAgICAgICAgIH0sIGhlcmUsIGNoYW5uZWxfZ3JvdXApO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblxuXHQgICAgICAvLyBUZXN0IE5ldHdvcmsgQ29ubmVjdGlvblxuXHQgICAgICBmdW5jdGlvbiBfdGVzdF9jb25uZWN0aW9uKHN1Y2Nlc3MpIHtcblx0ICAgICAgICBpZiAoc3VjY2Vzcykge1xuXHQgICAgICAgICAgLy8gQmVnaW4gTmV4dCBTb2NrZXQgQ29ubmVjdGlvblxuXHQgICAgICAgICAgdXRpbHMudGltZW91dChDT05ORUNULCB3aW5kb3dpbmcpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBOZXcgT3JpZ2luIG9uIEZhaWxlZCBDb25uZWN0aW9uXG5cdCAgICAgICAgICBTVERfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4sIDEpO1xuXHQgICAgICAgICAgU1VCX09SSUdJTiA9IG5leHRvcmlnaW4oT1JJR0lOLCAxKTtcblxuXHQgICAgICAgICAgLy8gUmUtdGVzdCBDb25uZWN0aW9uXG5cdCAgICAgICAgICB1dGlscy50aW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgU0VMRlsndGltZSddKF90ZXN0X2Nvbm5lY3Rpb24pO1xuXHQgICAgICAgICAgfSwgU0VDT05EKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBEaXNjb25uZWN0ICYgUmVjb25uZWN0XG5cdCAgICAgICAgZWFjaF9jaGFubmVsKGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICAvLyBSZWNvbm5lY3Rcblx0ICAgICAgICAgIGlmIChzdWNjZXNzICYmIGNoYW5uZWwuZGlzY29ubmVjdGVkKSB7XG5cdCAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdGVkID0gMDtcblx0ICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWwucmVjb25uZWN0KGNoYW5uZWwubmFtZSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIC8vIERpc2Nvbm5lY3Rcblx0ICAgICAgICAgIGlmICghc3VjY2VzcyAmJiAhY2hhbm5lbC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8vIERpc2Nvbm5lY3QgJiBSZWNvbm5lY3QgZm9yIGNoYW5uZWwgZ3JvdXBzXG5cdCAgICAgICAgZWFjaF9jaGFubmVsX2dyb3VwKGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAvLyBSZWNvbm5lY3Rcblx0ICAgICAgICAgIGlmIChzdWNjZXNzICYmIGNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdGVkKSB7XG5cdCAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdGVkID0gMDtcblx0ICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxfZ3JvdXAucmVjb25uZWN0KGNoYW5uZWxfZ3JvdXAubmFtZSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIC8vIERpc2Nvbm5lY3Rcblx0ICAgICAgICAgIGlmICghc3VjY2VzcyAmJiAhY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3QoY2hhbm5lbF9ncm91cC5uYW1lKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIEV2ZW50ZWQgU3Vic2NyaWJlXG5cdCAgICAgIGZ1bmN0aW9uIF9jb25uZWN0KCkge1xuXHQgICAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxzID0gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTKS5qb2luKCcsJyk7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxfZ3JvdXBzID0gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KENIQU5ORUxfR1JPVVBTKS5qb2luKCcsJyk7XG5cblx0ICAgICAgICAvLyBTdG9wIENvbm5lY3Rpb25cblx0ICAgICAgICBpZiAoIWNoYW5uZWxzICYmICFjaGFubmVsX2dyb3VwcykgcmV0dXJuO1xuXG5cdCAgICAgICAgaWYgKCFjaGFubmVscykgY2hhbm5lbHMgPSAnLCc7XG5cblx0ICAgICAgICAvLyBDb25uZWN0IHRvIFB1Yk51YiBTdWJzY3JpYmUgU2VydmVyc1xuXHQgICAgICAgIF9yZXNldF9vZmZsaW5lKCk7XG5cblx0ICAgICAgICB2YXIgZGF0YSA9IF9nZXRfdXJsX3BhcmFtcyh7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH0pO1xuXG5cdCAgICAgICAgaWYgKGNoYW5uZWxfZ3JvdXBzKSB7XG5cdCAgICAgICAgICBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3Vwcztcblx0ICAgICAgICB9XG5cblxuXHQgICAgICAgIHZhciBzdCA9IEpTT04uc3RyaW5naWZ5KFNUQVRFKTtcblx0ICAgICAgICBpZiAoc3QubGVuZ3RoID4gMikgZGF0YVsnc3RhdGUnXSA9IEpTT04uc3RyaW5naWZ5KFNUQVRFKTtcblxuXHQgICAgICAgIGlmIChQUkVTRU5DRV9IQikgZGF0YVsnaGVhcnRiZWF0J10gPSBQUkVTRU5DRV9IQjtcblxuXHQgICAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICAgIHN0YXJ0X3ByZXNlbmNlX2hlYXJ0YmVhdCgpO1xuXHQgICAgICAgIFNVQl9SRUNFSVZFUiA9IHhkcih7XG5cdCAgICAgICAgICB0aW1lb3V0OiBzdWJfdGltZW91dCxcblx0ICAgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2VbJ2Vycm9yJ10gJiYgcmVzcG9uc2VbJ3NlcnZpY2UnXSkge1xuXHQgICAgICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIFNVQl9FUlJPUik7XG5cdCAgICAgICAgICAgICAgX3Rlc3RfY29ubmVjdGlvbihmYWxzZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgU0VMRlsndGltZSddKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAhc3VjY2VzcyAmJiAoX2ludm9rZV9lcnJvcihyZXNwb25zZSwgU1VCX0VSUk9SKSk7XG5cdCAgICAgICAgICAgICAgICBfdGVzdF9jb25uZWN0aW9uKHN1Y2Nlc3MpO1xuXHQgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICAgIFNVQl9PUklHSU4sICdzdWJzY3JpYmUnLFxuXHQgICAgICAgICAgICBTVUJTQ1JJQkVfS0VZLCB1dGlscy5lbmNvZGUoY2hhbm5lbHMpLFxuXHQgICAgICAgICAgICBqc29ucCwgVElNRVRPS0VOXG5cdCAgICAgICAgICBdLFxuXHQgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGZvciBFcnJvcnNcblx0ICAgICAgICAgICAgaWYgKCFtZXNzYWdlcyB8fCAodHlwZW9mIG1lc3NhZ2VzID09ICdvYmplY3QnICYmICdlcnJvcicgaW4gbWVzc2FnZXMgJiYgbWVzc2FnZXNbJ2Vycm9yJ10pKSB7XG5cdCAgICAgICAgICAgICAgU1VCX0VSUk9SKG1lc3NhZ2VzKTtcblx0ICAgICAgICAgICAgICByZXR1cm4gdXRpbHMudGltZW91dChDT05ORUNULCBTRUNPTkQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXNlciBJZGxlIENhbGxiYWNrXG5cdCAgICAgICAgICAgIGlkbGVjYihtZXNzYWdlc1sxXSk7XG5cblx0ICAgICAgICAgICAgLy8gUmVzdG9yZSBQcmV2aW91cyBDb25uZWN0aW9uIFBvaW50IGlmIE5lZWRlZFxuXHQgICAgICAgICAgICBUSU1FVE9LRU4gPSAhVElNRVRPS0VOICYmIFNVQl9SRVNUT1JFICYmIGRiWydnZXQnXShTVUJTQ1JJQkVfS0VZKSB8fCBtZXNzYWdlc1sxXTtcblxuXHQgICAgICAgICAgICAvKlxuXHQgICAgICAgICAgICAgLy8gQ29ubmVjdFxuXHQgICAgICAgICAgICAgZWFjaF9jaGFubmVsX3JlZ2lzdHJ5KGZ1bmN0aW9uKHJlZ2lzdHJ5KXtcblx0ICAgICAgICAgICAgIGlmIChyZWdpc3RyeS5jb25uZWN0ZWQpIHJldHVybjtcblx0ICAgICAgICAgICAgIHJlZ2lzdHJ5LmNvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgICByZWdpc3RyeS5jb25uZWN0KGNoYW5uZWwubmFtZSk7XG5cdCAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cblx0ICAgICAgICAgICAgLy8gQ29ubmVjdFxuXHQgICAgICAgICAgICBlYWNoX2NoYW5uZWwoZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgICAgICBpZiAoY2hhbm5lbC5jb25uZWN0ZWQpIHJldHVybjtcblx0ICAgICAgICAgICAgICBjaGFubmVsLmNvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbC5jb25uZWN0KGNoYW5uZWwubmFtZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIC8vIENvbm5lY3QgZm9yIGNoYW5uZWwgZ3JvdXBzXG5cdCAgICAgICAgICAgIGVhY2hfY2hhbm5lbF9ncm91cChmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgICAgICAgIGlmIChjaGFubmVsX2dyb3VwLmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmNvbm5lY3QoY2hhbm5lbF9ncm91cC5uYW1lKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgaWYgKFJFU1VNRUQgJiYgIVNVQl9SRVNUT1JFKSB7XG5cdCAgICAgICAgICAgICAgVElNRVRPS0VOID0gMDtcblx0ICAgICAgICAgICAgICBSRVNVTUVEID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgLy8gVXBkYXRlIFNhdmVkIFRpbWV0b2tlblxuXHQgICAgICAgICAgICAgIGRiWydzZXQnXShTVUJTQ1JJQkVfS0VZLCAwKTtcblx0ICAgICAgICAgICAgICB1dGlscy50aW1lb3V0KF9jb25uZWN0LCB3aW5kb3dpbmcpO1xuXHQgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludm9rZSBNZW1vcnkgQ2F0Y2h1cCBhbmQgUmVjZWl2ZSBVcCB0byAxMDBcblx0ICAgICAgICAgICAgLy8gUHJldmlvdXMgTWVzc2FnZXMgZnJvbSB0aGUgUXVldWUuXG5cdCAgICAgICAgICAgIGlmIChiYWNrZmlsbCkge1xuXHQgICAgICAgICAgICAgIFRJTUVUT0tFTiA9IDEwMDAwO1xuXHQgICAgICAgICAgICAgIGJhY2tmaWxsID0gMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSBTYXZlZCBUaW1ldG9rZW5cblx0ICAgICAgICAgICAgZGJbJ3NldCddKFNVQlNDUklCRV9LRVksIG1lc3NhZ2VzWzFdKTtcblxuXHQgICAgICAgICAgICAvLyBSb3V0ZSBDaGFubmVsIDwtLS0+IENhbGxiYWNrIGZvciBNZXNzYWdlXG5cdCAgICAgICAgICAgIHZhciBuZXh0X2NhbGxiYWNrID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICB2YXIgY2hhbm5lbHMgPSAnJztcblx0ICAgICAgICAgICAgICB2YXIgY2hhbm5lbHMyID0gJyc7XG5cblx0ICAgICAgICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID4gMykge1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbHMgPSBtZXNzYWdlc1szXTtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWxzMiA9IG1lc3NhZ2VzWzJdO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZXMubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbHMgPSBtZXNzYWdlc1syXTtcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbHMgPSB1dGlscy5tYXAoXG5cdCAgICAgICAgICAgICAgICAgIGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUyksIGZ1bmN0aW9uIChjaGFuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1hcChcblx0ICAgICAgICAgICAgICAgICAgICAgIEFycmF5KG1lc3NhZ2VzWzBdLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywnKS5zcGxpdCgnLCcpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbjtcblx0ICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgICB9KS5qb2luKCcsJyk7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgdmFyIGxpc3QgPSBjaGFubmVscy5zcGxpdCgnLCcpO1xuXHQgICAgICAgICAgICAgIHZhciBsaXN0MiA9IChjaGFubmVsczIpID8gY2hhbm5lbHMyLnNwbGl0KCcsJykgOiBbXTtcblxuXHQgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGxpc3Quc2hpZnQoKSB8fCBTVUJfQ0hBTk5FTDtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsMiA9IGxpc3QyLnNoaWZ0KCk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaG9iaiA9IHt9O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbDIpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgJiYgY2hhbm5lbC5pbmRleE9mKCctcG5wcmVzJykgPj0gMFxuXHQgICAgICAgICAgICAgICAgICAgICYmIGNoYW5uZWwyLmluZGV4T2YoJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsMiArPSAnLXBucHJlcyc7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgY2hvYmogPSBDSEFOTkVMX0dST1VQU1tjaGFubmVsMl0gfHwgQ0hBTk5FTFNbY2hhbm5lbDJdIHx8IHsgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9IH07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICBjaG9iaiA9IENIQU5ORUxTW2NoYW5uZWxdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgciA9IFtcblx0ICAgICAgICAgICAgICAgICAgY2hvYmpcblx0ICAgICAgICAgICAgICAgICAgICAuY2FsbGJhY2sgfHwgU1VCX0NBTExCQUNLLFxuXHQgICAgICAgICAgICAgICAgICBjaGFubmVsLnNwbGl0KFBSRVNFTkNFX1NVRkZJWClbMF1cblx0ICAgICAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgICAgICBjaGFubmVsMiAmJiByLnB1c2goY2hhbm5lbDIuc3BsaXQoUFJFU0VOQ0VfU1VGRklYKVswXSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcjtcblx0ICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSgpO1xuXG5cdCAgICAgICAgICAgIHZhciBsYXRlbmN5ID0gZGV0ZWN0X2xhdGVuY3koK21lc3NhZ2VzWzFdKTtcblx0ICAgICAgICAgICAgdXRpbHMuZWFjaChtZXNzYWdlc1swXSwgZnVuY3Rpb24gKG1zZykge1xuXHQgICAgICAgICAgICAgIHZhciBuZXh0ID0gbmV4dF9jYWxsYmFjaygpO1xuXHQgICAgICAgICAgICAgIHZhciBkZWNyeXB0ZWRfbXNnID0gZGVjcnlwdChtc2csXG5cdCAgICAgICAgICAgICAgICAoQ0hBTk5FTFNbbmV4dFsxXV0pID8gQ0hBTk5FTFNbbmV4dFsxXV1bJ2NpcGhlcl9rZXknXSA6IG51bGwpO1xuXHQgICAgICAgICAgICAgIG5leHRbMF0gJiYgbmV4dFswXShkZWNyeXB0ZWRfbXNnLCBtZXNzYWdlcywgbmV4dFsyXSB8fCBuZXh0WzFdLCBsYXRlbmN5LCBuZXh0WzFdKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgdXRpbHMudGltZW91dChfY29ubmVjdCwgd2luZG93aW5nKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIENPTk5FQ1QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgX3Jlc2V0X29mZmxpbmUoKTtcblx0ICAgICAgICB1dGlscy50aW1lb3V0KF9jb25uZWN0LCB3aW5kb3dpbmcpO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIC8vIFJlZHVjZSBTdGF0dXMgRmxpY2tlclxuXHQgICAgICBpZiAoIVJFQURZKSByZXR1cm4gUkVBRFlfQlVGRkVSLnB1c2goQ09OTkVDVCk7XG5cblx0ICAgICAgLy8gQ29ubmVjdCBOb3dcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuaGVyZV9ub3coeyBjaGFubmVsIDogJ215X2NoYXQnLCBjYWxsYmFjayA6IGZ1biB9KTtcblx0ICAgICAqL1xuXHQgICAgaGVyZV9ub3c6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrO1xuXHQgICAgICB2YXIgZGVidWcgPSBhcmdzWydkZWJ1ZyddO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgdXVpZHMgPSAoJ3V1aWRzJyBpbiBhcmdzKSA/IGFyZ3NbJ3V1aWRzJ10gOiB0cnVlO1xuXHQgICAgICB2YXIgc3RhdGUgPSBhcmdzWydzdGF0ZSddO1xuXHQgICAgICB2YXIgZGF0YSA9IHsgdXVpZDogVVVJRCwgYXV0aDogYXV0aF9rZXkgfTtcblxuXHQgICAgICBpZiAoIXV1aWRzKSBkYXRhWydkaXNhYmxlX3V1aWRzJ10gPSAxO1xuXHQgICAgICBpZiAoc3RhdGUpIGRhdGFbJ3N0YXRlJ10gPSAxO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2FsbGJhY2snKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIHZhciB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3YyJywgJ3ByZXNlbmNlJyxcblx0ICAgICAgICAnc3ViX2tleScsIFNVQlNDUklCRV9LRVlcblx0ICAgICAgXTtcblxuXHQgICAgICBjaGFubmVsICYmIHVybC5wdXNoKCdjaGFubmVsJykgJiYgdXJsLnB1c2godXRpbHMuZW5jb2RlKGNoYW5uZWwpKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXHQgICAgICAgICFjaGFubmVsICYmIHVybC5wdXNoKCdjaGFubmVsJykgJiYgdXJsLnB1c2goJywnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGRlYnVnOiBkZWJ1Zyxcblx0ICAgICAgICB1cmw6IHVybFxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLmN1cnJlbnRfY2hhbm5lbHNfYnlfdXVpZCh7IGNoYW5uZWwgOiAnbXlfY2hhdCcsIGNhbGxiYWNrIDogZnVuIH0pO1xuXHQgICAgICovXG5cdCAgICB3aGVyZV9ub3c6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIHV1aWQgPSBhcmdzWyd1dWlkJ10gfHwgVVVJRDtcblx0ICAgICAgdmFyIGRhdGEgPSB7IGF1dGg6IGF1dGhfa2V5IH07XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykge1xuXHQgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YyJywgJ3ByZXNlbmNlJyxcblx0ICAgICAgICAgICdzdWJfa2V5JywgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICAgICd1dWlkJywgdXRpbHMuZW5jb2RlKHV1aWQpXG5cdCAgICAgICAgXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHN0YXRlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjayB8fCBmdW5jdGlvbiAocikge307XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgc3RhdGUgPSBhcmdzWydzdGF0ZSddO1xuXHQgICAgICB2YXIgdXVpZCA9IGFyZ3NbJ3V1aWQnXSB8fCBVVUlEO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciB1cmw7XG5cdCAgICAgIHZhciBkYXRhID0gX2dldF91cmxfcGFyYW1zKHsgYXV0aDogYXV0aF9rZXkgfSk7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblx0ICAgICAgaWYgKCF1dWlkKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgVVVJRCcpO1xuXHQgICAgICBpZiAoIWNoYW5uZWwgJiYgIWNoYW5uZWxfZ3JvdXApIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykge1xuXHQgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPSAndW5kZWZpbmVkJ1xuXHQgICAgICAgICYmIENIQU5ORUxTW2NoYW5uZWxdICYmIENIQU5ORUxTW2NoYW5uZWxdLnN1YnNjcmliZWQpIHtcblx0ICAgICAgICBpZiAoc3RhdGUpIFNUQVRFW2NoYW5uZWxdID0gc3RhdGU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWxfZ3JvdXAgIT0gJ3VuZGVmaW5lZCdcblx0ICAgICAgICAmJiBDSEFOTkVMX0dST1VQU1tjaGFubmVsX2dyb3VwXVxuXHQgICAgICAgICYmIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdLnN1YnNjcmliZWRcblx0ICAgICAgKSB7XG5cdCAgICAgICAgaWYgKHN0YXRlKSBTVEFURVtjaGFubmVsX2dyb3VwXSA9IHN0YXRlO1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cblx0ICAgICAgICBpZiAoIWNoYW5uZWwpIHtcblx0ICAgICAgICAgIGNoYW5uZWwgPSAnLCc7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZGF0YVsnc3RhdGUnXSA9IEpTT04uc3RyaW5naWZ5KHN0YXRlKTtcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIGRhdGFbJ2luc3RhbmNlaWQnXSA9IElOU1RBTkNFSUQ7XG5cblx0ICAgICAgaWYgKHN0YXRlKSB7XG5cdCAgICAgICAgdXJsID0gW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YyJywgJ3ByZXNlbmNlJyxcblx0ICAgICAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICAgICdjaGFubmVsJywgY2hhbm5lbCxcblx0ICAgICAgICAgICd1dWlkJywgdXVpZCwgJ2RhdGEnXG5cdCAgICAgICAgXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB1cmwgPSBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ2NoYW5uZWwnLCBjaGFubmVsLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dGlscy5lbmNvZGUodXVpZClcblx0ICAgICAgICBdO1xuXHQgICAgICB9XG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IHVybFxuXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuZ3JhbnQoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnLFxuXHQgICAgIGNhbGxiYWNrIDogZnVuLFxuXHQgICAgIGVycm9yICAgIDogZnVuLFxuXHQgICAgIHR0bCAgICAgIDogMjQgKiA2MCwgLy8gTWludXRlc1xuXHQgICAgIHJlYWQgICAgIDogdHJ1ZSxcblx0ICAgICB3cml0ZSAgICA6IHRydWUsXG5cdCAgICAgYXV0aF9rZXkgOiAnM3k4dWlhamRrbHl0b3dzaidcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgZ3JhbnQ6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ10gfHwgYXJnc1snY2hhbm5lbHMnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciB0dGwgPSBhcmdzWyd0dGwnXTtcblx0ICAgICAgdmFyIHIgPSAoYXJnc1sncmVhZCddKSA/ICcxJyA6ICcwJztcblx0ICAgICAgdmFyIHcgPSAoYXJnc1snd3JpdGUnXSkgPyAnMScgOiAnMCc7XG5cdCAgICAgIHZhciBtID0gKGFyZ3NbJ21hbmFnZSddKSA/ICcxJyA6ICcwJztcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBhcmdzWydhdXRoX2tleXMnXTtcblxuXHQgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2FsbGJhY2snKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXHQgICAgICBpZiAoIVBVQkxJU0hfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgUHVibGlzaCBLZXknKTtcblx0ICAgICAgaWYgKCFTRUNSRVRfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU2VjcmV0IEtleScpO1xuXG5cdCAgICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG5cdCAgICAgIHZhciBzaWduX2lucHV0ID0gU1VCU0NSSUJFX0tFWSArICdcXG4nICsgUFVCTElTSF9LRVkgKyAnXFxuJyArICdncmFudCcgKyAnXFxuJztcblxuXHQgICAgICB2YXIgZGF0YSA9IHsgdzogdywgcjogciwgdGltZXN0YW1wOiB0aW1lc3RhbXAgfTtcblxuXHQgICAgICBpZiAoYXJnc1snbWFuYWdlJ10pIHtcblx0ICAgICAgICBkYXRhWydtJ10gPSBtO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh1dGlscy5pc0FycmF5KGNoYW5uZWwpKSB7XG5cdCAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWxbJ2pvaW4nXSgnLCcpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh1dGlscy5pc0FycmF5KGF1dGhfa2V5KSkge1xuXHQgICAgICAgIGF1dGhfa2V5ID0gYXV0aF9rZXlbJ2pvaW4nXSgnLCcpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsICE9IG51bGwgJiYgY2hhbm5lbC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsJ10gPSBjaGFubmVsO1xuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWxfZ3JvdXAgIT0gJ3VuZGVmaW5lZCcgJiYgY2hhbm5lbF9ncm91cCAhPSBudWxsICYmIGNoYW5uZWxfZ3JvdXAubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykge1xuXHQgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHRsIHx8IHR0bCA9PT0gMCkgZGF0YVsndHRsJ10gPSB0dGw7XG5cblx0ICAgICAgaWYgKGF1dGhfa2V5KSBkYXRhWydhdXRoJ10gPSBhdXRoX2tleTtcblxuXHQgICAgICBkYXRhID0gX2dldF91cmxfcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIGlmICghYXV0aF9rZXkpIGRlbGV0ZSBkYXRhWydhdXRoJ107XG5cblx0ICAgICAgc2lnbl9pbnB1dCArPSBfZ2V0X3BhbV9zaWduX2lucHV0X2Zyb21fcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIHZhciBzaWduYXR1cmUgPSBobWFjX1NIQTI1NihzaWduX2lucHV0LCBTRUNSRVRfS0VZKTtcblxuXHQgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUucmVwbGFjZSgvXFwrL2csICctJyk7XG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcblxuXHQgICAgICBkYXRhWydzaWduYXR1cmUnXSA9IHNpZ25hdHVyZTtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MScsICdhdXRoJywgJ2dyYW50Jyxcblx0ICAgICAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgICAgIF1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5tb2JpbGVfZ3dfcHJvdmlzaW9uICh7XG5cdCAgICAgZGV2aWNlX2lkOiAnQTY1NUZCQTk5MzFBQicsXG5cdCAgICAgb3AgICAgICAgOiAnYWRkJyB8ICdyZW1vdmUnLFxuXHQgICAgIGd3X3R5cGUgIDogJ2FwbnMnIHwgJ2djbScsXG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgfSk7XG5cdCAgICAgKi9cblxuXHQgICAgbW9iaWxlX2d3X3Byb3Zpc2lvbjogZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgb3AgPSBhcmdzWydvcCddO1xuXHQgICAgICB2YXIgZ3dfdHlwZSA9IGFyZ3NbJ2d3X3R5cGUnXTtcblx0ICAgICAgdmFyIGRldmljZV9pZCA9IGFyZ3NbJ2RldmljZV9pZCddO1xuXHQgICAgICB2YXIgcGFyYW1zO1xuXHQgICAgICB2YXIgdXJsO1xuXG5cdCAgICAgIGlmICghZGV2aWNlX2lkKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgRGV2aWNlIElEIChkZXZpY2VfaWQpJyk7XG5cdCAgICAgIGlmICghZ3dfdHlwZSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIEdXIFR5cGUgKGd3X3R5cGU6IGdjbSBvciBhcG5zKScpO1xuXHQgICAgICBpZiAoIW9wKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgR1cgT3BlcmF0aW9uIChvcDogYWRkIG9yIHJlbW92ZSknKTtcblx0ICAgICAgaWYgKCFjaGFubmVsKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgZ3cgZGVzdGluYXRpb24gQ2hhbm5lbCAoY2hhbm5lbCknKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIC8vIENyZWF0ZSBVUkxcblx0ICAgICAgdXJsID0gW1xuXHQgICAgICAgIFNURF9PUklHSU4sICd2MS9wdXNoL3N1Yi1rZXknLFxuXHQgICAgICAgIFNVQlNDUklCRV9LRVksICdkZXZpY2VzJywgZGV2aWNlX2lkXG5cdCAgICAgIF07XG5cblx0ICAgICAgcGFyYW1zID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSwgdHlwZTogZ3dfdHlwZSB9O1xuXG5cdCAgICAgIGlmIChvcCA9PSAnYWRkJykge1xuXHQgICAgICAgIHBhcmFtc1snYWRkJ10gPSBjaGFubmVsO1xuXHQgICAgICB9IGVsc2UgaWYgKG9wID09ICdyZW1vdmUnKSB7XG5cdCAgICAgICAgcGFyYW1zWydyZW1vdmUnXSA9IGNoYW5uZWw7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIHBhcmFtc1snaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBwYXJhbXMsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuYXVkaXQoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnLFxuXHQgICAgIGNhbGxiYWNrIDogZnVuLFxuXHQgICAgIGVycm9yICAgIDogZnVuLFxuXHQgICAgIHJlYWQgICAgIDogdHJ1ZSxcblx0ICAgICB3cml0ZSAgICA6IHRydWUsXG5cdCAgICAgYXV0aF9rZXkgOiAnM3k4dWlhamRrbHl0b3dzaidcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgYXVkaXQ6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2FsbGJhY2snKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXHQgICAgICBpZiAoIVBVQkxJU0hfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgUHVibGlzaCBLZXknKTtcblx0ICAgICAgaWYgKCFTRUNSRVRfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU2VjcmV0IEtleScpO1xuXG5cdCAgICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG5cdCAgICAgIHZhciBzaWduX2lucHV0ID0gU1VCU0NSSUJFX0tFWSArICdcXG4nICsgUFVCTElTSF9LRVkgKyAnXFxuJyArICdhdWRpdCcgKyAnXFxuJztcblxuXHQgICAgICB2YXIgZGF0YSA9IHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfTtcblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykge1xuXHQgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWwgIT0gJ3VuZGVmaW5lZCcgJiYgY2hhbm5lbCAhPSBudWxsICYmIGNoYW5uZWwubGVuZ3RoID4gMCkgZGF0YVsnY2hhbm5lbCddID0gY2hhbm5lbDtcblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsX2dyb3VwICE9ICd1bmRlZmluZWQnICYmIGNoYW5uZWxfZ3JvdXAgIT0gbnVsbCAmJiBjaGFubmVsX2dyb3VwLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChhdXRoX2tleSkgZGF0YVsnYXV0aCddID0gYXV0aF9rZXk7XG5cblx0ICAgICAgZGF0YSA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICBpZiAoIWF1dGhfa2V5KSBkZWxldGUgZGF0YVsnYXV0aCddO1xuXG5cdCAgICAgIHNpZ25faW5wdXQgKz0gX2dldF9wYW1fc2lnbl9pbnB1dF9mcm9tX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICB2YXIgc2lnbmF0dXJlID0gaG1hY19TSEEyNTYoc2lnbl9pbnB1dCwgU0VDUkVUX0tFWSk7XG5cblx0ICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnJlcGxhY2UoL1xcKy9nLCAnLScpO1xuXHQgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUucmVwbGFjZSgvXFwvL2csICdfJyk7XG5cblx0ICAgICAgZGF0YVsnc2lnbmF0dXJlJ10gPSBzaWduYXR1cmU7XG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YxJywgJ2F1dGgnLCAnYXVkaXQnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZXG5cdCAgICAgICAgXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnJldm9rZSh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgYXV0aF9rZXkgOiAnM3k4dWlhamRrbHl0b3dzaidcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgcmV2b2tlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgYXJnc1sncmVhZCddID0gZmFsc2U7XG5cdCAgICAgIGFyZ3NbJ3dyaXRlJ10gPSBmYWxzZTtcblx0ICAgICAgU0VMRlsnZ3JhbnQnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfdXVpZDogZnVuY3Rpb24gKHV1aWQpIHtcblx0ICAgICAgVVVJRCA9IHV1aWQ7XG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldF91dWlkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBVVUlEO1xuXHQgICAgfSxcblxuXHQgICAgaXNBcnJheTogZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICByZXR1cm4gdXRpbHMuaXNBcnJheShhcmcpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X3N1YnNjcmliZWRfY2hhbm5lbHM6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUywgdHJ1ZSk7XG5cdCAgICB9LFxuXG5cdCAgICBwcmVzZW5jZV9oZWFydGJlYXQ6IGZ1bmN0aW9uIChhcmdzKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgZGF0YSA9IHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfTtcblxuXHQgICAgICB2YXIgc3QgPSBKU09OWydzdHJpbmdpZnknXShTVEFURSk7XG5cdCAgICAgIGlmIChzdC5sZW5ndGggPiAyKSBkYXRhWydzdGF0ZSddID0gSlNPTlsnc3RyaW5naWZ5J10oU1RBVEUpO1xuXG5cdCAgICAgIGlmIChQUkVTRU5DRV9IQiA+IDAgJiYgUFJFU0VOQ0VfSEIgPCAzMjApIGRhdGFbJ2hlYXJ0YmVhdCddID0gUFJFU0VOQ0VfSEI7XG5cblx0ICAgICAgaWYgKGpzb25wICE9ICcwJykge1xuXHQgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBjaGFubmVscyA9IHV0aWxzLmVuY29kZShnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMsIHRydWUpWydqb2luJ10oJywnKSk7XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwcyA9IGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUywgdHJ1ZSlbJ2pvaW4nXSgnLCcpO1xuXG5cdCAgICAgIGlmICghY2hhbm5lbHMpIGNoYW5uZWxzID0gJywnO1xuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cHMpIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXBzO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ2NoYW5uZWwnLCBjaGFubmVscyxcblx0ICAgICAgICAgICdoZWFydGJlYXQnXG5cdCAgICAgICAgXSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICBzdG9wX3RpbWVyczogZnVuY3Rpb24gKCkge1xuXHQgICAgICBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIpO1xuXHQgICAgICBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIyKTtcblx0ICAgICAgY2xlYXJUaW1lb3V0KFBSRVNFTkNFX0hCX1RJTUVPVVQpO1xuXHQgICAgfSxcblxuXHQgICAgc2h1dGRvd246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgU0VMRlsnc3RvcF90aW1lcnMnXSgpO1xuXHQgICAgICBzaHV0ZG93biAmJiBzaHV0ZG93bigpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gRXhwb3NlIFBVQk5VQiBGdW5jdGlvbnNcblx0ICAgIHhkcjogeGRyLFxuXHQgICAgcmVhZHk6IHJlYWR5LFxuXHQgICAgZGI6IGRiLFxuXHQgICAgdXVpZDogdXRpbHMuZ2VuZXJhdGVVVUlELFxuXHQgICAgbWFwOiB1dGlscy5tYXAsXG5cdCAgICBlYWNoOiB1dGlscy5lYWNoLFxuXHQgICAgJ2VhY2gtY2hhbm5lbCc6IGVhY2hfY2hhbm5lbCxcblx0ICAgIGdyZXA6IHV0aWxzLmdyZXAsXG5cdCAgICBvZmZsaW5lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF9yZXNldF9vZmZsaW5lKDEsIHsgbWVzc2FnZTogJ09mZmxpbmUuIFBsZWFzZSBjaGVjayB5b3VyIG5ldHdvcmsgc2V0dGluZ3MuJyB9KTtcblx0ICAgIH0sXG5cdCAgICBzdXBwbGFudDogdXRpbHMuc3VwcGxhbnQsXG5cdCAgICBub3c6IHV0aWxzLnJub3csXG5cdCAgICB1bmlxdWU6IHVuaXF1ZSxcblx0ICAgIHVwZGF0ZXI6IHV0aWxzLnVwZGF0ZXJcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gX3BvbGxfb25saW5lKCkge1xuXHQgICAgX2lzX29ubGluZSgpIHx8IF9yZXNldF9vZmZsaW5lKDEsIHsgZXJyb3I6ICdPZmZsaW5lLiBQbGVhc2UgY2hlY2sgeW91ciBuZXR3b3JrIHNldHRpbmdzLicgfSk7XG5cdCAgICBfcG9sbF90aW1lciAmJiBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIpO1xuXHQgICAgX3BvbGxfdGltZXIgPSB1dGlscy50aW1lb3V0KF9wb2xsX29ubGluZSwgU0VDT05EKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfcG9sbF9vbmxpbmUyKCkge1xuXHQgICAgaWYgKCFUSU1FX0NIRUNLKSByZXR1cm47XG5cdCAgICBTRUxGWyd0aW1lJ10oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcblx0ICAgICAgZGV0ZWN0X3RpbWVfZGV0bGEoZnVuY3Rpb24gKCkge1xuXHQgICAgICB9LCBzdWNjZXNzKTtcblx0ICAgICAgc3VjY2VzcyB8fCBfcmVzZXRfb2ZmbGluZSgxLCB7XG5cdCAgICAgICAgZXJyb3I6ICdIZWFydGJlYXQgZmFpbGVkIHRvIGNvbm5lY3QgdG8gUHVibnViIFNlcnZlcnMuJyArXG5cdCAgICAgICAgJ1BsZWFzZSBjaGVjayB5b3VyIG5ldHdvcmsgc2V0dGluZ3MuJ1xuXHQgICAgICB9KTtcblx0ICAgICAgX3BvbGxfdGltZXIyICYmIGNsZWFyVGltZW91dChfcG9sbF90aW1lcjIpO1xuXHQgICAgICBfcG9sbF90aW1lcjIgPSB1dGlscy50aW1lb3V0KF9wb2xsX29ubGluZTIsIEtFRVBBTElWRSk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfcmVzZXRfb2ZmbGluZShlcnIsIG1zZykge1xuXHQgICAgU1VCX1JFQ0VJVkVSICYmIFNVQl9SRUNFSVZFUihlcnIsIG1zZyk7XG5cdCAgICBTVUJfUkVDRUlWRVIgPSBudWxsO1xuXG5cdCAgICBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIpO1xuXHQgICAgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyMik7XG5cdCAgfVxuXG5cdCAgaWYgKCFVVUlEKSBVVUlEID0gU0VMRlsndXVpZCddKCk7XG5cdCAgaWYgKCFJTlNUQU5DRUlEKSBJTlNUQU5DRUlEID0gU0VMRlsndXVpZCddKCk7XG5cdCAgZGJbJ3NldCddKFNVQlNDUklCRV9LRVkgKyAndXVpZCcsIFVVSUQpO1xuXG5cdCAgX3BvbGxfdGltZXIgPSB1dGlscy50aW1lb3V0KF9wb2xsX29ubGluZSwgU0VDT05EKTtcblx0ICBfcG9sbF90aW1lcjIgPSB1dGlscy50aW1lb3V0KF9wb2xsX29ubGluZTIsIEtFRVBBTElWRSk7XG5cdCAgUFJFU0VOQ0VfSEJfVElNRU9VVCA9IHV0aWxzLnRpbWVvdXQoXG5cdCAgICBzdGFydF9wcmVzZW5jZV9oZWFydGJlYXQsXG5cdCAgICAoUFJFU0VOQ0VfSEJfSU5URVJWQUwgLSAzKSAqIFNFQ09ORFxuXHQgICk7XG5cblx0ICAvLyBEZXRlY3QgQWdlIG9mIE1lc3NhZ2Vcblx0ICBmdW5jdGlvbiBkZXRlY3RfbGF0ZW5jeSh0dCkge1xuXHQgICAgdmFyIGFkanVzdGVkX3RpbWUgPSB1dGlscy5ybm93KCkgLSBUSU1FX0RSSUZUO1xuXHQgICAgcmV0dXJuIGFkanVzdGVkX3RpbWUgLSB0dCAvIDEwMDAwO1xuXHQgIH1cblxuXHQgIGRldGVjdF90aW1lX2RldGxhKCk7XG5cdCAgZnVuY3Rpb24gZGV0ZWN0X3RpbWVfZGV0bGEoY2IsIHRpbWUpIHtcblx0ICAgIHZhciBzdGltZSA9IHV0aWxzLnJub3coKTtcblxuXHQgICAgdGltZSAmJiBjYWxjdWxhdGUodGltZSkgfHwgU0VMRlsndGltZSddKGNhbGN1bGF0ZSk7XG5cblx0ICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZSh0aW1lKSB7XG5cdCAgICAgIGlmICghdGltZSkgcmV0dXJuO1xuXHQgICAgICB2YXIgcHRpbWUgPSB0aW1lIC8gMTAwMDA7XG5cdCAgICAgIHZhciBsYXRlbmN5ID0gKHV0aWxzLnJub3coKSAtIHN0aW1lKSAvIDI7XG5cdCAgICAgIFRJTUVfRFJJRlQgPSB1dGlscy5ybm93KCkgLSAocHRpbWUgKyBsYXRlbmN5KTtcblx0ICAgICAgY2IgJiYgY2IoVElNRV9EUklGVCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIFNFTEY7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBQTl9BUEk6IFBOX0FQSSxcblx0ICB1bmlxdWU6IHVuaXF1ZSxcblx0ICBQTm1lc3NhZ2U6IFBObWVzc2FnZSxcblx0ICBERUZfVElNRU9VVDogREVGX1RJTUVPVVQsXG5cdCAgdGltZW91dDogdXRpbHMudGltZW91dCxcblx0ICBidWlsZF91cmw6IHV0aWxzLmJ1aWxkVVJMLFxuXHQgIGVhY2g6IHV0aWxzLmVhY2gsXG5cdCAgdXVpZDogdXRpbHMuZ2VuZXJhdGVVVUlELFxuXHQgIFVSTEJJVDogZGVmYXVsdENvbmZpZ3VyYXRpb24uVVJMQklULFxuXHQgIGdyZXA6IHV0aWxzLmdyZXAsXG5cdCAgc3VwcGxhbnQ6IHV0aWxzLnN1cHBsYW50LFxuXHQgIG5vdzogdXRpbHMucm5vdyxcblx0ICB1cGRhdGVyOiB1dGlscy51cGRhdGVyLFxuXHQgIG1hcDogdXRpbHMubWFwXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHRcdFwiUEFSQU1TQklUXCI6IFwiJlwiLFxuXHRcdFwiVVJMQklUXCI6IFwiL1wiXG5cdH07XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiAwLCBibG9jay1zY29wZWQtdmFyOiAwLCBuby1yZWRlY2xhcmU6IDAsIGd1YXJkLWZvci1pbjogMCAqL1xuXG5cdHZhciBkZWZhdWx0Q29uZmlndXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBSRVBMID0gL3soW1xcd1xcLV0rKX0vZztcblxuXHRmdW5jdGlvbiBybm93KCkge1xuXHQgIHJldHVybiArbmV3IERhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuXHQgIHJldHVybiAhIWFyZyAmJiB0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KGFyZykgfHwgdHlwZW9mKGFyZy5sZW5ndGgpID09PSAnbnVtYmVyJyk7XG5cdCAgLy8gcmV0dXJuICEhYXJnICYmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoYXJnKSB8fCB0eXBlb2YoYXJnLmxlbmd0aCkgPT09IFwibnVtYmVyXCIpXG5cdH1cblxuXHQvKipcblx0ICogRUFDSFxuXHQgKiA9PT09XG5cdCAqIGVhY2goIFsxLDIsM10sIGZ1bmN0aW9uKGl0ZW0pIHsgfSApXG5cdCAqL1xuXHRmdW5jdGlvbiBlYWNoKG8sIGYpIHtcblx0ICBpZiAoIW8gfHwgIWYpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICBpZiAoaXNBcnJheShvKSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvLmxlbmd0aDsgaSA8IGw7KSB7XG5cdCAgICAgIGYuY2FsbChvW2ldLCBvW2ldLCBpKyspO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBmb3IgKHZhciBpIGluIG8pIHtcblx0ICAgICAgby5oYXNPd25Qcm9wZXJ0eSAmJlxuXHQgICAgICBvLmhhc093blByb3BlcnR5KGkpICYmXG5cdCAgICAgIGYuY2FsbChvW2ldLCBpLCBvW2ldKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogRU5DT0RFXG5cdCAqID09PT09PVxuXHQgKiB2YXIgZW5jb2RlZF9kYXRhID0gZW5jb2RlKCdwYXRoJyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUocGF0aCkgeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpOyB9XG5cblx0LyoqXG5cdCAqIEJ1aWxkIFVybFxuXHQgKiA9PT09PT09XG5cdCAqXG5cdCAqL1xuXHRmdW5jdGlvbiBidWlsZFVSTCh1cmxDb21wb25lbnRzLCB1cmxQYXJhbXMpIHtcblx0ICB2YXIgdXJsID0gdXJsQ29tcG9uZW50cy5qb2luKGRlZmF1bHRDb25maWd1cmF0aW9uLlVSTEJJVCk7XG5cdCAgdmFyIHBhcmFtcyA9IFtdO1xuXG5cdCAgaWYgKCF1cmxQYXJhbXMpIHJldHVybiB1cmw7XG5cblx0ICBlYWNoKHVybFBhcmFtcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgIHZhciB2YWx1ZVN0ciA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSA/IEpTT05bJ3N0cmluZ2lmeSddKHZhbHVlKSA6IHZhbHVlO1xuXHQgICAgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgdmFsdWUgIT09IG51bGwgJiYgZW5jb2RlKHZhbHVlU3RyKS5sZW5ndGggPiAwXG5cdCAgICApICYmIHBhcmFtcy5wdXNoKGtleSArICc9JyArIGVuY29kZSh2YWx1ZVN0cikpO1xuXHQgIH0pO1xuXG5cdCAgdXJsICs9ICc/JyArIHBhcmFtcy5qb2luKGRlZmF1bHRDb25maWd1cmF0aW9uLlBBUkFNU0JJVCk7XG5cdCAgcmV0dXJuIHVybDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVUERBVEVSXG5cdCAqID09PT09PT1cblx0ICogdmFyIHRpbWVzdGFtcCA9IHVuaXF1ZSgpO1xuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlcihmdW4sIHJhdGUpIHtcblx0ICB2YXIgdGltZW91dDtcblx0ICB2YXIgbGFzdCA9IDA7XG5cdCAgdmFyIHJ1bm5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChsYXN0ICsgcmF0ZSA+IHJub3coKSkge1xuXHQgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJ1bm5pdCwgcmF0ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBsYXN0ID0gcm5vdygpO1xuXHQgICAgICBmdW4oKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0dXJuIHJ1bm5pdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHUkVQXG5cdCAqID09PT1cblx0ICogdmFyIGxpc3QgPSBncmVwKCBbMSwyLDNdLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtICUgMiB9IClcblx0ICovXG5cdGZ1bmN0aW9uIGdyZXAobGlzdCwgZnVuKSB7XG5cdCAgdmFyIGZpbiA9IFtdO1xuXHQgIGVhY2gobGlzdCB8fCBbXSwgZnVuY3Rpb24gKGwpIHtcblx0ICAgIGZ1bihsKSAmJiBmaW4ucHVzaChsKTtcblx0ICB9KTtcblx0ICByZXR1cm4gZmluO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNVUFBMQU5UXG5cdCAqID09PT09PT09XG5cdCAqIHZhciB0ZXh0ID0gc3VwcGxhbnQoICdIZWxsbyB7bmFtZX0hJywgeyBuYW1lIDogJ0pvaG4nIH0gKVxuXHQgKi9cblx0ZnVuY3Rpb24gc3VwcGxhbnQoc3RyLCB2YWx1ZXMpIHtcblx0ICByZXR1cm4gc3RyLnJlcGxhY2UoUkVQTCwgZnVuY3Rpb24gKF8sIG1hdGNoKSB7XG5cdCAgICByZXR1cm4gdmFsdWVzW21hdGNoXSB8fCBfO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIHRpbWVvdXRcblx0ICogPT09PT09PVxuXHQgKiB0aW1lb3V0KCBmdW5jdGlvbigpe30sIDEwMCApO1xuXHQgKi9cblx0ZnVuY3Rpb24gdGltZW91dChmdW4sIHdhaXQpIHtcblx0ICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCB3YWl0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiB1dWlkXG5cdCAqID09PT1cblx0ICogdmFyIG15X3V1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0ICovXG5cdGZ1bmN0aW9uIGdlbmVyYXRlVVVJRChjYWxsYmFjaykge1xuXHQgIHZhciB1ID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLFxuXHQgICAgZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuXHQgICAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG5cdCAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0ICAgIH0pO1xuXHQgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sodSk7XG5cdCAgcmV0dXJuIHU7XG5cdH1cblxuXHQvKipcblx0ICogTUFQXG5cdCAqID09PVxuXHQgKiB2YXIgbGlzdCA9IG1hcCggWzEsMiwzXSwgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbSArIDEgfSApXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAobGlzdCwgZnVuKSB7XG5cdCAgdmFyIGZpbiA9IFtdO1xuXHQgIGVhY2gobGlzdCB8fCBbXSwgZnVuY3Rpb24gKGssIHYpIHtcblx0ICAgIGZpbi5wdXNoKGZ1bihrLCB2KSk7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGZpbjtcblx0fVxuXG5cblx0ZnVuY3Rpb24gcGFtRW5jb2RlKHN0cikge1xuXHQgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSp+XS9nLCBmdW5jdGlvbiAoYykge1xuXHQgICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0ICB9KTtcblx0fVxuXG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgYnVpbGRVUkw6IGJ1aWxkVVJMLFxuXHQgIGVuY29kZTogZW5jb2RlLFxuXHQgIGVhY2g6IGVhY2gsXG5cdCAgdXBkYXRlcjogdXBkYXRlcixcblx0ICBybm93OiBybm93LFxuXHQgIGlzQXJyYXk6IGlzQXJyYXksXG5cdCAgbWFwOiBtYXAsXG5cdCAgcGFtRW5jb2RlOiBwYW1FbmNvZGUsXG5cdCAgZ2VuZXJhdGVVVUlEOiBnZW5lcmF0ZVVVSUQsXG5cdCAgdGltZW91dDogdGltZW91dCxcblx0ICBzdXBwbGFudDogc3VwcGxhbnQsXG5cdCAgZ3JlcDogZ3JlcFxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBlc2xpbnQgY2FtZWxjYXNlOiAwIGVxZXFlcTogMCAqL1xuXG5cdHZhciBDcnlwdG9KUyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cblx0ZnVuY3Rpb24gY3J5cHRvX29iaigpIHtcblx0ICBmdW5jdGlvbiBTSEEyNTYocykge1xuXHQgICAgcmV0dXJuIENyeXB0b0pTWydTSEEyNTYnXShzKVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ0hleCddKTtcblx0ICB9XG5cblx0ICB2YXIgaXYgPSAnMDEyMzQ1Njc4OTAxMjM0NSc7XG5cblx0ICB2YXIgYWxsb3dlZEtleUVuY29kaW5ncyA9IFsnaGV4JywgJ3V0ZjgnLCAnYmFzZTY0JywgJ2JpbmFyeSddO1xuXHQgIHZhciBhbGxvd2VkS2V5TGVuZ3RocyA9IFsxMjgsIDI1Nl07XG5cdCAgdmFyIGFsbG93ZWRNb2RlcyA9IFsnZWNiJywgJ2NiYyddO1xuXG5cdCAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHQgICAgZW5jcnlwdEtleTogdHJ1ZSxcblx0ICAgIGtleUVuY29kaW5nOiAndXRmOCcsXG5cdCAgICBrZXlMZW5ndGg6IDI1Nixcblx0ICAgIG1vZGU6ICdjYmMnXG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHBhcnNlX29wdGlvbnMob3B0aW9ucykge1xuXHQgICAgLy8gRGVmYXVsdHNcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgaWYgKCFvcHRpb25zWydoYXNPd25Qcm9wZXJ0eSddKCdlbmNyeXB0S2V5JykpIG9wdGlvbnNbJ2VuY3J5cHRLZXknXSA9IGRlZmF1bHRPcHRpb25zWydlbmNyeXB0S2V5J107XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ2tleUVuY29kaW5nJykpIG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5RW5jb2RpbmcnXTtcblx0ICAgIGlmICghb3B0aW9uc1snaGFzT3duUHJvcGVydHknXSgna2V5TGVuZ3RoJykpIG9wdGlvbnNbJ2tleUxlbmd0aCddID0gZGVmYXVsdE9wdGlvbnNbJ2tleUxlbmd0aCddO1xuXHQgICAgaWYgKCFvcHRpb25zWydoYXNPd25Qcm9wZXJ0eSddKCdtb2RlJykpIG9wdGlvbnNbJ21vZGUnXSA9IGRlZmF1bHRPcHRpb25zWydtb2RlJ107XG5cblx0ICAgIC8vIFZhbGlkYXRpb25cblx0ICAgIGlmIChhbGxvd2VkS2V5RW5jb2RpbmdzWydpbmRleE9mJ10ob3B0aW9uc1sna2V5RW5jb2RpbmcnXVsndG9Mb3dlckNhc2UnXSgpKSA9PSAtMSkgb3B0aW9uc1sna2V5RW5jb2RpbmcnXSA9IGRlZmF1bHRPcHRpb25zWydrZXlFbmNvZGluZyddO1xuXHQgICAgaWYgKGFsbG93ZWRLZXlMZW5ndGhzWydpbmRleE9mJ10ocGFyc2VJbnQob3B0aW9uc1sna2V5TGVuZ3RoJ10sIDEwKSkgPT0gLTEpIG9wdGlvbnNbJ2tleUxlbmd0aCddID0gZGVmYXVsdE9wdGlvbnNbJ2tleUxlbmd0aCddO1xuXHQgICAgaWYgKGFsbG93ZWRNb2Rlc1snaW5kZXhPZiddKG9wdGlvbnNbJ21vZGUnXVsndG9Mb3dlckNhc2UnXSgpKSA9PSAtMSkgb3B0aW9uc1snbW9kZSddID0gZGVmYXVsdE9wdGlvbnNbJ21vZGUnXTtcblxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVjb2RlX2tleShrZXksIG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zWydrZXlFbmNvZGluZyddID09PSAnYmFzZTY0Jykge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXVsncGFyc2UnXShrZXkpO1xuXHQgICAgfSBlbHNlIGlmIChvcHRpb25zWydrZXlFbmNvZGluZyddID09PSAnaGV4Jykge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ2VuYyddWydIZXgnXVsncGFyc2UnXShrZXkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGtleTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBnZXRfcGFkZGVkX2tleShrZXksIG9wdGlvbnMpIHtcblx0ICAgIGtleSA9IGRlY29kZV9rZXkoa2V5LCBvcHRpb25zKTtcblx0ICAgIGlmIChvcHRpb25zWydlbmNyeXB0S2V5J10pIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydlbmMnXVsnVXRmOCddWydwYXJzZSddKFNIQTI1NihrZXkpWydzbGljZSddKDAsIDMyKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4ga2V5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9tb2RlKG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zWydtb2RlJ10gPT09ICdlY2InKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snbW9kZSddWydFQ0InXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snbW9kZSddWydDQkMnXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBnZXRfaXYob3B0aW9ucykge1xuXHQgICAgcmV0dXJuIChvcHRpb25zWydtb2RlJ10gPT09ICdjYmMnKSA/IENyeXB0b0pTWydlbmMnXVsnVXRmOCddWydwYXJzZSddKGl2KSA6IG51bGw7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHtcblx0ICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChkYXRhLCBrZXksIG9wdGlvbnMpIHtcblx0ICAgICAgaWYgKCFrZXkpIHJldHVybiBkYXRhO1xuXHQgICAgICBvcHRpb25zID0gcGFyc2Vfb3B0aW9ucyhvcHRpb25zKTtcblx0ICAgICAgdmFyIGl2ID0gZ2V0X2l2KG9wdGlvbnMpO1xuXHQgICAgICB2YXIgbW9kZSA9IGdldF9tb2RlKG9wdGlvbnMpO1xuXHQgICAgICB2YXIgY2lwaGVyX2tleSA9IGdldF9wYWRkZWRfa2V5KGtleSwgb3B0aW9ucyk7XG5cdCAgICAgIHZhciBoZXhfbWVzc2FnZSA9IEpTT05bJ3N0cmluZ2lmeSddKGRhdGEpO1xuXHQgICAgICB2YXIgZW5jcnlwdGVkSGV4QXJyYXkgPSBDcnlwdG9KU1snQUVTJ11bJ2VuY3J5cHQnXShoZXhfbWVzc2FnZSwgY2lwaGVyX2tleSwgeyBpdjogaXYsIG1vZGU6IG1vZGUgfSlbJ2NpcGhlcnRleHQnXTtcblx0ICAgICAgdmFyIGJhc2VfNjRfZW5jcnlwdGVkID0gZW5jcnlwdGVkSGV4QXJyYXlbJ3RvU3RyaW5nJ10oQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXSk7XG5cdCAgICAgIHJldHVybiBiYXNlXzY0X2VuY3J5cHRlZCB8fCBkYXRhO1xuXHQgICAgfSxcblxuXHQgICAgZGVjcnlwdDogZnVuY3Rpb24gKGRhdGEsIGtleSwgb3B0aW9ucykge1xuXHQgICAgICBpZiAoIWtleSkgcmV0dXJuIGRhdGE7XG5cdCAgICAgIG9wdGlvbnMgPSBwYXJzZV9vcHRpb25zKG9wdGlvbnMpO1xuXHQgICAgICB2YXIgaXYgPSBnZXRfaXYob3B0aW9ucyk7XG5cdCAgICAgIHZhciBtb2RlID0gZ2V0X21vZGUob3B0aW9ucyk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gZ2V0X3BhZGRlZF9rZXkoa2V5LCBvcHRpb25zKTtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB2YXIgYmluYXJ5X2VuYyA9IENyeXB0b0pTWydlbmMnXVsnQmFzZTY0J11bJ3BhcnNlJ10oZGF0YSk7XG5cdCAgICAgICAgdmFyIGpzb25fcGxhaW4gPSBDcnlwdG9KU1snQUVTJ11bJ2RlY3J5cHQnXSh7IGNpcGhlcnRleHQ6IGJpbmFyeV9lbmMgfSwgY2lwaGVyX2tleSwgeyBpdjogaXYsIG1vZGU6IG1vZGUgfSlbJ3RvU3RyaW5nJ10oQ3J5cHRvSlNbJ2VuYyddWydVdGY4J10pO1xuXHQgICAgICAgIHZhciBwbGFpbnRleHQgPSBKU09OWydwYXJzZSddKGpzb25fcGxhaW4pO1xuXHQgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gY3J5cHRvX29iajtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Lypcblx0IENyeXB0b0pTIHYzLjEuMlxuXHQgY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG5cdCAoYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0IGNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2Vcblx0ICovXG5cdHZhciBDcnlwdG9KUz1DcnlwdG9KU3x8ZnVuY3Rpb24oaCxzKXt2YXIgZj17fSxnPWYubGliPXt9LHE9ZnVuY3Rpb24oKXt9LG09Zy5CYXNlPXtleHRlbmQ6ZnVuY3Rpb24oYSl7cS5wcm90b3R5cGU9dGhpczt2YXIgYz1uZXcgcTthJiZjLm1peEluKGEpO2MuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpfHwoYy5pbml0PWZ1bmN0aW9uKCl7Yy4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTtjLmluaXQucHJvdG90eXBlPWM7Yy4kc3VwZXI9dGhpcztyZXR1cm4gY30sY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5leHRlbmQoKTthLmluaXQuYXBwbHkoYSxhcmd1bWVudHMpO3JldHVybiBhfSxpbml0OmZ1bmN0aW9uKCl7fSxtaXhJbjpmdW5jdGlvbihhKXtmb3IodmFyIGMgaW4gYSlhLmhhc093blByb3BlcnR5KGMpJiYodGhpc1tjXT1hW2NdKTthLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikmJih0aGlzLnRvU3RyaW5nPWEudG9TdHJpbmcpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19LFxuXHQgICAgcj1nLldvcmRBcnJheT1tLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihhLGMpe2E9dGhpcy53b3Jkcz1hfHxbXTt0aGlzLnNpZ0J5dGVzPWMhPXM/Yzo0KmEubGVuZ3RofSx0b1N0cmluZzpmdW5jdGlvbihhKXtyZXR1cm4oYXx8aykuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy53b3JkcyxkPWEud29yZHMsYj10aGlzLnNpZ0J5dGVzO2E9YS5zaWdCeXRlczt0aGlzLmNsYW1wKCk7aWYoYiU0KWZvcih2YXIgZT0wO2U8YTtlKyspY1tiK2U+Pj4yXXw9KGRbZT4+PjJdPj4+MjQtOCooZSU0KSYyNTUpPDwyNC04KigoYitlKSU0KTtlbHNlIGlmKDY1NTM1PGQubGVuZ3RoKWZvcihlPTA7ZTxhO2UrPTQpY1tiK2U+Pj4yXT1kW2U+Pj4yXTtlbHNlIGMucHVzaC5hcHBseShjLGQpO3RoaXMuc2lnQnl0ZXMrPWE7cmV0dXJuIHRoaXN9LGNsYW1wOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy53b3JkcyxjPXRoaXMuc2lnQnl0ZXM7YVtjPj4+Ml0mPTQyOTQ5NjcyOTU8PFxuXHQgICAgICAzMi04KihjJTQpO2EubGVuZ3RoPWguY2VpbChjLzQpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBhPW0uY2xvbmUuY2FsbCh0aGlzKTthLndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCk7cmV0dXJuIGF9LHJhbmRvbTpmdW5jdGlvbihhKXtmb3IodmFyIGM9W10sZD0wO2Q8YTtkKz00KWMucHVzaCg0Mjk0OTY3Mjk2KmgucmFuZG9tKCl8MCk7cmV0dXJuIG5ldyByLmluaXQoYyxhKX19KSxsPWYuZW5jPXt9LGs9bC5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbihhKXt2YXIgYz1hLndvcmRzO2E9YS5zaWdCeXRlcztmb3IodmFyIGQ9W10sYj0wO2I8YTtiKyspe3ZhciBlPWNbYj4+PjJdPj4+MjQtOCooYiU0KSYyNTU7ZC5wdXNoKChlPj4+NCkudG9TdHJpbmcoMTYpKTtkLnB1c2goKGUmMTUpLnRvU3RyaW5nKDE2KSl9cmV0dXJuIGQuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9W10sYj0wO2I8YztiKz0yKWRbYj4+PjNdfD1wYXJzZUludChhLnN1YnN0cihiLFxuXHQgICAgICAgIDIpLDE2KTw8MjQtNCooYiU4KTtyZXR1cm4gbmV3IHIuaW5pdChkLGMvMil9fSxuPWwuTGF0aW4xPXtzdHJpbmdpZnk6ZnVuY3Rpb24oYSl7dmFyIGM9YS53b3JkczthPWEuc2lnQnl0ZXM7Zm9yKHZhciBkPVtdLGI9MDtiPGE7YisrKWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNbYj4+PjJdPj4+MjQtOCooYiU0KSYyNTUpKTtyZXR1cm4gZC5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihhKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1bXSxiPTA7YjxjO2IrKylkW2I+Pj4yXXw9KGEuY2hhckNvZGVBdChiKSYyNTUpPDwyNC04KihiJTQpO3JldHVybiBuZXcgci5pbml0KGQsYyl9fSxqPWwuVXRmOD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShuLnN0cmluZ2lmeShhKSkpfWNhdGNoKGMpe3Rocm93IEVycm9yKFwiTWFsZm9ybWVkIFVURi04IGRhdGFcIik7fX0scGFyc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG4ucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGEpKSl9fSxcblx0ICAgIHU9Zy5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtPW0uZXh0ZW5kKHtyZXNldDpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IHIuaW5pdDt0aGlzLl9uRGF0YUJ5dGVzPTB9LF9hcHBlbmQ6ZnVuY3Rpb24oYSl7XCJzdHJpbmdcIj09dHlwZW9mIGEmJihhPWoucGFyc2UoYSkpO3RoaXMuX2RhdGEuY29uY2F0KGEpO3RoaXMuX25EYXRhQnl0ZXMrPWEuc2lnQnl0ZXN9LF9wcm9jZXNzOmZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuX2RhdGEsZD1jLndvcmRzLGI9Yy5zaWdCeXRlcyxlPXRoaXMuYmxvY2tTaXplLGY9Yi8oNCplKSxmPWE/aC5jZWlsKGYpOmgubWF4KChmfDApLXRoaXMuX21pbkJ1ZmZlclNpemUsMCk7YT1mKmU7Yj1oLm1pbig0KmEsYik7aWYoYSl7Zm9yKHZhciBnPTA7ZzxhO2crPWUpdGhpcy5fZG9Qcm9jZXNzQmxvY2soZCxnKTtnPWQuc3BsaWNlKDAsYSk7Yy5zaWdCeXRlcy09Yn1yZXR1cm4gbmV3IHIuaW5pdChnLGIpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBhPW0uY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgYS5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCk7cmV0dXJuIGF9LF9taW5CdWZmZXJTaXplOjB9KTtnLkhhc2hlcj11LmV4dGVuZCh7Y2ZnOm0uZXh0ZW5kKCksaW5pdDpmdW5jdGlvbihhKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoYSk7dGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe3UucmVzZXQuY2FsbCh0aGlzKTt0aGlzLl9kb1Jlc2V0KCl9LHVwZGF0ZTpmdW5jdGlvbihhKXt0aGlzLl9hcHBlbmQoYSk7dGhpcy5fcHJvY2VzcygpO3JldHVybiB0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbihhKXthJiZ0aGlzLl9hcHBlbmQoYSk7cmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKX0sYmxvY2tTaXplOjE2LF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGMsZCl7cmV0dXJuKG5ldyBhLmluaXQoZCkpLmZpbmFsaXplKGMpfX0sX2NyZWF0ZUhtYWNIZWxwZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGMsZCl7cmV0dXJuKG5ldyB0LkhNQUMuaW5pdChhLFxuXHQgICAgZCkpLmZpbmFsaXplKGMpfX19KTt2YXIgdD1mLmFsZ289e307cmV0dXJuIGZ9KE1hdGgpO1xuXG5cdC8vIFNIQTI1NlxuXHQoZnVuY3Rpb24oaCl7Zm9yKHZhciBzPUNyeXB0b0pTLGY9cy5saWIsZz1mLldvcmRBcnJheSxxPWYuSGFzaGVyLGY9cy5hbGdvLG09W10scj1bXSxsPWZ1bmN0aW9uKGEpe3JldHVybiA0Mjk0OTY3Mjk2KihhLShhfDApKXwwfSxrPTIsbj0wOzY0Pm47KXt2YXIgajthOntqPWs7Zm9yKHZhciB1PWguc3FydChqKSx0PTI7dDw9dTt0KyspaWYoIShqJXQpKXtqPSExO2JyZWFrIGF9aj0hMH1qJiYoOD5uJiYobVtuXT1sKGgucG93KGssMC41KSkpLHJbbl09bChoLnBvdyhrLDEvMykpLG4rKyk7aysrfXZhciBhPVtdLGY9Zi5TSEEyNTY9cS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgZy5pbml0KG0uc2xpY2UoMCkpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oYyxkKXtmb3IodmFyIGI9dGhpcy5faGFzaC53b3JkcyxlPWJbMF0sZj1iWzFdLGc9YlsyXSxqPWJbM10saD1iWzRdLG09Yls1XSxuPWJbNl0scT1iWzddLHA9MDs2ND5wO3ArKyl7aWYoMTY+cClhW3BdPVxuXHQgIGNbZCtwXXwwO2Vsc2V7dmFyIGs9YVtwLTE1XSxsPWFbcC0yXTthW3BdPSgoazw8MjV8az4+PjcpXihrPDwxNHxrPj4+MTgpXms+Pj4zKSthW3AtN10rKChsPDwxNXxsPj4+MTcpXihsPDwxM3xsPj4+MTkpXmw+Pj4xMCkrYVtwLTE2XX1rPXErKChoPDwyNnxoPj4+NileKGg8PDIxfGg+Pj4xMSleKGg8PDd8aD4+PjI1KSkrKGgmbV5+aCZuKStyW3BdK2FbcF07bD0oKGU8PDMwfGU+Pj4yKV4oZTw8MTl8ZT4+PjEzKV4oZTw8MTB8ZT4+PjIyKSkrKGUmZl5lJmdeZiZnKTtxPW47bj1tO209aDtoPWora3wwO2o9ZztnPWY7Zj1lO2U9aytsfDB9YlswXT1iWzBdK2V8MDtiWzFdPWJbMV0rZnwwO2JbMl09YlsyXStnfDA7YlszXT1iWzNdK2p8MDtiWzRdPWJbNF0raHwwO2JbNV09Yls1XSttfDA7Yls2XT1iWzZdK258MDtiWzddPWJbN10rcXwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX2RhdGEsZD1hLndvcmRzLGI9OCp0aGlzLl9uRGF0YUJ5dGVzLGU9OCphLnNpZ0J5dGVzO1xuXHQgIGRbZT4+PjVdfD0xMjg8PDI0LWUlMzI7ZFsoZSs2ND4+Pjk8PDQpKzE0XT1oLmZsb29yKGIvNDI5NDk2NzI5Nik7ZFsoZSs2ND4+Pjk8PDQpKzE1XT1iO2Euc2lnQnl0ZXM9NCpkLmxlbmd0aDt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9cS5jbG9uZS5jYWxsKHRoaXMpO2EuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBhfX0pO3MuU0hBMjU2PXEuX2NyZWF0ZUhlbHBlcihmKTtzLkhtYWNTSEEyNTY9cS5fY3JlYXRlSG1hY0hlbHBlcihmKX0pKE1hdGgpO1xuXG5cdC8vIEhNQUMgU0hBMjU2XG5cdChmdW5jdGlvbigpe3ZhciBoPUNyeXB0b0pTLHM9aC5lbmMuVXRmODtoLmFsZ28uSE1BQz1oLmxpYi5CYXNlLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihmLGcpe2Y9dGhpcy5faGFzaGVyPW5ldyBmLmluaXQ7XCJzdHJpbmdcIj09dHlwZW9mIGcmJihnPXMucGFyc2UoZykpO3ZhciBoPWYuYmxvY2tTaXplLG09NCpoO2cuc2lnQnl0ZXM+bSYmKGc9Zi5maW5hbGl6ZShnKSk7Zy5jbGFtcCgpO2Zvcih2YXIgcj10aGlzLl9vS2V5PWcuY2xvbmUoKSxsPXRoaXMuX2lLZXk9Zy5jbG9uZSgpLGs9ci53b3JkcyxuPWwud29yZHMsaj0wO2o8aDtqKyspa1tqXV49MTU0OTU1NjgyOCxuW2pdXj05MDk1MjI0ODY7ci5zaWdCeXRlcz1sLnNpZ0J5dGVzPW07dGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe3ZhciBmPXRoaXMuX2hhc2hlcjtmLnJlc2V0KCk7Zi51cGRhdGUodGhpcy5faUtleSl9LHVwZGF0ZTpmdW5jdGlvbihmKXt0aGlzLl9oYXNoZXIudXBkYXRlKGYpO3JldHVybiB0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbihmKXt2YXIgZz1cblx0ICB0aGlzLl9oYXNoZXI7Zj1nLmZpbmFsaXplKGYpO2cucmVzZXQoKTtyZXR1cm4gZy5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGYpKX19KX0pKCk7XG5cblx0Ly8gQmFzZTY0XG5cdChmdW5jdGlvbigpe3ZhciB1PUNyeXB0b0pTLHA9dS5saWIuV29yZEFycmF5O3UuZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKGQpe3ZhciBsPWQud29yZHMscD1kLnNpZ0J5dGVzLHQ9dGhpcy5fbWFwO2QuY2xhbXAoKTtkPVtdO2Zvcih2YXIgcj0wO3I8cDtyKz0zKWZvcih2YXIgdz0obFtyPj4+Ml0+Pj4yNC04KihyJTQpJjI1NSk8PDE2fChsW3IrMT4+PjJdPj4+MjQtOCooKHIrMSklNCkmMjU1KTw8OHxsW3IrMj4+PjJdPj4+MjQtOCooKHIrMiklNCkmMjU1LHY9MDs0PnYmJnIrMC43NSp2PHA7disrKWQucHVzaCh0LmNoYXJBdCh3Pj4+NiooMy12KSY2MykpO2lmKGw9dC5jaGFyQXQoNjQpKWZvcig7ZC5sZW5ndGglNDspZC5wdXNoKGwpO3JldHVybiBkLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGQpe3ZhciBsPWQubGVuZ3RoLHM9dGhpcy5fbWFwLHQ9cy5jaGFyQXQoNjQpO3QmJih0PWQuaW5kZXhPZih0KSwtMSE9dCYmKGw9dCkpO2Zvcih2YXIgdD1bXSxyPTAsdz0wO3c8XG5cdGw7dysrKWlmKHclNCl7dmFyIHY9cy5pbmRleE9mKGQuY2hhckF0KHctMSkpPDwyKih3JTQpLGI9cy5pbmRleE9mKGQuY2hhckF0KHcpKT4+PjYtMioodyU0KTt0W3I+Pj4yXXw9KHZ8Yik8PDI0LTgqKHIlNCk7cisrfXJldHVybiBwLmNyZWF0ZSh0LHIpfSxfbWFwOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIn19KSgpO1xuXG5cdC8vIEJsb2NrQ2lwaGVyXG5cdChmdW5jdGlvbih1KXtmdW5jdGlvbiBwKGIsbixhLGMsZSxqLGspe2I9YisobiZhfH5uJmMpK2UraztyZXR1cm4oYjw8anxiPj4+MzItaikrbn1mdW5jdGlvbiBkKGIsbixhLGMsZSxqLGspe2I9YisobiZjfGEmfmMpK2UraztyZXR1cm4oYjw8anxiPj4+MzItaikrbn1mdW5jdGlvbiBsKGIsbixhLGMsZSxqLGspe2I9Yisobl5hXmMpK2UraztyZXR1cm4oYjw8anxiPj4+MzItaikrbn1mdW5jdGlvbiBzKGIsbixhLGMsZSxqLGspe2I9YisoYV4obnx+YykpK2UraztyZXR1cm4oYjw8anxiPj4+MzItaikrbn1mb3IodmFyIHQ9Q3J5cHRvSlMscj10LmxpYix3PXIuV29yZEFycmF5LHY9ci5IYXNoZXIscj10LmFsZ28sYj1bXSx4PTA7NjQ+eDt4KyspYlt4XT00Mjk0OTY3Mjk2KnUuYWJzKHUuc2luKHgrMSkpfDA7cj1yLk1ENT12LmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyB3LmluaXQoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OF0pfSxcblx0ICBfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24ocSxuKXtmb3IodmFyIGE9MDsxNj5hO2ErKyl7dmFyIGM9bithLGU9cVtjXTtxW2NdPShlPDw4fGU+Pj4yNCkmMTY3MTE5MzV8KGU8PDI0fGU+Pj44KSY0Mjc4MjU1MzYwfXZhciBhPXRoaXMuX2hhc2gud29yZHMsYz1xW24rMF0sZT1xW24rMV0saj1xW24rMl0saz1xW24rM10sej1xW24rNF0scj1xW24rNV0sdD1xW24rNl0sdz1xW24rN10sdj1xW24rOF0sQT1xW24rOV0sQj1xW24rMTBdLEM9cVtuKzExXSx1PXFbbisxMl0sRD1xW24rMTNdLEU9cVtuKzE0XSx4PXFbbisxNV0sZj1hWzBdLG09YVsxXSxnPWFbMl0saD1hWzNdLGY9cChmLG0sZyxoLGMsNyxiWzBdKSxoPXAoaCxmLG0sZyxlLDEyLGJbMV0pLGc9cChnLGgsZixtLGosMTcsYlsyXSksbT1wKG0sZyxoLGYsaywyMixiWzNdKSxmPXAoZixtLGcsaCx6LDcsYls0XSksaD1wKGgsZixtLGcsciwxMixiWzVdKSxnPXAoZyxoLGYsbSx0LDE3LGJbNl0pLG09cChtLGcsaCxmLHcsMjIsYls3XSksXG5cdCAgICBmPXAoZixtLGcsaCx2LDcsYls4XSksaD1wKGgsZixtLGcsQSwxMixiWzldKSxnPXAoZyxoLGYsbSxCLDE3LGJbMTBdKSxtPXAobSxnLGgsZixDLDIyLGJbMTFdKSxmPXAoZixtLGcsaCx1LDcsYlsxMl0pLGg9cChoLGYsbSxnLEQsMTIsYlsxM10pLGc9cChnLGgsZixtLEUsMTcsYlsxNF0pLG09cChtLGcsaCxmLHgsMjIsYlsxNV0pLGY9ZChmLG0sZyxoLGUsNSxiWzE2XSksaD1kKGgsZixtLGcsdCw5LGJbMTddKSxnPWQoZyxoLGYsbSxDLDE0LGJbMThdKSxtPWQobSxnLGgsZixjLDIwLGJbMTldKSxmPWQoZixtLGcsaCxyLDUsYlsyMF0pLGg9ZChoLGYsbSxnLEIsOSxiWzIxXSksZz1kKGcsaCxmLG0seCwxNCxiWzIyXSksbT1kKG0sZyxoLGYseiwyMCxiWzIzXSksZj1kKGYsbSxnLGgsQSw1LGJbMjRdKSxoPWQoaCxmLG0sZyxFLDksYlsyNV0pLGc9ZChnLGgsZixtLGssMTQsYlsyNl0pLG09ZChtLGcsaCxmLHYsMjAsYlsyN10pLGY9ZChmLG0sZyxoLEQsNSxiWzI4XSksaD1kKGgsZixcblx0ICAgICAgbSxnLGosOSxiWzI5XSksZz1kKGcsaCxmLG0sdywxNCxiWzMwXSksbT1kKG0sZyxoLGYsdSwyMCxiWzMxXSksZj1sKGYsbSxnLGgsciw0LGJbMzJdKSxoPWwoaCxmLG0sZyx2LDExLGJbMzNdKSxnPWwoZyxoLGYsbSxDLDE2LGJbMzRdKSxtPWwobSxnLGgsZixFLDIzLGJbMzVdKSxmPWwoZixtLGcsaCxlLDQsYlszNl0pLGg9bChoLGYsbSxnLHosMTEsYlszN10pLGc9bChnLGgsZixtLHcsMTYsYlszOF0pLG09bChtLGcsaCxmLEIsMjMsYlszOV0pLGY9bChmLG0sZyxoLEQsNCxiWzQwXSksaD1sKGgsZixtLGcsYywxMSxiWzQxXSksZz1sKGcsaCxmLG0saywxNixiWzQyXSksbT1sKG0sZyxoLGYsdCwyMyxiWzQzXSksZj1sKGYsbSxnLGgsQSw0LGJbNDRdKSxoPWwoaCxmLG0sZyx1LDExLGJbNDVdKSxnPWwoZyxoLGYsbSx4LDE2LGJbNDZdKSxtPWwobSxnLGgsZixqLDIzLGJbNDddKSxmPXMoZixtLGcsaCxjLDYsYls0OF0pLGg9cyhoLGYsbSxnLHcsMTAsYls0OV0pLGc9cyhnLGgsZixtLFxuXHQgICAgICBFLDE1LGJbNTBdKSxtPXMobSxnLGgsZixyLDIxLGJbNTFdKSxmPXMoZixtLGcsaCx1LDYsYls1Ml0pLGg9cyhoLGYsbSxnLGssMTAsYls1M10pLGc9cyhnLGgsZixtLEIsMTUsYls1NF0pLG09cyhtLGcsaCxmLGUsMjEsYls1NV0pLGY9cyhmLG0sZyxoLHYsNixiWzU2XSksaD1zKGgsZixtLGcseCwxMCxiWzU3XSksZz1zKGcsaCxmLG0sdCwxNSxiWzU4XSksbT1zKG0sZyxoLGYsRCwyMSxiWzU5XSksZj1zKGYsbSxnLGgseiw2LGJbNjBdKSxoPXMoaCxmLG0sZyxDLDEwLGJbNjFdKSxnPXMoZyxoLGYsbSxqLDE1LGJbNjJdKSxtPXMobSxnLGgsZixBLDIxLGJbNjNdKTthWzBdPWFbMF0rZnwwO2FbMV09YVsxXSttfDA7YVsyXT1hWzJdK2d8MDthWzNdPWFbM10raHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBiPXRoaXMuX2RhdGEsbj1iLndvcmRzLGE9OCp0aGlzLl9uRGF0YUJ5dGVzLGM9OCpiLnNpZ0J5dGVzO25bYz4+PjVdfD0xMjg8PDI0LWMlMzI7dmFyIGU9dS5mbG9vcihhL1xuXHQgICAgNDI5NDk2NzI5Nik7blsoYys2ND4+Pjk8PDQpKzE1XT0oZTw8OHxlPj4+MjQpJjE2NzExOTM1fChlPDwyNHxlPj4+OCkmNDI3ODI1NTM2MDtuWyhjKzY0Pj4+OTw8NCkrMTRdPShhPDw4fGE+Pj4yNCkmMTY3MTE5MzV8KGE8PDI0fGE+Pj44KSY0Mjc4MjU1MzYwO2Iuc2lnQnl0ZXM9NCoobi5sZW5ndGgrMSk7dGhpcy5fcHJvY2VzcygpO2I9dGhpcy5faGFzaDtuPWIud29yZHM7Zm9yKGE9MDs0PmE7YSsrKWM9blthXSxuW2FdPShjPDw4fGM+Pj4yNCkmMTY3MTE5MzV8KGM8PDI0fGM+Pj44KSY0Mjc4MjU1MzYwO3JldHVybiBifSxjbG9uZTpmdW5jdGlvbigpe3ZhciBiPXYuY2xvbmUuY2FsbCh0aGlzKTtiLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gYn19KTt0Lk1ENT12Ll9jcmVhdGVIZWxwZXIocik7dC5IbWFjTUQ1PXYuX2NyZWF0ZUhtYWNIZWxwZXIocil9KShNYXRoKTtcblx0KGZ1bmN0aW9uKCl7dmFyIHU9Q3J5cHRvSlMscD11LmxpYixkPXAuQmFzZSxsPXAuV29yZEFycmF5LHA9dS5hbGdvLHM9cC5FdnBLREY9ZC5leHRlbmQoe2NmZzpkLmV4dGVuZCh7a2V5U2l6ZTo0LGhhc2hlcjpwLk1ENSxpdGVyYXRpb25zOjF9KSxpbml0OmZ1bmN0aW9uKGQpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChkKX0sY29tcHV0ZTpmdW5jdGlvbihkLHIpe2Zvcih2YXIgcD10aGlzLmNmZyxzPXAuaGFzaGVyLmNyZWF0ZSgpLGI9bC5jcmVhdGUoKSx1PWIud29yZHMscT1wLmtleVNpemUscD1wLml0ZXJhdGlvbnM7dS5sZW5ndGg8cTspe24mJnMudXBkYXRlKG4pO3ZhciBuPXMudXBkYXRlKGQpLmZpbmFsaXplKHIpO3MucmVzZXQoKTtmb3IodmFyIGE9MTthPHA7YSsrKW49cy5maW5hbGl6ZShuKSxzLnJlc2V0KCk7Yi5jb25jYXQobil9Yi5zaWdCeXRlcz00KnE7cmV0dXJuIGJ9fSk7dS5FdnBLREY9ZnVuY3Rpb24oZCxsLHApe3JldHVybiBzLmNyZWF0ZShwKS5jb21wdXRlKGQsXG5cdCAgbCl9fSkoKTtcblxuXHQvLyBDaXBoZXJcblx0Q3J5cHRvSlMubGliLkNpcGhlcnx8ZnVuY3Rpb24odSl7dmFyIHA9Q3J5cHRvSlMsZD1wLmxpYixsPWQuQmFzZSxzPWQuV29yZEFycmF5LHQ9ZC5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtLHI9cC5lbmMuQmFzZTY0LHc9cC5hbGdvLkV2cEtERix2PWQuQ2lwaGVyPXQuZXh0ZW5kKHtjZmc6bC5leHRlbmQoKSxjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsZSxhKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsYSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLGUsYSl9LGluaXQ6ZnVuY3Rpb24oZSxhLGIpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChiKTt0aGlzLl94Zm9ybU1vZGU9ZTt0aGlzLl9rZXk9YTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dC5yZXNldC5jYWxsKHRoaXMpO3RoaXMuX2RvUmVzZXQoKX0scHJvY2VzczpmdW5jdGlvbihlKXt0aGlzLl9hcHBlbmQoZSk7cmV0dXJuIHRoaXMuX3Byb2Nlc3MoKX0sXG5cdCAgZmluYWxpemU6ZnVuY3Rpb24oZSl7ZSYmdGhpcy5fYXBwZW5kKGUpO3JldHVybiB0aGlzLl9kb0ZpbmFsaXplKCl9LGtleVNpemU6NCxpdlNpemU6NCxfRU5DX1hGT1JNX01PREU6MSxfREVDX1hGT1JNX01PREU6MixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKGUpe3JldHVybntlbmNyeXB0OmZ1bmN0aW9uKGIsayxkKXtyZXR1cm4oXCJzdHJpbmdcIj09dHlwZW9mIGs/YzphKS5lbmNyeXB0KGUsYixrLGQpfSxkZWNyeXB0OmZ1bmN0aW9uKGIsayxkKXtyZXR1cm4oXCJzdHJpbmdcIj09dHlwZW9mIGs/YzphKS5kZWNyeXB0KGUsYixrLGQpfX19fSk7ZC5TdHJlYW1DaXBoZXI9di5leHRlbmQoe19kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb2Nlc3MoITApfSxibG9ja1NpemU6MX0pO3ZhciBiPXAubW9kZT17fSx4PWZ1bmN0aW9uKGUsYSxiKXt2YXIgYz10aGlzLl9pdjtjP3RoaXMuX2l2PXU6Yz10aGlzLl9wcmV2QmxvY2s7Zm9yKHZhciBkPTA7ZDxiO2QrKyllW2ErZF1ePVxuXHQgIGNbZF19LHE9KGQuQmxvY2tDaXBoZXJNb2RlPWwuZXh0ZW5kKHtjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGUsYSl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoZSxhKX0saW5pdDpmdW5jdGlvbihlLGEpe3RoaXMuX2NpcGhlcj1lO3RoaXMuX2l2PWF9fSkpLmV4dGVuZCgpO3EuRW5jcnlwdG9yPXEuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSxhKXt2YXIgYj10aGlzLl9jaXBoZXIsYz1iLmJsb2NrU2l6ZTt4LmNhbGwodGhpcyxlLGEsYyk7Yi5lbmNyeXB0QmxvY2soZSxhKTt0aGlzLl9wcmV2QmxvY2s9ZS5zbGljZShhLGErYyl9fSk7cS5EZWNyeXB0b3I9cS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLGEpe3ZhciBiPXRoaXMuX2NpcGhlcixjPWIuYmxvY2tTaXplLGQ9ZS5zbGljZShhLGErYyk7Yi5kZWNyeXB0QmxvY2soZSxhKTt4LmNhbGwodGhpcyxcblx0ICBlLGEsYyk7dGhpcy5fcHJldkJsb2NrPWR9fSk7Yj1iLkNCQz1xO3E9KHAucGFkPXt9KS5Qa2NzNz17cGFkOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTQqYixjPWMtYS5zaWdCeXRlcyVjLGQ9Yzw8MjR8Yzw8MTZ8Yzw8OHxjLGw9W10sbj0wO248YztuKz00KWwucHVzaChkKTtjPXMuY3JlYXRlKGwsYyk7YS5jb25jYXQoYyl9LHVucGFkOmZ1bmN0aW9uKGEpe2Euc2lnQnl0ZXMtPWEud29yZHNbYS5zaWdCeXRlcy0xPj4+Ml0mMjU1fX07ZC5CbG9ja0NpcGhlcj12LmV4dGVuZCh7Y2ZnOnYuY2ZnLmV4dGVuZCh7bW9kZTpiLHBhZGRpbmc6cX0pLHJlc2V0OmZ1bmN0aW9uKCl7di5yZXNldC5jYWxsKHRoaXMpO3ZhciBhPXRoaXMuY2ZnLGI9YS5pdixhPWEubW9kZTtpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXZhciBjPWEuY3JlYXRlRW5jcnlwdG9yO2Vsc2UgYz1hLmNyZWF0ZURlY3J5cHRvcix0aGlzLl9taW5CdWZmZXJTaXplPTE7dGhpcy5fbW9kZT1jLmNhbGwoYSxcblx0ICB0aGlzLGImJmIud29yZHMpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayhhLGIpfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2ZnLnBhZGRpbmc7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl7YS5wYWQodGhpcy5fZGF0YSx0aGlzLmJsb2NrU2l6ZSk7dmFyIGI9dGhpcy5fcHJvY2VzcyghMCl9ZWxzZSBiPXRoaXMuX3Byb2Nlc3MoITApLGEudW5wYWQoYik7cmV0dXJuIGJ9LGJsb2NrU2l6ZTo0fSk7dmFyIG49ZC5DaXBoZXJQYXJhbXM9bC5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oYSl7dGhpcy5taXhJbihhKX0sdG9TdHJpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuKGF8fHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyl9fSksYj0ocC5mb3JtYXQ9e30pLk9wZW5TU0w9e3N0cmluZ2lmeTpmdW5jdGlvbihhKXt2YXIgYj1hLmNpcGhlcnRleHQ7YT1hLnNhbHQ7cmV0dXJuKGE/cy5jcmVhdGUoWzEzOTg4OTM2ODQsXG5cdCAgMTcwMTA3NjgzMV0pLmNvbmNhdChhKS5jb25jYXQoYik6YikudG9TdHJpbmcocil9LHBhcnNlOmZ1bmN0aW9uKGEpe2E9ci5wYXJzZShhKTt2YXIgYj1hLndvcmRzO2lmKDEzOTg4OTM2ODQ9PWJbMF0mJjE3MDEwNzY4MzE9PWJbMV0pe3ZhciBjPXMuY3JlYXRlKGIuc2xpY2UoMiw0KSk7Yi5zcGxpY2UoMCw0KTthLnNpZ0J5dGVzLT0xNn1yZXR1cm4gbi5jcmVhdGUoe2NpcGhlcnRleHQ6YSxzYWx0OmN9KX19LGE9ZC5TZXJpYWxpemFibGVDaXBoZXI9bC5leHRlbmQoe2NmZzpsLmV4dGVuZCh7Zm9ybWF0OmJ9KSxlbmNyeXB0OmZ1bmN0aW9uKGEsYixjLGQpe2Q9dGhpcy5jZmcuZXh0ZW5kKGQpO3ZhciBsPWEuY3JlYXRlRW5jcnlwdG9yKGMsZCk7Yj1sLmZpbmFsaXplKGIpO2w9bC5jZmc7cmV0dXJuIG4uY3JlYXRlKHtjaXBoZXJ0ZXh0OmIsa2V5OmMsaXY6bC5pdixhbGdvcml0aG06YSxtb2RlOmwubW9kZSxwYWRkaW5nOmwucGFkZGluZyxibG9ja1NpemU6YS5ibG9ja1NpemUsZm9ybWF0dGVyOmQuZm9ybWF0fSl9LFxuXHQgIGRlY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCl7ZD10aGlzLmNmZy5leHRlbmQoZCk7Yj10aGlzLl9wYXJzZShiLGQuZm9ybWF0KTtyZXR1cm4gYS5jcmVhdGVEZWNyeXB0b3IoYyxkKS5maW5hbGl6ZShiLmNpcGhlcnRleHQpfSxfcGFyc2U6ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYT9iLnBhcnNlKGEsdGhpcyk6YX19KSxwPShwLmtkZj17fSkuT3BlblNTTD17ZXhlY3V0ZTpmdW5jdGlvbihhLGIsYyxkKXtkfHwoZD1zLnJhbmRvbSg4KSk7YT13LmNyZWF0ZSh7a2V5U2l6ZTpiK2N9KS5jb21wdXRlKGEsZCk7Yz1zLmNyZWF0ZShhLndvcmRzLnNsaWNlKGIpLDQqYyk7YS5zaWdCeXRlcz00KmI7cmV0dXJuIG4uY3JlYXRlKHtrZXk6YSxpdjpjLHNhbHQ6ZH0pfX0sYz1kLlBhc3N3b3JkQmFzZWRDaXBoZXI9YS5leHRlbmQoe2NmZzphLmNmZy5leHRlbmQoe2tkZjpwfSksZW5jcnlwdDpmdW5jdGlvbihiLGMsZCxsKXtsPXRoaXMuY2ZnLmV4dGVuZChsKTtkPWwua2RmLmV4ZWN1dGUoZCxcblx0ICBiLmtleVNpemUsYi5pdlNpemUpO2wuaXY9ZC5pdjtiPWEuZW5jcnlwdC5jYWxsKHRoaXMsYixjLGQua2V5LGwpO2IubWl4SW4oZCk7cmV0dXJuIGJ9LGRlY3J5cHQ6ZnVuY3Rpb24oYixjLGQsbCl7bD10aGlzLmNmZy5leHRlbmQobCk7Yz10aGlzLl9wYXJzZShjLGwuZm9ybWF0KTtkPWwua2RmLmV4ZWN1dGUoZCxiLmtleVNpemUsYi5pdlNpemUsYy5zYWx0KTtsLml2PWQuaXY7cmV0dXJuIGEuZGVjcnlwdC5jYWxsKHRoaXMsYixjLGQua2V5LGwpfX0pfSgpO1xuXG5cdC8vIEFFU1xuXHQoZnVuY3Rpb24oKXtmb3IodmFyIHU9Q3J5cHRvSlMscD11LmxpYi5CbG9ja0NpcGhlcixkPXUuYWxnbyxsPVtdLHM9W10sdD1bXSxyPVtdLHc9W10sdj1bXSxiPVtdLHg9W10scT1bXSxuPVtdLGE9W10sYz0wOzI1Nj5jO2MrKylhW2NdPTEyOD5jP2M8PDE6Yzw8MV4yODM7Zm9yKHZhciBlPTAsaj0wLGM9MDsyNTY+YztjKyspe3ZhciBrPWpeajw8MV5qPDwyXmo8PDNeajw8NCxrPWs+Pj44XmsmMjU1Xjk5O2xbZV09aztzW2tdPWU7dmFyIHo9YVtlXSxGPWFbel0sRz1hW0ZdLHk9MjU3KmFba11eMTY4NDMwMDgqazt0W2VdPXk8PDI0fHk+Pj44O3JbZV09eTw8MTZ8eT4+PjE2O3dbZV09eTw8OHx5Pj4+MjQ7dltlXT15O3k9MTY4NDMwMDkqR142NTUzNypGXjI1Nyp6XjE2ODQzMDA4KmU7YltrXT15PDwyNHx5Pj4+ODt4W2tdPXk8PDE2fHk+Pj4xNjtxW2tdPXk8PDh8eT4+PjI0O25ba109eTtlPyhlPXpeYVthW2FbR156XV1dLGpePWFbYVtqXV0pOmU9aj0xfXZhciBIPVswLDEsMiw0LDgsXG5cdCAgMTYsMzIsNjQsMTI4LDI3LDU0XSxkPWQuQUVTPXAuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLl9rZXksYz1hLndvcmRzLGQ9YS5zaWdCeXRlcy80LGE9NCooKHRoaXMuX25Sb3VuZHM9ZCs2KSsxKSxlPXRoaXMuX2tleVNjaGVkdWxlPVtdLGo9MDtqPGE7aisrKWlmKGo8ZCllW2pdPWNbal07ZWxzZXt2YXIgaz1lW2otMV07aiVkPzY8ZCYmND09aiVkJiYoaz1sW2s+Pj4yNF08PDI0fGxbaz4+PjE2JjI1NV08PDE2fGxbaz4+PjgmMjU1XTw8OHxsW2smMjU1XSk6KGs9azw8OHxrPj4+MjQsaz1sW2s+Pj4yNF08PDI0fGxbaz4+PjE2JjI1NV08PDE2fGxbaz4+PjgmMjU1XTw8OHxsW2smMjU1XSxrXj1IW2ovZHwwXTw8MjQpO2Vbal09ZVtqLWRdXmt9Yz10aGlzLl9pbnZLZXlTY2hlZHVsZT1bXTtmb3IoZD0wO2Q8YTtkKyspaj1hLWQsaz1kJTQ/ZVtqXTplW2otNF0sY1tkXT00PmR8fDQ+PWo/azpiW2xbaz4+PjI0XV1eeFtsW2s+Pj4xNiYyNTVdXV5xW2xbaz4+PlxuXHQ4JjI1NV1dXm5bbFtrJjI1NV1dfSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLl9kb0NyeXB0QmxvY2soYSxiLHRoaXMuX2tleVNjaGVkdWxlLHQscix3LHYsbCl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbihhLGMpe3ZhciBkPWFbYysxXTthW2MrMV09YVtjKzNdO2FbYyszXT1kO3RoaXMuX2RvQ3J5cHRCbG9jayhhLGMsdGhpcy5faW52S2V5U2NoZWR1bGUsYix4LHEsbixzKTtkPWFbYysxXTthW2MrMV09YVtjKzNdO2FbYyszXT1kfSxfZG9DcnlwdEJsb2NrOmZ1bmN0aW9uKGEsYixjLGQsZSxqLGwsZil7Zm9yKHZhciBtPXRoaXMuX25Sb3VuZHMsZz1hW2JdXmNbMF0saD1hW2IrMV1eY1sxXSxrPWFbYisyXV5jWzJdLG49YVtiKzNdXmNbM10scD00LHI9MTtyPG07cisrKXZhciBxPWRbZz4+PjI0XV5lW2g+Pj4xNiYyNTVdXmpbaz4+PjgmMjU1XV5sW24mMjU1XV5jW3ArK10scz1kW2g+Pj4yNF1eZVtrPj4+MTYmMjU1XV5qW24+Pj44JjI1NV1ebFtnJjI1NV1eY1twKytdLHQ9XG5cdCAgZFtrPj4+MjRdXmVbbj4+PjE2JjI1NV1ealtnPj4+OCYyNTVdXmxbaCYyNTVdXmNbcCsrXSxuPWRbbj4+PjI0XV5lW2c+Pj4xNiYyNTVdXmpbaD4+PjgmMjU1XV5sW2smMjU1XV5jW3ArK10sZz1xLGg9cyxrPXQ7cT0oZltnPj4+MjRdPDwyNHxmW2g+Pj4xNiYyNTVdPDwxNnxmW2s+Pj44JjI1NV08PDh8ZltuJjI1NV0pXmNbcCsrXTtzPShmW2g+Pj4yNF08PDI0fGZbaz4+PjE2JjI1NV08PDE2fGZbbj4+PjgmMjU1XTw8OHxmW2cmMjU1XSleY1twKytdO3Q9KGZbaz4+PjI0XTw8MjR8ZltuPj4+MTYmMjU1XTw8MTZ8ZltnPj4+OCYyNTVdPDw4fGZbaCYyNTVdKV5jW3ArK107bj0oZltuPj4+MjRdPDwyNHxmW2c+Pj4xNiYyNTVdPDwxNnxmW2g+Pj44JjI1NV08PDh8ZltrJjI1NV0pXmNbcCsrXTthW2JdPXE7YVtiKzFdPXM7YVtiKzJdPXQ7YVtiKzNdPW59LGtleVNpemU6OH0pO3UuQUVTPXAuX2NyZWF0ZUhlbHBlcihkKX0pKCk7XG5cblx0Ly8gTW9kZSBFQ0Jcblx0Q3J5cHRvSlMubW9kZS5FQ0IgPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBFQ0IgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgRUNCLkVuY3J5cHRvciA9IEVDQi5leHRlbmQoe1xuXHQgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgfVxuXHQgIH0pO1xuXG5cdCAgRUNCLkRlY3J5cHRvciA9IEVDQi5leHRlbmQoe1xuXHQgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICB0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgfVxuXHQgIH0pO1xuXG5cdCAgcmV0dXJuIEVDQjtcblx0fSgpKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IENyeXB0b0pTO1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIElOVEVSRkFDRVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0dmFyIFdTID0gZnVuY3Rpb24oIHVybCwgcHJvdG9jb2xzICkge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXUykpIHJldHVybiBuZXcgV1MoIHVybCwgcHJvdG9jb2xzICk7XG5cblx0ICB2YXIgc2VsZiAgICAgPSB0aGlzXG5cdCAgICAsICAgdXJsICAgICAgPSBzZWxmLnVybCAgICAgID0gdXJsIHx8ICcnXG5cdCAgICAsICAgcHJvdG9jb2wgPSBzZWxmLnByb3RvY29sID0gcHJvdG9jb2xzIHx8ICdTZWMtV2ViU29ja2V0LVByb3RvY29sJ1xuXHQgICAgLCAgIGJpdHMgICAgID0gdXJsLnNwbGl0KCcvJylcblx0ICAgICwgICBzZXR1cCAgICA9IHtcblx0ICAgICdzc2wnICAgICAgICAgICA6IGJpdHNbMF0gPT09ICd3c3M6J1xuXHQgICAgLCdvcmlnaW4nICAgICAgICA6IGJpdHNbMl1cblx0ICAgICwncHVibGlzaF9rZXknICAgOiBiaXRzWzNdXG5cdCAgICAsJ3N1YnNjcmliZV9rZXknIDogYml0c1s0XVxuXHQgICAgLCdjaGFubmVsJyAgICAgICA6IGJpdHNbNV1cblx0ICB9O1xuXG5cdCAgLy8gUkVBRFkgU1RBVEVTXG5cdCAgc2VsZlsnQ09OTkVDVElORyddID0gMDsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgbm90IHlldCBvcGVuLlxuXHQgIHNlbGZbJ09QRU4nXSAgICAgICA9IDE7IC8vIFRoZSBjb25uZWN0aW9uIGlzIG9wZW4gYW5kIHJlYWR5IHRvIGNvbW11bmljYXRlLlxuXHQgIHNlbGZbJ0NMT1NJTkcnXSAgICA9IDI7IC8vIFRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBwcm9jZXNzIG9mIGNsb3NpbmcuXG5cdCAgc2VsZlsnQ0xPU0VEJ10gICAgID0gMzsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkIG9yIGNvdWxkbid0IGJlIG9wZW5lZC5cblxuXHQgIC8vIENMT1NFIFNUQVRFU1xuXHQgIHNlbGZbJ0NMT1NFX05PUk1BTCddICAgICAgICAgPSAxMDAwOyAvLyBOb3JtYWwgSW50ZW5kZWQgQ2xvc2U7IGNvbXBsZXRlZC5cblx0ICBzZWxmWydDTE9TRV9HT0lOR19BV0FZJ10gICAgID0gMTAwMTsgLy8gQ2xvc2VkIFVuZXhwZWN0dGVkbHkuXG5cdCAgc2VsZlsnQ0xPU0VfUFJPVE9DT0xfRVJST1InXSA9IDEwMDI7IC8vIFNlcnZlcjogTm90IFN1cHBvcnRlZC5cblx0ICBzZWxmWydDTE9TRV9VTlNVUFBPUlRFRCddICAgID0gMTAwMzsgLy8gU2VydmVyOiBVbnN1cHBvcnRlZCBQcm90b2NvbC5cblx0ICBzZWxmWydDTE9TRV9UT09fTEFSR0UnXSAgICAgID0gMTAwNDsgLy8gU2VydmVyOiBUb28gTXVjaCBEYXRhLlxuXHQgIHNlbGZbJ0NMT1NFX05PX1NUQVRVUyddICAgICAgPSAxMDA1OyAvLyBTZXJ2ZXI6IE5vIHJlYXNvbi5cblx0ICBzZWxmWydDTE9TRV9BQk5PUk1BTCddICAgICAgID0gMTAwNjsgLy8gQWJub3JtYWwgRGlzY29ubmVjdC5cblxuXHQgIC8vIEV2ZW50cyBEZWZhdWx0XG5cdCAgc2VsZlsnb25jbG9zZSddICAgPSBzZWxmWydvbmVycm9yJ10gPVxuXHQgICAgc2VsZlsnb25tZXNzYWdlJ10gPSBzZWxmWydvbm9wZW4nXSAgPVxuXHQgICAgICBzZWxmWydvbnNlbmQnXSAgICA9ICBmdW5jdGlvbigpe307XG5cblx0ICAvLyBBdHRyaWJ1dGVzXG5cdCAgc2VsZlsnYmluYXJ5VHlwZSddICAgICA9ICcnO1xuXHQgIHNlbGZbJ2V4dGVuc2lvbnMnXSAgICAgPSAnJztcblx0ICBzZWxmWydidWZmZXJlZEFtb3VudCddID0gMDtcblx0ICBzZWxmWyd0cmFzbm1pdHRpbmcnXSAgID0gZmFsc2U7XG5cdCAgc2VsZlsnYnVmZmVyJ10gICAgICAgICA9IFtdO1xuXHQgIHNlbGZbJ3JlYWR5U3RhdGUnXSAgICAgPSBzZWxmWydDT05ORUNUSU5HJ107XG5cblx0ICAvLyBDbG9zZSBpZiBubyBzZXR1cC5cblx0ICBpZiAoIXVybCkge1xuXHQgICAgc2VsZlsncmVhZHlTdGF0ZSddID0gc2VsZlsnQ0xPU0VEJ107XG5cdCAgICBzZWxmWydvbmNsb3NlJ10oe1xuXHQgICAgICAnY29kZScgICAgIDogc2VsZlsnQ0xPU0VfQUJOT1JNQUwnXSxcblx0ICAgICAgJ3JlYXNvbicgICA6ICdNaXNzaW5nIFVSTCcsXG5cdCAgICAgICd3YXNDbGVhbicgOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBzZWxmO1xuXHQgIH1cblxuXHQgIC8vIFB1Yk51YiBXZWJTb2NrZXQgRW11bGF0aW9uXG5cdCAgc2VsZi5wdWJudWIgICAgICAgPSBQVUJOVUJbJ2luaXQnXShzZXR1cCk7XG5cdCAgc2VsZi5wdWJudWIuc2V0dXAgPSBzZXR1cDtcblx0ICBzZWxmLnNldHVwICAgICAgICA9IHNldHVwO1xuXG5cdCAgc2VsZi5wdWJudWJbJ3N1YnNjcmliZSddKHtcblx0ICAgICdyZXN0b3JlJyAgICA6IGZhbHNlLFxuXHQgICAgJ2NoYW5uZWwnICAgIDogc2V0dXBbJ2NoYW5uZWwnXSxcblx0ICAgICdkaXNjb25uZWN0JyA6IHNlbGZbJ29uZXJyb3InXSxcblx0ICAgICdyZWNvbm5lY3QnICA6IHNlbGZbJ29ub3BlbiddLFxuXHQgICAgJ2Vycm9yJyAgICAgIDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGZbJ29uY2xvc2UnXSh7XG5cdCAgICAgICAgJ2NvZGUnICAgICA6IHNlbGZbJ0NMT1NFX0FCTk9STUFMJ10sXG5cdCAgICAgICAgJ3JlYXNvbicgICA6ICdNaXNzaW5nIFVSTCcsXG5cdCAgICAgICAgJ3dhc0NsZWFuJyA6IGZhbHNlXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgICdjYWxsYmFjaycgICA6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0ICAgICAgc2VsZlsnb25tZXNzYWdlJ10oeyAnZGF0YScgOiBtZXNzYWdlIH0pO1xuXHQgICAgfSxcblx0ICAgICdjb25uZWN0JyAgICA6IGZ1bmN0aW9uKCkge1xuXHQgICAgICBzZWxmWydyZWFkeVN0YXRlJ10gPSBzZWxmWydPUEVOJ107XG5cdCAgICAgIHNlbGZbJ29ub3BlbiddKCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH07XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIFdFQlNPQ0tFVCBTRU5EXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRXUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgc2VsZi5wdWJudWJbJ3B1Ymxpc2gnXSh7XG5cdCAgICAnY2hhbm5lbCcgIDogc2VsZi5wdWJudWIuc2V0dXBbJ2NoYW5uZWwnXSxcblx0ICAgICdtZXNzYWdlJyAgOiBkYXRhLFxuXHQgICAgJ2NhbGxiYWNrJyA6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdCAgICAgIHNlbGZbJ29uc2VuZCddKHsgJ2RhdGEnIDogcmVzcG9uc2UgfSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH07XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIFdFQlNPQ0tFVCBDTE9TRVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0V1MucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHNlbGYucHVibnViWyd1bnN1YnNjcmliZSddKHsgJ2NoYW5uZWwnIDogc2VsZi5wdWJudWIuc2V0dXBbJ2NoYW5uZWwnXSB9KTtcblx0ICBzZWxmWydyZWFkeVN0YXRlJ10gPSBzZWxmWydDTE9TRUQnXTtcblx0ICBzZWxmWydvbmNsb3NlJ10oe30pO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gV1M7XG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3B1Ym51Yi9tb2Rlcm4vZGlzdC9wdWJudWIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNsaWVudFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSaW5nQ2VudHJhbFwiXSA9IHJvb3RbXCJSaW5nQ2VudHJhbFwiXSB8fCB7fSwgcm9vdFtcIlJpbmdDZW50cmFsXCJdW1wiQ2xpZW50XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYWNjb3VudENsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgY2FsbExvZ0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xudmFyIGRpY3Rpb25hcnlDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcbnZhciBleHRlbnNpb25DbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcbnZhciBtZXNzYWdlc0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xudmFyIG5vdGlmaWNhdGlvbnNDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcbnZhciBwcmVzZW5jZUNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oODcpO1xudmFyIHJpbmdvdXRDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcbnZhciBmb3J3YXJkaW5nTnVtYmVyc0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTYpO1xudmFyIGJsb2NrZWROdW1iZXJzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XG52YXIgQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnQoc2RrKSB7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICAgICAgdGhpcy5fYWNjb3VudCA9IG5ldyBhY2NvdW50Q2xpZW50LkFjY291bnQoc2RrKTtcbiAgICAgICAgdGhpcy5fY2FsbExvZyA9IG5ldyBjYWxsTG9nQ2xpZW50LkNhbGxMb2coc2RrKTtcbiAgICAgICAgdGhpcy5fZGljdGlvbmFyeSA9IG5ldyBkaWN0aW9uYXJ5Q2xpZW50LkRpY3Rpb25hcnkoc2RrKTtcbiAgICAgICAgdGhpcy5fZXh0ZW5zaW9uID0gbmV3IGV4dGVuc2lvbkNsaWVudC5FeHRlbnNpb24oc2RrKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBuZXcgbWVzc2FnZXNDbGllbnQuTWVzc2FnZXMoc2RrKTtcbiAgICAgICAgdGhpcy5fbm90aWZpY2F0aW9ucyA9IG5ldyBub3RpZmljYXRpb25zQ2xpZW50Lk5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkoc2RrKTtcbiAgICAgICAgdGhpcy5fcHJlc2VuY2UgPSBuZXcgcHJlc2VuY2VDbGllbnQuUHJlc2VuY2Uoc2RrKTtcbiAgICAgICAgdGhpcy5fcmluZ291dCA9IG5ldyByaW5nb3V0Q2xpZW50LlJpbmdPdXQoc2RrKTtcbiAgICAgICAgdGhpcy5fZm9yd2FyZGluZ051bWJlcnMgPSBuZXcgZm9yd2FyZGluZ051bWJlcnNDbGllbnQuRm9yd2FyZGluZ051bWJlcnMoc2RrKTtcbiAgICAgICAgdGhpcy5fYmxvY2tlZE51bWJlcnMgPSBuZXcgYmxvY2tlZE51bWJlcnNDbGllbnQuQmxvY2tlZE51bWJlcnMoc2RrKTtcbiAgICB9XG4gICAgQ2xpZW50LnByb3RvdHlwZS5hY2NvdW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWNjb3VudDsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmNhbGxMb2cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jYWxsTG9nOyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuZGljdGlvbmFyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RpY3Rpb25hcnk7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5leHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9leHRlbnNpb247IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5tZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VzOyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUubm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25vdGlmaWNhdGlvbnM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5wcmVzZW5jZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByZXNlbmNlOyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUucmluZ291dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JpbmdvdXQ7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5mb3J3YXJkaW5nTnVtYmVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ZvcndhcmRpbmdOdW1iZXJzOyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuYmxvY2tlZE51bWJlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ibG9ja2VkTnVtYmVyczsgfTtcbiAgICBDbGllbnQudmVyc2lvbiA9ICcwLjEuMCc7XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYWNjb3VudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIGFjY291bnRidXNpbmVzc2FkZHJlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbnZhciBkaWFsaW5ncGxhbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBwaG9uZW51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbnZhciBhY2NvdW50cGhvbmVudW1iZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG52YXIgYWNjb3VudHNlcnZpY2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG52YXIgQWNjb3VudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBBY2NvdW50XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIHRoZSBhY2NvdW50IGluIEluaXRpYWwgc3RhdGUuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5BY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPk1hbmFnaW5nIGFjY291bnRzOiBjcmVhdGluZyBuZXcgYWNjb3VudHMsIHZpZXdpbmcgYW5kIHVwZGF0aW5nIGFjY291bnQgaW5mb3JtYXRpb24sIGRlbGV0aW5nIGV4aXN0aW5nIGFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0QWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIsIGFzc2lnbmVkIHBob25lIG51bWJlcnMsIGRldmljZXMgYW5kIG90aGVyIGV4dGVuc2lvbiBzZXR0aW5ncyk8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5jcmVhdGVBY2NvdW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQnLCBvcHRpb25zLCBleHBvcnRzLmNyZWF0ZUFjY291bnRPcHRpb25zKSwgYWNjb3VudGluZm8uQWNjb3VudEluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgSW5mb1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjA8L3A+XG4gICAgICogPHA+UmV0dXJucyBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBhIHBhcnRpY3VsYXIgUmluZ0NlbnRyYWwgY3VzdG9tZXIgYWNjb3VudC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5sb2FkQWNjb3VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50T3B0aW9ucyksIGFjY291bnRpbmZvLkFjY291bnRJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IEJ1c2luZXNzIEFkZHJlc3NcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5sb2FkQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYnVzaW5lc3MtYWRkcmVzcycsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRCdXNpbmVzc0FkZHJlc3NPcHRpb25zKSwgYWNjb3VudGluZm8uQWNjb3VudEluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEFjY291bnQgQnVzaW5lc3MgQWRkcmVzc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLnVwZGF0ZUFjY291bnRCdXNpbmVzc0FkZHJlc3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2J1c2luZXNzLWFkZHJlc3MnLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZUFjY291bnRCdXNpbmVzc0FkZHJlc3NPcHRpb25zKSwgYWNjb3VudGJ1c2luZXNzYWRkcmVzcy5BY2NvdW50QnVzaW5lc3NBZGRyZXNzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IERpYWxpbmcgUGxhblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgbGlzdCBvZiBjb3VudHJpZXMgd2hpY2ggY2FuIGJlIHNlbGVjdGVkIGZvciBhIGRpYWxpbmcgcGxhbiAodG8gY2FsbCBzaG9ydCBudW1iZXJzIGFuZCBzcGVjaWFsIHNlcnZpY2VzKS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5saXN0RGlhbGluZ1BsYW5zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9kaWFsaW5nLXBsYW4nLCBvcHRpb25zLCBleHBvcnRzLmxpc3REaWFsaW5nUGxhbnNPcHRpb25zKSwgZGlhbGluZ3BsYW5pbmZvLkRpYWxpbmdQbGFuSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aXNpb24gUGhvbmUgTnVtYmVyc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjExIChSZWxlYXNlIDYuMyk8L3A+XG4gICAgICogPHA+UHJvdmlzaW9ucyBhIHBob25lIG51bWJlci48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5wcm92aXNpb25QaG9uZU51bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3Bob25lLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMucHJvdmlzaW9uUGhvbmVOdW1iZXJPcHRpb25zKSwgcGhvbmVudW1iZXJpbmZvLlBob25lTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBQaG9uZSBOdW1iZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIHBob25lIG51bWJlcnMgYXNzaWduZWQgdG8gdGhlIFJpbmdDZW50cmFsIGN1c3RvbWVyIGFjY291bnQuIEJvdGggY29tcGFueS1sZXZlbCBhbmQgZXh0ZW5zaW9uLWxldmVsIG51bWJlcnMgYXJlIHJldHVybmVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxpc3RBY2NvdW50UGhvbmVOdW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9waG9uZS1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RBY2NvdW50UGhvbmVOdW1iZXJzT3B0aW9ucyksIGFjY291bnRwaG9uZW51bWJlcnMuQWNjb3VudFBob25lTnVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgUGhvbmUgTnVtYmVyKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubG9hZEFjY291bnRQaG9uZU51bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcGhvbmUtbnVtYmVyL3twaG9uZU51bWJlcklkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRQaG9uZU51bWJlck9wdGlvbnMpLCBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IFNlcnZpY2UgSW5mb1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjA8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgc2VydmljZSBwbGFuLCBhdmFpbGFibGUgZmVhdHVyZXMgYW5kIGxpbWl0YXRpb25zIGZvciBhIHBhcnRpY3VsYXIgUmluZ0NlbnRyYWwgY3VzdG9tZXIgYWNjb3VudC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5sb2FkU2VydmljZUluZm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3NlcnZpY2UtaW5mbycsIG9wdGlvbnMsIGV4cG9ydHMubG9hZFNlcnZpY2VJbmZvT3B0aW9ucyksIGFjY291bnRzZXJ2aWNlaW5mby5BY2NvdW50U2VydmljZUluZm8pO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnQ7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY3JlYXRlQWNjb3VudCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVBY2NvdW50T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVhY2NvdW50cmVxdWVzdC5DcmVhdGVBY2NvdW50UmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQWNjb3VudCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQWNjb3VudEJ1c2luZXNzQWRkcmVzcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVBY2NvdW50QnVzaW5lc3NBZGRyZXNzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZUFjY291bnRCdXNpbmVzc0FkZHJlc3NPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIm1vZGlmeWFjY291bnRidXNpbmVzc2FkZHJlc3NyZXF1ZXN0Lk1vZGlmeUFjY291bnRCdXNpbmVzc0FkZHJlc3NSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3REaWFsaW5nUGxhbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdERpYWxpbmdQbGFuc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBwcm92aXNpb25QaG9uZU51bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5wcm92aXNpb25QaG9uZU51bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJwcm92aXNpb25waG9uZW51bWJlcnMuUHJvdmlzaW9uUGhvbmVOdW1iZXJzXCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RBY2NvdW50UGhvbmVOdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RBY2NvdW50UGhvbmVOdW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidXNhZ2VUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIk1haW5Db21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRGlyZWN0TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlGYXhOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRm9yd2FyZGVkTnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50UGhvbmVOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEFjY291bnRQaG9uZU51bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBob25lTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZFNlcnZpY2VJbmZvIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRTZXJ2aWNlSW5mb09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlKSB7XG4gICAgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtcIk1haW5Db21wYW55TnVtYmVyXCJdID0gJ01haW5Db21wYW55TnVtYmVyJ10gPSBcIk1haW5Db21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCJdID0gJ0FkZGl0aW9uYWxDb21wYW55TnVtYmVyJ10gPSBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkRpcmVjdE51bWJlclwiXSA9ICdEaXJlY3ROdW1iZXInXSA9IFwiRGlyZWN0TnVtYmVyXCI7XG4gICAgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkNvbXBhbnlGYXhOdW1iZXJcIl0gPSAnQ29tcGFueUZheE51bWJlciddID0gXCJDb21wYW55RmF4TnVtYmVyXCI7XG4gICAgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLklMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGUgPSB7fSkpO1xudmFyIElMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZSA9IGV4cG9ydHMuSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIENsaWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50KHNkaykge1xuICAgICAgICB0aGlzLl9zZGsgPSBzZGs7XG4gICAgfVxuICAgIENsaWVudC5wcm90b3R5cGUucGFyc2VPcHRpb25zID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBvcHRpb25zLCBvcGVyYXRpb25QYXJhbWV0ZXJzKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBxdWVyeToge30sXG4gICAgICAgICAgICBib2R5OiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgb3BlcmF0aW9uUGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnJlcXVpcmVkICYmICFwYXJhbS5kZWZhdWx0ICYmICFvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBwYXJhbWV0ZXIgXCInICsgcGFyYW0ubmFtZSArICdcIiBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5kZWZhdWx0ICYmICFvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1twYXJhbS5uYW1lXSA9IHBhcmFtLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC51cmwgPSByZXF1ZXN0LnVybC5yZXBsYWNlKCd7JyArIHBhcmFtLm5hbWUgKyAnfScsIG9wdGlvbnNbcGFyYW0ubmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmluID09ICdxdWVyeScgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucXVlcnlbcGFyYW0ubmFtZV0gPSBvcHRpb25zW3BhcmFtLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmluID09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYm9keSA9IG9wdGlvbnNbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChhcGlPcHRpb25zLCBDbGFzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2RrLnBsYXRmb3JtKClcbiAgICAgICAgICAgIC5zZW5kKGFwaU9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAvL1RPRE8gU3VwcG9ydCBtdWx0aXBhcnRcbiAgICAgICAgICAgIC8vVE9ETyBUaGluayBob3cgdG8gcGFzcyBoZWFkZXJzJnN0dWZmIHRvIG91dHNpZGVcbiAgICAgICAgICAgIGlmIChDbGFzcyAmJiAhcmVzLl9pc011bHRpcGFydCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2xhc3MoX3RoaXMuX3NkaywgcmVzLmpzb24oKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgc2VydmljZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbnZhciBhY2NvdW50c3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xudmFyIEFjY291bnRJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtYWluTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdvcGVyYXRvcicsIENsYXNzOiBleHRlbnNpb25pbmZvLkV4dGVuc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhcnRuZXJJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZUluZm8nLCBDbGFzczogc2VydmljZWluZm8uU2VydmljZUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NldHVwV2l6YXJkU3RhdGUnLCBDbGFzczogQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogQWNjb3VudEluZm9TdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1c0luZm8nLCBDbGFzczogYWNjb3VudHN0YXR1c2luZm8uQWNjb3VudFN0YXR1c0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudEluZm8gPSBBY2NvdW50SW5mbztcbihmdW5jdGlvbiAoQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlKSB7XG4gICAgQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW0FjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZVtcIk5vdFN0YXJ0ZWRcIl0gPSAnTm90U3RhcnRlZCddID0gXCJOb3RTdGFydGVkXCI7XG4gICAgQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW0FjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZVtcIkluY29tcGxldGVcIl0gPSAnSW5jb21wbGV0ZSddID0gXCJJbmNvbXBsZXRlXCI7XG4gICAgQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW0FjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9ICdDb21wbGV0ZWQnXSA9IFwiQ29tcGxldGVkXCI7XG59KShleHBvcnRzLkFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSB8fCAoZXhwb3J0cy5BY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUgPSB7fSkpO1xudmFyIEFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSA9IGV4cG9ydHMuQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlO1xuKGZ1bmN0aW9uIChBY2NvdW50SW5mb1N0YXR1cykge1xuICAgIEFjY291bnRJbmZvU3RhdHVzW0FjY291bnRJbmZvU3RhdHVzW1wiQ29uZmlybWVkXCJdID0gJ0NvbmZpcm1lZCddID0gXCJDb25maXJtZWRcIjtcbiAgICBBY2NvdW50SW5mb1N0YXR1c1tBY2NvdW50SW5mb1N0YXR1c1tcIkRpc2FibGVkXCJdID0gJ0Rpc2FibGVkJ10gPSBcIkRpc2FibGVkXCI7XG59KShleHBvcnRzLkFjY291bnRJbmZvU3RhdHVzIHx8IChleHBvcnRzLkFjY291bnRJbmZvU3RhdHVzID0ge30pKTtcbnZhciBBY2NvdW50SW5mb1N0YXR1cyA9IGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTW9kZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsKHNkaywgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zZGsgPSBzZGs7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLmdldFByb3BlcnR5TWFwcGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgICAgICB2YXIgQ2xhc3MgPSBtYXBwaW5nLkNsYXNzLCBwcm9wID0gbWFwcGluZy5wcm9wZXJ0eTtcbiAgICAgICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVxdWlyZWQgcHJvcGVydHkgXCInICsgcHJvcCArICdcIiBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9jZXNzUHJvcGVydHkgPSBmdW5jdGlvbiAoZGF0YVBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUNsYXNzIHx8IHR5cGVvZiBDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVBhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENsYXNzKF90aGlzLl9zZGssIGRhdGFQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1hcHBpbmcuaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIF90aGlzW3Byb3BdID0gZGF0YVtwcm9wXS5tYXAocHJvY2Vzc1Byb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzW3Byb3BdID0gcHJvY2Vzc1Byb3BlcnR5KGRhdGFbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9kZWwnO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1snaWQnXTtcbiAgICB9O1xuICAgIHJldHVybiBNb2RlbDtcbn0oKSk7XG5leHBvcnRzLk1vZGVsID0gTW9kZWw7XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY29udGFjdGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIGRlcGFydG1lbnRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbnZhciBleHRlbnNpb25wZXJtaXNzaW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIHByb2ZpbGVpbWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciByZWZlcmVuY2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgcmVnaW9uYWxzZXR0aW5ncyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIGV4dGVuc2lvbnNlcnZpY2VmZWF0dXJlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIGV4dGVuc2lvbnN0YXR1c2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbnZhciBFeHRlbnNpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGFjdCcsIENsYXNzOiBjb250YWN0aW5mby5Db250YWN0SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVwYXJ0bWVudHMnLCBDbGFzczogZGVwYXJ0bWVudGluZm8uRGVwYXJ0bWVudEluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFydG5lcklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZXJtaXNzaW9ucycsIENsYXNzOiBleHRlbnNpb25wZXJtaXNzaW9ucy5FeHRlbnNpb25QZXJtaXNzaW9ucywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncHJvZmlsZUltYWdlJywgQ2xhc3M6IHByb2ZpbGVpbWFnZWluZm8uUHJvZmlsZUltYWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWZlcmVuY2VzJywgQ2xhc3M6IHJlZmVyZW5jZWluZm8uUmVmZXJlbmNlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWdpb25hbFNldHRpbmdzJywgQ2xhc3M6IHJlZ2lvbmFsc2V0dGluZ3MuUmVnaW9uYWxTZXR0aW5ncywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZUZlYXR1cmVzJywgQ2xhc3M6IGV4dGVuc2lvbnNlcnZpY2VmZWF0dXJlaW5mby5FeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2V0dXBXaXphcmRTdGF0ZScsIENsYXNzOiBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9TdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzSW5mbycsIENsYXNzOiBleHRlbnNpb25zdGF0dXNpbmZvLkV4dGVuc2lvblN0YXR1c0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogRXh0ZW5zaW9uSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25JbmZvID0gRXh0ZW5zaW9uSW5mbztcbihmdW5jdGlvbiAoRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUpIHtcbiAgICBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtcIk5vdFN0YXJ0ZWRcIl0gPSAnTm90U3RhcnRlZCddID0gXCJOb3RTdGFydGVkXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbXCJJbmNvbXBsZXRlXCJdID0gJ0luY29tcGxldGUnXSA9IFwiSW5jb21wbGV0ZVwiO1xuICAgIEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW0V4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUgfHwgKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUgPSB7fSkpO1xudmFyIEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlID0gZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZTtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uSW5mb1N0YXR1cykge1xuICAgIEV4dGVuc2lvbkluZm9TdGF0dXNbRXh0ZW5zaW9uSW5mb1N0YXR1c1tcIkVuYWJsZWRcIl0gPSAnRW5hYmxlZCddID0gXCJFbmFibGVkXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiRGlzYWJsZWRcIl0gPSAnRGlzYWJsZWQnXSA9IFwiRGlzYWJsZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU3RhdHVzW0V4dGVuc2lvbkluZm9TdGF0dXNbXCJOb3RBY3RpdmF0ZWRcIl0gPSAnTm90QWN0aXZhdGVkJ10gPSBcIk5vdEFjdGl2YXRlZFwiO1xuICAgIEV4dGVuc2lvbkluZm9TdGF0dXNbRXh0ZW5zaW9uSW5mb1N0YXR1c1tcIlVuYXNzaWduZWRcIl0gPSAnVW5hc3NpZ25lZCddID0gXCJVbmFzc2lnbmVkXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkluZm9TdGF0dXMgfHwgKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1N0YXR1cyA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1N0YXR1cyA9IGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1N0YXR1cztcbihmdW5jdGlvbiAoRXh0ZW5zaW9uSW5mb1R5cGUpIHtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJGYXhVc2VyXCJdID0gJ0ZheFVzZXInXSA9IFwiRmF4VXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVmlydHVhbFVzZXJcIl0gPSAnVmlydHVhbFVzZXInXSA9IFwiVmlydHVhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJEZXBhcnRtZW50XCJdID0gJ0RlcGFydG1lbnQnXSA9IFwiRGVwYXJ0bWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiQW5ub3VuY2VtZW50XCJdID0gJ0Fubm91bmNlbWVudCddID0gXCJBbm5vdW5jZW1lbnRcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJTaGFyZWRMaW5lc0dyb3VwXCJdID0gJ1NoYXJlZExpbmVzR3JvdXAnXSA9IFwiU2hhcmVkTGluZXNHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiUGFnaW5nT25seUdyb3VwXCJdID0gJ1BhZ2luZ09ubHlHcm91cCddID0gXCJQYWdpbmdPbmx5R3JvdXBcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiUGFya0xvY2F0aW9uXCJdID0gJ1BhcmtMb2NhdGlvbiddID0gXCJQYXJrTG9jYXRpb25cIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1R5cGUgfHwgKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1R5cGUgPSB7fSkpO1xudmFyIEV4dGVuc2lvbkluZm9UeXBlID0gZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb250YWN0YWRkcmVzc2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIENvbnRhY3RJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGFjdEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udGFjdEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb250YWN0SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmaXJzdE5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3ROYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb21wYW55JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbWFpbCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYnVzaW5lc3NQaG9uZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYnVzaW5lc3NBZGRyZXNzJywgQ2xhc3M6IGNvbnRhY3RhZGRyZXNzaW5mby5Db250YWN0QWRkcmVzc0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDb250YWN0SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NvbnRhY3RJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb250YWN0SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ29udGFjdEluZm8gPSBDb250YWN0SW5mbztcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDb250YWN0QWRkcmVzc0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250YWN0QWRkcmVzc0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udGFjdEFkZHJlc3NJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ29udGFjdEFkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXRlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjaXR5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdHJlZXQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ppcCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENvbnRhY3RBZGRyZXNzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NvbnRhY3RBZGRyZXNzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGFjdEFkZHJlc3NJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Db250YWN0QWRkcmVzc0luZm8gPSBDb250YWN0QWRkcmVzc0luZm87XG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRGVwYXJ0bWVudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZXBhcnRtZW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZXBhcnRtZW50SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERlcGFydG1lbnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERlcGFydG1lbnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGVwYXJ0bWVudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERlcGFydG1lbnRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EZXBhcnRtZW50SW5mbyA9IERlcGFydG1lbnRJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBwZXJtaXNzaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIEV4dGVuc2lvblBlcm1pc3Npb25zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uUGVybWlzc2lvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uUGVybWlzc2lvbnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25QZXJtaXNzaW9ucy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhZG1pbicsIENsYXNzOiBwZXJtaXNzaW9uaW5mby5QZXJtaXNzaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaW50ZXJuYXRpb25hbENhbGxpbmcnLCBDbGFzczogcGVybWlzc2lvbmluZm8uUGVybWlzc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25QZXJtaXNzaW9ucy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvblBlcm1pc3Npb25zJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25QZXJtaXNzaW9ucztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uUGVybWlzc2lvbnMgPSBFeHRlbnNpb25QZXJtaXNzaW9ucztcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUGVybWlzc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQZXJtaXNzaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQZXJtaXNzaW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBlcm1pc3Npb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuYWJsZWQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUGVybWlzc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQZXJtaXNzaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUGVybWlzc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlBlcm1pc3Npb25JbmZvID0gUGVybWlzc2lvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFByb2ZpbGVJbWFnZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9maWxlSW1hZ2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb2ZpbGVJbWFnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQcm9maWxlSW1hZ2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdldGFnJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYXN0TW9kaWZpZWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRUeXBlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzY2FsZXMnLCBDbGFzczogbnVsbCAvKiBzdHJpbmdbXSAqLywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUHJvZmlsZUltYWdlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Byb2ZpbGVJbWFnZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFByb2ZpbGVJbWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlByb2ZpbGVJbWFnZUluZm8gPSBQcm9maWxlSW1hZ2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBSZWZlcmVuY2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVmZXJlbmNlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWYnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogUmVmZXJlbmNlSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSZWZlcmVuY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmVmZXJlbmNlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmVmZXJlbmNlSW5mbyA9IFJlZmVyZW5jZUluZm87XG4oZnVuY3Rpb24gKFJlZmVyZW5jZUluZm9UeXBlKSB7XG4gICAgUmVmZXJlbmNlSW5mb1R5cGVbUmVmZXJlbmNlSW5mb1R5cGVbXCJQYXJ0bmVySWRcIl0gPSAnUGFydG5lcklkJ10gPSBcIlBhcnRuZXJJZFwiO1xuICAgIFJlZmVyZW5jZUluZm9UeXBlW1JlZmVyZW5jZUluZm9UeXBlW1wiQ3VzdG9tZXJEaXJlY3RvcnlJZFwiXSA9ICdDdXN0b21lckRpcmVjdG9yeUlkJ10gPSBcIkN1c3RvbWVyRGlyZWN0b3J5SWRcIjtcbn0pKGV4cG9ydHMuUmVmZXJlbmNlSW5mb1R5cGUgfHwgKGV4cG9ydHMuUmVmZXJlbmNlSW5mb1R5cGUgPSB7fSkpO1xudmFyIFJlZmVyZW5jZUluZm9UeXBlID0gZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciB0aW1lem9uZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbnZhciBsYW5ndWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBncmVldGluZ2xhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGZvcm1hdHRpbmdsb2NhbGVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgUmVnaW9uYWxTZXR0aW5ncyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZ2lvbmFsU2V0dGluZ3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVnaW9uYWxTZXR0aW5ncygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFJlZ2lvbmFsU2V0dGluZ3MucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaG9tZUNvdW50cnknLCBDbGFzczogY291bnRyeWluZm8uQ291bnRyeUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RpbWV6b25lJywgQ2xhc3M6IHRpbWV6b25laW5mby5UaW1lem9uZUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhbmd1YWdlJywgQ2xhc3M6IGxhbmd1YWdlaW5mby5MYW5ndWFnZUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2dyZWV0aW5nTGFuZ3VhZ2UnLCBDbGFzczogZ3JlZXRpbmdsYW5ndWFnZWluZm8uR3JlZXRpbmdMYW5ndWFnZUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zvcm1hdHRpbmdMb2NhbGUnLCBDbGFzczogZm9ybWF0dGluZ2xvY2FsZWluZm8uRm9ybWF0dGluZ0xvY2FsZUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSZWdpb25hbFNldHRpbmdzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmVnaW9uYWxTZXR0aW5ncyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnaW9uYWxTZXR0aW5ncztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmVnaW9uYWxTZXR0aW5ncyA9IFJlZ2lvbmFsU2V0dGluZ3M7XG5cblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvdW50cnlJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ291bnRyeUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ291bnRyeUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDb3VudHJ5SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRyeUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvdW50cnlJbmZvID0gQ291bnRyeUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFRpbWV6b25lSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWV6b25lSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lem9uZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUaW1lem9uZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVzY3JpcHRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBUaW1lem9uZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdUaW1lem9uZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWV6b25lSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuVGltZXpvbmVJbmZvID0gVGltZXpvbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBMYW5ndWFnZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYW5ndWFnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGFuZ3VhZ2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2dyZWV0aW5nJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZm9ybWF0dGluZ0xvY2FsZScsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2FsZUNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VpJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExhbmd1YWdlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xhbmd1YWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTGFuZ3VhZ2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5MYW5ndWFnZUluZm8gPSBMYW5ndWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JlZXRpbmdMYW5ndWFnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JlZXRpbmdMYW5ndWFnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHcmVldGluZ0xhbmd1YWdlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnR3JlZXRpbmdMYW5ndWFnZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5HcmVldGluZ0xhbmd1YWdlSW5mbyA9IEdyZWV0aW5nTGFuZ3VhZ2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBGb3JtYXR0aW5nTG9jYWxlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcm1hdHRpbmdMb2NhbGVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcm1hdHRpbmdMb2NhbGVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ0xvY2FsZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2FsZUNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBGb3JtYXR0aW5nTG9jYWxlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0Zvcm1hdHRpbmdMb2NhbGVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBGb3JtYXR0aW5nTG9jYWxlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRm9ybWF0dGluZ0xvY2FsZUluZm8gPSBGb3JtYXR0aW5nTG9jYWxlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmFibGVkJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmVhdHVyZU5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYXNvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8gPSBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDIxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEV4dGVuc2lvblN0YXR1c0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25TdGF0dXNJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvblN0YXR1c0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbW1lbnQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYXNvbicsIENsYXNzOiBFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uU3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvblN0YXR1c0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblN0YXR1c0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvblN0YXR1c0luZm8gPSBFeHRlbnNpb25TdGF0dXNJbmZvO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uKSB7XG4gICAgRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbltFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uW1wiVm9sdW50YXJpbHlcIl0gPSAnVm9sdW50YXJpbHknXSA9IFwiVm9sdW50YXJpbHlcIjtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uW0V4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bXCJJbnZvbHVudGFyaWx5XCJdID0gJ0ludm9sdW50YXJpbHknXSA9IFwiSW52b2x1bnRhcmlseVwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uIHx8IChleHBvcnRzLkV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24gPSB7fSkpO1xudmFyIEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24gPSBleHBvcnRzLkV4dGVuc2lvblN0YXR1c0luZm9SZWFzb247XG5cblxuLyoqKi8gfSxcbi8qIDIyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGJpbGxpbmdwbGFuaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xudmFyIGJyYW5kaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xudmFyIHNlcnZpY2VwbGFuaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xudmFyIHRhcmdldHNlcnZpY2VwbGFuaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xudmFyIFNlcnZpY2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VydmljZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmljZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZXJ2aWNlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2JpbGxpbmdQbGFuJywgQ2xhc3M6IGJpbGxpbmdwbGFuaW5mby5CaWxsaW5nUGxhbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2JyYW5kJywgQ2xhc3M6IGJyYW5kaW5mby5CcmFuZEluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NlcnZpY2VQbGFuJywgQ2xhc3M6IHNlcnZpY2VwbGFuaW5mby5TZXJ2aWNlUGxhbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RhcmdldFNlcnZpY2VQbGFuJywgQ2xhc3M6IHRhcmdldHNlcnZpY2VwbGFuaW5mby5UYXJnZXRTZXJ2aWNlUGxhbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1NlcnZpY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTZXJ2aWNlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZUluZm8gPSBTZXJ2aWNlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQmlsbGluZ1BsYW5JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmlsbGluZ1BsYW5JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbGxpbmdQbGFuSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJpbGxpbmdQbGFuSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb25Vbml0JywgQ2xhc3M6IEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogQmlsbGluZ1BsYW5JbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJpbGxpbmdQbGFuSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0JpbGxpbmdQbGFuSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQmlsbGluZ1BsYW5JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CaWxsaW5nUGxhbkluZm8gPSBCaWxsaW5nUGxhbkluZm87XG4oZnVuY3Rpb24gKEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCkge1xuICAgIEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXRbXCJNb250aFwiXSA9ICdNb250aCddID0gXCJNb250aFwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXRbXCJEYXlcIl0gPSAnRGF5J10gPSBcIkRheVwiO1xufSkoZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQgfHwgKGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0ID0ge30pKTtcbnZhciBCaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQgPSBleHBvcnRzLkJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdDtcbihmdW5jdGlvbiAoQmlsbGluZ1BsYW5JbmZvVHlwZSkge1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIkluaXRpYWxcIl0gPSAnSW5pdGlhbCddID0gXCJJbml0aWFsXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiUmVndWxhclwiXSA9ICdSZWd1bGFyJ10gPSBcIlJlZ3VsYXJcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIlRyaWFsXCJdID0gJ1RyaWFsJ10gPSBcIlRyaWFsXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiVHJpYWxOb0NDXCJdID0gJ1RyaWFsTm9DQyddID0gXCJUcmlhbE5vQ0NcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJGcmVlXCJdID0gJ0ZyZWUnXSA9IFwiRnJlZVwiO1xufSkoZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9UeXBlIHx8IChleHBvcnRzLkJpbGxpbmdQbGFuSW5mb1R5cGUgPSB7fSkpO1xudmFyIEJpbGxpbmdQbGFuSW5mb1R5cGUgPSBleHBvcnRzLkJpbGxpbmdQbGFuSW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDI0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgQnJhbmRJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnJhbmRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyYW5kSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJyYW5kSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaG9tZUNvdW50cnknLCBDbGFzczogY291bnRyeWluZm8uQ291bnRyeUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCcmFuZEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCcmFuZEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEJyYW5kSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQnJhbmRJbmZvID0gQnJhbmRJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTZXJ2aWNlUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmljZVBsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlZGl0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VydmljZVBsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTZXJ2aWNlUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNlcnZpY2VQbGFuSW5mbyA9IFNlcnZpY2VQbGFuSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgVGFyZ2V0U2VydmljZVBsYW5JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFyZ2V0U2VydmljZVBsYW5JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhcmdldFNlcnZpY2VQbGFuSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRhcmdldFNlcnZpY2VQbGFuSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFRhcmdldFNlcnZpY2VQbGFuSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1RhcmdldFNlcnZpY2VQbGFuSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gVGFyZ2V0U2VydmljZVBsYW5JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5UYXJnZXRTZXJ2aWNlUGxhbkluZm8gPSBUYXJnZXRTZXJ2aWNlUGxhbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDI3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEFjY291bnRTdGF0dXNJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudFN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFN0YXR1c0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb21tZW50JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWFzb24nLCBDbGFzczogQWNjb3VudFN0YXR1c0luZm9SZWFzb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRTdGF0dXNJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50U3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFN0YXR1c0luZm8gPSBBY2NvdW50U3RhdHVzSW5mbztcbihmdW5jdGlvbiAoQWNjb3VudFN0YXR1c0luZm9SZWFzb24pIHtcbiAgICBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltcIlZvbHVudGFyaWx5XCJdID0gJ1ZvbHVudGFyaWx5J10gPSBcIlZvbHVudGFyaWx5XCI7XG4gICAgQWNjb3VudFN0YXR1c0luZm9SZWFzb25bQWNjb3VudFN0YXR1c0luZm9SZWFzb25bXCJJbnZvbHVudGFyaWx5XCJdID0gJ0ludm9sdW50YXJpbHknXSA9IFwiSW52b2x1bnRhcmlseVwiO1xufSkoZXhwb3J0cy5BY2NvdW50U3RhdHVzSW5mb1JlYXNvbiB8fCAoZXhwb3J0cy5BY2NvdW50U3RhdHVzSW5mb1JlYXNvbiA9IHt9KSk7XG52YXIgQWNjb3VudFN0YXR1c0luZm9SZWFzb24gPSBleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uO1xuXG5cbi8qKiovIH0sXG4vKiAyOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBidXNpbmVzc2FkZHJlc3NpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG52YXIgQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRCdXNpbmVzc0FkZHJlc3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudEJ1c2luZXNzQWRkcmVzcygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRCdXNpbmVzc0FkZHJlc3MucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb21wYW55JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbWFpbCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYnVzaW5lc3NBZGRyZXNzJywgQ2xhc3M6IGJ1c2luZXNzYWRkcmVzc2luZm8uQnVzaW5lc3NBZGRyZXNzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudEJ1c2luZXNzQWRkcmVzcy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRCdXNpbmVzc0FkZHJlc3MnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRCdXNpbmVzc0FkZHJlc3M7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRCdXNpbmVzc0FkZHJlc3MgPSBBY2NvdW50QnVzaW5lc3NBZGRyZXNzO1xuXG5cbi8qKiovIH0sXG4vKiAyOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBCdXNpbmVzc0FkZHJlc3NJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVzaW5lc3NBZGRyZXNzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXNpbmVzc0FkZHJlc3NJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQnVzaW5lc3NBZGRyZXNzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb3VudHJ5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0ZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2l0eScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RyZWV0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd6aXAnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCdXNpbmVzc0FkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQnVzaW5lc3NBZGRyZXNzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQnVzaW5lc3NBZGRyZXNzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQnVzaW5lc3NBZGRyZXNzSW5mbyA9IEJ1c2luZXNzQWRkcmVzc0luZm87XG5cblxuLyoqKi8gfSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGRpYWxpbmdwbGFuY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBEaWFsaW5nUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWFsaW5nUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlhbGluZ1BsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGlhbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGlhbGluZ3BsYW5jb3VudHJ5aW5mby5EaWFsaW5nUGxhbkNvdW50cnlJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWFsaW5nUGxhbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWFsaW5nUGxhbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpYWxpbmdQbGFuSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGlhbGluZ1BsYW5JbmZvID0gRGlhbGluZ1BsYW5JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEaWFsaW5nUGxhbkNvdW50cnlJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlhbGluZ1BsYW5Db3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWFsaW5nUGxhbkNvdW50cnlJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGlhbGluZ1BsYW5Db3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsaW5nQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaXNvQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpYWxpbmdQbGFuQ291bnRyeUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWFsaW5nUGxhbkNvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWFsaW5nUGxhbkNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWFsaW5nUGxhbkNvdW50cnlJbmZvID0gRGlhbGluZ1BsYW5Db3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogMzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUGFnaW5nSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhZ2luZ0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFnaW5nSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBhZ2luZ0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGVyUGFnZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnZVN0YXJ0JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlRW5kJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0b3RhbFBhZ2VzJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0b3RhbEVsZW1lbnRzJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUGFnaW5nSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1BhZ2luZ0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFBhZ2luZ0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlBhZ2luZ0luZm8gPSBQYWdpbmdJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBOYXZpZ2F0aW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5hdmlnYXRpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5hdmlnYXRpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTmF2aWdhdGlvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmlyc3RQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduZXh0UGFnZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncHJldmlvdXNQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYXN0UGFnZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE5hdmlnYXRpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTmF2aWdhdGlvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE5hdmlnYXRpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5OYXZpZ2F0aW9uSW5mbyA9IE5hdmlnYXRpb25JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIHBob25lbnVtYmVyc2V4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcbnZhciBQaG9uZU51bWJlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQaG9uZU51bWJlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGhvbmVOdW1iZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGhvbmVOdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb3VudHJ5JywgQ2xhc3M6IGNvdW50cnlpbmZvLkNvdW50cnlJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogcGhvbmVudW1iZXJzZXh0ZW5zaW9uaW5mby5QaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlcycsIENsYXNzOiBudWxsIC8qIHN0cmluZ1tdICovLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2F0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYXltZW50VHlwZScsIENsYXNzOiBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBQaG9uZU51bWJlckluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1c2FnZVR5cGUnLCBDbGFzczogUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUGhvbmVOdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUGhvbmVOdW1iZXJJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQaG9uZU51bWJlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlBob25lTnVtYmVySW5mbyA9IFBob25lTnVtYmVySW5mbztcbihmdW5jdGlvbiAoUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUpIHtcbiAgICBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtcIkV4dGVybmFsXCJdID0gJ0V4dGVybmFsJ10gPSBcIkV4dGVybmFsXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbXCJUb2xsRnJlZVwiXSA9ICdUb2xsRnJlZSddID0gXCJUb2xsRnJlZVwiO1xuICAgIFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1Bob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1wiTG9jYWxcIl0gPSAnTG9jYWwnXSA9IFwiTG9jYWxcIjtcbn0pKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUgfHwgKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUgPSB7fSkpO1xudmFyIFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlID0gZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZTtcbihmdW5jdGlvbiAoUGhvbmVOdW1iZXJJbmZvVHlwZSkge1xuICAgIFBob25lTnVtYmVySW5mb1R5cGVbUGhvbmVOdW1iZXJJbmZvVHlwZVtcIlZvaWNlRmF4XCJdID0gJ1ZvaWNlRmF4J10gPSBcIlZvaWNlRmF4XCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVHlwZVtQaG9uZU51bWJlckluZm9UeXBlW1wiRmF4T25seVwiXSA9ICdGYXhPbmx5J10gPSBcIkZheE9ubHlcIjtcbiAgICBQaG9uZU51bWJlckluZm9UeXBlW1Bob25lTnVtYmVySW5mb1R5cGVbXCJWb2ljZU9ubHlcIl0gPSAnVm9pY2VPbmx5J10gPSBcIlZvaWNlT25seVwiO1xufSkoZXhwb3J0cy5QaG9uZU51bWJlckluZm9UeXBlIHx8IChleHBvcnRzLlBob25lTnVtYmVySW5mb1R5cGUgPSB7fSkpO1xudmFyIFBob25lTnVtYmVySW5mb1R5cGUgPSBleHBvcnRzLlBob25lTnVtYmVySW5mb1R5cGU7XG4oZnVuY3Rpb24gKFBob25lTnVtYmVySW5mb1VzYWdlVHlwZSkge1xuICAgIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZVtQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbXCJNYWluQ29tcGFueU51bWJlclwiXSA9ICdNYWluQ29tcGFueU51bWJlciddID0gXCJNYWluQ29tcGFueU51bWJlclwiO1xuICAgIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZVtQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiXSA9ICdBZGRpdGlvbmFsQ29tcGFueU51bWJlciddID0gXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiO1xuICAgIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZVtQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbXCJDb21wYW55TnVtYmVyXCJdID0gJ0NvbXBhbnlOdW1iZXInXSA9IFwiQ29tcGFueU51bWJlclwiO1xuICAgIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZVtQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbXCJEaXJlY3ROdW1iZXJcIl0gPSAnRGlyZWN0TnVtYmVyJ10gPSBcIkRpcmVjdE51bWJlclwiO1xuICAgIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZVtQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbXCJDb21wYW55RmF4TnVtYmVyXCJdID0gJ0NvbXBhbnlGYXhOdW1iZXInXSA9IFwiQ29tcGFueUZheE51bWJlclwiO1xuICAgIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZVtQaG9uZU51bWJlckluZm9Vc2FnZVR5cGVbXCJGb3J3YXJkZWROdW1iZXJcIl0gPSAnRm9yd2FyZGVkTnVtYmVyJ10gPSBcIkZvcndhcmRlZE51bWJlclwiO1xufSkoZXhwb3J0cy5QaG9uZU51bWJlckluZm9Vc2FnZVR5cGUgfHwgKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlID0ge30pKTtcbnZhciBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGUgPSBleHBvcnRzLlBob25lTnVtYmVySW5mb1VzYWdlVHlwZTtcblxuXG4vKioqLyB9LFxuLyogMzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYXJ0bmVySWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbyA9IFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDM2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIEFjY291bnRQaG9uZU51bWJlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50UGhvbmVOdW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRQaG9uZU51bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50UGhvbmVOdW1iZXJzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogcGhvbmVudW1iZXJpbmZvLlBob25lTnVtYmVySW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudFBob25lTnVtYmVycy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRQaG9uZU51bWJlcnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRQaG9uZU51bWJlcnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRQaG9uZU51bWJlcnMgPSBBY2NvdW50UGhvbmVOdW1iZXJzO1xuXG5cbi8qKiovIH0sXG4vKiAzNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBzZXJ2aWNlZmVhdHVyZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbnZhciBhY2NvdW50bGltaXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgQWNjb3VudFNlcnZpY2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudFNlcnZpY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRTZXJ2aWNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRTZXJ2aWNlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NlcnZpY2VQbGFuTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZUZlYXR1cmVzJywgQ2xhc3M6IHNlcnZpY2VmZWF0dXJlaW5mby5TZXJ2aWNlRmVhdHVyZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGltaXRzJywgQ2xhc3M6IGFjY291bnRsaW1pdHMuQWNjb3VudExpbWl0cywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFNlcnZpY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50U2VydmljZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRTZXJ2aWNlSW5mbyA9IEFjY291bnRTZXJ2aWNlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU2VydmljZUZlYXR1cmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VydmljZUZlYXR1cmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcnZpY2VGZWF0dXJlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlcnZpY2VGZWF0dXJlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5hYmxlZCcsIENsYXNzOiBTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VydmljZUZlYXR1cmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTZXJ2aWNlRmVhdHVyZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mbyA9IFNlcnZpY2VGZWF0dXJlSW5mbztcbihmdW5jdGlvbiAoU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZCkge1xuICAgIFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWRbU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZFtcIlRydWVcIl0gPSAnVHJ1ZSddID0gXCJUcnVlXCI7XG4gICAgU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZFtTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1wiRmFsc2VcIl0gPSAnRmFsc2UnXSA9IFwiRmFsc2VcIjtcbn0pKGV4cG9ydHMuU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZCB8fCAoZXhwb3J0cy5TZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkID0ge30pKTtcbnZhciBTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkID0gZXhwb3J0cy5TZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkO1xuXG5cbi8qKiovIH0sXG4vKiAzOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBBY2NvdW50TGltaXRzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudExpbWl0cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50TGltaXRzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudExpbWl0cy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcmVlU29mdFBob25lTGluZXNQZXJFeHRlbnNpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21lZXRpbmdTaXplJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtYXhNb25pdG9yZWRFeHRlbnNpb25zUGVyVXNlcicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRMaW1pdHMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50TGltaXRzJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50TGltaXRzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50TGltaXRzID0gQWNjb3VudExpbWl0cztcblxuXG4vKioqLyB9LFxuLyogNDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGFjY291bnRhY3RpdmVjYWxscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xudmFyIGFjY291bnRjYWxsbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG52YXIgYWNjb3VudGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcbnZhciBleHRlbnNpb25hY3RpdmVjYWxscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xudmFyIGV4dGVuc2lvbmNhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcbnZhciBleHRlbnNpb25jYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG52YXIgY2FsbGxvZ3N5bmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcbnZhciBjYWxscmVjb3JkaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG52YXIgQ2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IEFjdGl2ZSBDYWxsc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEzIChSZWxlYXNlIDYuNSk8L3A+XG4gICAgICogPHA+UmV0dXJucyByZWNvcmRzIG9mIGFsbCBjYWxscyB0aGF0IGFyZSBpbiBwcm9ncmVzcywgb3JkZXJlZCBieSBzdGFydCB0aW1lIGluIGRlc2NlbmRpbmcgb3JkZXIuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxpc3RBY2NvdW50QWN0aXZlQ2FsbHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2FjdGl2ZS1jYWxscycsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEFjY291bnRBY3RpdmVDYWxsc09wdGlvbnMpLCBhY2NvdW50YWN0aXZlY2FsbHMuQWNjb3VudEFjdGl2ZUNhbGxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDYWxsIExvZyBSZWNvcmRzIGJ5IEZpbHRlclxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjMgKFJlbGVhc2UgNS4xMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIGxvZyByZWNvcmRzIGZpbHRlcmVkIGJ5IHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZEFjY291bnRDYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9jYWxsLWxvZycsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRDYWxsTG9nT3B0aW9ucyksIGFjY291bnRjYWxsbG9nLkFjY291bnRDYWxsTG9nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBDYWxsIExvZyBSZWNvcmRzIGJ5IEZpbHRlclxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5kZWxldGVBY2NvdW50Q2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmRlbGV0ZUFjY291bnRDYWxsTG9nT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQ2FsbCBMb2cgUmVjb3JkKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGluZGl2aWR1YWwgY2FsbCBsb2cgcmVjb3JkKHMpIGJ5IElEKHMpLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQWNjb3VudENhbGxMb2dSZWNvcmQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2NhbGwtbG9nL3tjYWxsUmVjb3JkSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dSZWNvcmRPcHRpb25zKSwgYWNjb3VudGNhbGxsb2dyZWNvcmQuQWNjb3VudENhbGxMb2dSZWNvcmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjdGl2ZSBDYWxsc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEzIChSZWxlYXNlIDYuNSk8L3A+XG4gICAgICogPHA+UmV0dXJucyByZWNvcmRzIG9mIGFsbCBleHRlbnNpb24gY2FsbHMgdGhhdCBhcmUgaW4gcHJvZ3Jlc3MsIG9yZGVyZWQgYnkgc3RhcnQgdGltZSBpbiBkZXNjZW5kaW5nIG9yZGVyLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2FjdGl2ZS1jYWxscycsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzT3B0aW9ucyksIGV4dGVuc2lvbmFjdGl2ZWNhbGxzLkV4dGVuc2lvbkFjdGl2ZUNhbGxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDYWxsIExvZyBSZWNvcmRzIGJ5IEZpbHRlclxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjMgKFJlbGVhc2UgNS4xMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIGxvZyByZWNvcmRzIGZpbHRlcmVkIGJ5IHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZEV4dGVuc2lvbkNhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NhbGwtbG9nJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uQ2FsbExvZ09wdGlvbnMpLCBleHRlbnNpb25jYWxsbG9nLkV4dGVuc2lvbkNhbGxMb2cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0Q2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NhbGwtbG9nJywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBDYWxsIExvZyBSZWNvcmQocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4zIChSZWxlYXNlIDUuMTEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgY2FsbCBsb2cgcmVjb3JkKHMpIGJ5IHRoZWlyIElEKHMpLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cve2NhbGxSZWNvcmRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nUmVjb3JkT3B0aW9ucyksIGV4dGVuc2lvbmNhbGxsb2dyZWNvcmQuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsIExvZyBTeW5jaHJvbml6YXRpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUuc3luY0V4dGVuc2lvbkNhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NhbGwtbG9nLXN5bmMnLCBvcHRpb25zLCBleHBvcnRzLnN5bmNFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyksIGNhbGxsb2dzeW5jLkNhbGxMb2dTeW5jKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDYWxsIFJlY29yZGluZ1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjE4PC9wPlxuICAgICAqIDxwPlJldHVybnMgY2FsbCByZWNvcmRpbmcgbWV0YWRhdGEuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbFJlY29yZGluZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPkRvd25sb2FkaW5nIGNhbGwgcmVjb3JkaW5nIGNvbnRlbnQ8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcmVjb3JkaW5nL3tyZWNvcmRpbmdJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRDYWxsUmVjb3JkaW5nTWV0YWRhdGFPcHRpb25zKSwgY2FsbHJlY29yZGluZy5DYWxsUmVjb3JkaW5nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDYWxsIFJlY29yZGluZyBEYXRhXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbFJlY29yZGluZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPkRvd25sb2FkaW5nIGNhbGwgcmVjb3JkaW5nIGNvbnRlbnQ8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRDYWxsUmVjb3JkaW5nQ29udGVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcmVjb3JkaW5nL3tyZWNvcmRpbmdJZH0vY29udGVudCcsIG9wdGlvbnMsIGV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdDb250ZW50T3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2c7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuQ2FsbExvZyA9IENhbGxMb2c7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEFjY291bnRBY3RpdmVDYWxscyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0QWNjb3VudEFjdGl2ZUNhbGxzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50Q2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25OdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBob25lTnVtYmVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkQWNjb3VudENhbGxMb2dUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidmlld1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEFjY291bnRDYWxsTG9nVmlld1wiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlNpbXBsZVwiLFxuICAgICAgICAgICAgXCJEZXRhaWxlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIndpdGhSZWNvcmRpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlRnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZGVsZXRlQWNjb3VudENhbGxMb2cgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlQWNjb3VudENhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQWNjb3VudENhbGxMb2dSZWNvcmQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEFjY291bnRDYWxsTG9nUmVjb3JkT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FsbFJlY29yZElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25BY3RpdmVDYWxscyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlZvaWNlXCIsXG4gICAgICAgICAgICBcIkZheFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uQ2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uQ2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25OdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBob25lTnVtYmVyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlZvaWNlXCIsXG4gICAgICAgICAgICBcIkZheFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInZpZXdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1wiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlNpbXBsZVwiLFxuICAgICAgICAgICAgXCJEZXRhaWxlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIndpdGhSZWNvcmRpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZGVsZXRlRXh0ZW5zaW9uQ2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5kZWxldGVFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25DYWxsTG9nUmVjb3JkIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nUmVjb3JkT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbGxSZWNvcmRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBzeW5jRXh0ZW5zaW9uQ2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zeW5jRXh0ZW5zaW9uQ2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZTeW5jXCIsXG4gICAgICAgICAgICBcIklTeW5jXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3luY1Rva2VuXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlRnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmVjb3JkQ291bnRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXR1c0dyb3VwXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTWlzc2VkXCIsXG4gICAgICAgICAgICBcIkFsbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQ2FsbFJlY29yZGluZ01ldGFkYXRhIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRDYWxsUmVjb3JkaW5nTWV0YWRhdGFPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRpbmdJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdDb250ZW50T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmVjb3JkaW5nSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uKSB7XG4gICAgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uW0lMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24gPSB7fSkpO1xudmFyIElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uID0gZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlKSB7XG4gICAgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW0lMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW0lMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGUgPSB7fSkpO1xudmFyIElMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZSA9IGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uKSB7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbltJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uW0lMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uIHx8IChleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24gPSB7fSkpO1xudmFyIElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24gPSBleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMb2FkQWNjb3VudENhbGxMb2dUeXBlKSB7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dUeXBlW0lMb2FkQWNjb3VudENhbGxMb2dUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUgfHwgKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUgPSB7fSkpO1xudmFyIElMb2FkQWNjb3VudENhbGxMb2dUeXBlID0gZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZTtcbihmdW5jdGlvbiAoSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXcpIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVmlld1tJTG9hZEFjY291bnRDYWxsTG9nVmlld1tcIlNpbXBsZVwiXSA9ICdTaW1wbGUnXSA9IFwiU2ltcGxlXCI7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXdbSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXdbXCJEZXRhaWxlZFwiXSA9ICdEZXRhaWxlZCddID0gXCJEZXRhaWxlZFwiO1xufSkoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVmlldyB8fCAoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVmlldyA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXcgPSBleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3O1xuKGZ1bmN0aW9uIChJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uKSB7XG4gICAgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbltJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uW0lMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24gPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24gPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlKSB7XG4gICAgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlW0lMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUgfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUgPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlID0gZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZTtcbihmdW5jdGlvbiAoSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uKSB7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb24gPSB7fSkpO1xudmFyIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlKSB7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVtJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlW0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlIHx8IChleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUgPSB7fSkpO1xudmFyIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUgPSBleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGU7XG4oZnVuY3Rpb24gKElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXcpIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3W0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdbXCJTaW1wbGVcIl0gPSAnU2ltcGxlJ10gPSBcIlNpbXBsZVwiO1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdbSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tcIkRldGFpbGVkXCJdID0gJ0RldGFpbGVkJ10gPSBcIkRldGFpbGVkXCI7XG59KShleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXcgfHwgKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldyA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldyA9IGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldztcbihmdW5jdGlvbiAoSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGUpIHtcbiAgICBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtcIkZTeW5jXCJdID0gJ0ZTeW5jJ10gPSBcIkZTeW5jXCI7XG4gICAgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGVbSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSB8fCAoZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSA9IHt9KSk7XG52YXIgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGUgPSBleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlO1xuKGZ1bmN0aW9uIChJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cCkge1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cFtJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cFtcIkFsbFwiXSA9ICdBbGwnXSA9IFwiQWxsXCI7XG59KShleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwIHx8IChleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwID0ge30pKTtcbnZhciBJU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cCA9IGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXA7XG5cblxuLyoqKi8gfSxcbi8qIDQxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBBY2NvdW50QWN0aXZlQ2FsbHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50QWN0aXZlQ2FsbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudEFjdGl2ZUNhbGxzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudEFjdGl2ZUNhbGxzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50QWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50QWN0aXZlQ2FsbHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRBY3RpdmVDYWxscztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudEFjdGl2ZUNhbGxzID0gQWNjb3VudEFjdGl2ZUNhbGxzO1xuXG5cbi8qKiovIH0sXG4vKiA0MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9nY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIHJlY29yZGluZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBjYWxsbG9ncmVjb3JkbGVnaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xudmFyIENhbGxMb2dSZWNvcmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nUmVjb3JkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2dSZWNvcmQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Nlc3Npb25JZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogQ2FsbExvZ1JlY29yZFR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBDYWxsTG9nUmVjb3JkRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhY3Rpb24nLCBDbGFzczogQ2FsbExvZ1JlY29yZEFjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVzdWx0JywgQ2xhc3M6IENhbGxMb2dSZWNvcmRSZXN1bHQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXJ0VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZGluZycsIENsYXNzOiByZWNvcmRpbmdpbmZvLlJlY29yZGluZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RyYW5zcG9ydCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkVHJhbnNwb3J0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsZWdzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmRsZWdpbmZvLkNhbGxMb2dSZWNvcmRMZWdJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsTG9nUmVjb3JkJztcbiAgICB9O1xuICAgIHJldHVybiBDYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nUmVjb3JkID0gQ2FsbExvZ1JlY29yZDtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBDYWxsTG9nUmVjb3JkVHlwZVtDYWxsTG9nUmVjb3JkVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgQ2FsbExvZ1JlY29yZFR5cGVbQ2FsbExvZ1JlY29yZFR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkVHlwZSB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZFR5cGUgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgQ2FsbExvZ1JlY29yZERpcmVjdGlvbltDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkRGlyZWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmREaXJlY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkluY29taW5nRmF4XCJdID0gJ0luY29taW5nIEZheCddID0gXCJJbmNvbWluZ0ZheFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRm9sbG93TWVcIl0gPSAnRm9sbG93TWUnXSA9IFwiRm9sbG93TWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsaW5nQ2FyZFwiXSA9ICdDYWxsaW5nIENhcmQnXSA9IFwiQ2FsbGluZ0NhcmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJWb0lQQ2FsbFwiXSA9ICdWb0lQIENhbGwnXSA9IFwiVm9JUENhbGxcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlRyYW5zZmVyXCJdID0gJ1RyYW5zZmVyJ10gPSBcIlRyYW5zZmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvblsnRTkxMVVwZGF0ZSddID0gJ0U5MTEgVXBkYXRlJ10gPSAnRTkxMVVwZGF0ZSc7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZEFjdGlvbiB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkQWN0aW9uID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkQWN0aW9uO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkUmVzdWx0KSB7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGFjY2VwdGVkXCJdID0gJ0NhbGwgYWNjZXB0ZWQnXSA9IFwiQ2FsbGFjY2VwdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlcGx5XCJdID0gJ1JlcGx5J10gPSBcIlJlcGx5XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlRXJyb3JcIl0gPSAnUmVjZWl2ZSBFcnJvciddID0gXCJSZWNlaXZlRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhvbkRlbWFuZFwiXSA9ICdGYXggb24gRGVtYW5kJ10gPSBcIkZheG9uRGVtYW5kXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQmxvY2tlZFwiXSA9ICdCbG9ja2VkJ10gPSBcIkJsb2NrZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsY29ubmVjdGVkXCJdID0gJ0NhbGwgY29ubmVjdGVkJ10gPSBcIkNhbGxjb25uZWN0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbCBEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9mYXhtYWNoaW5lXCJdID0gJ05vIGZheCBtYWNoaW5lJ10gPSBcIk5vZmF4bWFjaGluZVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWNjb3VudFwiXSA9ICdBY2NvdW50J10gPSBcIkFjY291bnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsdXJlXCJdID0gJ0NhbGwgRmFpbHVyZSddID0gXCJDYWxsRmFpbHVyZVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWwgRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN0cmljdGVkTnVtYmVyXCJdID0gJ1Jlc3RyaWN0ZWQgTnVtYmVyJ10gPSBcIlJlc3RyaWN0ZWROdW1iZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZyBOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkhhbmd1cFwiXSA9ICdIYW5nIHVwJ10gPSBcIkhhbmd1cFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBvb3JMaW5lUXVhbGl0eVwiXSA9ICdQb29yIExpbmUgUXVhbGl0eSddID0gXCJQb29yTGluZVF1YWxpdHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIl0gPSAnSW50ZXJuYXRpb25hbCBSZXN0cmljdGlvbiddID0gXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJBYmFuZG9uZWRcIl0gPSAnQWJhbmRvbmVkJ10gPSBcIkFiYW5kb25lZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4UmVjZWlwdEVycm9yXCJdID0gJ0ZheCBSZWNlaXB0IEVycm9yJ10gPSBcIkZheFJlY2VpcHRFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFNlbmRFcnJvclwiXSA9ICdGYXggU2VuZCBFcnJvciddID0gXCJGYXhTZW5kRXJyb3JcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFJlc3VsdCB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkUmVzdWx0ID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkUmVzdWx0O1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkVHJhbnNwb3J0KSB7XG4gICAgQ2FsbExvZ1JlY29yZFRyYW5zcG9ydFtDYWxsTG9nUmVjb3JkVHJhbnNwb3J0W1wiUFNUTlwiXSA9ICdQU1ROJ10gPSBcIlBTVE5cIjtcbiAgICBDYWxsTG9nUmVjb3JkVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRUcmFuc3BvcnRbXCJWb0lQXCJdID0gJ1ZvSVAnXSA9IFwiVm9JUFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkVHJhbnNwb3J0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRUcmFuc3BvcnQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRUcmFuc3BvcnQgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRUcmFuc3BvcnQ7XG5cblxuLyoqKi8gfSxcbi8qIDQzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENhbGxMb2dDYWxsZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZ0NhbGxlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZ0NhbGxlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYWxsTG9nQ2FsbGVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ0NhbGxlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dDYWxsZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nQ2FsbGVySW5mbyA9IENhbGxMb2dDYWxsZXJJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA0NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBSZWNvcmRpbmdJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjb3JkaW5nSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWNvcmRpbmdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVjb3JkaW5nSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IFJlY29yZGluZ0luZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250ZW50VXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmVjb3JkaW5nSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JlY29yZGluZ0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29yZGluZ0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlJlY29yZGluZ0luZm8gPSBSZWNvcmRpbmdJbmZvO1xuKGZ1bmN0aW9uIChSZWNvcmRpbmdJbmZvVHlwZSkge1xuICAgIFJlY29yZGluZ0luZm9UeXBlW1JlY29yZGluZ0luZm9UeXBlW1wiQXV0b21hdGljXCJdID0gJ0F1dG9tYXRpYyddID0gXCJBdXRvbWF0aWNcIjtcbiAgICBSZWNvcmRpbmdJbmZvVHlwZVtSZWNvcmRpbmdJbmZvVHlwZVtcIk9uRGVtYW5kXCJdID0gJ09uRGVtYW5kJ10gPSBcIk9uRGVtYW5kXCI7XG59KShleHBvcnRzLlJlY29yZGluZ0luZm9UeXBlIHx8IChleHBvcnRzLlJlY29yZGluZ0luZm9UeXBlID0ge30pKTtcbnZhciBSZWNvcmRpbmdJbmZvVHlwZSA9IGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDQ1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm9jYWxsbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG52YXIgY2FsbGxvZ2NhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciByZWNvcmRpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nUmVjb3JkTGVnSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nUmVjb3JkTGVnSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uJywgQ2xhc3M6IGV4dGVuc2lvbmluZm9jYWxsbG9nLkV4dGVuc2lvbkluZm9DYWxsTG9nLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsZWdUeXBlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGFydFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0cmFuc3BvcnQnLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZGluZycsIENsYXNzOiByZWNvcmRpbmdpbmZvLlJlY29yZGluZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxMb2dSZWNvcmRMZWdJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDYWxsTG9nUmVjb3JkTGVnSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm8gPSBDYWxsTG9nUmVjb3JkTGVnSW5mbztcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24pIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJQaG9uZUNhbGxcIl0gPSAnUGhvbmUgQ2FsbCddID0gXCJQaG9uZUNhbGxcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJBY2NlcHRDYWxsXCJdID0gJ0FjY2VwdCBDYWxsJ10gPSBcIkFjY2VwdENhbGxcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiT3V0Z29pbmdGYXhcIl0gPSAnT3V0Z29pbmcgRmF4J10gPSBcIk91dGdvaW5nRmF4XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUmluZ0RpcmVjdGx5XCJdID0gJ1JpbmcgRGlyZWN0bHknXSA9IFwiUmluZ0RpcmVjdGx5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUmluZ091dFBDXCJdID0gJ1JpbmdPdXQgUEMnXSA9IFwiUmluZ091dFBDXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvblsnNDExSW5mbyddID0gJzQxMSBJbmZvJ10gPSAnNDExSW5mbyc7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlN1cHBvcnRcIl0gPSAnU3VwcG9ydCddID0gXCJTdXBwb3J0XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24gfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24gPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbjtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24pIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUpIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGU7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0KSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVzdWx0SW5Qcm9ncmVzc1wiXSA9ICdSZXN1bHRJblByb2dyZXNzJ10gPSBcIlJlc3VsdEluUHJvZ3Jlc3NcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJDYWxsYWNjZXB0ZWRcIl0gPSAnQ2FsbCBhY2NlcHRlZCddID0gXCJDYWxsYWNjZXB0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVwbHlcIl0gPSAnUmVwbHknXSA9IFwiUmVwbHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZWNlaXZlRXJyb3JcIl0gPSAnUmVjZWl2ZSBFcnJvciddID0gXCJSZWNlaXZlRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkZheG9uRGVtYW5kXCJdID0gJ0ZheCBvbiBEZW1hbmQnXSA9IFwiRmF4b25EZW1hbmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlBhcnRpYWxSZWNlaXZlXCJdID0gJ1BhcnRpYWwgUmVjZWl2ZSddID0gXCJQYXJ0aWFsUmVjZWl2ZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQmxvY2tlZFwiXSA9ICdCbG9ja2VkJ10gPSBcIkJsb2NrZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxjb25uZWN0ZWRcIl0gPSAnQ2FsbCBjb25uZWN0ZWQnXSA9IFwiQ2FsbGNvbm5lY3RlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiTm9BbnN3ZXJcIl0gPSAnTm8gQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbCBEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJTZW5kRXJyb3JcIl0gPSAnU2VuZCBFcnJvciddID0gXCJTZW5kRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJOb2ZheG1hY2hpbmVcIl0gPSAnTm8gZmF4IG1hY2hpbmUnXSA9IFwiTm9mYXhtYWNoaW5lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXN1bHRFbXB0eVwiXSA9ICdSZXN1bHRFbXB0eSddID0gXCJSZXN1bHRFbXB0eVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQWNjb3VudFwiXSA9ICdBY2NvdW50J10gPSBcIkFjY291bnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJDYWxsRmFpbGVkXCJdID0gJ0NhbGwgRmFpbGVkJ10gPSBcIkNhbGxGYWlsZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxGYWlsdXJlXCJdID0gJ0NhbGwgRmFpbHVyZSddID0gXCJDYWxsRmFpbHVyZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbCBFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJJUFBob25lb2ZmbGluZVwiXSA9ICdJUCBQaG9uZSBvZmZsaW5lJ10gPSBcIklQUGhvbmVvZmZsaW5lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXN0cmljdGVkTnVtYmVyXCJdID0gJ1Jlc3RyaWN0ZWQgTnVtYmVyJ10gPSBcIlJlc3RyaWN0ZWROdW1iZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nIE51bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU3RvcHBlZFwiXSA9ICdTdG9wcGVkJ10gPSBcIlN0b3BwZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkhhbmd1cFwiXSA9ICdIYW5nIHVwJ10gPSBcIkhhbmd1cFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUG9vckxpbmVRdWFsaXR5XCJdID0gJ1Bvb3IgTGluZSBRdWFsaXR5J10gPSBcIlBvb3JMaW5lUXVhbGl0eVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUGFydGlhbGx5U2VudFwiXSA9ICdQYXJ0aWFsbHkgU2VudCddID0gXCJQYXJ0aWFsbHlTZW50XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIl0gPSAnSW50ZXJuYXRpb25hbCBSZXN0cmljdGlvbiddID0gXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkFiYW5kb25lZFwiXSA9ICdBYmFuZG9uZWQnXSA9IFwiQWJhbmRvbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJEZWNsaW5lZFwiXSA9ICdEZWNsaW5lZCddID0gXCJEZWNsaW5lZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiRmF4UmVjZWlwdEVycm9yXCJdID0gJ0ZheCBSZWNlaXB0IEVycm9yJ10gPSBcIkZheFJlY2VpcHRFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiRmF4U2VuZEVycm9yXCJdID0gJ0ZheCBTZW5kIEVycm9yJ10gPSBcIkZheFNlbmRFcnJvclwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0O1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCkge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W1wiUFNUTlwiXSA9ICdQU1ROJ10gPSBcIlBTVE5cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydFtDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydFtcIlZvSVBcIl0gPSAnVm9JUCddID0gXCJWb0lQXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0ID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQ7XG5cblxuLyoqKi8gfSxcbi8qIDQ2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEV4dGVuc2lvbkluZm9DYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uSW5mb0NhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSW5mb0NhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25JbmZvQ2FsbExvZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mb0NhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25JbmZvQ2FsbExvZyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uSW5mb0NhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm9DYWxsTG9nID0gRXh0ZW5zaW9uSW5mb0NhbGxMb2c7XG5cblxuLyoqKi8gfSxcbi8qIDQ3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBBY2NvdW50Q2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRDYWxsTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRDYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudENhbGxMb2cucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRDYWxsTG9nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudENhbGxMb2cnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRDYWxsTG9nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50Q2FsbExvZyA9IEFjY291bnRDYWxsTG9nO1xuXG5cbi8qKiovIH0sXG4vKiA0OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9nY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIHJlY29yZGluZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRDYWxsTG9nUmVjb3JkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRDYWxsTG9nUmVjb3JkKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWN0aW9uJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXJ0VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZGluZycsIENsYXNzOiByZWNvcmRpbmdpbmZvLlJlY29yZGluZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRDYWxsTG9nUmVjb3JkJztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50Q2FsbExvZ1JlY29yZDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmQgPSBBY2NvdW50Q2FsbExvZ1JlY29yZDtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlKSB7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW0FjY291bnRDYWxsTG9nUmVjb3JkVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW0FjY291bnRDYWxsTG9nUmVjb3JkVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSB8fCAoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUgPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSA9IGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlO1xuKGZ1bmN0aW9uIChBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbikge1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uIHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0ge30pKTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb247XG4oZnVuY3Rpb24gKEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uKSB7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVDYWxsXCJdID0gJ1Bob25lIENhbGwnXSA9IFwiUGhvbmVDYWxsXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUxvZ2luXCJdID0gJ1Bob25lIExvZ2luJ10gPSBcIlBob25lTG9naW5cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkluY29taW5nRmF4XCJdID0gJ0luY29taW5nIEZheCddID0gXCJJbmNvbWluZ0ZheFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQWNjZXB0Q2FsbFwiXSA9ICdBY2NlcHQgQ2FsbCddID0gXCJBY2NlcHRDYWxsXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJGaW5kTWVcIl0gPSAnRmluZE1lJ10gPSBcIkZpbmRNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRm9sbG93TWVcIl0gPSAnRm9sbG93TWUnXSA9IFwiRm9sbG93TWVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIk91dGdvaW5nRmF4XCJdID0gJ091dGdvaW5nIEZheCddID0gXCJPdXRnb2luZ0ZheFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQ2FsbFJldHVyblwiXSA9ICdDYWxsIFJldHVybiddID0gXCJDYWxsUmV0dXJuXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsaW5nQ2FyZFwiXSA9ICdDYWxsaW5nIENhcmQnXSA9IFwiQ2FsbGluZ0NhcmRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdEaXJlY3RseVwiXSA9ICdSaW5nIERpcmVjdGx5J10gPSBcIlJpbmdEaXJlY3RseVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFdlYlwiXSA9ICdSaW5nT3V0IFdlYiddID0gXCJSaW5nT3V0V2ViXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJWb0lQQ2FsbFwiXSA9ICdWb0lQIENhbGwnXSA9IFwiVm9JUENhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRQQ1wiXSA9ICdSaW5nT3V0IFBDJ10gPSBcIlJpbmdPdXRQQ1wiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ01lXCJdID0gJ1JpbmdNZSddID0gXCJSaW5nTWVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlRyYW5zZmVyXCJdID0gJ1RyYW5zZmVyJ10gPSBcIlRyYW5zZmVyXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bJzQxMUluZm8nXSA9ICc0MTEgSW5mbyddID0gJzQxMUluZm8nO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRW1lcmdlbmN5XCJdID0gJ0VtZXJnZW5jeSddID0gXCJFbWVyZ2VuY3lcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvblsnRTkxMVVwZGF0ZSddID0gJ0U5MTEgVXBkYXRlJ10gPSAnRTkxMVVwZGF0ZSc7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJTdXBwb3J0XCJdID0gJ1N1cHBvcnQnXSA9IFwiU3VwcG9ydFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dE1vYmlsZVwiXSA9ICdSaW5nT3V0IE1vYmlsZSddID0gXCJSaW5nT3V0TW9iaWxlXCI7XG59KShleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uIHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uID0ge30pKTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbiA9IGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb247XG4oZnVuY3Rpb24gKEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0KSB7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0SW5Qcm9ncmVzc1wiXSA9ICdSZXN1bHRJblByb2dyZXNzJ10gPSBcIlJlc3VsdEluUHJvZ3Jlc3NcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsYWNjZXB0ZWRcIl0gPSAnQ2FsbCBhY2NlcHRlZCddID0gXCJDYWxsYWNjZXB0ZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVwbHlcIl0gPSAnUmVwbHknXSA9IFwiUmVwbHlcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlRXJyb3JcIl0gPSAnUmVjZWl2ZSBFcnJvciddID0gXCJSZWNlaXZlRXJyb3JcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheG9uRGVtYW5kXCJdID0gJ0ZheCBvbiBEZW1hbmQnXSA9IFwiRmF4b25EZW1hbmRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxSZWNlaXZlXCJdID0gJ1BhcnRpYWwgUmVjZWl2ZSddID0gXCJQYXJ0aWFsUmVjZWl2ZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQmxvY2tlZFwiXSA9ICdCbG9ja2VkJ10gPSBcIkJsb2NrZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxjb25uZWN0ZWRcIl0gPSAnQ2FsbCBjb25uZWN0ZWQnXSA9IFwiQ2FsbGNvbm5lY3RlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9BbnN3ZXJcIl0gPSAnTm8gQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbCBEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJTZW5kRXJyb3JcIl0gPSAnU2VuZCBFcnJvciddID0gXCJTZW5kRXJyb3JcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb2ZheG1hY2hpbmVcIl0gPSAnTm8gZmF4IG1hY2hpbmUnXSA9IFwiTm9mYXhtYWNoaW5lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRFbXB0eVwiXSA9ICdSZXN1bHRFbXB0eSddID0gXCJSZXN1bHRFbXB0eVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWNjb3VudFwiXSA9ICdBY2NvdW50J10gPSBcIkFjY291bnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsRmFpbGVkXCJdID0gJ0NhbGwgRmFpbGVkJ10gPSBcIkNhbGxGYWlsZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsdXJlXCJdID0gJ0NhbGwgRmFpbHVyZSddID0gXCJDYWxsRmFpbHVyZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbCBFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJJUFBob25lb2ZmbGluZVwiXSA9ICdJUCBQaG9uZSBvZmZsaW5lJ10gPSBcIklQUGhvbmVvZmZsaW5lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN0cmljdGVkTnVtYmVyXCJdID0gJ1Jlc3RyaWN0ZWQgTnVtYmVyJ10gPSBcIlJlc3RyaWN0ZWROdW1iZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nIE51bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3RvcHBlZFwiXSA9ICdTdG9wcGVkJ10gPSBcIlN0b3BwZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkhhbmd1cFwiXSA9ICdIYW5nIHVwJ10gPSBcIkhhbmd1cFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUG9vckxpbmVRdWFsaXR5XCJdID0gJ1Bvb3IgTGluZSBRdWFsaXR5J10gPSBcIlBvb3JMaW5lUXVhbGl0eVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbGx5U2VudFwiXSA9ICdQYXJ0aWFsbHkgU2VudCddID0gXCJQYXJ0aWFsbHlTZW50XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIl0gPSAnSW50ZXJuYXRpb25hbCBSZXN0cmljdGlvbiddID0gXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkFiYW5kb25lZFwiXSA9ICdBYmFuZG9uZWQnXSA9IFwiQWJhbmRvbmVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJEZWNsaW5lZFwiXSA9ICdEZWNsaW5lZCddID0gXCJEZWNsaW5lZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4UmVjZWlwdEVycm9yXCJdID0gJ0ZheCBSZWNlaXB0IEVycm9yJ10gPSBcIkZheFJlY2VpcHRFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4U2VuZEVycm9yXCJdID0gJ0ZheCBTZW5kIEVycm9yJ10gPSBcIkZheFNlbmRFcnJvclwiO1xufSkoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCB8fCAoZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCA9IHt9KSk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQgPSBleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0O1xuXG5cbi8qKiovIH0sXG4vKiA0OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uQWN0aXZlQ2FsbHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25BY3RpdmVDYWxscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BY3RpdmVDYWxscygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkFjdGl2ZUNhbGxzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25BY3RpdmVDYWxscy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkFjdGl2ZUNhbGxzJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25BY3RpdmVDYWxscztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uQWN0aXZlQ2FsbHMgPSBFeHRlbnNpb25BY3RpdmVDYWxscztcblxuXG4vKioqLyB9LFxuLyogNTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25DYWxsTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkNhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25DYWxsTG9nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uQ2FsbExvZyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uQ2FsbExvZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZyA9IEV4dGVuc2lvbkNhbGxMb2c7XG5cblxuLyoqKi8gfSxcbi8qIDUxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25DYWxsTG9nUmVjb3JkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Nlc3Npb25JZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhY3Rpb24nLCBDbGFzczogRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVzdWx0JywgQ2xhc3M6IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXJ0VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZGluZycsIENsYXNzOiByZWNvcmRpbmdpbmZvLlJlY29yZGluZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCA9IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQ7XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlKSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUgfHwgKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUgPSB7fSkpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZTtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbikge1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbiB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uKSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUNhbGxcIl0gPSAnUGhvbmUgQ2FsbCddID0gXCJQaG9uZUNhbGxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUxvZ2luXCJdID0gJ1Bob25lIExvZ2luJ10gPSBcIlBob25lTG9naW5cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJJbmNvbWluZ0ZheFwiXSA9ICdJbmNvbWluZyBGYXgnXSA9IFwiSW5jb21pbmdGYXhcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJBY2NlcHRDYWxsXCJdID0gJ0FjY2VwdCBDYWxsJ10gPSBcIkFjY2VwdENhbGxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJGaW5kTWVcIl0gPSAnRmluZE1lJ10gPSBcIkZpbmRNZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkZvbGxvd01lXCJdID0gJ0ZvbGxvd01lJ10gPSBcIkZvbGxvd01lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiT3V0Z29pbmdGYXhcIl0gPSAnT3V0Z29pbmcgRmF4J10gPSBcIk91dGdvaW5nRmF4XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiQ2FsbFJldHVyblwiXSA9ICdDYWxsIFJldHVybiddID0gXCJDYWxsUmV0dXJuXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiQ2FsbGluZ0NhcmRcIl0gPSAnQ2FsbGluZyBDYXJkJ10gPSBcIkNhbGxpbmdDYXJkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ0RpcmVjdGx5XCJdID0gJ1JpbmcgRGlyZWN0bHknXSA9IFwiUmluZ0RpcmVjdGx5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFdlYlwiXSA9ICdSaW5nT3V0IFdlYiddID0gXCJSaW5nT3V0V2ViXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiVm9JUENhbGxcIl0gPSAnVm9JUCBDYWxsJ10gPSBcIlZvSVBDYWxsXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFBDXCJdID0gJ1JpbmdPdXQgUEMnXSA9IFwiUmluZ091dFBDXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ01lXCJdID0gJ1JpbmdNZSddID0gXCJSaW5nTWVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJUcmFuc2ZlclwiXSA9ICdUcmFuc2ZlciddID0gXCJUcmFuc2ZlclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvblsnNDExSW5mbyddID0gJzQxMSBJbmZvJ10gPSAnNDExSW5mbyc7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiRW1lcmdlbmN5XCJdID0gJ0VtZXJnZW5jeSddID0gXCJFbWVyZ2VuY3lcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bJ0U5MTFVcGRhdGUnXSA9ICdFOTExIFVwZGF0ZSddID0gJ0U5MTFVcGRhdGUnO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlN1cHBvcnRcIl0gPSAnU3VwcG9ydCddID0gXCJTdXBwb3J0XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dE1vYmlsZVwiXSA9ICdSaW5nT3V0IE1vYmlsZSddID0gXCJSaW5nT3V0TW9iaWxlXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24gfHwgKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbiA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbiA9IGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbjtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCkge1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0SW5Qcm9ncmVzc1wiXSA9ICdSZXN1bHRJblByb2dyZXNzJ10gPSBcIlJlc3VsdEluUHJvZ3Jlc3NcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZUVycm9yXCJdID0gJ1JlY2VpdmUgRXJyb3InXSA9IFwiUmVjZWl2ZUVycm9yXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxSZWNlaXZlXCJdID0gJ1BhcnRpYWwgUmVjZWl2ZSddID0gXCJQYXJ0aWFsUmVjZWl2ZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkJsb2NrZWRcIl0gPSAnQmxvY2tlZCddID0gXCJCbG9ja2VkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9BbnN3ZXJcIl0gPSAnTm8gQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWwgRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTZW5kRXJyb3JcIl0gPSAnU2VuZCBFcnJvciddID0gXCJTZW5kRXJyb3JcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTZW50XCJdID0gJ1NlbnQnXSA9IFwiU2VudFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRFbXB0eVwiXSA9ICdSZXN1bHRFbXB0eSddID0gXCJSZXN1bHRFbXB0eVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkFjY291bnRcIl0gPSAnQWNjb3VudCddID0gXCJBY2NvdW50XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsRmFpbGVkXCJdID0gJ0NhbGwgRmFpbGVkJ10gPSBcIkNhbGxGYWlsZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsRmFpbHVyZVwiXSA9ICdDYWxsIEZhaWx1cmUnXSA9IFwiQ2FsbEZhaWx1cmVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJUFBob25lb2ZmbGluZVwiXSA9ICdJUCBQaG9uZSBvZmZsaW5lJ10gPSBcIklQUGhvbmVvZmZsaW5lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdHJpY3RlZE51bWJlclwiXSA9ICdSZXN0cmljdGVkIE51bWJlciddID0gXCJSZXN0cmljdGVkTnVtYmVyXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3RvcHBlZFwiXSA9ICdTdG9wcGVkJ10gPSBcIlN0b3BwZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJIYW5ndXBcIl0gPSAnSGFuZyB1cCddID0gXCJIYW5ndXBcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbGx5U2VudFwiXSA9ICdQYXJ0aWFsbHkgU2VudCddID0gXCJQYXJ0aWFsbHlTZW50XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCJdID0gJ0ludGVybmF0aW9uYWwgUmVzdHJpY3Rpb24nXSA9IFwiSW50ZXJuYXRpb25hbFJlc3RyaWN0aW9uXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJEZWNsaW5lZFwiXSA9ICdEZWNsaW5lZCddID0gXCJEZWNsaW5lZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFJlY2VpcHRFcnJvclwiXSA9ICdGYXggUmVjZWlwdCBFcnJvciddID0gXCJGYXhSZWNlaXB0RXJyb3JcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHQgfHwgKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCA9IGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdDtcblxuXG4vKioqLyB9LFxuLyogNTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIHN5bmNpbmZvY2FsbGxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xudmFyIENhbGxMb2dTeW5jID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZ1N5bmMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZ1N5bmMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDYWxsTG9nU3luYy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNJbmZvJywgQ2xhc3M6IHN5bmNpbmZvY2FsbGxvZy5TeW5jSW5mb0NhbGxMb2csIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDYWxsTG9nU3luYy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxMb2dTeW5jJztcbiAgICB9O1xuICAgIHJldHVybiBDYWxsTG9nU3luYztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ2FsbExvZ1N5bmMgPSBDYWxsTG9nU3luYztcblxuXG4vKioqLyB9LFxuLyogNTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU3luY0luZm9DYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3luY0luZm9DYWxsTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN5bmNJbmZvQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFN5bmNJbmZvQ2FsbExvZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVHlwZScsIENsYXNzOiBTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1Rva2VuJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFN5bmNJbmZvQ2FsbExvZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1N5bmNJbmZvQ2FsbExvZyc7XG4gICAgfTtcbiAgICByZXR1cm4gU3luY0luZm9DYWxsTG9nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2cgPSBTeW5jSW5mb0NhbGxMb2c7XG4oZnVuY3Rpb24gKFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlKSB7XG4gICAgU3luY0luZm9DYWxsTG9nU3luY1R5cGVbU3luY0luZm9DYWxsTG9nU3luY1R5cGVbXCJGU3luY1wiXSA9ICdGU3luYyddID0gXCJGU3luY1wiO1xuICAgIFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlW1N5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlW1wiSVN5bmNcIl0gPSAnSVN5bmMnXSA9IFwiSVN5bmNcIjtcbn0pKGV4cG9ydHMuU3luY0luZm9DYWxsTG9nU3luY1R5cGUgfHwgKGV4cG9ydHMuU3luY0luZm9DYWxsTG9nU3luY1R5cGUgPSB7fSkpO1xudmFyIFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlID0gZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ2FsbFJlY29yZGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxSZWNvcmRpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbFJlY29yZGluZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxSZWNvcmRpbmcucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRVcmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRUeXBlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxSZWNvcmRpbmcucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsUmVjb3JkaW5nJztcbiAgICB9O1xuICAgIHJldHVybiBDYWxsUmVjb3JkaW5nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsUmVjb3JkaW5nID0gQ2FsbFJlY29yZGluZztcblxuXG4vKioqLyB9LFxuLyogNTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGNvdW50cnlsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG52YXIgZGljdGlvbmFyeWNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG52YXIgbGFuZ3VhZ2VsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG52YXIgbGFuZ3VhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgZGljdGlvbmFyeWxvY2F0aW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xudmFyIGRpY3Rpb25hcnlzZWNyZXRxdWVzdGlvbmxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcbnZhciBzZWNyZXRxdWVzdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcbnZhciBkaWN0aW9uYXJ5c2hpcHBpbmdvcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG52YXIgZGljdGlvbmFyeXN0YXRlbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xudmFyIGRpY3Rpb25hcnlzdGF0ZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciBkaWN0aW9uYXJ5dGltZXpvbmVsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG52YXIgZGljdGlvbmFyeXRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xudmFyIERpY3Rpb25hcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnkoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQ291bnRyeSBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGFsbCB0aGUgY291bnRyaWVzIGF2YWlsYWJsZSBmb3IgY2FsbGluZy48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdENvdW50cmllcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvY291bnRyeScsIG9wdGlvbnMsIGV4cG9ydHMubGlzdENvdW50cmllc09wdGlvbnMpLCBjb3VudHJ5bGlzdC5Db3VudHJ5TGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQ291bnRyeVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEwIChSZWxlYXNlIDYuMik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgaW5mb3JtYXRpb24gb24gdGhlIHJlcXVpcmVkIGNvdW50cnkuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxvYWRDb3VudHJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9jb3VudHJ5L3tjb3VudHJ5SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQ291bnRyeU9wdGlvbnMpLCBkaWN0aW9uYXJ5Y291bnRyeWluZm8uRGljdGlvbmFyeUNvdW50cnlJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBMYW5ndWFnZSBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTQgKFJlbGVhc2UgNi42KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBzdXBwb3J0ZWQgbGFuZ3VhZ2VzLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0TGFuZ3VhZ2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9sYW5ndWFnZScsIG9wdGlvbnMsIGV4cG9ydHMubGlzdExhbmd1YWdlc09wdGlvbnMpLCBsYW5ndWFnZWxpc3QuTGFuZ3VhZ2VMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBMYW5ndWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjE0IChSZWxlYXNlIDYuNik8L3A+XG4gICAgICogPHA+UmV0dXJucyBsYW5ndWFnZSBieSBpdHMgcmVzcGVjdGl2ZSBJRC48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZExhbmd1YWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9sYW5ndWFnZS97bGFuZ3VhZ2VJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRMYW5ndWFnZU9wdGlvbnMpLCBsYW5ndWFnZWluZm8uTGFuZ3VhZ2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBMb2NhdGlvbiBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGFsbCB0aGUgYXZhaWxhYmxlIGxvY2F0aW9ucyBmb3IgdGhlIGNlcnRhaW4gc3RhdGUuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RMb2NhdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xvY2F0aW9uJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TG9jYXRpb25zT3B0aW9ucyksIGRpY3Rpb25hcnlsb2NhdGlvbmxpc3QuRGljdGlvbmFyeUxvY2F0aW9uTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU2VjcmV0IFF1ZXN0aW9uIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yMCAoUmVsZWFzZSA3LjQpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2Ygc2VjcmV0IHF1ZXN0aW9ucyBmb3IgYSBzcGVjaWZpYyBsYW5ndWFnZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdFNlY3JldFF1ZXN0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc2VjcmV0LXF1ZXN0aW9uJywgb3B0aW9ucywgZXhwb3J0cy5saXN0U2VjcmV0UXVlc3Rpb25zT3B0aW9ucyksIGRpY3Rpb25hcnlzZWNyZXRxdWVzdGlvbmxpc3QuRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU2VjcmV0IFF1ZXN0aW9uXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjAgKFJlbGVhc2UgNy40KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGEgcGFydGljdWxhciBzZWNyZXQgcXVlc3Rpb24gaW4gc3BlY2lmaWMgbGFuZ3VhZ2UgYnkgcXVlc3Rpb24gSUQuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxvYWRTZWNyZXRRdWVzdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc2VjcmV0LXF1ZXN0aW9uL3F1ZXN0aW9uSWQnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRTZWNyZXRRdWVzdGlvbk9wdGlvbnMpLCBzZWNyZXRxdWVzdGlvbmluZm8uU2VjcmV0UXVlc3Rpb25JbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTaGlwcGluZyBPcHRpb25zXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTYgKFJlbGVhc2UgNy4xKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIGRldmljZSBzaGlwcGluZyBvcHRpb25zIHdpdGggdGhlaXIgcHJpY2VzLCBhY2NvcmRpbmcgdG8gYnJhbmQsIHRpZXIsIG51bWJlciBvZiBvcmRlcmVkIGRldmljZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RTaGlwcGluZ09wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3NoaXBwaW5nLW9wdGlvbnMnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RTaGlwcGluZ09wdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeXNoaXBwaW5nb3B0aW9ucy5EaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTdGF0ZSBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGFsbCB0aGUgc3RhdGVzIGZvciBhIGNlcnRhaW4gY291bnRyeS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZGxpc3RTdGF0ZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3N0YXRlJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkbGlzdFN0YXRlc09wdGlvbnMpLCBkaWN0aW9uYXJ5c3RhdGVsaXN0LkRpY3Rpb25hcnlTdGF0ZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN0YXRlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGUgcmVxdWlyZWQgc3RhdGUuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxvYWRTdGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc3RhdGUve3N0YXRlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkU3RhdGVPcHRpb25zKSwgZGljdGlvbmFyeXN0YXRlaW5mby5EaWN0aW9uYXJ5U3RhdGVJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBUaW1lem9uZSBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGFsbCBhdmFpbGFibGUgdGltZXpvbmVzLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0VGltZXpvbmVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS90aW1lem9uZScsIG9wdGlvbnMsIGV4cG9ydHMubGlzdFRpbWV6b25lc09wdGlvbnMpLCBkaWN0aW9uYXJ5dGltZXpvbmVsaXN0LkRpY3Rpb25hcnlUaW1lem9uZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFRpbWV6b25lXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBvbiBhIGNlcnRhaW4gdGltZXpvbmUuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxvYWRUaW1lem9uZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvdGltZXpvbmUve3RpbWV6b25lSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkVGltZXpvbmVPcHRpb25zKSwgZGljdGlvbmFyeXRpbWV6b25laW5mby5EaWN0aW9uYXJ5VGltZXpvbmVJbmZvKTtcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5O1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkRpY3Rpb25hcnkgPSBEaWN0aW9uYXJ5O1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RDb3VudHJpZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdENvdW50cmllc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJsb2dpbkFsbG93ZWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJudW1iZXJTZWxsaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDb3VudHJ5IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRDb3VudHJ5T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvdW50cnlJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0TGFuZ3VhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RMYW5ndWFnZXNPcHRpb25zID0gW107XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZExhbmd1YWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRMYW5ndWFnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJsYW5ndWFnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RMb2NhdGlvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdExvY2F0aW9uc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJvcmRlckJ5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TG9jYXRpb25zT3JkZXJCeVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIk5wYVwiLFxuICAgICAgICAgICAgXCJDaXR5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RhdGVJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aE54eFwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0U2VjcmV0UXVlc3Rpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RTZWNyZXRRdWVzdGlvbnNPcHRpb25zID0gW107XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZFNlY3JldFF1ZXN0aW9uIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRTZWNyZXRRdWVzdGlvbk9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJxdWVzdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RTaGlwcGluZ09wdGlvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdFNoaXBwaW5nT3B0aW9uc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkbGlzdFN0YXRlcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkbGlzdFN0YXRlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb3VudHJ5SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIndpdGhQaG9uZU51bWJlcnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZFN0YXRlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRTdGF0ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdGF0ZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RUaW1lem9uZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdFRpbWV6b25lc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZFRpbWV6b25lIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRUaW1lem9uZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0aW1lem9uZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdExvY2F0aW9uc09yZGVyQnkpIHtcbiAgICBJTGlzdExvY2F0aW9uc09yZGVyQnlbSUxpc3RMb2NhdGlvbnNPcmRlckJ5W1wiTnBhXCJdID0gJ05wYSddID0gXCJOcGFcIjtcbiAgICBJTGlzdExvY2F0aW9uc09yZGVyQnlbSUxpc3RMb2NhdGlvbnNPcmRlckJ5W1wiQ2l0eVwiXSA9ICdDaXR5J10gPSBcIkNpdHlcIjtcbn0pKGV4cG9ydHMuSUxpc3RMb2NhdGlvbnNPcmRlckJ5IHx8IChleHBvcnRzLklMaXN0TG9jYXRpb25zT3JkZXJCeSA9IHt9KSk7XG52YXIgSUxpc3RMb2NhdGlvbnNPcmRlckJ5ID0gZXhwb3J0cy5JTGlzdExvY2F0aW9uc09yZGVyQnk7XG5cblxuLyoqKi8gfSxcbi8qIDU2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGRpY3Rpb25hcnljb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIENvdW50cnlMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ291bnRyeUxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ291bnRyeUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb3VudHJ5TGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGRpY3Rpb25hcnljb3VudHJ5aW5mby5EaWN0aW9uYXJ5Q291bnRyeUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENvdW50cnlMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ291bnRyeUxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50cnlMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Db3VudHJ5TGlzdCA9IENvdW50cnlMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA1NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEaWN0aW9uYXJ5Q291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5Q291bnRyeUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeUNvdW50cnlJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeUNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxpbmdDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbWVyZ2VuY3lDYWxsaW5nJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaXNvQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbnVtYmVyU2VsbGluZycsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvZ2luQWxsb3dlZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5Q291bnRyeUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5Q291bnRyeUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlDb3VudHJ5SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeUNvdW50cnlJbmZvID0gRGljdGlvbmFyeUNvdW50cnlJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA1OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBsYW5ndWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBMYW5ndWFnZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYW5ndWFnZUxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGFuZ3VhZ2VMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGFuZ3VhZ2VMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGxhbmd1YWdlaW5mby5MYW5ndWFnZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExhbmd1YWdlTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xhbmd1YWdlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gTGFuZ3VhZ2VMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5MYW5ndWFnZUxpc3QgPSBMYW5ndWFnZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDU5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxvY2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlMb2NhdGlvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5TG9jYXRpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlMb2NhdGlvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbG9jYXRpb25pbmZvLkxvY2F0aW9uSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlMb2NhdGlvbkxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5TG9jYXRpb25MaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5TG9jYXRpb25MaXN0ID0gRGljdGlvbmFyeUxvY2F0aW9uTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTG9jYXRpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9jYXRpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvY2F0aW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIExvY2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FyZWFDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjaXR5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICducGEnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ254eCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBMb2NhdGlvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdMb2NhdGlvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2F0aW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTG9jYXRpb25JbmZvID0gTG9jYXRpb25JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA2MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBzZWNyZXRxdWVzdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogc2VjcmV0cXVlc3Rpb25pbmZvLlNlY3JldFF1ZXN0aW9uSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QgPSBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA2MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTZWNyZXRRdWVzdGlvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWNyZXRRdWVzdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VjcmV0UXVlc3Rpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VjcmV0UXVlc3Rpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdxdWVzdGlvblR5cGUnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhbmd1YWdlSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3F1ZXN0aW9uVGV4dCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2hvd0luU2lnblVwJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNlY3JldFF1ZXN0aW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1NlY3JldFF1ZXN0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gU2VjcmV0UXVlc3Rpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TZWNyZXRRdWVzdGlvbkluZm8gPSBTZWNyZXRRdWVzdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDYzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNoaXBwaW5nbWV0aG9kaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3F1YW50aXR5JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcmljZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWV0aG9kJywgQ2xhc3M6IHNoaXBwaW5nbWV0aG9kaW5mby5TaGlwcGluZ01ldGhvZEluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zJztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zID0gRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucztcblxuXG4vKioqLyB9LFxuLyogNjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU2hpcHBpbmdNZXRob2RJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2hpcHBpbmdNZXRob2RJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNoaXBwaW5nTWV0aG9kSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNoaXBwaW5nTWV0aG9kSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNoaXBwaW5nTWV0aG9kSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1NoaXBwaW5nTWV0aG9kSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gU2hpcHBpbmdNZXRob2RJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TaGlwcGluZ01ldGhvZEluZm8gPSBTaGlwcGluZ01ldGhvZEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDY1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGRpY3Rpb25hcnlzdGF0ZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBEaWN0aW9uYXJ5U3RhdGVMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVN0YXRlTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U3RhdGVMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVN0YXRlTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGRpY3Rpb25hcnlzdGF0ZWluZm8uRGljdGlvbmFyeVN0YXRlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVN0YXRlTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlTdGF0ZUxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTdGF0ZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTdGF0ZUxpc3QgPSBEaWN0aW9uYXJ5U3RhdGVMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA2NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBzdGF0ZWNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG52YXIgRGljdGlvbmFyeVN0YXRlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlTdGF0ZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVN0YXRlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlTdGF0ZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY291bnRyeScsIENsYXNzOiBzdGF0ZWNvdW50cnlpbmZvLlN0YXRlQ291bnRyeUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lzb0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U3RhdGVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVN0YXRlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVN0YXRlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVN0YXRlSW5mbyA9IERpY3Rpb25hcnlTdGF0ZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDY3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFN0YXRlQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0ZUNvdW50cnlJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YXRlQ291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTdGF0ZUNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTdGF0ZUNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU3RhdGVDb3VudHJ5SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVDb3VudHJ5SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU3RhdGVDb3VudHJ5SW5mbyA9IFN0YXRlQ291bnRyeUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDY4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGRpY3Rpb25hcnl0aW1lem9uZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVRpbWV6b25lTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVRpbWV6b25lTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGRpY3Rpb25hcnl0aW1lem9uZWluZm8uRGljdGlvbmFyeVRpbWV6b25lSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVRpbWV6b25lTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlUaW1lem9uZUxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlUaW1lem9uZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlUaW1lem9uZUxpc3QgPSBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA2OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVRpbWV6b25lSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXNjcmlwdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlUaW1lem9uZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5VGltZXpvbmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5VGltZXpvbmVJbmZvID0gRGljdGlvbmFyeVRpbWV6b25lSW5mbztcblxuXG4vKioqLyB9LFxuLyogNzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGV4dGVuc2lvbmxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcbnZhciBleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBleHRlbnNpb25waG9uZW51bWJlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbnZhciBleHRlbnNpb25ncmFudGxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcbnZhciBkZXBhcnRtZW50bWVtYmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xudmFyIEV4dGVuc2lvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb24oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4wPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9ucyBjcmVhdGVkIGZvciBhIHBhcnRpY3VsYXIgYWNjb3VudC4gQWxsIHR5cGVzIG9mIGV4dGVuc2lvbnMgYXJlIGluY2x1ZGVkIGluIHRoaXMgbGlzdC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uc09wdGlvbnMpLCBleHRlbnNpb25saXN0LkV4dGVuc2lvbkxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGEgcGFydGljdWxhciBleHRlbnNpb24gb2YgYW4gYWNjb3VudC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25JbmZvID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvbkluZm9PcHRpb25zKSwgZXh0ZW5zaW9uaW5mby5FeHRlbnNpb25JbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gUGhvbmUgTnVtYmVyIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgcGhvbmUgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGJ5IGEgcGFydGljdWxhciBleHRlbnNpb24sIGFuZCBjYW4gYmUgZmlsdGVyZWQgYnkgdGhlIHBob25lIG51bWJlciB0eXBlLiBUaGUgcmV0dXJuZWQgbGlzdCBjb250YWlucyBhbGwgbnVtYmVycyB3aGljaCBhcmUgZGlyZWN0bHkgbWFwcGVkIHRvIGEgZ2l2ZW4gZXh0ZW5zaW9uIHBsdXMgdGhlIGZlYXR1cmVzIGFuZCBhbHNvIGNvbXBhbnktbGV2ZWwgbnVtYmVyc1xuICAgICAqICAgICB3aGljaCBtYXkgYmUgdXNlZCB3aGVuIHBlcmZvcm1pbmcgZGlmZmVyZW50IG9wZXJhdGlvbnMgb24gYmVoYWxmIG9mIHRoaXMgZXh0ZW5zaW9uLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubGlzdEV4dGVuc2lvblBob25lTnVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcGhvbmUtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzT3B0aW9ucyksIGV4dGVuc2lvbnBob25lbnVtYmVycy5FeHRlbnNpb25QaG9uZU51bWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBHcmFudCBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBleHRlbnNpb24gZ3JhbnRzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubGlzdEV4dGVuc2lvbkdyYW50cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZ3JhbnQnLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25HcmFudHNPcHRpb25zKSwgZXh0ZW5zaW9uZ3JhbnRsaXN0LkV4dGVuc2lvbkdyYW50TGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIFByb2ZpbGUgSW1hZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBleHRlbnNpb24gcHJvZmlsZSBpbWFnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uUHJvZmlsZUltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcm9maWxlLWltYWdlJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgZXh0ZW5zaW9uIHByb2ZpbGUgaW1hZ2UuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGlnaDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmNyZWF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2UnLCBvcHRpb25zLCBleHBvcnRzLmNyZWF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBFeHRlbnNpb24gUHJvZmlsZSBJbWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlVwZGF0ZXMgdGhlIGV4dGVuc2lvbiBwcm9maWxlIGltYWdlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhpZ2g8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS51cGRhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2UnLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gUHJvZmlsZSBJbWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIHNjYWxlZCBwcm9maWxlIGltYWdlIG9mIGFuIGV4dGVuc2lvbi48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uU2NhbGVkUHJvZmlsZUltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcm9maWxlLWltYWdlL3tzY2FsZVNpemV9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uU2NhbGVkUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IERlcGFydG1lbnQgTWVtYmVyIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxpc3REZXBhcnRtZW50TWVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZGVwYXJ0bWVudC97ZGVwYXJ0bWVudElkfS9tZW1iZXJzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RGVwYXJ0bWVudE1lbWJlcnNPcHRpb25zKSwgZGVwYXJ0bWVudG1lbWJlcnMuRGVwYXJ0bWVudE1lbWJlcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbjtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5FeHRlbnNpb24gPSBFeHRlbnNpb247XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvbnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdGF0dXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25zU3RhdHVzXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRW5hYmxlZFwiLFxuICAgICAgICAgICAgXCJEaXNhYmxlZFwiLFxuICAgICAgICAgICAgXCJOb3RBY3RpdmF0ZWRcIixcbiAgICAgICAgICAgIFwiVW5hc3NpZ25lZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25zVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlVzZXJcIixcbiAgICAgICAgICAgIFwiRmF4VXNlclwiLFxuICAgICAgICAgICAgXCJWaXJ0dWFsVXNlclwiLFxuICAgICAgICAgICAgXCJEaWdpdGFsVXNlclwiLFxuICAgICAgICAgICAgXCJEZXBhcnRtZW50XCIsXG4gICAgICAgICAgICBcIkFubm91bmNlbWVudFwiLFxuICAgICAgICAgICAgXCJWb2ljZW1haWxcIixcbiAgICAgICAgICAgIFwiU2hhcmVkTGluZXNHcm91cFwiLFxuICAgICAgICAgICAgXCJQYWdpbmdPbmx5R3JvdXBcIixcbiAgICAgICAgICAgIFwiSXZyTWVudVwiLFxuICAgICAgICAgICAgXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiLFxuICAgICAgICAgICAgXCJQYXJrTG9jYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvbkluZm8gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvbkluZm9PcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvblBob25lTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ1c2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJNYWluQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJBZGRpdGlvbmFsQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJDb21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkRpcmVjdE51bWJlclwiLFxuICAgICAgICAgICAgXCJDb21wYW55RmF4TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkZvcndhcmRlZE51bWJlclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9uR3JhbnRzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25HcmFudHNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvblByb2ZpbGVJbWFnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvblNjYWxlZFByb2ZpbGVJbWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uU2NhbGVkUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInNjYWxlU2l6ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RGVwYXJ0bWVudE1lbWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdERlcGFydG1lbnRNZW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGVwYXJ0bWVudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdEV4dGVuc2lvbnNTdGF0dXMpIHtcbiAgICBJTGlzdEV4dGVuc2lvbnNTdGF0dXNbSUxpc3RFeHRlbnNpb25zU3RhdHVzW1wiRW5hYmxlZFwiXSA9ICdFbmFibGVkJ10gPSBcIkVuYWJsZWRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNTdGF0dXNbSUxpc3RFeHRlbnNpb25zU3RhdHVzW1wiRGlzYWJsZWRcIl0gPSAnRGlzYWJsZWQnXSA9IFwiRGlzYWJsZWRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNTdGF0dXNbSUxpc3RFeHRlbnNpb25zU3RhdHVzW1wiTm90QWN0aXZhdGVkXCJdID0gJ05vdEFjdGl2YXRlZCddID0gXCJOb3RBY3RpdmF0ZWRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNTdGF0dXNbSUxpc3RFeHRlbnNpb25zU3RhdHVzW1wiVW5hc3NpZ25lZFwiXSA9ICdVbmFzc2lnbmVkJ10gPSBcIlVuYXNzaWduZWRcIjtcbn0pKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zU3RhdHVzIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1N0YXR1cyA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25zU3RhdHVzID0gZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNTdGF0dXM7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uc1R5cGUpIHtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJVc2VyXCJdID0gJ1VzZXInXSA9IFwiVXNlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4VXNlciddID0gXCJGYXhVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiVmlydHVhbFVzZXJcIl0gPSAnVmlydHVhbFVzZXInXSA9IFwiVmlydHVhbFVzZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJEaWdpdGFsVXNlclwiXSA9ICdEaWdpdGFsVXNlciddID0gXCJEaWdpdGFsVXNlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkRlcGFydG1lbnRcIl0gPSAnRGVwYXJ0bWVudCddID0gXCJEZXBhcnRtZW50XCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiQW5ub3VuY2VtZW50XCJdID0gJ0Fubm91bmNlbWVudCddID0gXCJBbm5vdW5jZW1lbnRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlNoYXJlZExpbmVzR3JvdXBcIl0gPSAnU2hhcmVkTGluZXNHcm91cCddID0gXCJTaGFyZWRMaW5lc0dyb3VwXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiUGFnaW5nT25seUdyb3VwXCJdID0gJ1BhZ2luZ09ubHlHcm91cCddID0gXCJQYWdpbmdPbmx5R3JvdXBcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJJdnJNZW51XCJdID0gJ0l2ck1lbnUnXSA9IFwiSXZyTWVudVwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCJdID0gJ0FwcGxpY2F0aW9uRXh0ZW5zaW9uJ10gPSBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiUGFya0xvY2F0aW9uXCJdID0gJ1BhcmtMb2NhdGlvbiddID0gXCJQYXJrTG9jYXRpb25cIjtcbn0pKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNUeXBlID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvbnNUeXBlID0gZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNUeXBlO1xuKGZ1bmN0aW9uIChJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZSkge1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiTWFpbkNvbXBhbnlOdW1iZXJcIl0gPSAnTWFpbkNvbXBhbnlOdW1iZXInXSA9IFwiTWFpbkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCJdID0gJ0FkZGl0aW9uYWxDb21wYW55TnVtYmVyJ10gPSBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJDb21wYW55TnVtYmVyXCJdID0gJ0NvbXBhbnlOdW1iZXInXSA9IFwiQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRGlyZWN0TnVtYmVyXCJdID0gJ0RpcmVjdE51bWJlciddID0gXCJEaXJlY3ROdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkNvbXBhbnlGYXhOdW1iZXJcIl0gPSAnQ29tcGFueUZheE51bWJlciddID0gXCJDb21wYW55RmF4TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJGb3J3YXJkZWROdW1iZXJcIl0gPSAnRm9yd2FyZGVkTnVtYmVyJ10gPSBcIkZvcndhcmRlZE51bWJlclwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA3MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25MaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25MaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkxpc3QgPSBFeHRlbnNpb25MaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA3MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBwaG9uZW51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25QaG9uZU51bWJlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25QaG9uZU51bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uUGhvbmVOdW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uUGhvbmVOdW1iZXJzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogcGhvbmVudW1iZXJpbmZvLlBob25lTnVtYmVySW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uUGhvbmVOdW1iZXJzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uUGhvbmVOdW1iZXJzJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25QaG9uZU51bWJlcnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvblBob25lTnVtYmVycyA9IEV4dGVuc2lvblBob25lTnVtYmVycztcblxuXG4vKioqLyB9LFxuLyogNzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZ3JhbnRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uR3JhbnRMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uR3JhbnRMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkdyYW50TGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkdyYW50TGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGdyYW50aW5mby5HcmFudEluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkdyYW50TGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkdyYW50TGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uR3JhbnRMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25HcmFudExpc3QgPSBFeHRlbnNpb25HcmFudExpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDc0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm9ncmFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcbnZhciBHcmFudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmFudEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JhbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgR3JhbnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uJywgQ2xhc3M6IGV4dGVuc2lvbmluZm9ncmFudHMuRXh0ZW5zaW9uSW5mb0dyYW50cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbFBpY2t1cCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxNb25pdG9yaW5nJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEdyYW50SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0dyYW50SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhbnRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5HcmFudEluZm8gPSBHcmFudEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDc1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEV4dGVuc2lvbkluZm9HcmFudHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvR3JhbnRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkluZm9HcmFudHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25JbmZvR3JhbnRzJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25JbmZvR3JhbnRzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25JbmZvR3JhbnRzID0gRXh0ZW5zaW9uSW5mb0dyYW50cztcbihmdW5jdGlvbiAoRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGUpIHtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJGYXhVc2VyXCJdID0gJ0ZheCBVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlZpcnR1YWxVc2VyXCJdID0gJ1ZpcnR1YWxVc2VyJ10gPSBcIlZpcnR1YWxVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJEaWdpdGFsVXNlclwiXSA9ICdEaWdpdGFsVXNlciddID0gXCJEaWdpdGFsVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkFubm91bmNlbWVudFwiXSA9ICdBbm5vdW5jZW1lbnQnXSA9IFwiQW5ub3VuY2VtZW50XCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiU2hhcmVkTGluZXNHcm91cFwiXSA9ICdTaGFyZWRMaW5lc0dyb3VwJ10gPSBcIlNoYXJlZExpbmVzR3JvdXBcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlBhZ2luZ09ubHlcIl0gPSAnUGFnaW5nT25seSddID0gXCJQYWdpbmdPbmx5XCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJJdnJNZW51XCJdID0gJ0l2ck1lbnUnXSA9IFwiSXZyTWVudVwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiQXBwbGljYXRpb25FeHRlbnNpb25cIl0gPSAnQXBwbGljYXRpb25FeHRlbnNpb24nXSA9IFwiQXBwbGljYXRpb25FeHRlbnNpb25cIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlBhcmtMb2NhdGlvblwiXSA9ICdQYXJrIExvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvR3JhbnRzVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvR3JhbnRzVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA3NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBEZXBhcnRtZW50TWVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlcGFydG1lbnRNZW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlcGFydG1lbnRNZW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGVwYXJ0bWVudE1lbWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBleHRlbnNpb25pbmZvLkV4dGVuc2lvbkluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERlcGFydG1lbnRNZW1iZXJzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGVwYXJ0bWVudE1lbWJlcnMnO1xuICAgIH07XG4gICAgcmV0dXJuIERlcGFydG1lbnRNZW1iZXJzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EZXBhcnRtZW50TWVtYmVycyA9IERlcGFydG1lbnRNZW1iZXJzO1xuXG5cbi8qKiovIH0sXG4vKiA3NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgbWVzc2FnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciBtZXNzYWdlbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xudmFyIG1lc3NhZ2VzeW5jID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG52YXIgTWVzc2FnZXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlcygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBQYWdlciBNZXNzYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIGFuZCBzZW5kcyBhIHBhZ2VyIG1lc3NhZ2UuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5JbnRlcm5hbE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+U2VuZGluZyBhbmQgcmVjZWl2aW5nIGludHJhLWNvbXBhbnkgdGV4dCBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRJbnRlcm5hbE1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jb21wYW55LXBhZ2VyJywgb3B0aW9ucywgZXhwb3J0cy5zZW5kSW50ZXJuYWxNZXNzYWdlT3B0aW9ucyksIG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBGYXggTWVzc2FnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+Q3JlYXRlcyBhbmQgc2VuZHMvcmVzZW5kcyBuZXcgZmF4IG1lc3NhZ2UuIFJlc2VuZCBjYW4gYmUgZG9uZSBpZiBzZW5kaW5nIGZhaWxlZC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkZheGVzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+U2VuZGluZyBhbmQgcmVjZWl2aW5nIGZheGVzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5zZW5kRmF4TWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZheCcsIG9wdGlvbnMsIGV4cG9ydHMuc2VuZEZheE1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFNNUyBNZXNzYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIGFuZCBzZW5kcyBuZXcgU01TIG1lc3NhZ2UuIFNlbmRpbmcgU01TIG1lc3NhZ2VzIHNpbXVsdGFuZW91c2x5IHRvIGRpZmZlcmVudCByZWNpcGllbnRzIGlzIGxpbWl0ZWQgdXAgdG8gNTAgcmVxdWVzdHMgcGVyIG1pbnV0ZTsgcmVsZXZhbnQgZm9yIGFsbCBjbGllbnQgYXBwbGljYXRpb25zLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+U01TPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+U2VuZGluZyBhbmQgcmVjZWl2aW5nIFNNUyAodGV4dCkgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5zZW5kU01TID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vc21zJywgb3B0aW9ucywgZXhwb3J0cy5zZW5kU01TT3B0aW9ucyksIG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBNZXNzYWdlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgbWVzc2FnZXMgZnJvbSBhbiBleHRlbnNpb24gbWFpbGJveC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxpc3RNZXNzYWdlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZScsIG9wdGlvbnMsIGV4cG9ydHMubGlzdE1lc3NhZ2VzT3B0aW9ucyksIG1lc3NhZ2VsaXN0Lk1lc3NhZ2VMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBNZXNzYWdlKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGluZGl2aWR1YWwgbWVzc2FnZSByZWNvcmQocykgYnkgdGhlIGdpdmVuIG1lc3NhZ2UgSUQocykuIFRoZSBsZW5ndGggb2YgaW5ib3VuZCBtZXNzYWdlcyBpcyB1bmxpbWl0ZWQuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5sb2FkTWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZS97bWVzc2FnZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZE1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlVwZGF0ZXMgbWVzc2FnZShzKSBieSBJRChzKS4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy4gQ3VycmVudGx5LCBvbmx5IHRoZSBtZXNzYWdlIHJlYWQgc3RhdHVzIHVwZGF0aW5nIGlzIHN1cHBvcnRlZC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS51cGRhdGVNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVNZXNzYWdlT3B0aW9ucyksIG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBNZXNzYWdlKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+RGVsZXRlcyBtZXNzYWdlKHMpIGJ5IHRoZSBnaXZlbiBtZXNzYWdlIElEKHMpLiBUaGUgZmlyc3QgY2FsbCBvZiB0aGlzIG1ldGhvZCB0cmFuc2ZlcnMgdGhlIG1lc3NhZ2UgdG8gdGhlICdEZWxldGUnIHN0YXR1cy4gVGhlIHNlY29uZCBjYWxsIHRyYW5zZmVycyB0aGUgZGVsZXRlZCBtZXNzYWdlIHRvIHRoZSAnUHVyZ2VkJyBzdGF0dXMuIElmIGl0IGlzIHJlcXVpcmVkIHRvIG1ha2UgdGhlIG1lc3NhZ2UgJ1B1cmdlZCcgaW1tZWRpYXRlbHlcbiAgICAgKiAgICAgKGZyb20gdGhlIGZpcnN0IGNhbGwpLCB0aGVuIHNldCB0aGUgcXVlcnkgcGFyYW1ldGVyIHB1cmdlIHRvICdUcnVlJy4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0TWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuZGVsZXRlTWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZS97bWVzc2FnZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMuZGVsZXRlTWVzc2FnZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBNZXNzYWdlIEF0dGFjaG1lbnRcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC40IChSZWxlYXNlIDUuMTMpPC9wPlxuICAgICAqIDxwPlJldHVybnMgcGFydGljdWxhciBtZXNzYWdlIGF0dGFjaG1lbnQgZGF0YSBhcyBhIG1lZGlhIHN0cmVhbS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5sb2FkTWVzc2FnZUF0dGFjaG1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUve21lc3NhZ2VJZH0vY29udGVudC97YXR0YWNobWVudElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZE1lc3NhZ2VBdHRhY2htZW50T3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgU3luY1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjQgKFJlbGVhc2UgNS4xMyk8L3A+XG4gICAgICogPHA+UHJvdmlkZXMgZmFjaWxpdGllcyB0byBzeW5jaHJvbml6ZSBtYWlsYm94IGNvbnRlbnQgc3RvcmVkIGV4dGVybmFsbHkgd2l0aCBzZXJ2ZXIgc3RhdGUuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5zeW5jTWVzc2FnZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3luYycsIG9wdGlvbnMsIGV4cG9ydHMuc3luY01lc3NhZ2VzT3B0aW9ucyksIG1lc3NhZ2VzeW5jLk1lc3NhZ2VTeW5jKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlcztcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5NZXNzYWdlcyA9IE1lc3NhZ2VzO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHNlbmRJbnRlcm5hbE1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc2VuZEludGVybmFsTWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiY3JlYXRlcGFnZXJtZXNzYWdlcmVxdWVzdC5DcmVhdGVQYWdlck1lc3NhZ2VSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHNlbmRGYXhNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnNlbmRGYXhNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcIm5vdGVzXCI6IFwiXCIsXG4gICAgICAgIFwicGFyYW1UeXBlXCI6IFwicGF0aFwiLFxuICAgICAgICBcImRlZmF1bHRWYWx1ZVwiOiBcIn5cIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImFsbG93TXVsdGlwbGVcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwibm90ZXNcIjogXCJcIixcbiAgICAgICAgXCJwYXJhbVR5cGVcIjogXCJwYXRoXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiflwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiYWxsb3dNdWx0aXBsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgICAgIFwiaW5cIjogXCJoZWFkZXJcIixcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwibXVsdGlwYXJ0L21peGVkOyBib3VuZGFyeT1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODhcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICAgICAgXCJpblwiOiBcImhlYWRlclwiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcImNvbnN1bWVzXCI6IFtcbiAgICAgICAgICAgIFwibXVsdGlwYXJ0L21peGVkOyBib3VuZGFyeT1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODhcIlxuICAgICAgICBdLFxuICAgICAgICBcImRlZmF1bHRcIjogXCItLUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFxcbkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxcblxcbntcXG4gIFxcXCJ0b1xcXCI6W3tcXFwicGhvbmVOdW1iZXJcXFwiOlxcXCIxODAwNTYzMDAwM1xcXCJ9XSxcXG4gIFxcXCJmYXhSZXNvbHV0aW9uXFxcIjpcXFwiSGlnaFxcXCIsXFxuICBcXFwic2VuZFRpbWVcXFwiOlxcXCIyMDEzLTAyLTI2VDA5OjMxOjIwLjg4MlpcXFwiXFxufVxcblxcbi0tQm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4XFxuQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluXFxuXFxuSGVsbG8sIFdvcmxkIVxcblxcbi0tQm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4LS1cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHNlbmRTTVMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc2VuZFNNU09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiY3JlYXRlc21zbWVzc2FnZS5DcmVhdGVTTVNNZXNzYWdlXCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RNZXNzYWdlcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0TWVzc2FnZXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYXZhaWxhYmlsaXR5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJBbGl2ZVwiLFxuICAgICAgICAgICAgXCJEZWxldGVkXCIsXG4gICAgICAgICAgICBcIlB1cmdlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvbnZlcnNhdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlRnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RNZXNzYWdlc0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXN0aW5jdENvbnZlcnNhdGlvbnNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJGYXhcIixcbiAgICAgICAgICAgIFwiU01TXCIsXG4gICAgICAgICAgICBcIlZvaWNlTWFpbFwiLFxuICAgICAgICAgICAgXCJQYWdlclwiLFxuICAgICAgICAgICAgXCJUZXh0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmVhZFN0YXR1c1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1c1wiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIlJlYWRcIixcbiAgICAgICAgICAgIFwiVW5yZWFkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkTWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkTWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlTWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51cGRhdGVNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJ1cGRhdGVtZXNzYWdlcmVxdWVzdC5VcGRhdGVNZXNzYWdlUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmRlbGV0ZU1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicHVyZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb252ZXJzYXRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRNZXNzYWdlQXR0YWNobWVudCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkTWVzc2FnZUF0dGFjaG1lbnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYXR0YWNobWVudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHN5bmNNZXNzYWdlcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zeW5jTWVzc2FnZXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY29udmVyc2F0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJU3luY01lc3NhZ2VzRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpc3RpbmN0Q29udmVyc2F0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZheFwiLFxuICAgICAgICAgICAgXCJTTVNcIixcbiAgICAgICAgICAgIFwiVm9pY2VNYWlsXCIsXG4gICAgICAgICAgICBcIlBhZ2VyXCIsXG4gICAgICAgICAgICBcIlRleHRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRDb3VudFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3luY1Rva2VuXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJU3luY01lc3NhZ2VzU3luY1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJGU3luY1wiLFxuICAgICAgICAgICAgXCJJU3luY1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSkge1xuICAgIElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtcIkFsaXZlXCJdID0gJ0FsaXZlJ10gPSBcIkFsaXZlXCI7XG4gICAgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W1wiRGVsZXRlZFwiXSA9ICdEZWxldGVkJ10gPSBcIkRlbGV0ZWRcIjtcbiAgICBJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W0lMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbXCJQdXJnZWRcIl0gPSAnUHVyZ2VkJ10gPSBcIlB1cmdlZFwiO1xufSkoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5IHx8IChleHBvcnRzLklMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHkgPSB7fSkpO1xudmFyIElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHkgPSBleHBvcnRzLklMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHk7XG4oZnVuY3Rpb24gKElMaXN0TWVzc2FnZXNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uW0lMaXN0TWVzc2FnZXNEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMaXN0TWVzc2FnZXNEaXJlY3Rpb25bSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMaXN0TWVzc2FnZXNEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxpc3RNZXNzYWdlc0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlKSB7XG4gICAgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW0lMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG4gICAgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW0lMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtcIlNNU1wiXSA9ICdTTVMnXSA9IFwiU01TXCI7XG4gICAgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW0lMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtcIlZvaWNlTWFpbFwiXSA9ICdWb2ljZU1haWwnXSA9IFwiVm9pY2VNYWlsXCI7XG4gICAgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW0lMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtcIlBhZ2VyXCJdID0gJ1BhZ2VyJ10gPSBcIlBhZ2VyXCI7XG4gICAgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW0lMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG59KShleHBvcnRzLklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGUgPSB7fSkpO1xudmFyIElMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZSA9IGV4cG9ydHMuSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cykge1xuICAgIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW0lMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW1wiUmVhZFwiXSA9ICdSZWFkJ10gPSBcIlJlYWRcIjtcbiAgICBJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1c1tJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1c1tcIlVucmVhZFwiXSA9ICdVbnJlYWQnXSA9IFwiVW5yZWFkXCI7XG59KShleHBvcnRzLklMaXN0TWVzc2FnZXNSZWFkU3RhdHVzIHx8IChleHBvcnRzLklMaXN0TWVzc2FnZXNSZWFkU3RhdHVzID0ge30pKTtcbnZhciBJTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cyA9IGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXM7XG4oZnVuY3Rpb24gKElTeW5jTWVzc2FnZXNEaXJlY3Rpb24pIHtcbiAgICBJU3luY01lc3NhZ2VzRGlyZWN0aW9uW0lTeW5jTWVzc2FnZXNEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElTeW5jTWVzc2FnZXNEaXJlY3Rpb25bSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklTeW5jTWVzc2FnZXNEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSVN5bmNNZXNzYWdlc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSVN5bmNNZXNzYWdlc0RpcmVjdGlvbiA9IGV4cG9ydHMuSVN5bmNNZXNzYWdlc0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlKSB7XG4gICAgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW0lTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG4gICAgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW0lTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtcIlNNU1wiXSA9ICdTTVMnXSA9IFwiU01TXCI7XG4gICAgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW0lTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtcIlZvaWNlTWFpbFwiXSA9ICdWb2ljZU1haWwnXSA9IFwiVm9pY2VNYWlsXCI7XG4gICAgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW0lTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtcIlBhZ2VyXCJdID0gJ1BhZ2VyJ10gPSBcIlBhZ2VyXCI7XG4gICAgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW0lTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG59KShleHBvcnRzLklTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5JU3luY01lc3NhZ2VzTWVzc2FnZVR5cGUgPSB7fSkpO1xudmFyIElTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZSA9IGV4cG9ydHMuSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChJU3luY01lc3NhZ2VzU3luY1R5cGUpIHtcbiAgICBJU3luY01lc3NhZ2VzU3luY1R5cGVbSVN5bmNNZXNzYWdlc1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBJU3luY01lc3NhZ2VzU3luY1R5cGVbSVN5bmNNZXNzYWdlc1N5bmNUeXBlW1wiSVN5bmNcIl0gPSAnSVN5bmMnXSA9IFwiSVN5bmNcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc1N5bmNUeXBlIHx8IChleHBvcnRzLklTeW5jTWVzc2FnZXNTeW5jVHlwZSA9IHt9KSk7XG52YXIgSVN5bmNNZXNzYWdlc1N5bmNUeXBlID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzU3luY1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDc4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1lc3NhZ2VhdHRhY2htZW50aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xudmFyIG1lc3NhZ2VzdG9yZWNhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcbnZhciBNZXNzYWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYXR0YWNobWVudHMnLCBDbGFzczogbWVzc2FnZWF0dGFjaG1lbnRpbmZvLk1lc3NhZ2VBdHRhY2htZW50SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhdmFpbGFiaWxpdHknLCBDbGFzczogTWVzc2FnZUluZm9BdmFpbGFiaWxpdHksIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnZlcnNhdGlvbklkJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjcmVhdGlvblRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RlbGl2ZXJ5RXJyb3JDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogTWVzc2FnZUluZm9EaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZheFBhZ2VDb3VudCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4UmVzb2x1dGlvbicsIENsYXNzOiBNZXNzYWdlSW5mb0ZheFJlc29sdXRpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogbWVzc2FnZXN0b3JlY2FsbGVyaW5mby5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYXN0TW9kaWZpZWRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXNzYWdlU3RhdHVzJywgQ2xhc3M6IE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGdUb0RlcGFydG1lbnQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcmlvcml0eScsIENsYXNzOiBNZXNzYWdlSW5mb1ByaW9yaXR5LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWFkU3RhdHVzJywgQ2xhc3M6IE1lc3NhZ2VJbmZvUmVhZFN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc21zRGVsaXZlcnlUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzbXNTZW5kaW5nQXR0ZW1wdHNDb3VudCcsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3ViamVjdCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogbWVzc2FnZXN0b3JlY2FsbGVyaW5mby5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogTWVzc2FnZUluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd2bVRyYW5zY3JpcHRpb25TdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZUluZm8gPSBNZXNzYWdlSW5mbztcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9BdmFpbGFiaWxpdHkpIHtcbiAgICBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtcIkFsaXZlXCJdID0gJ0FsaXZlJ10gPSBcIkFsaXZlXCI7XG4gICAgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbXCJEZWxldGVkXCJdID0gJ0RlbGV0ZWQnXSA9IFwiRGVsZXRlZFwiO1xuICAgIE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W01lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W1wiUHVyZ2VkXCJdID0gJ1B1cmdlZCddID0gXCJQdXJnZWRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9BdmFpbGFiaWxpdHkgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9BdmFpbGFiaWxpdHkgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5ID0gZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eTtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9EaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlSW5mb0RpcmVjdGlvbltNZXNzYWdlSW5mb0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgTWVzc2FnZUluZm9EaXJlY3Rpb25bTWVzc2FnZUluZm9EaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9EaXJlY3Rpb24gPSBleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0ZheFJlc29sdXRpb24pIHtcbiAgICBNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uW1wiSGlnaFwiXSA9ICdIaWdoJ10gPSBcIkhpZ2hcIjtcbiAgICBNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uW1wiTG93XCJdID0gJ0xvdyddID0gXCJMb3dcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbiA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uID0gZXhwb3J0cy5NZXNzYWdlSW5mb0ZheFJlc29sdXRpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbXCJRdWV1ZWRcIl0gPSAnUXVldWVkJ10gPSBcIlF1ZXVlZFwiO1xuICAgIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbXCJTZW50XCJdID0gJ1NlbnQnXSA9IFwiU2VudFwiO1xuICAgIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbXCJEZWxpdmVyZWRcIl0gPSAnRGVsaXZlcmVkJ10gPSBcIkRlbGl2ZXJlZFwiO1xuICAgIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbXCJEZWxpdmVyeUZhaWxlZFwiXSA9ICdEZWxpdmVyeUZhaWxlZCddID0gXCJEZWxpdmVyeUZhaWxlZFwiO1xuICAgIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbXCJTZW5kaW5nRmFpbGVkXCJdID0gJ1NlbmRpbmdGYWlsZWQnXSA9IFwiU2VuZGluZ0ZhaWxlZFwiO1xuICAgIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXNbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cztcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9Qcmlvcml0eSkge1xuICAgIE1lc3NhZ2VJbmZvUHJpb3JpdHlbTWVzc2FnZUluZm9Qcmlvcml0eVtcIk5vcm1hbFwiXSA9ICdOb3JtYWwnXSA9IFwiTm9ybWFsXCI7XG4gICAgTWVzc2FnZUluZm9Qcmlvcml0eVtNZXNzYWdlSW5mb1ByaW9yaXR5W1wiSGlnaFwiXSA9ICdIaWdoJ10gPSBcIkhpZ2hcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9Qcmlvcml0eSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1ByaW9yaXR5ID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb1ByaW9yaXR5ID0gZXhwb3J0cy5NZXNzYWdlSW5mb1ByaW9yaXR5O1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1JlYWRTdGF0dXMpIHtcbiAgICBNZXNzYWdlSW5mb1JlYWRTdGF0dXNbTWVzc2FnZUluZm9SZWFkU3RhdHVzW1wiUmVhZFwiXSA9ICdSZWFkJ10gPSBcIlJlYWRcIjtcbiAgICBNZXNzYWdlSW5mb1JlYWRTdGF0dXNbTWVzc2FnZUluZm9SZWFkU3RhdHVzW1wiVW5yZWFkXCJdID0gJ1VucmVhZCddID0gXCJVbnJlYWRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9SZWFkU3RhdHVzIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvUmVhZFN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9SZWFkU3RhdHVzID0gZXhwb3J0cy5NZXNzYWdlSW5mb1JlYWRTdGF0dXM7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvVHlwZSkge1xuICAgIE1lc3NhZ2VJbmZvVHlwZVtNZXNzYWdlSW5mb1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xuICAgIE1lc3NhZ2VJbmZvVHlwZVtNZXNzYWdlSW5mb1R5cGVbXCJTTVNcIl0gPSAnU01TJ10gPSBcIlNNU1wiO1xuICAgIE1lc3NhZ2VJbmZvVHlwZVtNZXNzYWdlSW5mb1R5cGVbXCJWb2ljZU1haWxcIl0gPSAnVm9pY2VNYWlsJ10gPSBcIlZvaWNlTWFpbFwiO1xuICAgIE1lc3NhZ2VJbmZvVHlwZVtNZXNzYWdlSW5mb1R5cGVbXCJQYWdlclwiXSA9ICdQYWdlciddID0gXCJQYWdlclwiO1xuICAgIE1lc3NhZ2VJbmZvVHlwZVtNZXNzYWdlSW5mb1R5cGVbXCJUZXh0XCJdID0gJ1RleHQnXSA9IFwiVGV4dFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1R5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9UeXBlID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb1R5cGUgPSBleHBvcnRzLk1lc3NhZ2VJbmZvVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMpIHtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIk5vdEF2YWlsYWJsZVwiXSA9ICdOb3RBdmFpbGFibGUnXSA9IFwiTm90QXZhaWxhYmxlXCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiVGltZWRPdXRcIl0gPSAnVGltZWRPdXQnXSA9IFwiVGltZWRPdXRcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkNvbXBsZXRlZFwiXSA9ICdDb21wbGV0ZWQnXSA9IFwiQ29tcGxldGVkXCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJDb21wbGV0ZWRQYXJ0aWFsbHlcIl0gPSAnQ29tcGxldGVkUGFydGlhbGx5J10gPSBcIkNvbXBsZXRlZFBhcnRpYWxseVwiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiRmFpbGVkXCJdID0gJ0ZhaWxlZCddID0gXCJGYWlsZWRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzID0gZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cztcblxuXG4vKioqLyB9LFxuLyogNzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTWVzc2FnZUF0dGFjaG1lbnRJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZUF0dGFjaG1lbnRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VBdHRhY2htZW50SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRUeXBlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd2bUR1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZUF0dGFjaG1lbnRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlQXR0YWNobWVudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mbyA9IE1lc3NhZ2VBdHRhY2htZW50SW5mbztcbihmdW5jdGlvbiAoTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSkge1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIkF1ZGlvUmVjb3JkaW5nXCJdID0gJ0F1ZGlvUmVjb3JkaW5nJ10gPSBcIkF1ZGlvUmVjb3JkaW5nXCI7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiQXVkaW9UcmFuc2NyaXB0aW9uXCJdID0gJ0F1ZGlvVHJhbnNjcmlwdGlvbiddID0gXCJBdWRpb1RyYW5zY3JpcHRpb25cIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJUZXh0XCJdID0gJ1RleHQnXSA9IFwiVGV4dFwiO1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIlNvdXJjZURvY3VtZW50XCJdID0gJ1NvdXJjZURvY3VtZW50J10gPSBcIlNvdXJjZURvY3VtZW50XCI7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiUmVuZGVyZWREb2N1bWVudFwiXSA9ICdSZW5kZXJlZERvY3VtZW50J10gPSBcIlJlbmRlcmVkRG9jdW1lbnRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlQXR0YWNobWVudEluZm9UeXBlID0ge30pKTtcbnZhciBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlID0gZXhwb3J0cy5NZXNzYWdlQXR0YWNobWVudEluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA4MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZVN0b3JlQ2FsbGVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21lc3NhZ2VTdGF0dXMnLCBDbGFzczogTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZheEVycm9yQ29kZScsIENsYXNzOiBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlU3RvcmVDYWxsZXJJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvID0gTWVzc2FnZVN0b3JlQ2FsbGVySW5mbztcbihmdW5jdGlvbiAoTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMpIHtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlF1ZXVlZFwiXSA9ICdRdWV1ZWQnXSA9IFwiUXVldWVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJTZW50XCJdID0gJ1NlbnQnXSA9IFwiU2VudFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiRGVsaXZlcmVkXCJdID0gJ0RlbGl2ZXJlZCddID0gXCJEZWxpdmVyZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJ5RmFpbGVkXCJdID0gJ0RlbGl2ZXJ5RmFpbGVkJ10gPSBcIkRlbGl2ZXJ5RmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJTZW5kaW5nRmFpbGVkXCJdID0gJ1NlbmRpbmdGYWlsZWQnXSA9IFwiU2VuZGluZ0ZhaWxlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMgfHwgKGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMgPSB7fSkpO1xudmFyIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzID0gZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cztcbihmdW5jdGlvbiAoTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSkge1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlVuZGVmaW5lZFwiXSA9ICdVbmRlZmluZWQnXSA9IFwiVW5kZWZpbmVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiTm9GYXhTZW5kUGVybWlzc2lvblwiXSA9ICdOb0ZheFNlbmRQZXJtaXNzaW9uJ10gPSBcIk5vRmF4U2VuZFBlcm1pc3Npb25cIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJOb0ludGVybmF0aW9uYWxQZXJtaXNzaW9uXCJdID0gJ05vSW50ZXJuYXRpb25hbFBlcm1pc3Npb24nXSA9IFwiTm9JbnRlcm5hdGlvbmFsUGVybWlzc2lvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vRmF4TWFjaGluZVwiXSA9ICdOb0ZheE1hY2hpbmUnXSA9IFwiTm9GYXhNYWNoaW5lXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiT3V0Z29pbmdDYWxsRXJyb3JcIl0gPSAnT3V0Z29pbmdDYWxsRXJyb3InXSA9IFwiT3V0Z29pbmdDYWxsRXJyb3JcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJSZW5kZXJpbmdGYWlsZWRcIl0gPSAnUmVuZGVyaW5nRmFpbGVkJ10gPSBcIlJlbmRlcmluZ0ZhaWxlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlRvb01hbnlQYWdlc1wiXSA9ICdUb29NYW55UGFnZXMnXSA9IFwiVG9vTWFueVBhZ2VzXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiUmV0dXJuVG9EQlF1ZXVlXCJdID0gJ1JldHVyblRvREJRdWV1ZSddID0gXCJSZXR1cm5Ub0RCUXVldWVcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJOb0NhbGxUaW1lXCJdID0gJ05vQ2FsbFRpbWUnXSA9IFwiTm9DYWxsVGltZVwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiUHJvaGliaXRlZE51bWJlclwiXSA9ICdQcm9oaWJpdGVkTnVtYmVyJ10gPSBcIlByb2hpYml0ZWROdW1iZXJcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkZheFNlbmRpbmdQcm9oaWJpdGVkXCJdID0gJ0ZheFNlbmRpbmdQcm9oaWJpdGVkJ10gPSBcIkZheFNlbmRpbmdQcm9oaWJpdGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVGhlUGhvbmVJc0JsYWNrbGlzdGVkXCJdID0gJ1RoZVBob25lSXNCbGFja2xpc3RlZCddID0gXCJUaGVQaG9uZUlzQmxhY2tsaXN0ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJVc2VyTm90Rm91bmRcIl0gPSAnVXNlck5vdEZvdW5kJ10gPSBcIlVzZXJOb3RGb3VuZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkNvbnZlcnRFcnJvclwiXSA9ICdDb252ZXJ0RXJyb3InXSA9IFwiQ29udmVydEVycm9yXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiREJHZW5lcmFsRXJyb3JcIl0gPSAnREJHZW5lcmFsRXJyb3InXSA9IFwiREJHZW5lcmFsRXJyb3JcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJTa3lwZUJpbGxpbmdGYWlsZWRcIl0gPSAnU2t5cGVCaWxsaW5nRmFpbGVkJ10gPSBcIlNreXBlQmlsbGluZ0ZhaWxlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkFjY291bnRTdXNwZW5kZWRcIl0gPSAnQWNjb3VudFN1c3BlbmRlZCddID0gXCJBY2NvdW50U3VzcGVuZGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiUHJvaGliaXRlZERlc3RpbmF0aW9uXCJdID0gJ1Byb2hpYml0ZWREZXN0aW5hdGlvbiddID0gXCJQcm9oaWJpdGVkRGVzdGluYXRpb25cIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlIHx8IChleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUgPSBleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGU7XG5cblxuLyoqKi8gfSxcbi8qIDgxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1lc3NhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgTWVzc2FnZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbWVzc2FnZWluZm8uTWVzc2FnZUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZUxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlTGlzdCA9IE1lc3NhZ2VMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA4MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBtZXNzYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xudmFyIG1lc3NhZ2Vzc3luY2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKTtcbnZhciBNZXNzYWdlU3luYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VTeW5jLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VTeW5jKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZVN5bmMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNJbmZvJywgQ2xhc3M6IG1lc3NhZ2Vzc3luY2luZm8uTWVzc2FnZXNTeW5jSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZVN5bmMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlU3luYyc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZVN5bmM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VTeW5jID0gTWVzc2FnZVN5bmM7XG5cblxuLyoqKi8gfSxcbi8qIDgzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE1lc3NhZ2VzU3luY0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlc1N5bmNJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VzU3luY0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlc1N5bmNJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUeXBlJywgQ2xhc3M6IE1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1Rva2VuJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VzU3luY0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlc1N5bmNJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlc1N5bmNJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlc1N5bmNJbmZvID0gTWVzc2FnZXNTeW5jSW5mbztcbihmdW5jdGlvbiAoTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlKSB7XG4gICAgTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW01lc3NhZ2VzU3luY0luZm9TeW5jVHlwZVtcIkZTeW5jXCJdID0gJ0ZTeW5jJ10gPSBcIkZTeW5jXCI7XG4gICAgTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW01lc3NhZ2VzU3luY0luZm9TeW5jVHlwZVtcIklTeW5jXCJdID0gJ0lTeW5jJ10gPSBcIklTeW5jXCI7XG59KShleHBvcnRzLk1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSA9IGV4cG9ydHMuTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA4NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZ2V0c3Vic2NyaXB0aW9uaW5mb3Jlc3BvbnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XG52YXIgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBTdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC42IChSZWxlYXNlIDUuMTUpPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYSBuZXcgc3Vic2NyaXB0aW9uLiBUbyBjYWxsIHRoaXMgbWV0aG9kIHdpdGggQVBOUyB0cmFuc3BvcnQgdHlwZSB5b3UgaGF2ZSB0byBzcGVjaWZ5IGVuZHBvaW50X2lkIGF0dHJpYnV0ZSBpbiBnZXQgdG9rZW4gcmVxdWVzdCBhdCBhdXRob3JpemF0aW9uLjwvcD5cbiAgICAgKiA8aDQ+VXNhZ2UgUGxhbiBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24nLCBvcHRpb25zLCBleHBvcnRzLmNyZWF0ZU9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC42IChSZWxlYXNlIDUuMTUpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIHJlcXVlc3RlZCBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRPcHRpb25zKSwgZ2V0c3Vic2NyaXB0aW9uaW5mb3Jlc3BvbnNlLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5ldyBTdWJzY3JpcHRpb24gLyBNb2RpZnkgRXZlbnQgRmlsdGVyc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+V2l0aCBlbXB0eSByZXF1ZXN0IGJvZHkgLSByZW5ld3MgdGhlIGV4aXN0ZW50IHN1YnNjcmlwdGlvbi4gSWYgZXZlbnQgZmlsdGVycyBzcGVjaWZpZWQgLSBtb2RpZmllcyB0aGUgZXZlbnQgZmlsdGVycyBmb3IgdGhlIGV4aXN0aW5nIHN1YnNjcmlwdGlvbi4gVGhlIGNsaWVudCBhcHBsaWNhdGlvbiBjYW4gZXh0ZW5kIG9yIG5hcnJvdyB0aGUgZXZlbnRzIGZvciB3aGljaCBpdCByZWNlaXZlcyBub3RpZmljYXRpb25zIGluIHRoZSBmcmFtZVxuICAgICAqICAgICBvZiBvbmUgc3Vic2NyaXB0aW9uLjwvcD5cbiAgICAgKiA8aDQ+VXNhZ2UgUGxhbiBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi97c3Vic2NyaXB0aW9uSWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVPcHRpb25zKSwgZ2V0c3Vic2NyaXB0aW9uaW5mb3Jlc3BvbnNlLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgU3Vic2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+Q2FuY2VscyB0aGUgZXhpc3RlbnQgc3Vic2NyaXB0aW9uLjwvcD5cbiAgICAgKiA8aDQ+VXNhZ2UgUGxhbiBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi97c3Vic2NyaXB0aW9uSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5yZW1vdmVPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSTtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJID0gTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiY3JlYXRlc3Vic2NyaXB0aW9ucmVxdWVzdC5DcmVhdGVTdWJzY3JpcHRpb25SZXF1ZXN0XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN1YnNjcmlwdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51cGRhdGVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3Vic2NyaXB0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1vZGlmeXN1YnNjcmlwdGlvbnJlcXVlc3QuTW9kaWZ5U3Vic2NyaXB0aW9uUmVxdWVzdFwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHJlbW92ZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5yZW1vdmVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3Vic2NyaXB0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDg1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG5vdGlmaWNhdGlvbmRlbGl2ZXJ5bW9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oODYpO1xudmFyIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXZlbnRGaWx0ZXJzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nW10gKi8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXhwaXJhdGlvblRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4cGlyZXNJbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY3JlYXRpb25UaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZWxpdmVyeU1vZGUnLCBDbGFzczogbm90aWZpY2F0aW9uZGVsaXZlcnltb2RlLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlJztcbiAgICB9O1xuICAgIHJldHVybiBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2U7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSA9IEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZTtcbihmdW5jdGlvbiAoR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzKSB7XG4gICAgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW0dldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1c1tcIkFjdGl2ZVwiXSA9ICdBY3RpdmUnXSA9IFwiQWN0aXZlXCI7XG4gICAgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW0dldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1c1tcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG59KShleHBvcnRzLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cyB8fCAoZXhwb3J0cy5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMgPSB7fSkpO1xudmFyIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cyA9IGV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA4NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RyYW5zcG9ydFR5cGUnLCBDbGFzczogTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmNyeXB0aW9uJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhZGRyZXNzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N1YnNjcmliZXJLZXknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuY3J5cHRpb25BbGdvcml0aG0nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuY3J5cHRpb25LZXknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZ2lzdHJhdGlvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjZXJ0aWZpY2F0ZU5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUnO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZTtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlID0gTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlO1xuKGZ1bmN0aW9uIChOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlKSB7XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW1wiUHViTnViXCJdID0gJ1B1Yk51YiddID0gXCJQdWJOdWJcIjtcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbXCJBUE5TXCJdID0gJ0FQTlMnXSA9IFwiQVBOU1wiO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVsnUHViTnViL0FQTlMvVm9JUCddID0gJ1B1Yk51Yi9BUE5TL1ZvSVAnXSA9ICdQdWJOdWIvQVBOUy9Wb0lQJztcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbXCJXZWJIb29rXCJdID0gJ1dlYkhvb2snXSA9IFwiV2ViSG9va1wiO1xufSkoZXhwb3J0cy5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlIHx8IChleHBvcnRzLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUgPSB7fSkpO1xudmFyIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUgPSBleHBvcnRzLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDg3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBwcmVzZW5jZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcbnZhciBtb25pdG9yZWRleHRlbnNpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XG52YXIgUHJlc2VuY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVzZW5jZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24ocykgUHJlc2VuY2UgU3RhdHVzIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHByZXNlbmNlIHN0YXR1cyBvZiBhbiBleHRlbnNpb24gb3Igc2V2ZXJhbCBleHRlbnNpb25zIGJ5IHRoZWlyIElEKHMpLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLlRoZSBwcmVzZW5jZVN0YXR1cyBpcyByZXR1cm5lZCBhcyBPZmZsaW5lICh0aGUgcGFyYW1ldGVycyB0ZWxlcGhvbnlTdGF0dXMsIG1lc3NhZ2UsIHVzZXJTdGF0dXMgYW5kIGRuZFN0YXR1cyBhcmUgbm90XG4gICAgICogICAgIHJldHVybmVkIGF0IGFsbCkgZm9yIHRoZSBmb2xsb3dpbmcgZXh0ZW5zaW9uIHR5cGVzOiBEZXBhcnRtZW50L0Fubm91bmNlbWVudCBPbmx5L1Rha2UgTWVzc2FnZXMgT25seSAoVm9pY2VtYWlsKS9GYXggVXNlci9QYWdpbmcgT25seSBHcm91cC9TaGFyZWQgTGluZXMgR3JvdXAvSVZSIE1lbnUvQXBwbGljYXRpb24gRXh0ZW5zaW9uL1BhcmsgTG9jYXRpb24uSWYgdGhlIHVzZXIgcmVxdWVzdHMgaGlzL2hlciBvd24gcHJlc2VuY2Ugc3RhdHVzLFxuICAgICAqICAgICB0aGUgcmVzcG9uc2UgY29udGFpbnMgYWN0dWFsIHByZXNlbmNlIHN0YXR1cyBldmVuIGlmIHRoZSBzdGF0dXMgcHVibGljYXRpb24gaXMgdHVybmVkIG9mZi5CYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZC4gRm9yIGJhdGNoIHJlcXVlc3RzIHRoZSBudW1iZXIgb2YgZXh0ZW5zaW9ucyBpbiBvbmUgcmVxdWVzdCBpcyBsaW1pdGVkIHRvIDMwLiBJZiBtb3JlIGV4dGVuc2lvbnMgYXJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LCB0aGVcbiAgICAgKiAgICAgZXJyb3IgY29kZSA0MDAgQmFkIFJlcXVlc3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgbG9naWNhbCBlcnJvciBjb2RlIEludmFsaWRNdWx0aXBhcnRSZXF1ZXN0IGFuZCB0aGUgY29ycmVzcG9uZGluZyBtZXNzYWdlICdFeHRlbnNpb24gUHJlc2VuY2UgSW5mbyBtdWx0aXBhcnQgcmVxdWVzdCBpcyBsaW1pdGVkIHRvIDMwIGV4dGVuc2lvbnMnLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZFByZXNlbmNlPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+R2V0dGluZyB1c2VyIHByZXNlbmNlIGluZm9ybWF0aW9uPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBQcmVzZW5jZS5wcm90b3R5cGUuZ2V0UHJlc2VuY2VTdGF0dXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3ByZXNlbmNlJywgb3B0aW9ucywgZXhwb3J0cy5nZXRQcmVzZW5jZVN0YXR1c09wdGlvbnMpLCBwcmVzZW5jZWluZm8uUHJlc2VuY2VJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBNb25pdG9yZWQgRXh0ZW5zaW9uc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjEzIChSZWxlYXNlIDYuNSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBsaXN0IG9mIGxpbmVzIC0gZXh0ZW5zaW9ucyB3aGljaCBwcmVzZW5jZSBzdGF0dXMgY2FuIGJlIGluZGljYXRlZCBhbmQgbW9uaXRvcmVkIG9uIEJMRi1lbmFibGVkIChCdXN5IExhbXAgRmllbGQpIGRldmljZXMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkUHJlc2VuY2U8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5HZXR0aW5nIHVzZXIgcHJlc2VuY2UgaW5mb3JtYXRpb248L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIFByZXNlbmNlLnByb3RvdHlwZS5saXN0TW9uaXRvcmVkRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJlc2VuY2UvbGluZScsIG9wdGlvbnMsIGV4cG9ydHMubGlzdE1vbml0b3JlZEV4dGVuc2lvbnNPcHRpb25zKSwgbW9uaXRvcmVkZXh0ZW5zaW9ucy5Nb25pdG9yZWRFeHRlbnNpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZTtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5QcmVzZW5jZSA9IFByZXNlbmNlO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGdldFByZXNlbmNlU3RhdHVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmdldFByZXNlbmNlU3RhdHVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0TW9uaXRvcmVkRXh0ZW5zaW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0TW9uaXRvcmVkRXh0ZW5zaW9uc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDg4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHByZXNlbmNlZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xudmFyIFByZXNlbmNlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByZXNlbmNlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQcmVzZW5jZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhbGxvd1NlZU15UHJlc2VuY2UnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkbmRTdGF0dXMnLCBDbGFzczogUHJlc2VuY2VJbmZvRG5kU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogcHJlc2VuY2VleHRlbnNpb25pbmZvLlByZXNlbmNlRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVzc2FnZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGlja1VwQ2FsbHNPbkhvbGQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcmVzZW5jZVN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmluZ09uTW9uaXRvcmVkQ2FsbCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RlbGVwaG9ueVN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VzZXJTdGF0dXMnLCBDbGFzczogUHJlc2VuY2VJbmZvVXNlclN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFByZXNlbmNlSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1ByZXNlbmNlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QcmVzZW5jZUluZm8gPSBQcmVzZW5jZUluZm87XG4oZnVuY3Rpb24gKFByZXNlbmNlSW5mb0RuZFN0YXR1cykge1xuICAgIFByZXNlbmNlSW5mb0RuZFN0YXR1c1tQcmVzZW5jZUluZm9EbmRTdGF0dXNbXCJUYWtlQWxsQ2FsbHNcIl0gPSAnVGFrZUFsbENhbGxzJ10gPSBcIlRha2VBbGxDYWxsc1wiO1xuICAgIFByZXNlbmNlSW5mb0RuZFN0YXR1c1tQcmVzZW5jZUluZm9EbmRTdGF0dXNbXCJEb05vdEFjY2VwdEFueUNhbGxzXCJdID0gJ0RvTm90QWNjZXB0QW55Q2FsbHMnXSA9IFwiRG9Ob3RBY2NlcHRBbnlDYWxsc1wiO1xuICAgIFByZXNlbmNlSW5mb0RuZFN0YXR1c1tQcmVzZW5jZUluZm9EbmRTdGF0dXNbXCJEb05vdEFjY2VwdERlcGFydG1lbnRDYWxsc1wiXSA9ICdEb05vdEFjY2VwdERlcGFydG1lbnRDYWxscyddID0gXCJEb05vdEFjY2VwdERlcGFydG1lbnRDYWxsc1wiO1xuICAgIFByZXNlbmNlSW5mb0RuZFN0YXR1c1tQcmVzZW5jZUluZm9EbmRTdGF0dXNbXCJUYWtlRGVwYXJ0bWVudENhbGxzT25seVwiXSA9ICdUYWtlRGVwYXJ0bWVudENhbGxzT25seSddID0gXCJUYWtlRGVwYXJ0bWVudENhbGxzT25seVwiO1xufSkoZXhwb3J0cy5QcmVzZW5jZUluZm9EbmRTdGF0dXMgfHwgKGV4cG9ydHMuUHJlc2VuY2VJbmZvRG5kU3RhdHVzID0ge30pKTtcbnZhciBQcmVzZW5jZUluZm9EbmRTdGF0dXMgPSBleHBvcnRzLlByZXNlbmNlSW5mb0RuZFN0YXR1cztcbihmdW5jdGlvbiAoUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tcIk9mZmxpbmVcIl0gPSAnT2ZmbGluZSddID0gXCJPZmZsaW5lXCI7XG4gICAgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1ByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1wiQXZhaWxhYmxlXCJdID0gJ0F2YWlsYWJsZSddID0gXCJBdmFpbGFibGVcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMgfHwgKGV4cG9ydHMuUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMgPSB7fSkpO1xudmFyIFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cztcbihmdW5jdGlvbiAoUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzKSB7XG4gICAgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1ByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tcIk5vQ2FsbFwiXSA9ICdOb0NhbGwnXSA9IFwiTm9DYWxsXCI7XG4gICAgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1ByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tcIkNhbGxDb25uZWN0ZWRcIl0gPSAnQ2FsbENvbm5lY3RlZCddID0gXCJDYWxsQ29ubmVjdGVkXCI7XG4gICAgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1ByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tcIlJpbmdpbmdcIl0gPSAnUmluZ2luZyddID0gXCJSaW5naW5nXCI7XG4gICAgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1ByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tcIk9uSG9sZFwiXSA9ICdPbkhvbGQnXSA9IFwiT25Ib2xkXCI7XG4gICAgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1ByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1c1tcIlBhcmtlZENhbGxcIl0gPSAnUGFya2VkQ2FsbCddID0gXCJQYXJrZWRDYWxsXCI7XG59KShleHBvcnRzLlByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMgPSB7fSkpO1xudmFyIFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cyA9IGV4cG9ydHMuUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9Vc2VyU3RhdHVzKSB7XG4gICAgUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1wiT2ZmbGluZVwiXSA9ICdPZmZsaW5lJ10gPSBcIk9mZmxpbmVcIjtcbiAgICBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1ByZXNlbmNlSW5mb1VzZXJTdGF0dXNbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIFByZXNlbmNlSW5mb1VzZXJTdGF0dXNbUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tcIkF2YWlsYWJsZVwiXSA9ICdBdmFpbGFibGUnXSA9IFwiQXZhaWxhYmxlXCI7XG59KShleHBvcnRzLlByZXNlbmNlSW5mb1VzZXJTdGF0dXMgfHwgKGV4cG9ydHMuUHJlc2VuY2VJbmZvVXNlclN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvVXNlclN0YXR1cyA9IGV4cG9ydHMuUHJlc2VuY2VJbmZvVXNlclN0YXR1cztcblxuXG4vKioqLyB9LFxuLyogODkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUHJlc2VuY2VFeHRlbnNpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlc2VuY2VFeHRlbnNpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlRXh0ZW5zaW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByZXNlbmNlRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQcmVzZW5jZUV4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQcmVzZW5jZUV4dGVuc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlRXh0ZW5zaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUHJlc2VuY2VFeHRlbnNpb25JbmZvID0gUHJlc2VuY2VFeHRlbnNpb25JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA5MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBsaW5laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIE1vbml0b3JlZEV4dGVuc2lvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb25pdG9yZWRFeHRlbnNpb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbml0b3JlZEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNb25pdG9yZWRFeHRlbnNpb25zLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBsaW5laW5mby5MaW5lSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTW9uaXRvcmVkRXh0ZW5zaW9ucy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01vbml0b3JlZEV4dGVuc2lvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbml0b3JlZEV4dGVuc2lvbnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1vbml0b3JlZEV4dGVuc2lvbnMgPSBNb25pdG9yZWRFeHRlbnNpb25zO1xuXG5cbi8qKiovIH0sXG4vKiA5MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBtb25pdG9yZWRsaW5lc2V4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcbnZhciBMaW5lSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTGluZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uJywgQ2xhc3M6IG1vbml0b3JlZGxpbmVzZXh0ZW5zaW9uaW5mby5Nb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBMaW5lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xpbmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBMaW5lSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTGluZUluZm8gPSBMaW5lSW5mbztcblxuXG4vKioqLyB9LFxuLyogOTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Nb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8gPSBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm87XG4oZnVuY3Rpb24gKE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUpIHtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJVc2VyXCJdID0gJ1VzZXInXSA9IFwiVXNlclwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4VXNlciddID0gXCJGYXhVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiVmlydHVhbFVzZXJcIl0gPSAnVmlydHVhbFVzZXInXSA9IFwiVmlydHVhbFVzZXJcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJEaWdpdGFsVXNlclwiXSA9ICdEaWdpdGFsVXNlciddID0gXCJEaWdpdGFsVXNlclwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIkRlcGFydG1lbnRcIl0gPSAnRGVwYXJ0bWVudCddID0gXCJEZXBhcnRtZW50XCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiQXBwbGljYXRpb25FeHRlbnNpb25cIl0gPSAnQXBwbGljYXRpb25FeHRlbnNpb24nXSA9IFwiQXBwbGljYXRpb25FeHRlbnNpb25cIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5Nb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlIHx8IChleHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUgPSB7fSkpO1xudmFyIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUgPSBleHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDkzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciByaW5nb3V0c3RhdHVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XG52YXIgUmluZ091dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJpbmdPdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmluZ091dCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgUmluZ091dCBDYWxsXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNyAoUmVsZWFzZSA1LjE2KTwvcD5cbiAgICAgKiA8cD5NYWtlcyBhIDItbGVnIFJpbmdPdXQgY2FsbC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJpbmdPdXQ8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5QZXJmb3JtaW5nIHR3by1sZWdnZWQgcmluZy1vdXQgcGhvbmUgY2FsbHM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIFJpbmdPdXQucHJvdG90eXBlLm1ha2VSaW5nT3V0Q2FsbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQnLCBvcHRpb25zLCBleHBvcnRzLm1ha2VSaW5nT3V0Q2FsbE9wdGlvbnMpLCByaW5nb3V0c3RhdHVzLlJpbmdPdXRTdGF0dXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN0YXR1cyBvZiBSaW5nT3V0IENhbGxcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIHN0YXR1cyBvZiBhIDItbGVnIFJpbmdPdXQgY2FsbC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJpbmdPdXQ8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5QZXJmb3JtaW5nIHR3by1sZWdnZWQgcmluZy1vdXQgcGhvbmUgY2FsbHM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIFJpbmdPdXQucHJvdG90eXBlLmdldFJpbmdPdXRDYWxsU3RhdHVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9yaW5nb3V0L3tyaW5nb3V0SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5nZXRSaW5nT3V0Q2FsbFN0YXR1c09wdGlvbnMpLCByaW5nb3V0c3RhdHVzLlJpbmdPdXRTdGF0dXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuY2VsIFJpbmdPdXQgQ2FsbFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPkNhbmNlbHMgdGhlIDItbGVnIFJpbmdPdXQgY2FsbC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJpbmdPdXQ8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5QZXJmb3JtaW5nIHR3by1sZWdnZWQgcmluZy1vdXQgcGhvbmUgY2FsbHM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIFJpbmdPdXQucHJvdG90eXBlLmNhbmNlbFJpbmdPdXRDYWxsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9yaW5nb3V0L3tyaW5nb3V0SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5jYW5jZWxSaW5nT3V0Q2FsbE9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBSaW5nT3V0O1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLlJpbmdPdXQgPSBSaW5nT3V0O1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIG1ha2VSaW5nT3V0Q2FsbCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5tYWtlUmluZ091dENhbGxPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIm1ha2VyaW5nb3V0cmVxdWVzdC5NYWtlUmluZ091dFJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZ2V0UmluZ091dENhbGxTdGF0dXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZ2V0UmluZ091dENhbGxTdGF0dXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmluZ291dElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNhbmNlbFJpbmdPdXRDYWxsIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNhbmNlbFJpbmdPdXRDYWxsT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJpbmdvdXRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogOTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcmluZ291dHN0YXR1c2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcbnZhciBSaW5nT3V0U3RhdHVzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dFN0YXR1cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSaW5nT3V0U3RhdHVzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmluZ091dFN0YXR1cy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IHJpbmdvdXRzdGF0dXNpbmZvLlJpbmdPdXRTdGF0dXNJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmluZ091dFN0YXR1cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JpbmdPdXRTdGF0dXMnO1xuICAgIH07XG4gICAgcmV0dXJuIFJpbmdPdXRTdGF0dXM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlJpbmdPdXRTdGF0dXMgPSBSaW5nT3V0U3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA5NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBSaW5nT3V0U3RhdHVzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJpbmdPdXRTdGF0dXNJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpbmdPdXRTdGF0dXNJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmluZ091dFN0YXR1c0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbFN0YXR1cycsIENsYXNzOiBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxlclN0YXR1cycsIENsYXNzOiBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGVlU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmluZ091dFN0YXR1c0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSaW5nT3V0U3RhdHVzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmluZ091dFN0YXR1c0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvID0gUmluZ091dFN0YXR1c0luZm87XG4oZnVuY3Rpb24gKFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJJbnZhbGlkXCJdID0gJ0ludmFsaWQnXSA9IFwiSW52YWxpZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJTdWNjZXNzXCJdID0gJ1N1Y2Nlc3MnXSA9IFwiU3VjY2Vzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJOb0Fuc3dlclwiXSA9ICdOb0Fuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJHZW5lcmljRXJyb3JcIl0gPSAnR2VuZXJpY0Vycm9yJ10gPSBcIkdlbmVyaWNFcnJvclwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJGaW5pc2hlZFwiXSA9ICdGaW5pc2hlZCddID0gXCJGaW5pc2hlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJEZXN0aW5hdGlvbkJsb2NrZWRcIl0gPSAnRGVzdGluYXRpb25CbG9ja2VkJ10gPSBcIkRlc3RpbmF0aW9uQmxvY2tlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJOb3RFbm91Z2hGdW5kc1wiXSA9ICdOb3RFbm91Z2hGdW5kcyddID0gXCJOb3RFbm91Z2hGdW5kc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMgfHwgKGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzID0ge30pKTtcbnZhciBSaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cztcbihmdW5jdGlvbiAoUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMpIHtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkludmFsaWRcIl0gPSAnSW52YWxpZCddID0gXCJJbnZhbGlkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJTdWNjZXNzXCJdID0gJ1N1Y2Nlc3MnXSA9IFwiU3VjY2Vzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiSW5Qcm9ncmVzc1wiXSA9ICdJblByb2dyZXNzJ10gPSBcIkluUHJvZ3Jlc3NcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJOb0Fuc3dlclwiXSA9ICdOb0Fuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkdlbmVyaWNFcnJvclwiXSA9ICdHZW5lcmljRXJyb3InXSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJGaW5pc2hlZFwiXSA9ICdGaW5pc2hlZCddID0gXCJGaW5pc2hlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWxEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkRlc3RpbmF0aW9uQmxvY2tlZFwiXSA9ICdEZXN0aW5hdGlvbkJsb2NrZWQnXSA9IFwiRGVzdGluYXRpb25CbG9ja2VkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJOb3RFbm91Z2hGdW5kc1wiXSA9ICdOb3RFbm91Z2hGdW5kcyddID0gXCJOb3RFbm91Z2hGdW5kc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiTm9TdWNoVXNlclwiXSA9ICdOb1N1Y2hVc2VyJ10gPSBcIk5vU3VjaFVzZXJcIjtcbn0pKGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMgfHwgKGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMgPSB7fSkpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzID0gZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cztcbihmdW5jdGlvbiAoUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMpIHtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkludmFsaWRcIl0gPSAnSW52YWxpZCddID0gXCJJbnZhbGlkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJTdWNjZXNzXCJdID0gJ1N1Y2Nlc3MnXSA9IFwiU3VjY2Vzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiSW5Qcm9ncmVzc1wiXSA9ICdJblByb2dyZXNzJ10gPSBcIkluUHJvZ3Jlc3NcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJOb0Fuc3dlclwiXSA9ICdOb0Fuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiUmVqZWN0ZWRcIl0gPSAnUmVqZWN0ZWQnXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkdlbmVyaWNFcnJvclwiXSA9ICdHZW5lcmljRXJyb3InXSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJGaW5pc2hlZFwiXSA9ICdGaW5pc2hlZCddID0gXCJGaW5pc2hlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiSW50ZXJuYXRpb25hbERpc2FibGVkXCJdID0gJ0ludGVybmF0aW9uYWxEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkRlc3RpbmF0aW9uQmxvY2tlZFwiXSA9ICdEZXN0aW5hdGlvbkJsb2NrZWQnXSA9IFwiRGVzdGluYXRpb25CbG9ja2VkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJOb3RFbm91Z2hGdW5kc1wiXSA9ICdOb3RFbm91Z2hGdW5kcyddID0gXCJOb3RFbm91Z2hGdW5kc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiTm9TdWNoVXNlclwiXSA9ICdOb1N1Y2hVc2VyJ10gPSBcIk5vU3VjaFVzZXJcIjtcbn0pKGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMgfHwgKGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMgPSB7fSkpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzID0gZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cztcblxuXG4vKioqLyB9LFxuLyogOTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGV4dGVuc2lvbmZvcndhcmRpbmdudW1iZXJsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XG52YXIgZm9yd2FyZGluZ251bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcbnZhciBGb3J3YXJkaW5nTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcndhcmRpbmdOdW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcndhcmRpbmdOdW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBGb3J3YXJkaW5nIE51bWJlciBMaXN0XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNyAoUmVsZWFzZSA1LjE2KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIGV4dGVuc2lvbiBwaG9uZSBudW1iZXJzIHVzZWQgZm9yIGNhbGwgZm9yd2FyZGluZyBhbmQgY2FsbCBmbGlwLiBUaGUgcmV0dXJuZWQgbGlzdCBjb250YWlucyBhbGwgdGhlIGV4dGVuc2lvbiBwaG9uZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgZm9yIGNhbGwgZm9yd2FyZGluZyBhbmQgY2FsbCBmbGlwLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEZvcndhcmRpbmdOdW1iZXJzLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnNPcHRpb25zKSwgZXh0ZW5zaW9uZm9yd2FyZGluZ251bWJlcmxpc3QuRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEZvcndhcmRpbmcgTnVtYmVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTIgKFJlbGVhc2UgNi40KTwvcD5cbiAgICAgKiA8cD5BZGRzIGEgbmV3IGZvcndhcmRpbmcgbnVtYmVyIHRvIHRoZSBmb3J3YXJkaW5nIG51bWJlciBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmNyZWF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9mb3J3YXJkaW5nLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMpLCBmb3J3YXJkaW5nbnVtYmVyaW5mby5Gb3J3YXJkaW5nTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgRm9yd2FyZGluZyBOdW1iZXIgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yNCAoUmVsZWFzZSA4LjApPC9wPlxuICAgICAqIDxwPlVwZGF0ZXMgYW4gZXhpc3RlbnQgZm9yd2FyZGluZyBudW1iZXIgZnJvbSB0aGUgZm9yd2FyZGluZyBudW1iZXIgbGlzdC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlciwgYXNzaWduZWQgcGhvbmUgbnVtYmVycywgZGV2aWNlcyBhbmQgb3RoZXIgZXh0ZW5zaW9uIHNldHRpbmdzKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEZvcndhcmRpbmdOdW1iZXJzLnByb3RvdHlwZS51cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9mb3J3YXJkaW5nLW51bWJlci97Zm9yd2FyZGluZ051bWJlcklkfScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMpLCBmb3J3YXJkaW5nbnVtYmVyaW5mby5Gb3J3YXJkaW5nTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgRm9yd2FyZGluZyBOdW1iZXIgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yNCAoUmVsZWFzZSA4LjApPC9wPlxuICAgICAqIDxwPkRlbGV0ZXMgYSBmb3J3YXJkaW5nIG51bWJlciBmcm9tIHRoZSBmb3J3YXJkaW5nIG51bWJlciBsaXN0IGJ5IGl0cyBJRC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlciwgYXNzaWduZWQgcGhvbmUgbnVtYmVycywgZGV2aWNlcyBhbmQgb3RoZXIgZXh0ZW5zaW9uIHNldHRpbmdzKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEZvcndhcmRpbmdOdW1iZXJzLnByb3RvdHlwZS5kZWxldGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9mb3J3YXJkaW5nLW51bWJlci97Zm9yd2FyZGluZ051bWJlcklkfScsIG9wdGlvbnMsIGV4cG9ydHMuZGVsZXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBGb3J3YXJkaW5nTnVtYmVycztcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5Gb3J3YXJkaW5nTnVtYmVycyA9IEZvcndhcmRpbmdOdW1iZXJzO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNyZWF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiY3JlYXRlZm9yd2FyZGluZ251bWJlcnJlcXVlc3QuQ3JlYXRlRm9yd2FyZGluZ051bWJlclJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImZvcndhcmRpbmdOdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJ1cGRhdGVmb3J3YXJkaW5nbnVtYmVycmVxdWVzdC5VcGRhdGVGb3J3YXJkaW5nTnVtYmVyUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZm9yd2FyZGluZ051bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiA5NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBmb3J3YXJkaW5nbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QgPSBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdDtcblxuXG4vKioqLyB9LFxuLyogOTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRm9yd2FyZGluZ051bWJlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3J3YXJkaW5nTnVtYmVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3J3YXJkaW5nTnVtYmVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEZvcndhcmRpbmdOdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsYWJlbCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmVhdHVyZXMnLCBDbGFzczogRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmxpcE51bWJlcicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEZvcndhcmRpbmdOdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRm9yd2FyZGluZ051bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcndhcmRpbmdOdW1iZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Gb3J3YXJkaW5nTnVtYmVySW5mbyA9IEZvcndhcmRpbmdOdW1iZXJJbmZvO1xuKGZ1bmN0aW9uIChGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzKSB7XG4gICAgRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlc1tGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzW1wiQ2FsbEZsaXBcIl0gPSAnQ2FsbEZsaXAnXSA9IFwiQ2FsbEZsaXBcIjtcbiAgICBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzW0ZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbXCJDYWxsRm9yd2FyZGluZ1wiXSA9ICdDYWxsRm9yd2FyZGluZyddID0gXCJDYWxsRm9yd2FyZGluZ1wiO1xufSkoZXhwb3J0cy5Gb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzIHx8IChleHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMgPSB7fSkpO1xudmFyIEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMgPSBleHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXM7XG5cblxuLyoqKi8gfSxcbi8qIDk5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBibG9ja2VkbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcbnZhciBibG9ja2VkbnVtYmVyc2xpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG52YXIgQmxvY2tlZE51bWJlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja2VkTnVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja2VkTnVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBCbG9ja2VkIE51bWJlclxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUuYmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ibG9ja2VkLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMuYmxvY2tOdW1iZXJPcHRpb25zKSwgYmxvY2tlZG51bWJlcmluZm8uQmxvY2tlZE51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEJsb2NrZWQgTnVtYmVyIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgcGhvbmUgbnVtYmVycyB3aGljaCBhcmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIHRvIGJsb2NrIGluYm91bmQgY2FsbHMgYW5kIFNNUyBtZXNzYWdlcy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUubGlzdEJsb2NrZWROdW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ibG9ja2VkLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEJsb2NrZWROdW1iZXJzT3B0aW9ucyksIGJsb2NrZWRudW1iZXJzbGlzdC5CbG9ja2VkTnVtYmVyc0xpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEJsb2NrZWQgTnVtYmVyKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLmxvYWRCbG9ja2VkTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ibG9ja2VkLW51bWJlci97YmxvY2tlZE51bWJlcklkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEJsb2NrZWROdW1iZXJPcHRpb25zKSwgYmxvY2tlZG51bWJlcmluZm8uQmxvY2tlZE51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEJsb2NrZWQgTnVtYmVyKHMpIGJ5IElEXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS51cGRhdGVCbG9ja2VkTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ibG9ja2VkLW51bWJlci97YmxvY2tlZE51bWJlcklkfScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlQmxvY2tlZE51bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLnVuYmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51bmJsb2NrTnVtYmVyT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkJsb2NrZWROdW1iZXJzID0gQmxvY2tlZE51bWJlcnM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgYmxvY2tOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuYmxvY2tOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RCbG9ja2VkTnVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0QmxvY2tlZE51bWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRCbG9ja2VkTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRCbG9ja2VkTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJsb2NrZWROdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVCbG9ja2VkTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZUJsb2NrZWROdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZE51bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVuYmxvY2tOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudW5ibG9ja051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJibG9ja2VkTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDEwMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBCbG9ja2VkTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrZWROdW1iZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmxvY2tlZE51bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCbG9ja2VkTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0Jsb2NrZWROdW1iZXJJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja2VkTnVtYmVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlckluZm8gPSBCbG9ja2VkTnVtYmVySW5mbztcblxuXG4vKioqLyB9LFxuLyogMTAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGJsb2NrZWRudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEJsb2NrZWROdW1iZXJzTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrZWROdW1iZXJzTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja2VkTnVtYmVyc0xpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCbG9ja2VkTnVtYmVyc0xpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQmxvY2tlZE51bWJlcnNMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmxvY2tlZE51bWJlcnNMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja2VkTnVtYmVyc0xpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJsb2NrZWROdW1iZXJzTGlzdCA9IEJsb2NrZWROdW1iZXJzTGlzdDtcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaW5nY2VudHJhbC1jbGllbnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmluZ2NlbnRyYWwtY2xpZW50L2J1aWxkL3JpbmdjZW50cmFsLWNsaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuL3N5bWJvbC1tYXAnO1xuaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4vcmVkdXgtaGVscGVyJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnQtZW1pdHRlcic7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ3N0b3JlJyxcbiAgJ21hcHBlcicsXG4gICdwcmVmaXgnLFxuICAnYWN0aW9ucycsXG4gICdlbWl0dGVyJyxcbl0pO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAZGVzY3JpcHRpb24gRGVmYXVsdCByZWR1Y2VyIGlmIG1vZHVsZSBkb2VzIG5vdCBoYXMgaXRzIG93biByZWR1Y2VyLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0UmVkdWNlcihzdGF0ZSkge1xuICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHt9O1xuICByZXR1cm4gc3RhdGU7XG59XG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAZGVzY3JpcHRpb24gRGVmYXVsdCBwYXJlbnQgc3RhdGUgdG8gbW9kdWxlIHN0YXRlIG1hcHBlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdE1hcHBlcihzdGF0ZSkge1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZGVmYXVsdFxuICogQGRlc2NyaXB0aW9uIEJhc2UgbW9kdWxlIGNsYXNzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSY01vZHVsZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBzdGF0ZU1hcHBlciA9IGRlZmF1bHRNYXBwZXIsXG4gICAgcHJlZml4LFxuICAgIGFjdGlvbnMsXG4gIH0pIHtcbiAgICAvLyBFeHRlbmRpbmcgRXZlbnRFbWl0dGVyIGJyZWFrcyBzb21lIG1lY2hhbmljLCBzbyB3ZSB3aXJlIGVtaXR0ZXIgdXAgbGlrZSB0aGlzIGluc3RlYWQuXG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXNbc3ltYm9scy5tYXBwZXJdID0gc3RhdGVNYXBwZXI7XG4gICAgdGhpc1tzeW1ib2xzLnByZWZpeF0gPSBwcmVmaXg7XG4gICAgdGhpc1tzeW1ib2xzLmFjdGlvbnNdID0gYWN0aW9ucyAmJiBwcmVmaXhBY3Rpb25zKGFjdGlvbnMsIHByZWZpeCk7XG4gICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXIoKHN0b3JlKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMuc3RvcmVdID0gc3RvcmU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBVbnJlZ2lzdGVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb24pfSBoYW5kbGVyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBVbnJlZ2lzdGVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgb25jZShldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vbmNlKGV2ZW50LCBoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9mZihldmVudCwgaGFuZGxlcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0gey4uLmFyZ3N9IGFyZ3NcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0uZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9mZihldmVudCwgaGFuZGxlcik7XG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5tYXBwZXJdKHRoaXNbc3ltYm9scy5zdG9yZV0uZ2V0U3RhdGUoKSk7XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRSZWR1Y2VyO1xuICB9XG4gIGdldCBzdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnN0b3JlXTtcbiAgfVxuICBnZXQgcHJlZml4KCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMucHJlZml4XTtcbiAgfVxuICBnZXQgYWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLmFjdGlvbnNdO1xuICB9XG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9yYy1tb2R1bGUuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuL2VudW0nO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGRlc2NyaXB0aW9uIEhlbHBlciBjbGFzcyBmb3IgY3JlYXRpbmcgYSBzeW1ib2wgbWFwcGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW1ib2xNYXAgZXh0ZW5kcyBFbnVtIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXlzKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgZGVmaW5pdGlvbltrZXldID0gU3ltYm9sKCk7XG4gICAgfSk7XG4gICAgc3VwZXIoZGVmaW5pdGlvbik7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9zeW1ib2wtbWFwLmpzXG4gKiovIiwiY29uc3QgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IERFRklOSVRJT04gPSBTeW1ib2woKTtcbmNvbnN0IFZBTFVFUyA9IFN5bWJvbCgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnVtIHtcbiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbikge1xuICAgIHRoaXNbREVGSU5JVElPTl0gPSBPYmplY3QuYXNzaWduKHt9LCBkZWZpbml0aW9uKTtcbiAgICB0aGlzW1ZBTFVFU10gPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tERUZJTklUSU9OXVtrZXldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbVkFMVUVTXS5hZGQodGhpc1tERUZJTklUSU9OXVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGhhc1ZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXNbVkFMVUVTXS5oYXModmFsdWUpO1xuICB9XG59XG5cbi8qXG4gKiAvL3dpdGggUHJveHkgc3VwcG9ydFxuICpjb25zdCBlbnVtSGFuZGxlciA9IHtcbiAqICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAqICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAqICB9LFxuICogIHNldCgpIHtcbiAqICAgIHJldHVybjtcbiAqICB9XG4gKn07XG4gKkVudW0gPSBjbGFzcyBFbnVtIGV4dGVuZHMgUHJveHkge1xuICogIGNvbnN0cnVjdG9yKGRlZmluaXRpb24pIHtcbiAqICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pLCBlbnVtSGFuZGxlcik7XG4gKiAgfVxuICp9XG4gKi9cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2VudW0uanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuL2VudW0nO1xuXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIEBjbGFzc1xuICogQGRlc2NyaXB0aW9uIGhlbHBlciBjbGFzcyBmb3IgY3JlYXRpbmcgcmVkdXggYWN0aW9uIGRlZmluaXRpb24gbWFwc1xuICovXG5leHBvcnQgY2xhc3MgQWN0aW9uTWFwIGV4dGVuZHMgRW51bSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gYWN0aW9ucyAtIGxpc3Qgb2YgYWN0aW9uIHN0cmluZ3NcbiAgICogQGV4dGVuZHMgRW51bVxuICAgKi9cbiAgY29uc3RydWN0b3IoYWN0aW9ucyA9IFtdLCBwcmVmaXggPSAnJykge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7fTtcbiAgICBhY3Rpb25zLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgIGRlZmluaXRpb25bYWN0aW9uXSA9IHByZWZpeCAhPT0gJycgPyBgJHtwcmVmaXh9LSR7YWN0aW9ufWAgOiBhY3Rpb247XG4gICAgfSk7XG4gICAgc3VwZXIoZGVmaW5pdGlvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvbiBoZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIGEgcHJlZml4ZWQgYWN0aW9uIGRlZmluaXRpb24gbWFwc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4QWN0aW9ucyhhY3Rpb25zLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXggfHwgcHJlZml4ID09PSAnJykgcmV0dXJuIGFjdGlvbnM7XG4gIGNvbnN0IGRlZmluaXRpb24gPSB7fTtcbiAgZm9yIChjb25zdCBhY3Rpb24gaW4gYWN0aW9ucykge1xuICAgIGlmIChhY3Rpb25zOjpoYXNPd25Qcm9wZXJ0eShhY3Rpb24pKSB7XG4gICAgICBkZWZpbml0aW9uW2FjdGlvbl0gPSBgJHtwcmVmaXh9LSR7YWN0aW9ufWA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRW51bShkZWZpbml0aW9uKTtcbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3JlZHV4LWhlbHBlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXZlbnQtZW1pdHRlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2Fzc2lnbicpXG4gICwgbm9ybWFsaXplT3B0cyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zJylcbiAgLCBpc0NhbGxhYmxlICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUnKVxuICAsIGNvbnRhaW5zICAgICAgPSByZXF1aXJlKCdlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zJylcblxuICAsIGQ7XG5cbmQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkc2NyLCB2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIHcsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICgoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHx8ICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpKSB7XG5cdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdHZhbHVlID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsICdjJyk7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2UnKTtcblx0XHR3ID0gY29udGFpbnMuY2FsbChkc2NyLCAndycpO1xuXHR9XG5cblx0ZGVzYyA9IHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUsIHdyaXRhYmxlOiB3IH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG5kLmdzID0gZnVuY3Rpb24gKGRzY3IsIGdldCwgc2V0LyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgb3B0aW9ucywgZGVzYztcblx0aWYgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gZ2V0O1xuXHRcdGdldCA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcblx0fVxuXHRpZiAoZ2V0ID09IG51bGwpIHtcblx0XHRnZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoZ2V0KSkge1xuXHRcdG9wdGlvbnMgPSBnZXQ7XG5cdFx0Z2V0ID0gc2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKHNldCA9PSBudWxsKSB7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKHNldCkpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsICdjJyk7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2UnKTtcblx0fVxuXG5cdGRlc2MgPSB7IGdldDogZ2V0LCBzZXQ6IHNldCwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlIH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpXG5cdD8gT2JqZWN0LmFzc2lnblxuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgb2JqO1xuXHRpZiAodHlwZW9mIGFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRvYmogPSB7IGZvbzogJ3JheicgfTtcblx0YXNzaWduKG9iaiwgeyBiYXI6ICdkd2EnIH0sIHsgdHJ6eTogJ3RyenknIH0pO1xuXHRyZXR1cm4gKG9iai5mb28gKyBvYmouYmFyICsgb2JqLnRyenkpID09PSAncmF6ZHdhdHJ6eSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoJy4uL2tleXMnKVxuICAsIHZhbHVlID0gcmVxdWlyZSgnLi4vdmFsaWQtdmFsdWUnKVxuXG4gICwgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc3QsIHNyYy8qLCDigKZzcmNuKi8pIHtcblx0dmFyIGVycm9yLCBpLCBsID0gbWF4KGFyZ3VtZW50cy5sZW5ndGgsIDIpLCBhc3NpZ247XG5cdGRlc3QgPSBPYmplY3QodmFsdWUoZGVzdCkpO1xuXHRhc3NpZ24gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dHJ5IHsgZGVzdFtrZXldID0gc3JjW2tleV07IH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZTtcblx0XHR9XG5cdH07XG5cdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0a2V5cyhzcmMpLmZvckVhY2goYXNzaWduKTtcblx0fVxuXHRpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyb3I7XG5cdHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3Qua2V5c1xuXHQ6IHJlcXVpcmUoJy4vc2hpbScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRPYmplY3Qua2V5cygncHJpbWl0aXZlJyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0cmV0dXJuIGtleXMob2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBPYmplY3Qob2JqZWN0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3Qva2V5cy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBudWxsIG9yIHVuZGVmaW5lZFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbnZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgb2JqKSB7XG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIHNyYykgb2JqW2tleV0gPSBzcmNba2V5XTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMvKiwg4oCmb3B0aW9ucyovKSB7XG5cdHZhciByZXN1bHQgPSBjcmVhdGUobnVsbCk7XG5cdGZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMgPT0gbnVsbCkgcmV0dXJuO1xuXHRcdHByb2Nlc3MoT2JqZWN0KG9wdGlvbnMpLCByZXN1bHQpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gRGVwcmVjYXRlZFxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJzsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBTdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHIgPSAncmF6ZHdhdHJ6eSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHN0ci5jb250YWlucyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKChzdHIuY29udGFpbnMoJ2R3YScpID09PSB0cnVlKSAmJiAoc3RyLmNvbnRhaW5zKCdmb28nKSA9PT0gZmFsc2UpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmRleE9mID0gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcvKiwgcG9zaXRpb24qLykge1xuXHRyZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKSA+IC0xO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvc2hpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG5cdHJldHVybiBmbjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IHsgQWN0aW9uTWFwLCBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5cbmltcG9ydCBTeW1ib2xNYXAgZnJvbSAnLi4vLi4vbGliL3N5bWJvbC1tYXAnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdyZWR1Y2VyJyxcbl0pO1xuXG5mdW5jdGlvbiBnZXRTZXR0aW5nc1JlZHVjZXIocHJlZml4KSB7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4ge307XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzIGV4dGVuZHMgUmNNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgICB0aGlzW3N5bWJvbHMucmVkdWNlcl0gPSB7XG4gICAgICBiYXNlOiBnZXRTZXR0aW5nc1JlZHVjZXIodGhpcy5wcmVmaXgpLFxuICAgIH07XG4gIH1cbiAgcmVnaXN0ZXJSZWR1Y2VyKG5hbWUsIHJlZHVjZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMucmVkdWNlcl1bbmFtZV0gPSByZWR1Y2VyO1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBjb21iaW5lUmVkdWNlcnModGhpc1tzeW1ib2xzLnJlZHVjZXJdKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zZXR0aW5ncy9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcG9zZSA9IGV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBleHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IGV4cG9ydHMuY3JlYXRlU3RvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfY3JlYXRlU3RvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3RvcmUpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VycyA9IHJlcXVpcmUoJy4vY29tYmluZVJlZHVjZXJzJyk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbWJpbmVSZWR1Y2Vycyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluZEFjdGlvbkNyZWF0b3JzKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2FwcGx5TWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseU1pZGRsZXdhcmUpO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBfY29tYmluZVJlZHVjZXJzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IF9iaW5kQWN0aW9uQ3JlYXRvcnMyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb21wb3NlID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQWN0aW9uVHlwZXMgPSB1bmRlZmluZWQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNyZWF0ZVN0b3JlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG52YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW2luaXRpYWxTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5oYW5jZXIgVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBpbml0aWFsU3RhdGU7XG4gICAgaW5pdGlhbFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cblxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8XG4gICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiZcbiAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbi8qKlxuICogR2V0cyB0aGUgYFtbUHJvdG90eXBlXV1gIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBgW1tQcm90b3R5cGVdXWAuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlKE9iamVjdCh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpKGdsb2JhbCB8fCB3aW5kb3cgfHwgdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21iaW5lUmVkdWNlcnM7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbikge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUID8gJ2luaXRpYWxTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSk7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgdmFyIHNhbml0eUVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzYW5pdHlFcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzYW5pdHlFcnJvcikge1xuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbik7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYXBwbHlNaWRkbGV3YXJlO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMltcImRlZmF1bHRcIl0uYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IGZ1bmNzW2Z1bmNzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJlc3QgPSBmdW5jcy5zbGljZSgwLCAtMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiBmdW5jdGlvbiB2KCkge1xuICAgICAgICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgICAgICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBpZiAodHlwZW9mIF9yZXQgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tcG9zZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IGJyYW5kQWN0aW9ucyBmcm9tICcuL2JyYW5kLWFjdGlvbnMnO1xuaW1wb3J0IGdldFJlZHVjZXIgZnJvbSAnLi9icmFuZC1yZWR1Y2VyJztcbmltcG9ydCBTeW1ib2xNYXAgZnJvbSAnLi4vLi4vbGliL3N5bWJvbC1tYXAnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdpbml0aWFsU3RhdGUnLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyYW5kIGV4dGVuZHMgUmNNb2R1bGUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXIsXG4gICAgc3RhdGVNYXBwZXIgPSAoc3RhdGUpID0+IHN0YXRlLmJyYW5kLFxuICAgIHByZWZpeCxcbiAgICBpZCxcbiAgICBuYW1lLFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXIsXG4gICAgICBzdGF0ZU1hcHBlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIGFjdGlvbnM6IGJyYW5kQWN0aW9ucyxcbiAgICB9KTtcbiAgICB0aGlzW3N5bWJvbHMuaW5pdGlhbFN0YXRlXSA9IHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICB9O1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRSZWR1Y2VyKHRoaXNbc3ltYm9scy5pbml0aWFsU3RhdGVdLCB0aGlzLnByZWZpeCk7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlkO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm5hbWU7XG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9icmFuZC9pbmRleC5qc1xuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3NldEJyYW5kJyxcbl0pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IGJyYW5kQWN0aW9ucyBmcm9tICcuL2JyYW5kLWFjdGlvbnMnO1xuaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZHVjZXIoaW5pdGlhbFN0YXRlLCBwcmVmaXgpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHByZWZpeEFjdGlvbnMoYnJhbmRBY3Rpb25zLCBwcmVmaXgpO1xuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG5cbiAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgYWN0aW9ucy5zZXRCcmFuZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgbmFtZTogYWN0aW9uLnBheWxvYWQubmFtZSxcbiAgICAgICAgICBpZDogYWN0aW9uLnBheWxvYWQuaWQsXG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtcmVkdWNlci5qc1xuICoqLyIsImltcG9ydCBSY01vZHVsZSBmcm9tICcuLi8uLi9saWIvcmMtbW9kdWxlJztcbmltcG9ydCBTeW1ib2xNYXAgZnJvbSAnLi4vLi4vbGliL3N5bWJvbC1tYXAnO1xuaW1wb3J0IEVudW0gZnJvbSAnLi4vLi4vbGliL2VudW0nO1xuaW1wb3J0IGxvZ2luU3RhdHVzIGZyb20gJy4vbG9naW4tc3RhdHVzJztcbmltcG9ydCBhdXRoQWN0aW9ucyBmcm9tICcuL2F1dGgtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0QXV0aFJlZHVjZXIgZnJvbSAnLi9hdXRoLXJlZHVjZXInO1xuaW1wb3J0IHsgYXV0aEV2ZW50cywgYXV0aEV2ZW50VHlwZXMgfSBmcm9tICcuL2F1dGgtZXZlbnRzJztcbmltcG9ydCB7IGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuXG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ3BsYXRmb3JtJyxcbiAgJ2VtaXR0ZXInLFxuICAnYmVmb3JlTG9nb3V0SGFuZGxlcnMnLFxuXSk7XG5cbmNvbnN0IEVOVU1TID0gbmV3IEVudW0oe1xuICBsb2dpblN0YXR1cyxcbn0pO1xuXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gQXV0aGVudGljYXRpb24gbW9kdWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dGggZXh0ZW5kcyBSY01vZHVsZSB7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWN0aW9uczogYXV0aEFjdGlvbnMsXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgcGxhdGZvcm0sXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB0aGlzW3N5bWJvbHMucGxhdGZvcm1dID0gcGxhdGZvcm07XG4gICAgdGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXSA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGxvYWQgaW5mbyBvbiBsb2dpblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpblN1Y2Nlc3MsICgpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9naW5TdWNjZXNzLFxuICAgICAgfSk7XG4gICAgICB0aGlzOjplbWl0KGF1dGhFdmVudFR5cGVzLmxvZ2luU3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0ZS5zdGF0dXMpO1xuICAgIH0pO1xuICAgIC8vIGxvZ2luRXJyb3JcbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9naW5FcnJvciwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbkVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIHVubG9hZCBpbmZvIG9uIGxvZ291dFxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dvdXRTdWNjZXNzLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ291dFN1Y2Nlc3MsXG4gICAgICB9KTtcbiAgICAgIC8vIHRoaXMuZW1pdChhdXRoRXZlbnRzLnVzZXJJbmZvQ2xlYXJlZCk7XG4gICAgfSk7XG5cbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0RXJyb3IsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9nb3V0RXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMucmVmcmVzaEVycm9yLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZnJlc2hFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGxvYWQgaW5mbyBpZiBhbHJlYWR5IGxvZ2dlZCBpblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZWRJbiA9IGF3YWl0IHBsYXRmb3JtLmxvZ2dlZEluKCk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmluaXQsXG4gICAgICAgIHN0YXR1czogbG9nZ2VkSW4gPyBsb2dpblN0YXR1cy5sb2dnZWRJbiA6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXRlLnN0YXR1cyk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRBdXRoUmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQGRlc2NyaXB0aW9uIExvZ2luIGZ1bmN0aW9uIHVzaW5nIHVzZXJuYW1lIGFuZCBwYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgbG9naW4oeyB1c2VybmFtZSwgcGFzc3dvcmQsIGV4dGVuc2lvbiwgcmVtZW1iZXIgfSkge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ2luLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgcmVtZW1iZXIsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdJbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW4oe1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgIHJlbWVtYmVyLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZGVzY3JpcHRpb24gZ2V0IE9BdXRoIHBhZ2UgdXJsXG4gICAqL1xuICBsb2dpblVybCh7IHJlZGlyZWN0VXJpLCBzdGF0ZSwgYnJhbmRJZCwgZGlzcGxheSwgcHJvbXB0IH0pIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dpblVybCh7XG4gICAgICByZWRpcmVjdFVyaSxcbiAgICAgIHN0YXRlLFxuICAgICAgYnJhbmRJZCxcbiAgICAgIGRpc3BsYXksXG4gICAgICBwcm9tcHQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcGFyc2VMb2dpblVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5wYXJzZUxvZ2luUmVkaXJlY3RVcmwodXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBBdXRob3JpemUgdXNpbmcgT0FhdXRoIGNvZGVcbiAgICovXG4gIGFzeW5jIGF1dGhvcml6ZSh7IGNvZGUsIHJlZGlyZWN0VXJpIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdJbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW4oe1xuICAgICAgY29kZSxcbiAgICAgIHJlZGlyZWN0VXJpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXN5bmNcbiAgICogQGRlc2NyaXB0aW9uIExvZyB0aGUgdXNlciBvdXRcbiAgICovXG4gIGFzeW5jIGxvZ291dCgpIHtcbiAgICAvLyBkZWFsIHdpdGggcmVtb3Zpbmcgc3Vic2NyaXB0aW9uc1xuXG4gICAgdGhpczo6ZW1pdChhdXRoRXZlbnRUeXBlcy5sb2dpblN0YXR1c0NoYW5nZWQsIGF1dGhFdmVudHMubG9nZ2luZ091dCk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbLi4udGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXV07XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB3cmFwcyB3aXRoIGFzeW5jIHNvIGV2ZW4gbm9ybWFsIGZ1bmN0aW9ucyBjYW4gYmUgYXdhaXRlZFxuICAgICAgICAvLyBUT0RPIGNhbmNlbCBsb2dvdXQgaWYgaGFuZGxlciByZXNvbHZlcyB0byBmYWxzZVxuICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4gaGFuZGxlcigpKSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgZW1pdCBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dvdXQoKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKi9cbiAgYWRkQmVmb3JlTG9nb3V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXS5hZGQoaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc10ucmVtb3ZlKGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZW1vdmVCZWZvcmVMb2dvdXRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdLnJlbW92ZShoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gYXV0aEV2ZW50cztcbiAgfVxuXG4gIGdldCBldmVudFR5cGVzKCkge1xuICAgIHJldHVybiBhdXRoRXZlbnRUeXBlcztcbiAgfVxuXG4gIGdldCBlbnVtcygpIHtcbiAgICByZXR1cm4gRU5VTVM7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2dlZEluKCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9pbmRleC5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXHJcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcclxuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xyXG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc2V0UHJvdG8gICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLCAvLyBhZnRlciBpbml0LCBiZWZvcmUgc3RhdHVzIGZyb20gcGxhdGZvcm0gaXMgZGV0ZXJtaW5lZFxuICBub3RMb2dnZWRJbjogJ05PVF9MT0dHRURfSU4nLFxuICBsb2dnaW5nSW46ICdMT0dHSU5HX0lOJyxcbiAgbG9nZ2VkSW46ICdMT0dHRURfSU4nLFxuICBsb2dnaW5nT3V0OiAnTE9HR0lOR19PVVQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvbG9naW4tc3RhdHVzLmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnbG9naW4nLFxuICAnbG9naW5TdWNjZXNzJyxcbiAgJ2xvZ2luRXJyb3InLFxuICAnbG9nb3V0JyxcbiAgJ2xvZ291dFN1Y2Nlc3MnLFxuICAnbG9nb3V0RXJyb3InLFxuICAncmVmcmVzaCcsXG4gICdyZWZyZXNoU3VjY2VzcycsXG4gICdyZWZyZXNoRXJyb3InLFxuICAnaW5pdCcsXG5dLCAnYXV0aCcpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qc1xuICoqLyIsImltcG9ydCB7IHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCBhdXRoQWN0aW9ucyBmcm9tICcuL2F1dGgtYWN0aW9ucyc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHN0YXR1czogbG9naW5TdGF0dXMucGVuZGluZyxcbiAgYXV0aEVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXV0aFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKGF1dGhBY3Rpb25zLCBwcmVmaXgpO1xuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5pbml0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHsgc3RhdHVzOiBhY3Rpb24uc3RhdHVzIH0pO1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW46XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnaW5nSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9naW5TdWNjZXNzOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbG9naW5TdGF0dXMubG9nZ2VkSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0U3VjY2VzczpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ2luRXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IGxvZ2luU3RhdHVzLm5vdExvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGFjdGlvbnMubG9nb3V0RXJyb3I6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5sb2dnZWRJbixcbiAgICAgICAgICBhdXRoRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9hdXRoLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuXG5jb25zdCBldmVudERlZmluaXRpb25zID0ge1xuICAuLi5sb2dpblN0YXR1cyxcbn07XG5cbmV4cG9ydCBjb25zdCBhdXRoRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICBsb2dpblN0YXR1c0NoYW5nZWQ6ICdMT0dJTl9TVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgYXV0aEV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvYXV0aC1ldmVudHMuanNcbiAqKi8iLCJleHBvcnQgZnVuY3Rpb24gZXh0cmFjdERhdGEobW9kZWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1hcChpdGVtID0+IGV4dHJhY3REYXRhKGl0ZW0pKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSAnXycgJiYgbW9kZWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRyYWN0RGF0YShtb2RlbFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaXN0KGZuKSB7XG4gIGxldCBmZXRjaGVkUGFnZXMgPSAwO1xuICBsZXQgdG90YWxQYWdlcyA9IDE7XG4gIGxldCBsaXN0ID0gW107XG4gIHdoaWxlIChmZXRjaGVkUGFnZXMgPCB0b3RhbFBhZ2VzKSB7XG4gICAgZmV0Y2hlZFBhZ2VzKys7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZuKHtcbiAgICAgIHBhZ2U6IGZldGNoZWRQYWdlcyxcbiAgICB9KTtcbiAgICB0b3RhbFBhZ2VzID0gZGF0YS5wYWdpbmcudG90YWxQYWdlcztcbiAgICBsaXN0ID0gbGlzdC5jb25jYXQoZGF0YS5yZWNvcmRzKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQGRlc2NyaXB0aW9uIEhlbHBlciBmdW5jdGlvbiB0byBlbWl0IGV2ZW50VHlwZWQgZXZlbnRzIGFuZCB0aGUgZXZlbnQgaXRzZWxmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbWl0KGV2ZW50VHlwZSwgZXZlbnQsIC4uLnBheWxvYWRzKSB7XG4gIHRoaXMuZW1pdChldmVudCwgLi4ucGF5bG9hZHMpO1xuICB0aGlzLmVtaXQoZXZlbnRUeXBlLCBldmVudCwgLi4ucGF5bG9hZHMpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdCk7XG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3V0aWxzLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCBnZXRTdWJzY3JpcHRpb25SZWR1Y2VyIGZyb20gJy4vc3Vic2NyaXB0aW9uLXJlZHVjZXInO1xuaW1wb3J0IHsgc3Vic2NyaXB0aW9uRXZlbnRzLCBzdWJzY3JpcHRpb25FdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpcHRpb24tZXZlbnRzJztcbmltcG9ydCBzdWJzY3JpcHRpb25TdGF0dXMgZnJvbSAnLi9zdWJzY3JpcHRpb24tc3RhdHVzJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB7IGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhdXRoJyxcbiAgJ3NkaycsXG4gICdwbGF0Zm9ybScsXG4gICdzdWJzY3JpcHRpb24nLFxuICAnZmlsdGVyQ2FjaGUnLFxuXSk7XG5cblxuY29uc3QgZmlsdGVyUmVnZXggPSB7XG4gIG1lc3NhZ2U6IC9tZXNzYWdlLXN0b3JlJC8sXG4gIHByZXNlbmNlOiAvcHJlc2VuY2UoXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlKT8kLyxcbiAgdGVsZXBob255OiAvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbiAgbGluZTogL3ByZXNlbmNlXFwvbGluZSQvLFxuICBsaW5lUHJlc2VuY2U6IC9wcmVzZW5jZVxcL2xpbmVcXC9wcmVzZW5jZShcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUpPyQvLFxuICBsaW5lVGVsZXBob255OiAvcHJlc2VuY2VcXC9saW5lXFwvcHJlc2VuY2VcXD9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUkLyxcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgbWVzc2FnZXMgZGVsaXZlcmVkIGJ5IHRoZSBzdWJzY3JpcHRvblxuICovXG5mdW5jdGlvbiBtZXNzYWdlSGFuZGxlcihtZXNzYWdlKSB7XG4gIC8vIGRldGVybWluZSB3aGljaCBldmVudHMgdGhlIG1lc3NhZ2UgZmFsbHMgdW5kZXJcbiAgY29uc3QgZXZlbnRzID0gW107XG4gIGlmIChmaWx0ZXJSZWdleC5tZXNzYWdlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbWVzc2FnZScpO1xuICB9IGVsc2UgaWYgKGZpbHRlclJlZ2V4LmxpbmUudGVzdChtZXNzYWdlLmV2ZW50KSkge1xuICAgIGV2ZW50cy5wdXNoKCdsaW5lJyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyUmVnZXgubGluZVByZXNlbmNlLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbGluZVByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LmxpbmVUZWxlcGhvbnkudGVzdChtZXNzYWdlLmV2ZW50KSkgZXZlbnRzLnB1c2goJ2xpbmVUZWxlcGhvbnknKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXJSZWdleC5wcmVzZW5jZS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSB7XG4gICAgZXZlbnRzLnB1c2goJ3ByZXNlbmNlJyk7XG4gICAgaWYgKGZpbHRlclJlZ2V4LnRlbGVwaG9ueS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSBldmVudHMucHVzaCgndGVsZXBob255Jyk7XG4gIH1cbiAgLy8gZGlzcGF0Y2ggdGhlIG1lc3NhZ2UgaW4gcmVkdXggbWFubmVyXG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5ub3RpZmljYXRpb24sXG4gICAgZXZlbnRUeXBlczogZXZlbnRzLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2UsXG4gIH0pO1xuICAvLyBlbWl0IHRoZSBtZXNzYWdlcyBhcyBldmVudHNcbiAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5ub3RpZmljYXRpb24sIHN1YnNjcmlwdGlvbkV2ZW50c1tldmVudF0sIG1lc3NhZ2UpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGNvbnN0IHBsYXRmb3JtID0gdGhpc1tzeW1ib2xzLnBsYXRmb3JtXTtcbiAgdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl0gPSB0aGlzW3N5bWJvbHMuc2RrXS5jcmVhdGVTdWJzY3JpcHRpb24oKTtcbiAgY29uc3Qgb3duZXJJZCA9IHBsYXRmb3JtLmF1dGgoKS5kYXRhKCkub3duZXJfaWQ7XG4gIGxldCBjYWNoZUtleSA9IG51bGw7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlS2V5ID0gYCR7dGhpcy5wcmVmaXh9LXN1Yi0ke293bmVySWR9YDtcbiAgICBjb25zdCBjYWNoZWRTdWJzY3JpcHRpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZFN1YnNjcmlwdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5iYXNlLnNldFN1YnNjcmlwdGlvbihKU09OLnBhcnNlKGNhY2hlZFN1YnNjcmlwdGlvbikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZmlsdGVycyk7XG5cbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMubm90aWZpY2F0aW9uLCBtZXNzYWdlID0+IHtcbiAgICB0aGlzOjptZXNzYWdlSGFuZGxlcihtZXNzYWdlKTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbW92ZVN1Y2Nlc3MsICgpID0+IHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5yZW1vdmVFcnJvciwgKCkgPT4ge1xuICAgIC8vIFRPRE9cbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbmV3U3VjY2VzcywgKCkgPT4ge1xuICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHRoaXMuYmFzZS5zdWJzY3JpcHRpb24oKSkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5zdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCksXG4gICAgfSk7XG4gICAgaWYgKG9sZFN0YXR1cyAhPT0gdGhpcy5zdGF0dXMpIHtcbiAgICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMucmVuZXdFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE8gaGFuZGxlIDQyOVxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZVN0YXR1cyxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uU3RhdHVzLm5vdFN1YnNjcmliZWQsXG4gICAgICBzdWJzY3JpcHRpb246IG51bGwsXG4gICAgfSk7XG4gICAgdGhpczo6ZW1pdChzdWJzY3JpcHRpb25FdmVudFR5cGVzLnN0YXR1c0NoYW5nZWQsIHRoaXMuc3RhdHVzKTtcbiAgICB0aGlzLmJhc2UucmVzZXQoKS5zZXRFdmVudEZpbHRlcnModGhpcy5maWx0ZXJzKS5yZWdpc3RlcigpLmNhdGNoKGUgPT4geyB9KTtcbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnN1YnNjcmliZVN1Y2Nlc3MsICgpID0+IHtcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCkpKTtcbiAgICB9XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMuc3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5iYXNlLnN1YnNjcmlwdGlvbigpLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5zdWJzY3JpYmVFcnJvciwgZXJyb3IgPT4ge1xuICAgIC8vIFRPRE9cbiAgICAvLyBoYW5kbGUgNDI5XG4gICAgLy8gaGFuZGxlIHN1YnNjcmlwdGlvbiBsaW1pdFxuICB9KTtcblxuICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJzY3JpcHRpb24gZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBvcHRpb25zLnJlZ2lzdGVyU3RvcmVIYW5kbGVyKHN0b3JlID0+IHtcbiAgICAgICAgICAvLyBzZXQgc3RvcmUgdG8gc2VsZiBmaXJzdFxuICAgICAgICAgIGhhbmRsZXIoc3RvcmUpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHN0b3JlIHdpdGggY2FjaGVkRmlsdGVyc1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgICBmaWx0ZXJzOiB0aGlzLmZpbHRlcnMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzW3N5bWJvbHMuZmlsdGVyQ2FjaGVdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczogc3Vic2NyaXB0aW9uQWN0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGF1dGgsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNkayxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzW3N5bWJvbHMuYXV0aF0gPSBhdXRoO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2RrXSA9IHNkaztcbiAgICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG5cbiAgICAvLyBjYWNoZXMgZmlsdGVycyBiZWZvcmUgcmVkdXggc3RvcmUgaXMgY3JlYXRlZFxuICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBbXTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkSW4sICgpID0+IHtcbiAgICAgIHRoaXM6OmluaXQoKTtcbiAgICB9KTtcblxuICAgIGF1dGgub24oYXV0aC5ldmVudHMubG9nZ2VkT3V0LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpblN1Y2Nlc3MsICgpID0+IHtcbiAgICAvLyAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyB9KTtcbiAgICAvLyBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgIC8vICAgaWYgKHRoaXMuYmFzZSkge1xuICAgIC8vICAgICBhd2FpdCB0aGlzLnJlc2V0KCk7XG4gICAgLy8gICB9XG4gICAgLy8gICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG4gICAgLy8gfSk7XG5cbiAgICBhdXRoLmFkZEJlZm9yZUxvZ291dEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXNldCgpO1xuICAgIH0pO1xuXG4gICAgLy8gKGFzeW5jICgpID0+IHtcbiAgICAvLyAgIGlmIChhd2FpdCBwbGF0Zm9ybS5sb2dnZWRJbigpKSB7XG4gICAgLy8gICAgIHRoaXM6OmluaXQoKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KSgpO1xuICB9XG5cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFN1YnNjcmlwdGlvblJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gIH1cblxuICBnZXQgZmlsdGVycygpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSB8fCB0aGlzLnN0YXRlLmZpbHRlcnM7XG4gIH1cblxuICBnZXQgYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl07XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBzdWJzY3JpcHRpb25FdmVudHM7XG4gIH1cblxuICBnZXQgZXZlbnRUeXBlcygpIHtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uRXZlbnRUeXBlcztcbiAgfVxuXG4gIHN1YnNjcmliZShldmVudCkge1xuICAgIC8vIFRPRE8gbm9ybWFsaXplZCBlcnJvclxuICAgIGlmICghc3Vic2NyaXB0aW9uRXZlbnRzOjpFbnVtLmhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmVudCBpcyBub3QgcmVjb2duaXplZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPT09IC0xKSB7XG4gICAgICBjb25zdCBuZXdGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLnNsaWNlKCk7XG4gICAgICBuZXdGaWx0ZXJzLnB1c2goZXZlbnQpO1xuICAgICAgaWYgKHRoaXMuYmFzZSkge1xuICAgICAgICB0aGlzLmJhc2Uuc2V0RXZlbnRGaWx0ZXJzKG5ld0ZpbHRlcnMpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlRmlsdGVycyxcbiAgICAgICAgICBmaWx0ZXJzOiBuZXdGaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXNlLnJlZ2lzdGVyKCkuY2F0Y2goKCkgPT4geyAvKiBkbyBub3RoaW5nICovIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSA9IG5ld0ZpbHRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdW5zdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAvLyBUT0RPIG5vcm1hbGl6ZWQgZXJyb3JcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkV2ZW50czo6RW51bS5oYXNWYWx1ZShldmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXZlbnQgaXMgbm90IHJlY29nbml6ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgaWR4ID0gdGhpcy5maWx0ZXJzLmluZGV4T2YoZXZlbnQpO1xuICAgIGlmICh0aGlzLmZpbHRlcnMuaW5kZXhPZihldmVudCkgPiAtMSkge1xuICAgICAgY29uc3QgbmV3RmlsdGVycyA9IHRoaXMuZmlsdGVycy5zbGljZSgpO1xuICAgICAgbmV3RmlsdGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgdGhpcy5iYXNlLnNldEV2ZW50RmlsdGVycyhuZXdGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgZmlsdGVyczogbmV3RmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBuZXdGaWx0ZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3Vic2NyaXB0aW9uU3RhdHVzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmJhc2UucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5iYXNlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIHRoaXNbc3ltYm9scy5zdWJzY3JpcHRpb25dID0gbnVsbDtcbiAgICBjb25zdCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIGlmIChvbGRTdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgfVxuXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3VwZGF0ZUZpbHRlcnMnLFxuICAnbm90aWZpY2F0aW9uJyxcblxuICAndXBkYXRlU3RhdHVzJyxcblxuXSwgJ3N1YnNjcmlwdGlvbicpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgc3Vic2NyaXB0aW9uQWN0aW9ucyBmcm9tICcuL3N1YnNjcmlwdGlvbi1hY3Rpb25zJztcbmltcG9ydCB7IHN1YnNjcmlwdGlvbkV2ZW50cyB9IGZyb20gJy4vc3Vic2NyaXB0aW9uLWV2ZW50cyc7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgY2FjaGVLZXk6IG51bGwsXG4gIGZpbHRlcnM6IFtdLFxuICBzdGF0dXM6IHN1YnNjcmlwdGlvbkV2ZW50cy5wZW5kaW5nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUmVkdWNlcihwcmVmaXgpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHByZWZpeEFjdGlvbnMoc3Vic2NyaXB0aW9uQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnVwZGF0ZVN0YXR1czpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdHVzOiBhY3Rpb24uc3RhdHVzLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBhY3Rpb25zLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBjYXNlIGFjdGlvbnMudXBkYXRlRmlsdGVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsdGVyczogYWN0aW9uLmZpbHRlcnMuc2xpY2UoKSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uU3RhdHVzIGZyb20gJy4vc3Vic2NyaXB0aW9uLXN0YXR1cyc7XG5cblxuY29uc3QgZXZlbnREZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vbWVzc2FnZS1zdG9yZScsXG4gIHByZXNlbmNlOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnLFxuICB0ZWxlcGhvbnk6ICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vfi9wcmVzZW5jZT9kZXRhaWxlZFRlbGVwaG9ueVN0YXRlPXRydWUnLFxuICBsaW5lOiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZScsXG4gIGxpbmVQcmVzZW5jZTpcbiAgICAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UvbGluZS9wcmVzZW5jZScsXG4gIGxpbmVUZWxlcGhvbnk6XG4gICAgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlL2xpbmUvcHJlc2VuY2U/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJyxcbiAgLi4uc3Vic2NyaXB0aW9uU3RhdHVzLFxufTtcblxuZXhwb3J0IGNvbnN0IHN1YnNjcmlwdGlvbkV2ZW50cyA9IG5ldyBFbnVtKGV2ZW50RGVmaW5pdGlvbik7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb24gPSB7XG4gIG5vdGlmaWNhdGlvbjogJ05PVElGSUNBVElPTicsXG4gIHN0YXR1c0NoYW5nZWQ6ICdTVEFUVVNfQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3Qgc3Vic2NyaXB0aW9uRXZlbnRUeXBlcyA9IG5ldyBFbnVtKGV2ZW50VHlwZURlZmluaXRpb24pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLWV2ZW50cy5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgcGVuZGluZzogJ1BFTkRJTkcnLFxuICBzdWJzY3JpYmVkOiAnU1VCU0NSSUJFRCcsXG4gIG5vdFN1YnNjcmliZWQ6ICdOT1RfU1VCU0NSSUJFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCB7IGV4dHJhY3REYXRhLCBmZXRjaExpc3QsIGVtaXQgfSBmcm9tICcuLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHVzZXJBY3Rpb25zIGZyb20gJy4vdXNlci1hY3Rpb25zJztcbmltcG9ydCBnZXRVc2VyUmVkdWNlciBmcm9tICcuL3VzZXItcmVkdWNlcic7XG5pbXBvcnQgeyB1c2VyRXZlbnRzLCB1c2VyRXZlbnRUeXBlcyB9IGZyb20gJy4vdXNlci1ldmVudHMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhcGknLFxuICAncGxhdGZvcm0nLFxuICAnc2V0dGluZ3MnLFxuXSk7XG5cbi8vIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbi8vICAgdGVzdDogdHJ1ZSxcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGdldFVzZXJTZXR0aW5nc1JlZHVjZXIocHJlZml4KSB7XG4vLyAgIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuLy8gICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbi8vICAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuLy8gICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbi8vICAgICAgIGRlZmF1bHQ6XG4vLyAgICAgICAgIHJldHVybiBzdGF0ZTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyB9XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxvYWRGdW5jdGlvbiAtIGFzeW5jIGxvYWRlciBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGRlc2NyaXB0aW9uIEdlbmVyaWMgZGF0YSBsb2FkaW5nIGxvZ2ljIHdpdGggZXZlbnRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWREYXRhKGRhdGFUeXBlLCBsb2FkRnVuY3Rpb24pIHtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1gXSxcbiAgfSk7XG4gIHRoaXMuZW1pdCh1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1gXSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXM6OmxvYWRGdW5jdGlvbigpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0sXG4gICAgICBwYXlsb2FkLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQodXNlckV2ZW50VHlwZXMudXNlckluZm9DaGFuZ2VkLCB1c2VyRXZlbnRzW2Bsb2FkJHtkYXRhVHlwZX1TdWNjZXNzYF0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zW2Bsb2FkJHtkYXRhVHlwZX1GYWlsZWRgXSxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQodXNlckV2ZW50c1tgbG9hZCR7ZGF0YVR5cGV9RmFpbGVkYF0pO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG4gKiBAZGVzY3JpcHRpb24gRmV0Y2ggYWNjb3VudCBpbmZvIGFuZCBleHRyYWN0IHRoZSBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5sb2FkQWNjb3VudCgpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRBY2NvdW50SW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdBY2NvdW50SW5mbycsIGV4dHJhY3RBY2NvdW50SW5mbyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RFeHRlbnNpb25JbmZvKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubG9hZEV4dGVuc2lvbkluZm8oKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRXh0ZW5zaW9uSW5mbygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdFeHRlbnNpb25JbmZvJywgZXh0cmFjdEV4dGVuc2lvbkluZm8pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RGlhbGluZ1BsYW5zKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmFjY291bnQoKS5saXN0RGlhbGluZ1BsYW5zKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWREaWFsaW5nUGxhbnMoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnRGlhbGluZ1BsYW5zJywgZXh0cmFjdERpYWxpbmdQbGFucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RQaG9uZU51bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZXh0ZW5zaW9uKCkubGlzdEV4dGVuc2lvblBob25lTnVtYmVycyhvcHRpb25zKVxuICApKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkUGhvbmVOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ1Bob25lTnVtYmVycycsIGV4dHJhY3RQaG9uZU51bWJlcnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0Rm9yd2FyZGluZ051bWJlcnMoKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzOjpmZXRjaExpc3Qob3B0aW9ucyA9PiAoXG4gICAgdGhpc1tzeW1ib2xzLmFwaV0uZm9yd2FyZGluZ051bWJlcnMoKS5saXN0RXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlcnMob3B0aW9ucylcbiAgKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEZvcndhcmRpbmdOdW1iZXJzKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ0ZvcndhcmRpbmdOdW1iZXJzJywgZXh0cmFjdEZvcndhcmRpbmdOdW1iZXJzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEJsb2NrZWROdW1iZXJzKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmJsb2NrZWROdW1iZXJzKCkubGlzdEJsb2NrZWROdW1iZXJzKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCbG9ja2VkTnVtYmVycygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdCbG9ja2VkTnVtYmVycycsIGV4dHJhY3RCbG9ja2VkTnVtYmVycyk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSW5mbygpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzOjpsb2FkQWNjb3VudEluZm8oKSxcbiAgICAgIHRoaXM6OmxvYWRFeHRlbnNpb25JbmZvKCksXG4gICAgICB0aGlzOjpsb2FkRGlhbGluZ1BsYW5zKCksXG4gICAgICB0aGlzOjpsb2FkUGhvbmVOdW1iZXJzKCksXG4gICAgICB0aGlzOjpsb2FkRm9yd2FyZGluZ051bWJlcnMoKSxcbiAgICAgIHRoaXM6OmxvYWRCbG9ja2VkTnVtYmVycygpLFxuICAgIF0pO1xuICAgIC8vIHRoaXMuZW1pdCh1c2VyRXZlbnRzLnVzZXJJbmZvTG9hZGVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE8gc2VuZCBlcnJvciBvdXRcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBVc2VyXG4gKiBAZXh0ZW5kcyBSY01vZHVsZVxuICogQGRlZmF1bHRcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlciBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiB1c2VyQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhcGksXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzLFxuICAgIH0gPSBvcHRpb25zO1xuICAgIHRoaXNbc3ltYm9scy5hcGldID0gYXBpO1xuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuc2V0dGluZ3NdID0gc2V0dGluZ3M7XG5cbiAgICAvLyBzZXR0aW5ncy5yZWdpc3RlclJlZHVjZXIoJ3VzZXInLCBnZXRVc2VyU2V0dGluZ3NSZWR1Y2VyKCkpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpczo6bG9hZEluZm8oKTtcbiAgICB9KTtcbiAgICAvLyB1bmxvYWQgaW5mbyBvbiBsb2dvdXRcbiAgICBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9nb3V0U3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jbGVhclVzZXJJbmZvLFxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLmVtaXQodXNlckV2ZW50cy51c2VySW5mb0NsZWFyZWQpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBsb2FkIGluZm8gaWYgYWxyZWFkeSBsb2dnZWQgaW5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF3YWl0IHBsYXRmb3JtLmxvZ2dlZEluKCkpIHtcbiAgICAgICAgYXdhaXQgdGhpczo6bG9hZEluZm8oKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogVE9ETzpcbiAgICAgKiAgIDEuIERpYWxpbmcgUGxhbiBDaGVja2luZ1xuICAgICAqL1xuICB9XG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRVc2VyUmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB1c2VyRXZlbnRzO1xuICB9XG5cbiAgZ2V0IGV2ZW50VHlwZXMoKSB7XG4gICAgcmV0dXJuIHVzZXJFdmVudFR5cGVzO1xuICB9XG5cbiAgZ2V0IGRpcmVjdE51bWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbHRlcihuID0+IG4udXNhZ2VUeXBlID09PSAnRGlyZWN0TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgbWFpbkNvbXBhbnlOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbmQobiA9PiBuLnVzYWdlVHlwZSA9PT0gJ01haW5Db21wYW55TnVtYmVyJyk7XG4gIH1cblxuICBnZXQgZGlhbGluZ1BsYW5zKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRpYWxpbmdQbGFucztcbiAgfVxuXG4gIGdldCBleHRlbnNpb25OdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXh0ZW5zaW9uSW5mby5leHRlbnNpb25OdW1iZXI7XG4gIH1cblxuICBnZXQgc21zTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5waG9uZU51bWJlcnMuZmlsdGVyKG4gPT4gbi5mZWF0dXJlcy5pbmRleE9mKCdTbXNTZW5kZXInKSA+IC0xKTtcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICdjbGVhclVzZXJJbmZvJyxcblxuICAnbG9hZEFjY291bnRJbmZvJyxcbiAgJ2xvYWRBY2NvdW50SW5mb1N1Y2Nlc3MnLFxuICAnbG9hZEFjY291bnRJbmZvRmFpbGVkJyxcblxuICAnbG9hZEV4dGVuc2lvbkluZm8nLFxuICAnbG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzJyxcbiAgJ2xvYWRFeHRlbnNpb25JbmZvRmFpbGVkJyxcblxuICAnbG9hZERpYWxpbmdQbGFucycsXG4gICdsb2FkRGlhbGluZ1BsYW5zU3VjY2VzcycsXG4gICdsb2FkRGlhbGluZ1BsYW5zRmFpbGVkJyxcblxuICAnbG9hZFBob25lTnVtYmVycycsXG4gICdsb2FkUGhvbmVOdW1iZXJzU3VjY2VzcycsXG4gICdsb2FkUGhvbmVOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzJyxcbiAgJ2xvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkJyxcblxuICAnbG9hZEJsb2NrZWROdW1iZXJzJyxcbiAgJ2xvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkJyxcblxuXSwgJ3VzZXInKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgdXNlckFjdGlvbnMgZnJvbSAnLi91c2VyLWFjdGlvbnMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGFjY291bnRJbmZvOiBudWxsLFxuICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuXG4gIGV4dGVuc2lvbkluZm86IG51bGwsXG4gIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgZXh0ZW5zaW9uSW5mb0Vycm9yOiBudWxsLFxuXG4gIGRpYWxpbmdQbGFuczogW10sXG4gIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICBkaWFsaW5nUGxhbnNFcnJvcjogbnVsbCxcblxuICBwaG9uZU51bWJlcnM6IFtdLFxuICBwaG9uZU51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgcGhvbmVOdW1iZXJzRXJyb3I6IG51bGwsXG5cbiAgZm9yd2FyZGluZ051bWJlcnM6IFtdLFxuICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICBmb3J3YXJkaW5nTnVtYmVyc0Vycm9yOiBudWxsLFxuXG4gIGJsb2NrZWROdW1iZXJzOiBbXSxcbiAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgYmxvY2tlZE51bWJlcnNFcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVzZXJSZWR1Y2VyKHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyh1c2VyQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICAvLyBhY2NvdW50IGluZm9cbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkQWNjb3VudEluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFjY291bnRJbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGFjY291bnRJbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBhY2NvdW50SW5mb0Vycm9yOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEFjY291bnRJbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjb3VudEluZm9FcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGV4dGVuc2lvbiBpbmZvXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbkluZm9FcnJvcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRFeHRlbnNpb25JbmZvRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb25JbmZvRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBkaWFsaW5nIHBsYW5zXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZERpYWxpbmdQbGFuczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlhbGluZ1BsYW5zTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWREaWFsaW5nUGxhbnNTdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaWFsaW5nUGxhbnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZGlhbGluZ1BsYW5zRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG5cbiAgICAgIC8vIHBob25lIG51bWJlcnNcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkUGhvbmVOdW1iZXJzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwaG9uZU51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZFBob25lTnVtYmVyc0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGhvbmVOdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBwaG9uZU51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGZvcndhcmRpbmcgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRGb3J3YXJkaW5nTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEZvcndhcmRpbmdOdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3J3YXJkaW5nTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGJsb2NrZWQgbnVtYmVyc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRCbG9ja2VkTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEJsb2NrZWROdW1iZXJzU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb24ubG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBibG9ja2VkTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNFcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgYWN0aW9uLmNsZWFyVXNlckluZm86XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgICAgKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvdXNlci91c2VyLXJlZHVjZXIuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5cbmNvbnN0IGV2ZW50RGVmaW5pdGlvbnMgPSB7XG4gIHVzZXJJbmZvTG9hZGVkOiAnVVNFUl9JTkZPX0xPQURFRCcsXG4gIHVzZXJJbmZvQ2xlYXJlZDogJ1VTRVJfSU5GT19DTEVBUkVEJyxcblxuICBsb2FkQWNjb3VudEluZm86ICdMT0FEX0FDQ09VTlRfSU5GTycsXG4gIGxvYWRBY2NvdW50SW5mb1N1Y2Nlc3M6ICdMT0FEX0FDQ09VTlRfSU5GT19TVUNDRVNTJyxcbiAgbG9hZEFjY291bnRJbmZvRmFpbGVkOiAnTE9BRF9BQ0NPVU5UX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRXh0ZW5zaW9uSW5mbzogJ0xPQURfRVhURU5TSU9OX0lORk8nLFxuICBsb2FkRXh0ZW5zaW9uSW5mb1N1Y2Nlc3M6ICdMT0FEX0VYVEVOU0lPTl9JTkZPX1NVQ0NFU1MnLFxuICBsb2FkRXh0ZW5zaW9uSW5mb0ZhaWxlZDogJ0xPQURfRVhURU5TSU9OX0lORk9fRkFJTEVEJyxcblxuICBsb2FkRGlhbGluZ1BsYW5zOiAnTE9BRF9ESUFMSU5HX1BMQU5TJyxcbiAgbG9hZERpYWxpbmdQbGFuc1N1Y2Nlc3M6ICdMT0FEX0RJQUxJTkdfUExBTlNfU1VDQ0VTUycsXG4gIGxvYWREaWFsaW5nUGxhbnNGYWlsZWQ6ICdMT0FEX0RJQUxJTkdfUExBTlNfRkFJTEVEJyxcblxuICBsb2FkUGhvbmVOdW1iZXJzOiAnTE9BRF9QSE9ORV9OVU1CRVJTJyxcbiAgbG9hZFBob25lTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX1BIT05FX05VTUJFUlNfU1VDQ0VTUycsXG4gIGxvYWRQaG9uZU51bWJlcnNGYWlsZWQ6ICdMT0FEX1BIT05FX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkRm9yd2FyZGluZ051bWJlcnM6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSUycsXG4gIGxvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0ZPUldBUkRJTkdfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEZvcndhcmRpbmdOdW1iZXJzRmFpbGVkOiAnTE9BRF9GT1JXQVJESU5HX05VTUJFUlNfRkFJTEVEJyxcblxuICBsb2FkQmxvY2tlZE51bWJlcnM6ICdMT0FEX0JMT0NLRURfTlVNQkVSUycsXG4gIGxvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3M6ICdMT0FEX0JMT0NLRURfTlVNQkVSU19TVUNDRVNTJyxcbiAgbG9hZEJsb2NrZWROdW1iZXJzRmFpbGVkOiAnTE9BRF9CTE9DS0VEX05VTUJFUlNfRkFJTEVEJyxcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VyRXZlbnRzID0gbmV3IEVudW0oZXZlbnREZWZpbml0aW9ucyk7XG5cbmNvbnN0IGV2ZW50VHlwZURlZmluaXRpb25zID0ge1xuICB1c2VySW5mb0NoYW5nZWQ6ICdVU0VSX0lORk9fQ0hBTkdFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgdXNlckV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9ucyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvdXNlci1ldmVudHMuanNcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4uLy4uL2xpYi9zeW1ib2wtbWFwJztcbmltcG9ydCBFbnVtIGZyb20gJy4uLy4uL2xpYi9lbnVtJztcbmltcG9ydCB3ZWJwaG9uZUFjdGlvbnMgZnJvbSAnLi93ZWJwaG9uZS1hY3Rpb25zJztcbmltcG9ydCBjYWxsQWN0aW9ucyBmcm9tICcuL2NhbGwtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL3dlYnBob25lLXJlZHVjZXInO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgUmluZ0NlbnRyYWxXZWJwaG9uZSBmcm9tICdyaW5nY2VudHJhbC13ZWItcGhvbmUnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5pbXBvcnQgY2FsbFN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy9jYWxsLXN0YXR1cyc7XG5cbmltcG9ydCB7IGF1dGhFdmVudHMsIGF1dGhFdmVudFR5cGVzIH0gZnJvbSAnLi4vYXV0aC9hdXRoLWV2ZW50cyc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2FwaScsXG4gICdhdXRoJyxcbiAgJ3BsYXRmb3JtJyxcbiAgJ2VtaXR0ZXInLFxuICAnc2V0dGluZ3MnLFxuICAncGhvbmVJbnN0YW5jZScsXG5dKTtcblxuY29uc3QgRU5VTVMgPSBuZXcgRW51bSh7XG4gIHdlYnBob25lU3RhdHVzLFxuICBjYWxsU3RhdHVzLFxufSk7XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXRQaG9uZUluc3RhbmNlKCkge1xuICBjb25zdCBpbmZvID0gYXdhaXQgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXVxuICAgIC5wb3N0KCcvY2xpZW50LWluZm8vc2lwLXByb3Zpc2lvbicsIHtcbiAgICAgIHNpcEluZm86IFt7IHRyYW5zcG9ydDogJ1dTUycgfV0sXG4gICAgfSlcbiAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSk7XG4gIHJldHVybiBuZXcgUmluZ0NlbnRyYWxXZWJwaG9uZShpbmZvLCB7XG4gICAgbG9nTGV2ZWw6IDAsXG4gICAgYXVkaW9IZWxwZXI6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlY29yZChmbGFnID0gdHJ1ZSkge1xuICBpZiAoIWZsYWcpIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnN0b3BSZWNvcmQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnN0b3BSZWNvcmQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uc3RhcnRSZWNvcmQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnJlY29yZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbXV0ZShmbGFnID0gdHJ1ZSkge1xuICBpZiAoIWZsYWcpIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnVubXV0ZSgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMudW5tdXRlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLm11dGUoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLm11dGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhvbGQoZmxhZyA9IHRydWUpIHtcbiAgaWYgKCFmbGFnKSB7XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi51bmhvbGQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnVuaG9sZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5ob2xkKCk7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICB0eXBlOiBjYWxsQWN0aW9ucy5ob2xkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJrKCkge1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnBhcmsoKTtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uOiB7XG4gICAgICB0eXBlOiBjYWxsQWN0aW9ucy5wYXJrLFxuICAgIH0sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cmFuc2ZlcihudW1iZXIpIHtcbiAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi50cmFuc2ZlcihudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnRyYW5zZmVyLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBudW1iZXIsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmbGlwKG51bWJlcikge1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmZsaXAobnVtYmVyKTtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uOiB7XG4gICAgICB0eXBlOiBjYWxsQWN0aW9ucy5mbGlwLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBudW1iZXIsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkdG1mKG51bWJlcikge1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmR0bWYobnVtYmVyKTtcbiAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgb3BlcmF0aW9uOiB7XG4gICAgICB0eXBlOiBjYWxsQWN0aW9ucy5kdG1mLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBudW1iZXIsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvcGVyYXRpb25zKG5hbWUsIC4uLmFyZ3MpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHsgcmVjb3JkLCBtdXRlLCBob2xkLCBwYXJrLCB0cmFuc2ZlciwgZmxpcCwgZHRtZiB9O1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICB0cnkge1xuICAgIGF3YWl0IGFjdGlvbnNbbmFtZV0uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gVE9ETzogbmVlZGVkP1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYnBob25lIGV4dGVuZHMgUmNNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGFjdGlvbnM6IHdlYnBob25lQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBhcGksXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzLFxuICAgICAgYXV0aCxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzW3N5bWJvbHMuYXBpXSA9IGFwaTtcbiAgICB0aGlzW3N5bWJvbHMucGxhdGZvcm1dID0gcGxhdGZvcm07XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB0aGlzW3N5bWJvbHMuc2V0dGluZ3NdID0gc2V0dGluZ3M7XG4gICAgdGhpc1tzeW1ib2xzLmF1dGhdID0gYXV0aDtcblxuICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgICAvLyBUT0RPOiBjb21tZW50ZWQgb3V0IHVudGlsIHNldHRpbmcgbW9kdWxlIGNvbXBsZXRlZFxuICAgIC8vIHNldHRpbmdzLnJlZ2lzdGVyUmVkdWNlcignd2VicGhvbmUnLCBnZXRXZWJwaG9uZVJlZHVjZXIoKSlcbiAgICB0aGlzW3N5bWJvbHMuYXV0aF0ub24oYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0gPSBhd2FpdCB0aGlzOjppbml0UGhvbmVJbnN0YW5jZSgpO1xuICAgICAgdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdLnVzZXJBZ2VudC5vbigncmVnaXN0ZXJlZCcsICgpID0+IHtcbiAgICAgICAgLy8gc2lwIHdpbGwgZmlyZSBtdWx0aXBsZSByZWdpc3RlcmVkIGV2ZW50cywgb25seSBkaXNwYXRjaCBvbmUgcmVnaXN0ZXIgYWN0aW9uIHRvIHN0YXRlLlxuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIGlzUmVnaXN0ZXJlZCBzdGF0ZSBuZWVkZWQgdG8gYmUgc3RvcmUgYXMgaW5zdGFuY2UgdmFyaWFibGVcbiAgICAgICAgLy8gICAgICAgb3IganVzdCBjaGVjayBzdG9yZSBzdGF0ZVxuICAgICAgICBpZiAoIXRoaXMuaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMucmVnaXN0ZXJTdWNjZXNzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdLnVzZXJBZ2VudC5pc1JlZ2lzdGVyZWQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdLnVzZXJBZ2VudC5vbigndW5yZWdpc3RlcmVkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaXNSZWdpc3RlcmVkKCk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51bnJlZ2lzdGVyLFxuICAgICAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuY2xlYXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3JlZ2lzdHJhdGlvbkZhaWxlZCcsIChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMucmVnaXN0ZXJFcnJvcixcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ2ludml0ZScsIChzZXNzaW9uKSA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmxpc3RlblNlc3Npb25FdmVudHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsSW5jb21pbmcsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IHNlc3Npb24ucmVtb3RlSWRlbnRpdHksXG4gICAgICAgICAgICBsb2NhbElkZW50aXR5OiBzZXNzaW9uLmxvY2FsSWRlbnRpdHksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRSZWR1Y2VyKHRoaXMucHJlZml4KTtcbiAgfVxuXG4gIGdldCBlbnVtcygpIHtcbiAgICByZXR1cm4gRU5VTVM7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHBob25lIGNhbGwsIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgaW4gcmVnaXN0ZXJTdWNjZXNzIHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b051bWJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21OdW1iZXJdXG4gICAqIEByZXR1cm4ge1Nlc3Npb259XG4gICAqL1xuICBhc3luYyBjYWxsKHsgdG9OdW1iZXIsIGZyb21OdW1iZXIsIG1lZGlhIH0pIHtcbiAgICAvLyBDaGVjayBzdGF0dXNcbiAgICBpZiAoIXRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ25vdCByZWdpc3RlcmVkJyk7XG4gICAgfVxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGwsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIHRvTnVtYmVyLFxuICAgICAgICBmcm9tTnVtYmVyLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdLnVzZXJBZ2VudC5pbnZpdGUodG9OdW1iZXIsIHtcbiAgICAgIG1lZGlhOiB7XG4gICAgICAgIHJlbmRlcjogbWVkaWEsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuU2Vzc2lvbkV2ZW50cygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYSBwaG9uZSBjYWxsLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gY2FsbCBpcyBpbmNvbWluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWVkaWEsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmluZ2NlbnRyYWwvcmluZ2NlbnRyYWwtd2ViLXBob25lI2FjY2VwdGluZy1pbmNvbWluZy1jYWxsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBhY2NlcHQobWVkaWEpIHtcbiAgICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmFjY2VwdChtZWRpYSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGJ5ZSgpIHtcbiAgICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnRlcm1pbmF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZWNvcmQoZmxhZykge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAncmVjb3JkJywgZmxhZyk7XG4gIH1cblxuICBhc3luYyBtdXRlKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ211dGUnLCBmbGFnKTtcbiAgfVxuXG4gIGFzeW5jIGhvbGQoZmxhZykge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnaG9sZCcsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgcGFyayhmbGFnKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdwYXJrJywgZmxhZyk7XG4gIH1cblxuICBhc3luYyB0cmFuc2ZlcihudW1iZXIpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ3RyYW5zZmVyJywgbnVtYmVyKTtcbiAgfVxuXG4gIGFzeW5jIGZsaXAobnVtYmVyKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdmbGlwJywgbnVtYmVyKTtcbiAgfVxuXG4gIGFzeW5jIGR0bWYobnVtYmVyKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdkdG1mJywgbnVtYmVyKTtcbiAgfVxuXG4gIGxvYWRSaW5nQXVkaW8oeyBpbmNvbWluZywgb3V0Z29pbmcgfSkge1xuICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuYXVkaW9IZWxwZXIubG9hZEF1ZGlvKHtcbiAgICAgIGluY29taW5nLFxuICAgICAgb3V0Z29pbmcsXG4gICAgfSk7XG4gIH1cblxuICBjaGVja1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnNlc3Npb25FcnJvcixcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgbGlzdGVuIHNlc3Npb24gZXZlbnRzXG4gICAqL1xuICBsaXN0ZW5TZXNzaW9uRXZlbnRzKCkge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2FjY2VwdGVkJywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyBhY2NlcHRlZCBldmVudCBmb3Igb3V0Ym91bmQgY2FsbCB3aWxsIHJldHVybmUgYSBpbmNvbWluZ1Jlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbENvbm5lY3QsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IHJlc3BvbnNlLnRvLFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogcmVzcG9uc2UuZnJvbSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIC8vIGFjY2VwdGVkIGV2ZW50IGZvciBpbmJvdW5kIGNhbGwgd2lsbCBvbmx5IGNvbnRhaW4gYSByb3cgc2lwIGRhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsQWNjZXB0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbGwgc2l0dWF0aW9uIGFib3V0IGNhbGwgdGVybWluYXRlZCBleGNlcHQgJ2NhbGwgY2FuY2VsJ1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFbmQsXG4gICAgICAgIGVycm9yOiBjYXVzZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgfSk7XG4gICAgLy8gd2hlbiB3ZSBjYWxsIG91dCBhbmQgY2FuY2VsIHRoZSBwaG9uZSBjYWxsXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5vbignY2FuY2VsJywgKHJlc3BvbnNlLCBjYXVzZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgICBlcnJvcjogY2F1c2UsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgIH0pO1xuICAgIC8vIHNob3VsZCBub3QgbmVlZFxuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2J5ZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9pbmRleC5qc1xuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3JlZ2lzdGVyJyxcbiAgJ3JlZ2lzdGVyU3VjY2VzcycsXG4gICdyZWdpc3RlckVycm9yJyxcbiAgJ3VucmVnaXN0ZXInLFxuXG4gIC8vIG91dGJvdW5kIGNhbGxcbiAgJ2NhbGwnLFxuICAnY2FsbENvbm5lY3QnLFxuICAvLyBpbmJvdW5kIGNhbGxcbiAgJ2NhbGxBY2NlcHQnLFxuICAnY2FsbEluY29taW5nJyxcblxuICAnY2FsbEVuZCcsXG4gICdjYWxsRXJyb3InLFxuICAnY2FsbE9wZXJhdGlvbicsXG4gIC8vIG5vIGFjdGl2ZSBzZXNzaW9uXG4gICdzZXNzaW9uRXJyb3InLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gIC8vIG9wZXJhdGlvbmFsIGVycm9yXG4gICdlcnJvcicsXG4gIC8vIHVucmVnaXN0ZXIsIGNsZWFyIG9wZXJhdGlvbmFsIHN0YXRlXG4gICdjbGVhcicsXG4gIC8vIG9wZXJhdGlvblxuICAnZmxpcCcsXG4gICdyZWNvcmQnLFxuICAnc3RvcFJlY29yZCcsXG4gICdob2xkJyxcbiAgJ3VuaG9sZCcsXG4gICdtdXRlJyxcbiAgJ3VubXV0ZScsXG4gICdwYXJrJyxcbiAgJ3RyYW5zZmVyJyxcbiAgJ2ZvcndhcmQnLFxuICAnZHRtZicsXG5dKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHdlYnBob25lQWN0aW9ucyBmcm9tICcuL3dlYnBob25lLWFjdGlvbnMnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5cbmltcG9ydCBjYWxsUmVkdWNlciBmcm9tICcuL2NhbGwtcmVkdWNlcic7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgc3RhdHVzOiB3ZWJwaG9uZVN0YXR1cy5wcmVSZWdpc3RlcixcbiAgLy8gYXNzaWduIGZyb20gVUlcbiAgdG9OdW1iZXI6ICcnLFxuICBmcm9tTnVtYmVyOiAnJyxcbiAgLy8gc2lwIGluZm8gcmV0dXJuIGZyb20gc2lwIHNlcnZlclxuICByZW1vdGVJZGVudGl0eTogbnVsbCxcbiAgbG9jYWxJZGVudGl0eTogbnVsbCxcbiAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcigpLFxuICBlcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKHdlYnBob25lQWN0aW9ucywgcHJlZml4KTtcblxuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5yZWdpc3RlclN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLnJlZ2lzdGVyRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMudW5yZWdpc3RlcjpcbiAgICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0aW5nLFxuICAgICAgICAgIHRvTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC50b051bWJlcixcbiAgICAgICAgICBmcm9tTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5mcm9tTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsSW5jb21pbmc6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5yZW1vdGVJZGVudGl0eSxcbiAgICAgICAgICBsb2NhbElkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5sb2NhbElkZW50aXR5LFxuICAgICAgICB9KTtcbiAgICAgIC8vIFRPRE86IHVwZGF0ZSBmcm9tTnVtYmVyLCB0b051bWJlclxuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxDb25uZWN0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0ZWQsXG4gICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgIGxvY2FsSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLmxvY2FsSWRlbnRpdHksXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxBY2NlcHQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbENvbm5lY3RlZCxcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVuZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVycm9yOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbE9wZXJhdGlvbjpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcihzdGF0ZS5vcGVyYXRpb24sIGFjdGlvbi5vcGVyYXRpb24pLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5zZXNzaW9uRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHtcbiAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvd2VicGhvbmUtcmVkdWNlci5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgLy8gRm9yIHJlZ2lzdGVyaW5nXG4gIHByZVJlZ2lzdGVyOiAnUFJFX1JFR0lTVEVSJyxcbiAgcmVnaXN0ZXJTdWNjZXNzZWQ6ICdSRUdJU1RFUl9TVUNDRVNTRUQnLFxuICByZWdpc3RlckZhaWxlZDogJ1JFR0lTVEVSX0ZBSUxFRCcsXG4gIC8vIEZvciBjYWxsb3V0IGFuZCBhY3RpdmUgY2FsbFxuICBjYWxsQ29ubmVjdGluZzogJ0NBTExfQ09OTkVDVElORycsXG4gIGNhbGxDb25uZWN0ZWQ6ICdDQUxMX0NPTk5FQ1RFRCcsXG4gIGNhbGxGYWlsZWQ6ICdDQUxMX0ZBSUxFRCcsXG4gIC8vIEZvciBpbmNvbWluZyBjYWxsXG4gIGNhbGxJbmNvbWluZzogJ0NBTExfSU5DT01JTkcnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9lbnVtcy93ZWJwaG9uZS1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgY2FsbEFjdGlvbnMgZnJvbSAnLi9jYWxsLWFjdGlvbnMnO1xuaW1wb3J0IGNhbGxTdGF0dXMgZnJvbSAnLi4vLi4vZW51bXMvY2FsbC1zdGF0dXMnO1xuXG5mdW5jdGlvbiBjb250YWluKGFyciwgZWxlKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZihlbGUpID4gLTE7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGVsZSkge1xuICBpZiAoY29udGFpbihhcnIsIGVsZSkpIHtcbiAgICBhcnIuc3BsaWNlKGFyci5pbmRleE9mKGVsZSksIDEpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgLy8gb3BlcmF0aW9ucyB3aGljaCBpcyBlbmFibGVcbiAgc3RhdHVzOiBbXSxcbiAgLy8gc29tZSBvcGVyYXRpb25zIHdpbGwgZGlzYWJsZSBhbm90aGVyLCBzdWNoIGFzICdob2xkJ1xuICBkaXNhYmxlZDogW10sXG4gIC8vIHNvbWUgb3BlcmF0aW9ucyBoYXZlIGluZm9tYXRpb24gbmVlZCB0byBiZSBzdG9yZWRcbiAgdHJhbnNmZXJUYWdldDogbnVsbCxcbiAgZmxpcFRhcmdldDogbnVsbCxcbiAgZHRtZk51bWJlcjogbnVsbCxcbiAgLy8gb3BlcmF0aW9uIGVycm9yXG4gIGVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICBjYXNlIGNhbGxBY3Rpb25zLmVycm9yOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmNsZWFyOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5yZWNvcmQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5yZWNvcmRpbmcpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuc3RvcFJlY29yZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHJlbW92ZShzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMubXV0ZTpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLm11dGVkKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLm11dGVkKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMudW5tdXRlOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogcmVtb3ZlKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5tdXRlZCksXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5ob2xkaW5nKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogWydwYXJrJywgJ3JlY29yZCddLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy51bmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiByZW1vdmUoc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogW10sXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnBhcms6XG4gICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWxsX3BhcmtpbmdcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnBhcmtlcikgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZXIpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy50cmFuc2ZlcjpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnRyYW5zZmVyZWQpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMudHJhbnNmZXJlZCksXG4gICAgICAgIHRyYW5zZmVyVGFnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZmxpcDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmZsaXApID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMuZmxpcCksXG4gICAgICAgIGZsaXBUYXJnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZHRtZjpcbiAgICAgIC8vIFRPRE86IGNsYXJpZnkgcGFyayBhY3Rpb25cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZWQpLFxuICAgICAgICBkdG1mTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5udW1iZXIsXG4gICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vbGliL2VudW0nO1xuXG5jb25zdCBkZWZpbml0aW9uID0ge1xuICBmbGlwOiAnRkxJUEVEJyxcbiAgcmVjb3JkaW5nOiAnUkVDT1JESU5HJyxcbiAgaG9sZGluZzogJ0hPTERJTkcnLFxuICBtdXRlZDogJ01VVEVEJyxcbiAgcGFya2VkOiAnUEFSS0VEJyxcbiAgdHJhbnNmZXJlZDogJ1RSQU5TRkVSRUQnLFxuICBmb3J3YXJkZWQ6ICdGT1dBUkRFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzXG4gKiovIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ3NpcC5qcyddLCBmdW5jdGlvbihTSVApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KFNJUCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NpcC5qcycpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzOyAvL0VTNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuUmluZ0NlbnRyYWwgPSByb290LlJpbmdDZW50cmFsIHx8IHt9O1xuICAgICAgICByb290LlJpbmdDZW50cmFsLldlYlBob25lID0gZmFjdG9yeShyb290LlNJUCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTSVApIHtcblxuICAgIHZhciBtZXNzYWdlcyA9IHtcbiAgICAgICAgcGFyazoge3JlcWlkOiAxLCBjb21tYW5kOiAnY2FsbHBhcmsnfSxcbiAgICAgICAgc3RhcnRSZWNvcmQ6IHtyZXFpZDogMiwgY29tbWFuZDogJ3N0YXJ0Y2FsbHJlY29yZCd9LFxuICAgICAgICBzdG9wUmVjb3JkOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdzdG9wY2FsbHJlY29yZCd9LFxuICAgICAgICBmbGlwOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdjYWxsZmxpcCcsIHRhcmdldDogJyd9LFxuICAgICAgICBtb25pdG9yOiB7cmVxaWQ6IDQsIGNvbW1hbmQ6ICdtb25pdG9yJ30sXG4gICAgICAgIGJhcmdlOiB7cmVxaWQ6IDUsIGNvbW1hbmQ6ICdiYXJnZSd9LFxuICAgICAgICB3aGlzcGVyOiB7cmVxaWQ6IDYsIGNvbW1hbmQ6ICd3aGlzcGVyJ30sXG4gICAgICAgIHRha2VvdmVyOiB7cmVxaWQ6IDcsIGNvbW1hbmQ6ICd0YWtlb3Zlcid9XG4gICAgfTtcblxuICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSAxMDAwMDtcblxuICAgIGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsYXkobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICAgICAgICBzcmMgPSBzcmMgfHwge307XG4gICAgICAgIGRzdCA9IGRzdCB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvSGVscGVyKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9lbmFibGVkID0gISFvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMubG9hZEF1ZGlvKG9wdGlvbnMpO1xuXG4gICAgfVxuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl9wbGF5U291bmQgPSBmdW5jdGlvbih1cmwsIHZhbCwgdm9sdW1lKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8ICF1cmwpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fYXVkaW9bdXJsXSkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLmxvb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0udm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0ucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0ucGxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUubG9hZEF1ZGlvID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbmNvbWluZyA9IG9wdGlvbnMuaW5jb21pbmc7XG4gICAgICAgIHRoaXMuX291dGdvaW5nID0gb3B0aW9ucy5vdXRnb2luZztcbiAgICAgICAgdGhpcy5fYXVkaW8gPSB7fTtcbiAgICB9XG5cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24odm9sdW1lKSB7XG4gICAgICAgIGlmICh2b2x1bWUgPCAwKSB7IHZvbHVtZSA9IDA7IH1cbiAgICAgICAgaWYgKHZvbHVtZSA+IDEpIHsgdm9sdW1lID0gMTsgfVxuICAgICAgICB0aGlzLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgZm9yICh2YXIgdXJsIGluIHRoaXMuX2F1ZGlvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXVkaW8uaGFzT3duUHJvcGVydHkodXJsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0udm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlJbmNvbWluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX2luY29taW5nLCB2YWwsICh0aGlzLnZvbHVtZSB8fCAwLjUpKTtcbiAgICB9O1xuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlPdXRnb2luZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX291dGdvaW5nLCB2YWwsICh0aGlzLnZvbHVtZSB8fCAxKSk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZ0RhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnV1aWRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcEtleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwTmFtZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwVmVyc2lvbl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXVkaW9IZWxwZXJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9uU2Vzc2lvbl0gZmlyZWQgZWFjaCB0aW1lIFVzZXJBZ2VudCBzdGFydHMgd29ya2luZyB3aXRoIHNlc3Npb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJQaG9uZShyZWdEYXRhLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmVnRGF0YSA9IHJlZ0RhdGEgfHwge307XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuc2lwSW5mbyA9IHJlZ0RhdGEuc2lwSW5mb1swXSB8fCByZWdEYXRhLnNpcEluZm87XG4gICAgICAgIHRoaXMuc2lwRmxhZ3MgPSByZWdEYXRhLnNpcEZsYWdzO1xuXG4gICAgICAgIHZhciBpZCA9IG9wdGlvbnMudXVpZCB8fCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncmMtd2ViUGhvbmUtdXVpZCcpIHx8IHV1aWQoKTsgLy9UT0RPIE1ha2UgY29uZmlndXJhYmxlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyYy13ZWJQaG9uZS11dWlkJywgaWQpO1xuXG4gICAgICAgIHRoaXMuZW5kcG9pbnRIZWFkZXIgPSAnUC1yYy1lbmRwb2ludC1pZDogJyArIGlkO1xuXG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgdXJpOiAnc2lwOicgKyB0aGlzLnNpcEluZm8udXNlcm5hbWUgKyAnQCcgKyB0aGlzLnNpcEluZm8uZG9tYWluLFxuICAgICAgICAgICAgd3NTZXJ2ZXJzOiB0aGlzLnNpcEluZm8ub3V0Ym91bmRQcm94eSAmJiB0aGlzLnNpcEluZm8udHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgPyB0aGlzLnNpcEluZm8udHJhbnNwb3J0LnRvTG93ZXJDYXNlKCkgKyAnOi8vJyArIHRoaXMuc2lwSW5mby5vdXRib3VuZFByb3h5XG4gICAgICAgICAgICAgICAgOiB0aGlzLnNpcEluZm8ud3NTZXJ2ZXJzLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvblVzZXI6IHRoaXMuc2lwSW5mby5hdXRob3JpemF0aW9uSWQsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5zaXBJbmZvLnBhc3N3b3JkLFxuICAgICAgICAgICAgdHJhY2VTaXA6IHRydWUsXG4gICAgICAgICAgICBzdHVuU2VydmVyczogdGhpcy5zaXBJbmZvLnN0dW5TZXJ2ZXJzIHx8IFsnc3R1bjo3NC4xMjUuMTk0LjEyNzoxOTMwMiddLCAvL0ZJWE1FIEhhcmRjb2RlZD9cbiAgICAgICAgICAgIHR1cm5TZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGxvZzoge1xuICAgICAgICAgICAgICAgIGxldmVsOiBvcHRpb25zLmxvZ0xldmVsIHx8IDEgLy9GSVhNRSBMT0cgTEVWRUwgM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5zaXBJbmZvLmRvbWFpbixcbiAgICAgICAgICAgIGF1dG9zdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIHJlZ2lzdGVyOiB0cnVlLFxuICAgICAgICAgICAgaWNlR2F0aGVyaW5nVGltZW91dDogdGhpcy5zaXBJbmZvLmljZUdhdGhlcmluZ1RpbWVvdXQgfHwgMzAwMFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYXBwS2V5ID0gb3B0aW9ucy5hcHBLZXk7XG4gICAgICAgIHRoaXMuYXBwTmFtZSA9IG9wdGlvbnMuYXBwTmFtZTtcbiAgICAgICAgdGhpcy5hcHBWZXJzaW9uID0gb3B0aW9ucy5hcHBWZXJzaW9uO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudEhlYWRlciA9ICdSQy1Vc2VyLUFnZW50OiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5hcHBOYW1lID8gKG9wdGlvbnMuYXBwTmFtZSArIChvcHRpb25zLmFwcFZlcnNpb24gPyAnLycgKyBvcHRpb25zLmFwcFZlcnNpb24gOiAnJykpICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUkNXRUJQSE9ORS8nICsgV2ViUGhvbmUudmVyc2lvbjtcblxuICAgICAgICB0aGlzLmNsaWVudElkSGVhZGVyID0gJ0NsaWVudC1pZDonICsgb3B0aW9ucy5hcHBLZXk7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBuZXcgU0lQLlVBKGNvbmZpZ3VyYXRpb24pLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWdlbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRJZEhlYWRlclxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5lbmRwb2ludEhlYWRlciA9IHRoaXMuZW5kcG9pbnRIZWFkZXI7XG4gICAgICAgIHRoaXMudXNlckFnZW50LnVzZXJBZ2VudEhlYWRlciA9IHRoaXMudXNlckFnZW50SGVhZGVyO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudC5jbGllbnRJZEhlYWRlciA9IHRoaXMuY2xpZW50SWRIZWFkZXI7XG4gICAgICAgIHRoaXMudXNlckFnZW50LnNpcEluZm8gPSB0aGlzLnNpcEluZm87XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQuX19pbnZpdGUgPSB0aGlzLnVzZXJBZ2VudC5pbnZpdGU7XG4gICAgICAgIHRoaXMudXNlckFnZW50Lmludml0ZSA9IGludml0ZTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5vbignaW52aXRlJywgZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy51c2VyQWdlbnQuYXVkaW9IZWxwZXIucGxheUluY29taW5nKHRydWUpO1xuICAgICAgICAgICAgcGF0Y2hTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50LmF1ZGlvSGVscGVyID0gbmV3IEF1ZGlvSGVscGVyKG9wdGlvbnMuYXVkaW9IZWxwZXIpO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50Lm9uU2Vzc2lvbiA9IG9wdGlvbnMub25TZXNzaW9uIHx8IG51bGw7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIFdlYlBob25lLnZlcnNpb24gPSAnMC4zLjEnO1xuICAgIFdlYlBob25lLnV1aWQgPSB1dWlkO1xuICAgIFdlYlBob25lLmRlbGF5ID0gZGVsYXk7XG4gICAgV2ViUGhvbmUuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICBmdW5jdGlvbiBwYXRjaFNlc3Npb24oc2Vzc2lvbikge1xuXG4gICAgICAgIGlmIChzZXNzaW9uLl9fcGF0Y2hlZCkgcmV0dXJuIHNlc3Npb247XG5cbiAgICAgICAgc2Vzc2lvbi5fX3BhdGNoZWQgPSB0cnVlO1xuXG4gICAgICAgIHNlc3Npb24uX19zZW5kUmVxdWVzdCA9IHNlc3Npb24uc2VuZFJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24uX19yZWNlaXZlUmVxdWVzdCA9IHNlc3Npb24ucmVjZWl2ZVJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24uX19yZWNlaXZlSW52aXRlUmVzcG9uc2UgPSBzZXNzaW9uLnJlY2VpdmVJbnZpdGVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5fX3JlY2VpdmVSZXNwb25zZSA9IHNlc3Npb24ucmVjZWl2ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLl9fYWNjZXB0ID0gc2Vzc2lvbi5hY2NlcHQ7XG4gICAgICAgIHNlc3Npb24uX19ob2xkID0gc2Vzc2lvbi5ob2xkO1xuICAgICAgICBzZXNzaW9uLl9fdW5ob2xkID0gc2Vzc2lvbi51bmhvbGQ7XG4gICAgICAgIHNlc3Npb24uX19kdG1mID0gc2Vzc2lvbi5kdG1mO1xuXG4gICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QgPSBzZW5kUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdCA9IHJlY2VpdmVSZXF1ZXN0O1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVJbnZpdGVSZXNwb25zZSA9IHJlY2VpdmVJbnZpdGVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVzcG9uc2UgPSByZWNlaXZlUmVzcG9uc2U7XG4gICAgICAgIHNlc3Npb24uYWNjZXB0ID0gYWNjZXB0O1xuICAgICAgICBzZXNzaW9uLmhvbGQgPSBob2xkO1xuICAgICAgICBzZXNzaW9uLnVuaG9sZCA9IHVuaG9sZDtcbiAgICAgICAgc2Vzc2lvbi5kdG1mID0gZHRtZjtcblxuICAgICAgICBzZXNzaW9uLmJsaW5kVHJhbnNmZXIgPSBibGluZFRyYW5zZmVyO1xuICAgICAgICBzZXNzaW9uLnRyYW5zZmVyID0gdHJhbnNmZXI7XG4gICAgICAgIHNlc3Npb24ucGFyayA9IHBhcms7XG4gICAgICAgIHNlc3Npb24uZm9yd2FyZCA9IGZvcndhcmQ7XG4gICAgICAgIHNlc3Npb24uc3RhcnRSZWNvcmQgPSBzdGFydFJlY29yZDtcbiAgICAgICAgc2Vzc2lvbi5zdG9wUmVjb3JkID0gc3RvcFJlY29yZDtcbiAgICAgICAgc2Vzc2lvbi5mbGlwID0gZmxpcDtcblxuICAgICAgICBzZXNzaW9uLm9uKCdyZXBsYWNlZCcsIHBhdGNoU2Vzc2lvbik7XG4gICAgICAgIC8vIHNlc3Npb24ub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuXG4gICAgICAgIC8vIEF1ZGlvXG4gICAgICAgIHNlc3Npb24ub24oJ2FjY2VwdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdyZWplY3RlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbignYnllJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCd0ZXJtaW5hdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdjYW5jZWwnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ2ZhaWxlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbigncmVwbGFjZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLm9uKCdpY2VDb25uZWN0aW9uQ29tcGxldGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5vbignaWNlQ29ubmVjdGlvbkZhaWxlZCcsIHN0b3BQbGF5aW5nKTtcblxuICAgICAgICBmdW5jdGlvbiBzdG9wUGxheWluZygpIHtcbiAgICAgICAgICAgIHNlc3Npb24udWEuYXVkaW9IZWxwZXIucGxheU91dGdvaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNlc3Npb24udWEuYXVkaW9IZWxwZXIucGxheUluY29taW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2FjY2VwdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcigncmVqZWN0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdieWUnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCd0ZXJtaW5hdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignY2FuY2VsJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignZmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcigncmVwbGFjZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5yZW1vdmVMaXN0ZW5lcignaWNlQ29ubmVjdGlvbkNvbXBsZXRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCdpY2VDb25uZWN0aW9uRmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlc3Npb24udWEub25TZXNzaW9uKSBzZXNzaW9uLnVhLm9uU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZW5kUmVjZWl2ZShzZXNzaW9uLCBjb21tYW5kLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZXh0ZW5kKGNvbW1hbmQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBjc2VxID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuSU5GTywge1xuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogY29tbWFuZFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24udWEudXNlckFnZW50SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVhLmVuZHBvaW50SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVhLmNsaWVudElkSGVhZGVyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzZXEgPSByZXNwb25zZS5jc2VxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uSW5mbyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuY3NlcSA9PT0gY3NlcSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcmVxdWVzdCAmJiByZXF1ZXN0LmJvZHkgfHwgJ3t9JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iajtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc3BvbnNlICYmIG9iai5yZXNwb25zZS5jb21tYW5kID09PSBjb21tYW5kLmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNwb25zZS5yZXN1bHQuY29kZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG9iai5yZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Qob2JqLnJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfSU5GTycsIG9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7IC8vRklYTUUgV2hhdCB0byByZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dDogbm8gcmVwbHknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignUkNfU0lQX0lORk8nLCBvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ub24oJ1JDX1NJUF9JTkZPJywgb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBJTkZPIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzOiAnICsgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgKyAnICh3YWl0aW5nIGZvciAyMDApJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHR5cGUsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZSA9PSBTSVAuQy5QUkFDSykge1xuICAgICAgICAgICAgdHlwZSA9IFNJUC5DLkFDSztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX3NlbmRSZXF1ZXN0KHR5cGUsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBlYWNoIHRpbWUgYSBwcm92aXNpb25hbCAoMTAwLTE5OSkgcmVzcG9uc2UgaXMgcmVjZWl2ZWQuXG4gICAgICogRWFybHkgbWVkaWEgaXMgc3VwcG9ydGVkIGJ5IFNJUC5qcyBsaWJyYXJ5XG4gICAgICogQnV0IGluIGNhc2UgaXQgaXMgc2VudCB3aXRob3V0IDEwMHJlbCBzdXBwb3J0IHdlIHBsYXkgaXQgbWFudWFsbHlcbiAgICAgKiBTVEFUVVNfRUFSTFlfTUVESUEgPT09IDExLCBpdCB3aWxsIGJlIHNldCBieSBTSVAuanMgaWYgMTAwcmVsIGlzIHN1cHBvcnRlZFxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDcyMzg4XG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7ZnVuY2l0b259IGNiXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2gxMDByZWwoc2Vzc2lvbiwgcmVzcG9uc2UsIGNiKSB7XG5cbiAgICAgICAgLy9FYXJseSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgU0lQLmpzIGxpYnJhcnlcbiAgICAgICAgLy9CdXQgaW4gY2FzZSBpdCBpcyBzZW50IHdpdGhvdXQgMTAwcmVsIHN1cHBvcnQgd2UgcGxheSBpdCBtYW51YWxseVxuICAgICAgICAvL1NUQVRVU19FQVJMWV9NRURJQSA9PT0gMTEsIGl0IHdpbGwgYmUgc2V0IGJ5IFNJUC5qcyBpZiAxMDByZWwgaXMgc3VwcG9ydGVkXG4gICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfRUFSTFlfTUVESUEgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDE4MyAmJiB0eXBlb2YocmVzcG9uc2UuYm9keSkgPT09ICdzdHJpbmcnICYmIHJlc3BvbnNlLmJvZHkuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmhhc0hlYWRlcigncmVxdWlyZScpKSByZXNwb25zZS5zZXRIZWFkZXIoJ3JlcXVpcmUnLCAnMTAwcmVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2IuY2FsbChzZXNzaW9uLCByZXNwb25zZSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNlaXZlSW52aXRlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHBhdGNoMTAwcmVsKHRoaXMsIHJlc3BvbnNlLCB0aGlzLl9fcmVjZWl2ZUludml0ZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHBhdGNoMTAwcmVsKHRoaXMsIHJlc3BvbnNlLCB0aGlzLl9fcmVjZWl2ZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UmVjb3JkKHNlc3Npb24sIGZsYWcpIHtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9ICEhZmxhZ1xuICAgICAgICAgICAgPyBtZXNzYWdlcy5zdGFydFJlY29yZFxuICAgICAgICAgICAgOiBtZXNzYWdlcy5zdG9wUmVjb3JkO1xuXG4gICAgICAgIGlmICgoc2Vzc2lvbi5fX29uUmVjb3JkICYmICFmbGFnKSB8fCAoIXNlc3Npb24uX19vblJlY29yZCAmJiBmbGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRSZWNlaXZlKHNlc3Npb24sIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLl9fb25SZWNvcmQgPSAhIWZsYWc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0SG9sZChzZXNzaW9uLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQ6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZDogcmVqZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLl9faG9sZChvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5fX3VuaG9sZChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuVUF9XG4gICAgICogQHBhcmFtIG51bWJlclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybiB7U0lQLlNlc3Npb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52aXRlKG51bWJlciwgb3B0aW9ucykge1xuXG4gICAgICAgIHZhciB1YSA9IHRoaXM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG5cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCh1YS51c2VyQWdlbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHVhLmVuZHBvaW50SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCh1YS5jbGllbnRJZEhlYWRlcik7XG5cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnUC1Bc3NlcnRlZC1JZGVudGl0eTogc2lwOicgKyAob3B0aW9ucy5mcm9tTnVtYmVyIHx8IHVhLnNpcEluZm8udXNlcm5hbWUpICsgJ0AnICsgdWEuc2lwSW5mby5kb21haW4pOyAvL0ZJWE1FIFBob25lIE51bWJlclxuXG4gICAgICAgIC8vRklYTUUgQmFja2VuZCBzaG91bGQga25vdyBpdCBhbHJlYWR5XG4gICAgICAgIGlmIChvcHRpb25zLmhvbWVDb3VudHJ5SWQpIHsgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnUC1yYy1jb3VudHJ5LWlkOiAnICsgb3B0aW9ucy5ob21lQ291bnRyeUlkKTsgfVxuXG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSBvcHRpb25zLm1lZGlhIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzID0gb3B0aW9ucy5tZWRpYS5jb25zdHJhaW50cyB8fCB7YXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZX07XG5cbiAgICAgICAgb3B0aW9ucy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge29wdGlvbmFsOiBbe0R0bHNTcnRwS2V5QWdyZWVtZW50OiAndHJ1ZSd9XX07XG5cbiAgICAgICAgdWEuYXVkaW9IZWxwZXIucGxheU91dGdvaW5nKHRydWUpO1xuXG4gICAgICAgIHJldHVybiBwYXRjaFNlc3Npb24odWEuX19pbnZpdGUobnVtYmVyLCBvcHRpb25zKSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjZWl2ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgU0lQLkMuSU5GTzpcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ1JDX1NJUF9JTkZPJywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgLy9TSVAuanMgZG9lcyBub3Qgc3VwcG9ydCBhcHBsaWNhdGlvbi9qc29uIGNvbnRlbnQgdHlwZSwgc28gd2UgbW9ua2V5IG92ZXJyaWRlIGl0cyBiZWhhdmlvdXIgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQgfHwgc2Vzc2lvbi5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvL1JlZnJlc2ggaW52aXRlIHNob3VsZCBub3QgYmUgcmVqZWN0ZWQgd2l0aCA0ODhcbiAgICAgICAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNhbGxfaWQgJiYgc2Vzc2lvbi5kaWFsb2cgJiYgc2Vzc2lvbi5kaWFsb2cuaWQgJiYgcmVxdWVzdC5jYWxsX2lkID09IHNlc3Npb24uZGlhbG9nLmlkLmNhbGxfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogY2hlY2sgdGhhdCBTRFAgZGlkIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLmxvZygncmUtSU5WSVRFIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxTRFAgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5wZWVyQ29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uLnNkcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbJ0NvbnRhY3Q6ICcgKyBzZXNzaW9uLmNvbnRhY3RdLCBsb2NhbFNEUCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5zZXRJbnZpdGUyeHhUaW1lcihyZXF1ZXN0LCBsb2NhbFNEUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5zZXRBQ0tUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2Vsc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIDQ4OCBieSBTSVAuanNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvL1dlIG5lZWQgdG8gYW5hbGl6ZSBOT1RJRlkgbWVzc2FnZXMgc29tZXRpbWVzLCBzbyB3ZSBmaXJlIGFuIGV2ZW50XG4gICAgICAgICAgICBjYXNlIFNJUC5DLk5PVElGWTpcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ1JDX1NJUF9OT1RJRlknLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vzc2lvbi5fX3JlY2VpdmVSZXF1ZXN0LmFwcGx5KHNlc3Npb24sIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjY2VwdChvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuXG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS51c2VyQWdlbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuZW5kcG9pbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuY2xpZW50SWRIZWFkZXIpO1xuXG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSBvcHRpb25zLm1lZGlhIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzID0gb3B0aW9ucy5tZWRpYS5jb25zdHJhaW50cyB8fCB7YXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZX07XG5cbiAgICAgICAgb3B0aW9ucy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge29wdGlvbmFsOiBbe0R0bHNTcnRwS2V5QWdyZWVtZW50OiAndHJ1ZSd9XX07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkFuc3dlcmVkKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignZmFpbGVkJywgb25GYWlsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignYWNjZXB0ZWQnLCBvbkFuc3dlcmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9UT0RPIE1vcmUgZXZlbnRzP1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdhY2NlcHRlZCcsIG9uQW5zd2VyZWQpO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdmYWlsZWQnLCBvbkZhaWwpO1xuXG4gICAgICAgICAgICBzZXNzaW9uLl9fYWNjZXB0KG9wdGlvbnMpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHRtZlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZHRtZihkdG1mLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIGR1cmF0aW9uID0gcGFyc2VJbnQoZHVyYXRpb24pIHx8IDEwMDA7XG4gICAgICAgIHZhciBwZWVyID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIucGVlckNvbm5lY3Rpb247XG4gICAgICAgIHZhciBzdHJlYW0gPSBzZXNzaW9uLmdldExvY2FsU3RyZWFtcygpWzBdO1xuICAgICAgICB2YXIgZHRtZlNlbmRlciA9IHBlZXIuY3JlYXRlRFRNRlNlbmRlcihzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSk7XG4gICAgICAgIGlmIChkdG1mU2VuZGVyICE9PSB1bmRlZmluZWQgJiYgZHRtZlNlbmRlci5jYW5JbnNlcnREVE1GKSB7XG4gICAgICAgICAgICByZXR1cm4gZHRtZlNlbmRlci5pbnNlcnREVE1GKGR0bWYsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbmQgRFRNRiBmYWlsZWQ6ICcgKyAoIWR0bWZTZW5kZXIgPyAnbm8gc2VuZGVyJyA6ICghZHRtZlNlbmRlci5jYW5JbnNlcnREVE1GID8gJ2NhblxcJ3QgaW5zZXJ0IERUTUYnIDogJ1Vua25vd24nKSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBob2xkKCkge1xuICAgICAgICByZXR1cm4gc2V0SG9sZCh0aGlzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5ob2xkKCkge1xuICAgICAgICByZXR1cm4gc2V0SG9sZCh0aGlzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJsaW5kVHJhbnNmZXIodGFyZ2V0LCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgICAgIHZhciBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvL0JsaW5kIFRyYW5zZmVyIGlzIHRha2VuIGZyb20gU0lQLmpzIHNvdXJjZVxuXG4gICAgICAgICAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3Ioc2Vzc2lvbi5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3JtYWxpemVUYXJnZXQgYWxsb3dzIGluc3RhbmNlcyBvZiBTSVAuVVJJIHRvIHBhc3MgdGhyb3VnaCB1bmFsdGVyZWQsXG4gICAgICAgICAgICAvLyBzbyB0cnkgdG8gbWFrZSBvbmUgYWhlYWQgb2YgdGltZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBTSVAuR3JhbW1hci5wYXJzZSh0YXJnZXQsICdSZWZlcl9UbycpLnVyaSB8fCB0YXJnZXQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIuZGVidWcoXCIucmVmZXIoKSBjYW5ub3QgcGFyc2UgUmVmZXJfVG8gZnJvbVwiLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLmRlYnVnKFwiLi4uZmFsbGluZyB0aHJvdWdoIHRvIG5vcm1hbGl6ZVRhcmdldCgpXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0YXJnZXQgdmFsaWRpdHlcbiAgICAgICAgICAgIHRhcmdldCA9IHNlc3Npb24udWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OiAnICsgb3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHNlc3Npb24uY29udGFjdCk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcgKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVmZXItVG86ICcgKyB0YXJnZXQpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS51c2VyQWdlbnRIZWFkZXIpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5lbmRwb2ludEhlYWRlcik7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLmNsaWVudElkSGVhZGVyKTtcblxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5SRUZFUiwge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSAyMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsSWQgPSByZXNwb25zZS5jYWxsX2lkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Ob3RpZnkgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY2FsbF9pZCA9PT0gY2FsbElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcmVxdWVzdCAmJiByZXF1ZXN0LmJvZHkgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAvMVswLTldezJ9Ly50ZXN0KGJvZHkpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLzJbMC05XXsyfS8udGVzdChib2R5KTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfTk9USUZZJywgb25Ob3RpZnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dDogbm8gcmVwbHknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignUkNfU0lQX05PVElGWScsIG9uTm90aWZ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlc3BvbnNlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLm9uKCdSQ19TSVBfTk9USUZZJywgb25Ob3RpZnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzOiAnICsgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgKyAnICh3YWl0aW5nIGZvciAyMDIpJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zlcih0YXJnZXQsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIChzZXNzaW9uLmlzT25Ib2xkKCkgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiBzZXNzaW9uLmhvbGQoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVsYXkoMzAwKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmJsaW5kVHJhbnNmZXIodGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2NlcHRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt0cmFuc2Zlck9wdGlvbnNdXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3J3YXJkKHRhcmdldCwgYWNjZXB0T3B0aW9ucywgdHJhbnNmZXJPcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIGludGVydmFsID0gbnVsbCxcbiAgICAgICAgICAgIHNlc3Npb24gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBzZXNzaW9uLmFjY2VwdChhY2NlcHRPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5tdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZXNzaW9uLnRyYW5zZmVyKHRhcmdldCwgdHJhbnNmZXJPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNzAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRSZWNvcmQoKSB7XG4gICAgICAgIHJldHVybiBzZXRSZWNvcmQodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9wUmVjb3JkKCkge1xuICAgICAgICByZXR1cm4gc2V0UmVjb3JkKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gc2VuZFJlY2VpdmUodGhpcywgbWVzc2FnZXMuZmxpcCwge3RhcmdldDogdGFyZ2V0fSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJrKCkge1xuICAgICAgICByZXR1cm4gc2VuZFJlY2VpdmUodGhpcywgbWVzc2FnZXMucGFyayk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICByZXR1cm4gV2ViUGhvbmU7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC13ZWItcGhvbmUvc3JjL3JpbmdjZW50cmFsLXdlYi1waG9uZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vU0lQJykocmVxdWlyZSgnLi9lbnZpcm9ubWVudCcpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG5hbWUgU0lQXG4gKiBAbmFtZXNwYWNlXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuXG52YXIgcGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciBTSVAgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICB2ZXJzaW9uOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gcGtnLnZlcnNpb247IH1cbiAgfSxcbiAgbmFtZToge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHBrZy50aXRsZTsgfVxuICB9XG59KTtcblxucmVxdWlyZSgnLi9VdGlscycpKFNJUCwgZW52aXJvbm1lbnQpO1xuU0lQLkxvZ2dlckZhY3RvcnkgPSByZXF1aXJlKCcuL0xvZ2dlckZhY3RvcnknKShlbnZpcm9ubWVudC5jb25zb2xlKTtcblNJUC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpKGVudmlyb25tZW50LmNvbnNvbGUpO1xuU0lQLkMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpKFNJUC5uYW1lLCBTSVAudmVyc2lvbik7XG5TSVAuRXhjZXB0aW9ucyA9IHJlcXVpcmUoJy4vRXhjZXB0aW9ucycpO1xuU0lQLlRpbWVycyA9IHJlcXVpcmUoJy4vVGltZXJzJykoZW52aXJvbm1lbnQudGltZXJzKTtcblNJUC5UcmFuc3BvcnQgPSBlbnZpcm9ubWVudC5UcmFuc3BvcnQoU0lQLCBlbnZpcm9ubWVudC5XZWJTb2NrZXQpO1xucmVxdWlyZSgnLi9QYXJzZXInKShTSVApO1xucmVxdWlyZSgnLi9TSVBNZXNzYWdlJykoU0lQKTtcbnJlcXVpcmUoJy4vVVJJJykoU0lQKTtcbnJlcXVpcmUoJy4vTmFtZUFkZHJIZWFkZXInKShTSVApO1xucmVxdWlyZSgnLi9UcmFuc2FjdGlvbnMnKShTSVApO1xucmVxdWlyZSgnLi9EaWFsb2dzJykoU0lQKTtcbnJlcXVpcmUoJy4vUmVxdWVzdFNlbmRlcicpKFNJUCk7XG5yZXF1aXJlKCcuL1JlZ2lzdGVyQ29udGV4dCcpKFNJUCk7XG5TSVAuTWVkaWFIYW5kbGVyID0gcmVxdWlyZSgnLi9NZWRpYUhhbmRsZXInKShTSVAuRXZlbnRFbWl0dGVyKTtcbnJlcXVpcmUoJy4vQ2xpZW50Q29udGV4dCcpKFNJUCk7XG5yZXF1aXJlKCcuL1NlcnZlckNvbnRleHQnKShTSVApO1xucmVxdWlyZSgnLi9TZXNzaW9uJykoU0lQLCBlbnZpcm9ubWVudCk7XG5yZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpKFNJUCk7XG5TSVAuV2ViUlRDID0gcmVxdWlyZSgnLi9XZWJSVEMnKShTSVAsIGVudmlyb25tZW50KTtcbnJlcXVpcmUoJy4vVUEnKShTSVAsIGVudmlyb25tZW50KTtcblNJUC5IYWNrcyA9IHJlcXVpcmUoJy4vSGFja3MnKShTSVApO1xucmVxdWlyZSgnLi9TYW5pdHlDaGVjaycpKFNJUCk7XG5TSVAuRGlnZXN0QXV0aGVudGljYXRpb24gPSByZXF1aXJlKCcuL0RpZ2VzdEF1dGhlbnRpY2F0aW9uJykoU0lQLlV0aWxzKTtcblNJUC5HcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyJykoU0lQKTtcblxucmV0dXJuIFNJUDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1NJUC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiX2FyZ3NcIjogW1xuXHRcdFtcblx0XHRcdFwic2lwLmpzQDAuNy41XCIsXG5cdFx0XHRcIi9Vc2Vycy9ob3dhcmQuemhhbmcvU2l0ZXMvcmluZ2NlbnRyYWwtanMtaW50ZWdyYXRpb24tY29tbW9ucy9ub2RlX21vZHVsZXMvcmluZ2NlbnRyYWwtd2ViLXBob25lXCJcblx0XHRdXG5cdF0sXG5cdFwiX2Zyb21cIjogXCJzaXAuanNAMC43LjVcIixcblx0XCJfaWRcIjogXCJzaXAuanNAMC43LjVcIixcblx0XCJfaW5DYWNoZVwiOiB0cnVlLFxuXHRcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuXHRcIl9sb2NhdGlvblwiOiBcIi9zaXAuanNcIixcblx0XCJfbm9kZVZlcnNpb25cIjogXCI0LjQuM1wiLFxuXHRcIl9ucG1PcGVyYXRpb25hbEludGVybmFsXCI6IHtcblx0XHRcImhvc3RcIjogXCJwYWNrYWdlcy0xMi13ZXN0LmludGVybmFsLm5wbWpzLmNvbVwiLFxuXHRcdFwidG1wXCI6IFwidG1wL3NpcC5qcy0wLjcuNS50Z3pfMTQ2MTU5NDQxODY5MF8wLjU4Mzk5MzMxMjQzNzA4NzNcIlxuXHR9LFxuXHRcIl9ucG1Vc2VyXCI6IHtcblx0XHRcImVtYWlsXCI6IFwiMTIxMmp0cmFjZXVyQGdtYWlsLmNvbVwiLFxuXHRcdFwibmFtZVwiOiBcImpvc2VwaGZyYXppZXJcIlxuXHR9LFxuXHRcIl9ucG1WZXJzaW9uXCI6IFwiMi4xNS4xXCIsXG5cdFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcblx0XCJfcmVxdWVzdGVkXCI6IHtcblx0XHRcIm5hbWVcIjogXCJzaXAuanNcIixcblx0XHRcInJhd1wiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcdFwicmF3U3BlY1wiOiBcIjAuNy41XCIsXG5cdFx0XCJzY29wZVwiOiBudWxsLFxuXHRcdFwic3BlY1wiOiBcIjAuNy41XCIsXG5cdFx0XCJ0eXBlXCI6IFwidmVyc2lvblwiXG5cdH0sXG5cdFwiX3JlcXVpcmVkQnlcIjogW1xuXHRcdFwiL3JpbmdjZW50cmFsLXdlYi1waG9uZVwiXG5cdF0sXG5cdFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc2lwLmpzLy0vc2lwLmpzLTAuNy41LnRnelwiLFxuXHRcIl9zaGFzdW1cIjogXCI4NmFjZTcwNTE1OTRmOTFiNDU1MWJkYjgxMjBhMTZjNDQ5NjJkM2EyXCIsXG5cdFwiX3Nocmlua3dyYXBcIjogbnVsbCxcblx0XCJfc3BlY1wiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcIl93aGVyZVwiOiBcIi9Vc2Vycy9ob3dhcmQuemhhbmcvU2l0ZXMvcmluZ2NlbnRyYWwtanMtaW50ZWdyYXRpb24tY29tbW9ucy9ub2RlX21vZHVsZXMvcmluZ2NlbnRyYWwtd2ViLXBob25lXCIsXG5cdFwiYXV0aG9yXCI6IHtcblx0XHRcImVtYWlsXCI6IFwiZGV2ZWxvcGVyQG9uc2lwLmNvbVwiLFxuXHRcdFwibmFtZVwiOiBcIk9uU0lQXCIsXG5cdFx0XCJ1cmxcIjogXCJodHRwOi8vc2lwanMuY29tL2F1dGhvcnMvXCJcblx0fSxcblx0XCJicm93c2VyXCI6IHtcblx0XHRcIi4vc3JjL2Vudmlyb25tZW50LmpzXCI6IFwiLi9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qc1wiXG5cdH0sXG5cdFwiYnVnc1wiOiB7XG5cdFx0XCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vb25zaXAvU0lQLmpzL2lzc3Vlc1wiXG5cdH0sXG5cdFwiY29udHJpYnV0b3JzXCI6IFtcblx0XHR7XG5cdFx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMvYmxvYi9tYXN0ZXIvVEhBTktTLm1kXCJcblx0XHR9XG5cdF0sXG5cdFwiZGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcInByb21pc2N1b3VzXCI6IFwiXjAuNi4wXCIsXG5cdFx0XCJ3c1wiOiBcIl4wLjYuNFwiXG5cdH0sXG5cdFwiZGVzY3JpcHRpb25cIjogXCJBIHNpbXBsZSwgaW50dWl0aXZlLCBhbmQgcG93ZXJmdWwgSmF2YVNjcmlwdCBzaWduYWxpbmcgbGlicmFyeVwiLFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJiZWVmeVwiOiBcIl4yLjEuNVwiLFxuXHRcdFwiYnJvd3NlcmlmeVwiOiBcIl40LjEuOFwiLFxuXHRcdFwiZ3J1bnRcIjogXCJ+MC40LjBcIixcblx0XHRcImdydW50LWJyb3dzZXJpZnlcIjogXCJeNC4wLjFcIixcblx0XHRcImdydW50LWNsaVwiOiBcIn4wLjEuNlwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1jb3B5XCI6IFwiXjAuNS4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLWphc21pbmVcIjogXCJeMC45LjJcIixcblx0XHRcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwiPjAuNS4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIn4wLjIuMFwiLFxuXHRcdFwiZ3J1bnQtcGVnXCI6IFwifjEuMy4xXCIsXG5cdFx0XCJncnVudC10cmltdHJhaWxpbmdzcGFjZXNcIjogXCJeMC40LjBcIixcblx0XHRcInBlZ2pzXCI6IFwiXjAuOC4wXCJcblx0fSxcblx0XCJkaXJlY3Rvcmllc1wiOiB7fSxcblx0XCJkaXN0XCI6IHtcblx0XHRcInNoYXN1bVwiOiBcIjg2YWNlNzA1MTU5NGY5MWI0NTUxYmRiODEyMGExNmM0NDk2MmQzYTJcIixcblx0XHRcInRhcmJhbGxcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zaXAuanMvLS9zaXAuanMtMC43LjUudGd6XCJcblx0fSxcblx0XCJlbmdpbmVzXCI6IHtcblx0XHRcIm5vZGVcIjogXCI+PTAuOFwiXG5cdH0sXG5cdFwiZ2l0SGVhZFwiOiBcImJhZTQ0YmQwMzU5ZjRkNzBkZWQzMDlhMzIzNjFmMDRhMDRlNzhkNmVcIixcblx0XCJob21lcGFnZVwiOiBcImh0dHA6Ly9zaXBqcy5jb21cIixcblx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XCJzaXBcIixcblx0XHRcIndlYnNvY2tldFwiLFxuXHRcdFwid2VicnRjXCIsXG5cdFx0XCJsaWJyYXJ5XCIsXG5cdFx0XCJqYXZhc2NyaXB0XCJcblx0XSxcblx0XCJsaWNlbnNlXCI6IFwiTUlUXCIsXG5cdFwibWFpblwiOiBcInNyYy9pbmRleC5qc1wiLFxuXHRcIm1haW50YWluZXJzXCI6IFtcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiZXJpYy5ncmVlbkBvbnNpcC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImVncmVlbl9vbnNpcFwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiamFtZXNAb25zaXAuY29tXCIsXG5cdFx0XHRcIm5hbWVcIjogXCJqYW1lcy1jcmlzY3VvbG9cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJlbWFpbFwiOiBcIjEyMTJqdHJhY2V1ckBnbWFpbC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImpvc2VwaGZyYXppZXJcIlxuXHRcdH1cblx0XSxcblx0XCJuYW1lXCI6IFwic2lwLmpzXCIsXG5cdFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwicHJvbWlzY3VvdXNcIjogXCJeMC42LjBcIlxuXHR9LFxuXHRcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vb25zaXAvU0lQLmpzLmdpdFwiXG5cdH0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJidWlsZFwiOiBcImdydW50IGJ1aWxkXCIsXG5cdFx0XCJwcmVwdWJsaXNoXCI6IFwiY2Qgc3JjL0dyYW1tYXIgJiYgbWtkaXIgLXAgZGlzdCAmJiBwZWdqcyAtLWV4dHJhLW9wdGlvbnMtZmlsZSBwZWcuanNvbiBzcmMvR3JhbW1hci5wZWdqcyBkaXN0L0dyYW1tYXIuanNcIixcblx0XHRcInJlcGxcIjogXCJiZWVmeSB0ZXN0L3JlcGwuanMgLS1vcGVuXCIsXG5cdFx0XCJ0ZXN0XCI6IFwiZ3J1bnQgdHJhdmlzIC0tdmVyYm9zZVwiXG5cdH0sXG5cdFwidGl0bGVcIjogXCJTSVAuanNcIixcblx0XCJ2ZXJzaW9uXCI6IFwiMC43LjVcIlxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvcGFja2FnZS5qc29uXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcbnZhciBVdGlscztcblxuVXRpbHM9IHtcblxuICBQcm9taXNlOiBlbnZpcm9ubWVudC5Qcm9taXNlLFxuXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlciAoKSB7XG4gICAgdmFyIGRlZmVycmVkID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBVdGlscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfSxcblxuICBwcm9taXNpZnk6IGZ1bmN0aW9uIHByb21pc2lmeSAob2JqZWN0LCBtZXRob2ROYW1lLCBjYWxsYmFja3NGaXJzdCkge1xuICAgIHZhciBvbGRNZXRob2QgPSBvYmplY3RbbWV0aG9kTmFtZV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2lmaWVkTWV0aG9kIChhcmcsIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFV0aWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgb2xkQXJncyA9IFthcmcsIHJlc29sdmUsIHJlamVjdF07XG4gICAgICAgIGlmIChjYWxsYmFja3NGaXJzdCkge1xuICAgICAgICAgIG9sZEFyZ3MgPSBbcmVzb2x2ZSwgcmVqZWN0LCBhcmddO1xuICAgICAgICB9XG4gICAgICAgIG9sZE1ldGhvZC5hcHBseShvYmplY3QsIG9sZEFyZ3MpO1xuICAgICAgfSkudGhlbihvblN1Y2Nlc3MsIG9uRmFpbHVyZSk7XG4gICAgfTtcbiAgfSxcblxuICBhdWdtZW50OiBmdW5jdGlvbiAob2JqZWN0LCBjb25zdHJ1Y3RvciwgYXJncywgb3ZlcnJpZGUpIHtcbiAgICB2YXIgaWR4LCBwcm90bztcblxuICAgIC8vIEFkZCBwdWJsaWMgcHJvcGVydGllcyBmcm9tIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlIG9udG8gb2JqZWN0XG4gICAgcHJvdG8gPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgZm9yIChpZHggaW4gcHJvdG8pIHtcbiAgICAgIGlmIChvdmVycmlkZSB8fCBvYmplY3RbaWR4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdFtpZHhdID0gcHJvdG9baWR4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIG9iamVjdCBhcyB0aG91Z2ggaXQgd2VyZSBqdXN0IGNyZWF0ZWQgYnkgY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3Rvci5hcHBseShvYmplY3QsIGFyZ3MpO1xuICB9LFxuXG4gIG9wdGlvbnNPdmVycmlkZTogZnVuY3Rpb24gKG9wdGlvbnMsIHdpbm5lciwgbG9zZXIsIGlzRGVwcmVjYXRlZCwgbG9nZ2VyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaXNEZXByZWNhdGVkICYmIG9wdGlvbnNbbG9zZXJdKSB7XG4gICAgICBsb2dnZXIud2Fybihsb3NlciArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgd2lubmVyICsgJyBpbnN0ZWFkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbd2lubmVyXSAmJiBvcHRpb25zW2xvc2VyXSkge1xuICAgICAgbG9nZ2VyLndhcm4od2lubmVyICsgJyBvdmVycmlkaW5nICcgKyBsb3Nlcik7XG4gICAgfVxuXG4gICAgb3B0aW9uc1t3aW5uZXJdID0gb3B0aW9uc1t3aW5uZXJdIHx8IG9wdGlvbnNbbG9zZXJdIHx8IGRlZmF1bHRWYWx1ZTtcbiAgfSxcblxuICBzdHJfdXRmOF9sZW5ndGg6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKS5yZXBsYWNlKC8lW0EtRlxcZF17Mn0vZywgJ1UnKS5sZW5ndGg7XG4gIH0sXG5cbiAgZ2VuZXJhdGVGYWtlU0RQOiBmdW5jdGlvbihib2R5KSB7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gYm9keS5pbmRleE9mKCdvPScpO1xuICAgIHZhciBlbmQgPSBib2R5LmluZGV4T2YoJ1xcclxcbicsIHN0YXJ0KTtcblxuICAgIHJldHVybiAndj0wXFxyXFxuJyArIGJvZHkuc2xpY2Uoc3RhcnQsIGVuZCkgKyAnXFxyXFxucz0tXFxyXFxudD0wIDBcXHJcXG5jPUlOIElQNCAwLjAuMC4wJztcbiAgfSxcblxuICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihmbikge1xuICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBpc0RlY2ltYWw6IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG51bSkgJiYgKHBhcnNlRmxvYXQobnVtKSA9PT0gcGFyc2VJbnQobnVtLDEwKSk7XG4gIH0sXG5cbiAgY3JlYXRlUmFuZG9tVG9rZW46IGZ1bmN0aW9uKHNpemUsIGJhc2UpIHtcbiAgICB2YXIgaSwgcixcbiAgICAgIHRva2VuID0gJyc7XG5cbiAgICBiYXNlID0gYmFzZSB8fCAzMjtcblxuICAgIGZvciggaT0wOyBpIDwgc2l6ZTsgaSsrICkge1xuICAgICAgciA9IE1hdGgucmFuZG9tKCkgKiBiYXNlfDA7XG4gICAgICB0b2tlbiArPSByLnRvU3RyaW5nKGJhc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfSxcblxuICBuZXdUYWc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oU0lQLlVBLkMuVEFHX0xFTkdUSCk7XG4gIH0sXG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzEwOTUzOC9icm9vZmFcbiAgbmV3VVVJRDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIFVVSUQgPSAgJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBVVUlEO1xuICB9LFxuXG4gIGhvc3RUeXBlOiBmdW5jdGlvbihob3N0KSB7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3QgPSBTSVAuR3JhbW1hci5wYXJzZShob3N0LCdob3N0Jyk7XG4gICAgICBpZiAoaG9zdCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QuaG9zdF90eXBlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBOb3JtYWxpemUgU0lQIFVSSS5cbiAgKiBOT1RFOiBJdCBkb2VzIG5vdCBhbGxvdyBhIFNJUCBVUkkgd2l0aG91dCB1c2VybmFtZS5cbiAgKiBBY2NlcHRzICdzaXAnLCAnc2lwcycgYW5kICd0ZWwnIFVSSXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvICdzaXAnLlxuICAqIERldGVjdHMgdGhlIGRvbWFpbiBwYXJ0IChpZiBnaXZlbikgYW5kIHByb3Blcmx5IGhleC1lc2NhcGVzIHRoZSB1c2VyIHBvcnRpb24uXG4gICogSWYgdGhlIHVzZXIgcG9ydGlvbiBoYXMgb25seSAndGVsJyBudW1iZXIgc3ltYm9scyB0aGUgdXNlciBwb3J0aW9uIGlzIGNsZWFuIG9mICd0ZWwnIHZpc3VhbCBzZXBhcmF0b3JzLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICAqIEBwYXJhbSB7U3RyaW5nfSBbZG9tYWluXVxuICAqL1xuICBub3JtYWxpemVUYXJnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgZG9tYWluKSB7XG4gICAgdmFyIHVyaSwgdGFyZ2V0X2FycmF5LCB0YXJnZXRfdXNlciwgdGFyZ2V0X2RvbWFpbjtcblxuICAgIC8vIElmIG5vIHRhcmdldCBpcyBnaXZlbiB0aGVuIHJhaXNlIGFuIGVycm9yLlxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgLy8gSWYgYSBTSVAuVVJJIGluc3RhbmNlIGlzIGdpdmVuIHRoZW4gcmV0dXJuIGl0LlxuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU0lQLlVSSSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcblxuICAgIC8vIElmIGEgc3RyaW5nIGlzIGdpdmVuIHNwbGl0IGl0IGJ5ICdAJzpcbiAgICAvLyAtIExhc3QgZnJhZ21lbnQgaXMgdGhlIGRlc2lyZWQgZG9tYWluLlxuICAgIC8vIC0gT3RoZXJ3aXNlIGFwcGVuZCB0aGUgZ2l2ZW4gZG9tYWluIGFyZ3VtZW50LlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhcmdldF9hcnJheSA9IHRhcmdldC5zcGxpdCgnQCcpO1xuXG4gICAgICBzd2l0Y2godGFyZ2V0X2FycmF5Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXQ7XG4gICAgICAgICAgdGFyZ2V0X2RvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0X2FycmF5WzBdO1xuICAgICAgICAgIHRhcmdldF9kb21haW4gPSB0YXJnZXRfYXJyYXlbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfYXJyYXkuc2xpY2UoMCwgdGFyZ2V0X2FycmF5Lmxlbmd0aC0xKS5qb2luKCdAJyk7XG4gICAgICAgICAgdGFyZ2V0X2RvbWFpbiA9IHRhcmdldF9hcnJheVt0YXJnZXRfYXJyYXkubGVuZ3RoLTFdO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIFVSSSBzY2hlbWUgKGlmIHByZXNlbnQpLlxuICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfdXNlci5yZXBsYWNlKC9eKHNpcHM/fHRlbCk6L2ksICcnKTtcblxuICAgICAgLy8gUmVtb3ZlICd0ZWwnIHZpc3VhbCBzZXBhcmF0b3JzIGlmIHRoZSB1c2VyIHBvcnRpb24ganVzdCBjb250YWlucyAndGVsJyBudW1iZXIgc3ltYm9scy5cbiAgICAgIGlmICgvXltcXC1cXC5cXChcXCldKlxcKz9bMC05XFwtXFwuXFwoXFwpXSskLy50ZXN0KHRhcmdldF91c2VyKSkge1xuICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF91c2VyLnJlcGxhY2UoL1tcXC1cXC5cXChcXCldL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgdGhlIGNvbXBsZXRlIFNJUCBVUkkuXG4gICAgICB0YXJnZXQgPSBTSVAuQy5TSVAgKyAnOicgKyBTSVAuVXRpbHMuZXNjYXBlVXNlcih0YXJnZXRfdXNlcikgKyAnQCcgKyB0YXJnZXRfZG9tYWluO1xuXG4gICAgICAvLyBGaW5hbGx5IHBhcnNlIHRoZSByZXN1bHRpbmcgVVJJLlxuICAgICAgaWYgKHVyaSA9IFNJUC5VUkkucGFyc2UodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEhleC1lc2NhcGUgYSBTSVAgVVJJIHVzZXIuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICAqL1xuICBlc2NhcGVVc2VyOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgLy8gRG9uJ3QgaGV4LWVzY2FwZSAnOicgKCUzQSksICcrJyAoJTJCKSwgJz8nICglM0ZcIiksICcvJyAoJTJGKS5cbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1c2VyKSkucmVwbGFjZSgvJTNBL2lnLCAnOicpLnJlcGxhY2UoLyUyQi9pZywgJysnKS5yZXBsYWNlKC8lM0YvaWcsICc/JykucmVwbGFjZSgvJTJGL2lnLCAnLycpO1xuICB9LFxuXG4gIGhlYWRlcml6ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGV4Y2VwdGlvbnMgPSB7XG4gICAgICAnQ2FsbC1JZCc6ICdDYWxsLUlEJyxcbiAgICAgICdDc2VxJzogJ0NTZXEnLFxuICAgICAgJ01pbi1TZSc6ICdNaW4tU0UnLFxuICAgICAgJ1JhY2snOiAnUkFjaycsXG4gICAgICAnUnNlcSc6ICdSU2VxJyxcbiAgICAgICdXd3ctQXV0aGVudGljYXRlJzogJ1dXVy1BdXRoZW50aWNhdGUnXG4gICAgICB9LFxuICAgICAgbmFtZSA9IHN0cmluZy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18vZywnLScpLnNwbGl0KCctJyksXG4gICAgICBobmFtZSA9ICcnLFxuICAgICAgcGFydHMgPSBuYW1lLmxlbmd0aCwgcGFydDtcblxuICAgIGZvciAocGFydCA9IDA7IHBhcnQgPCBwYXJ0czsgcGFydCsrKSB7XG4gICAgICBpZiAocGFydCAhPT0gMCkge1xuICAgICAgICBobmFtZSArPSctJztcbiAgICAgIH1cbiAgICAgIGhuYW1lICs9IG5hbWVbcGFydF0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbmFtZVtwYXJ0XS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChleGNlcHRpb25zW2huYW1lXSkge1xuICAgICAgaG5hbWUgPSBleGNlcHRpb25zW2huYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGhuYW1lO1xuICB9LFxuXG4gIHNpcEVycm9yQ2F1c2U6IGZ1bmN0aW9uKHN0YXR1c19jb2RlKSB7XG4gICAgdmFyIGNhdXNlO1xuXG4gICAgZm9yIChjYXVzZSBpbiBTSVAuQy5TSVBfRVJST1JfQ0FVU0VTKSB7XG4gICAgICBpZiAoU0lQLkMuU0lQX0VSUk9SX0NBVVNFU1tjYXVzZV0uaW5kZXhPZihzdGF0dXNfY29kZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5jYXVzZXNbY2F1c2VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTSVAuQy5jYXVzZXMuU0lQX0ZBSUxVUkVfQ09ERTtcbiAgfSxcblxuICBnZXRSZWFzb25QaHJhc2U6IGZ1bmN0aW9uIGdldFJlYXNvblBocmFzZSAoY29kZSwgc3BlY2lmaWMpIHtcbiAgICByZXR1cm4gc3BlY2lmaWMgfHwgU0lQLkMuUkVBU09OX1BIUkFTRVtjb2RlXSB8fCAnJztcbiAgfSxcblxuICBnZXRSZWFzb25IZWFkZXJWYWx1ZTogZnVuY3Rpb24gZ2V0UmVhc29uSGVhZGVyVmFsdWUgKGNvZGUsIHJlYXNvbikge1xuICAgIHJlYXNvbiA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UoY29kZSwgcmVhc29uKTtcbiAgICByZXR1cm4gJ1NJUCA7Y2F1c2U9JyArIGNvZGUgKyAnIDt0ZXh0PVwiJyArIHJlYXNvbiArICdcIic7XG4gIH0sXG5cbiAgZ2V0Q2FuY2VsUmVhc29uOiBmdW5jdGlvbiBnZXRDYW5jZWxSZWFzb24gKGNvZGUsIHJlYXNvbikge1xuICAgIGlmIChjb2RlICYmIGNvZGUgPCAyMDAgfHwgY29kZSA+IDY5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNfY29kZTogJyArIGNvZGUpO1xuICAgIH0gZWxzZSBpZiAoY29kZSkge1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZShjb2RlLCByZWFzb24pO1xuICAgIH1cbiAgfSxcblxuICBidWlsZFN0YXR1c0xpbmU6IGZ1bmN0aW9uIGJ1aWxkU3RhdHVzTGluZSAoY29kZSwgcmVhc29uKSB7XG4gICAgY29kZSA9IGNvZGUgfHwgbnVsbDtcbiAgICByZWFzb24gPSByZWFzb24gfHwgbnVsbDtcblxuICAgIC8vIFZhbGlkYXRlIGNvZGUgYW5kIHJlYXNvbiB2YWx1ZXNcbiAgICBpZiAoIWNvZGUgfHwgKGNvZGUgPCAxMDAgfHwgY29kZSA+IDY5OSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzX2NvZGU6ICcrIGNvZGUpO1xuICAgIH0gZWxzZSBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24gIT09ICdzdHJpbmcnICYmICEocmVhc29uIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCByZWFzb25fcGhyYXNlOiAnKyByZWFzb24pO1xuICAgIH1cblxuICAgIHJlYXNvbiA9IFV0aWxzLmdldFJlYXNvblBocmFzZShjb2RlLCByZWFzb24pO1xuXG4gICAgcmV0dXJuICdTSVAvMi4wICcgKyBjb2RlICsgJyAnICsgcmVhc29uICsgJ1xcclxcbic7XG4gIH0sXG5cbiAgLyoqXG4gICogR2VuZXJhdGUgYSByYW5kb20gVGVzdC1OZXQgSVAgKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU3MzUpXG4gICogQHByaXZhdGVcbiAgKi9cbiAgZ2V0UmFuZG9tVGVzdE5ldElQOiBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBnZXRPY3RldChmcm9tLHRvKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKih0by1mcm9tKzEpK2Zyb20pO1xuICAgIH1cbiAgICByZXR1cm4gJzE5Mi4wLjIuJyArIGdldE9jdGV0KDEsIDI1NCk7XG4gIH0sXG5cbiAgLy8gTUQ1IChNZXNzYWdlLURpZ2VzdCBBbGdvcml0aG0pIGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvXG4gIGNhbGN1bGF0ZU1ENTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgZnVuY3Rpb24gUm90YXRlTGVmdChsVmFsdWUsIGlTaGlmdEJpdHMpIHtcbiAgICAgIHJldHVybiAobFZhbHVlPDxpU2hpZnRCaXRzKSB8IChsVmFsdWU+Pj4oMzItaVNoaWZ0Qml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFkZFVuc2lnbmVkKGxYLGxZKSB7XG4gICAgICB2YXIgbFg0LGxZNCxsWDgsbFk4LGxSZXN1bHQ7XG4gICAgICBsWDggPSAobFggJiAweDgwMDAwMDAwKTtcbiAgICAgIGxZOCA9IChsWSAmIDB4ODAwMDAwMDApO1xuICAgICAgbFg0ID0gKGxYICYgMHg0MDAwMDAwMCk7XG4gICAgICBsWTQgPSAobFkgJiAweDQwMDAwMDAwKTtcbiAgICAgIGxSZXN1bHQgPSAobFggJiAweDNGRkZGRkZGKSsobFkgJiAweDNGRkZGRkZGKTtcbiAgICAgIGlmIChsWDQgJiBsWTQpIHtcbiAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gMHg4MDAwMDAwMCBeIGxYOCBeIGxZOCk7XG4gICAgICB9XG4gICAgICBpZiAobFg0IHwgbFk0KSB7XG4gICAgICAgIGlmIChsUmVzdWx0ICYgMHg0MDAwMDAwMCkge1xuICAgICAgICAgIHJldHVybiAobFJlc3VsdCBeIDB4QzAwMDAwMDAgXiBsWDggXiBsWTgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAobFJlc3VsdCBeIDB4NDAwMDAwMDAgXiBsWDggXiBsWTgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKGxSZXN1bHQgXiBsWDggXiBsWTgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEYoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHKHgseSx6KSB7XG4gICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSCh4LHkseikge1xuICAgICAgcmV0dXJuICh4IF4geSBeIHopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEkoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeSBeICh4IHwgKH56KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZGKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoRihiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR0coYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChHKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBISChhLGIsYyxkLHgscyxhYykge1xuICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEgoYiwgYywgZCksIHgpLCBhYykpO1xuICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIElJKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSShiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udmVydFRvV29yZEFycmF5KHN0cmluZykge1xuICAgICAgdmFyIGxXb3JkQ291bnQ7XG4gICAgICB2YXIgbE1lc3NhZ2VMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxOdW1iZXJPZldvcmRzX3RlbXAxPWxNZXNzYWdlTGVuZ3RoICsgODtcbiAgICAgIHZhciBsTnVtYmVyT2ZXb3Jkc190ZW1wMj0obE51bWJlck9mV29yZHNfdGVtcDEtKGxOdW1iZXJPZldvcmRzX3RlbXAxICUgNjQpKS82NDtcbiAgICAgIHZhciBsTnVtYmVyT2ZXb3JkcyA9IChsTnVtYmVyT2ZXb3Jkc190ZW1wMisxKSoxNjtcbiAgICAgIHZhciBsV29yZEFycmF5PUFycmF5KGxOdW1iZXJPZldvcmRzLTEpO1xuICAgICAgdmFyIGxCeXRlUG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGxCeXRlQ291bnQgPSAwO1xuICAgICAgd2hpbGUgKCBsQnl0ZUNvdW50IDwgbE1lc3NhZ2VMZW5ndGggKSB7XG4gICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudC0obEJ5dGVDb3VudCAlIDQpKS80O1xuICAgICAgICBsQnl0ZVBvc2l0aW9uID0gKGxCeXRlQ291bnQgJSA0KSo4O1xuICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID0gKGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoc3RyaW5nLmNoYXJDb2RlQXQobEJ5dGVDb3VudCk8PGxCeXRlUG9zaXRpb24pKTtcbiAgICAgICAgbEJ5dGVDb3VudCsrO1xuICAgICAgfVxuICAgICAgbFdvcmRDb3VudCA9IChsQnl0ZUNvdW50LShsQnl0ZUNvdW50ICUgNCkpLzQ7XG4gICAgICBsQnl0ZVBvc2l0aW9uID0gKGxCeXRlQ291bnQgJSA0KSo4O1xuICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSA9IGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoMHg4MDw8bEJ5dGVQb3NpdGlvbik7XG4gICAgICBsV29yZEFycmF5W2xOdW1iZXJPZldvcmRzLTJdID0gbE1lc3NhZ2VMZW5ndGg8PDM7XG4gICAgICBsV29yZEFycmF5W2xOdW1iZXJPZldvcmRzLTFdID0gbE1lc3NhZ2VMZW5ndGg+Pj4yOTtcbiAgICAgIHJldHVybiBsV29yZEFycmF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdvcmRUb0hleChsVmFsdWUpIHtcbiAgICAgIHZhciBXb3JkVG9IZXhWYWx1ZT1cIlwiLFdvcmRUb0hleFZhbHVlX3RlbXA9XCJcIixsQnl0ZSxsQ291bnQ7XG4gICAgICBmb3IgKGxDb3VudCA9IDA7bENvdW50PD0zO2xDb3VudCsrKSB7XG4gICAgICAgIGxCeXRlID0gKGxWYWx1ZT4+PihsQ291bnQqOCkpICYgMjU1O1xuICAgICAgICBXb3JkVG9IZXhWYWx1ZV90ZW1wID0gXCIwXCIgKyBsQnl0ZS50b1N0cmluZygxNik7XG4gICAgICAgIFdvcmRUb0hleFZhbHVlID0gV29yZFRvSGV4VmFsdWUgKyBXb3JkVG9IZXhWYWx1ZV90ZW1wLnN1YnN0cihXb3JkVG9IZXhWYWx1ZV90ZW1wLmxlbmd0aC0yLDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFdvcmRUb0hleFZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFV0ZjhFbmNvZGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxyXFxuL2csXCJcXG5cIik7XG4gICAgICB2YXIgdXRmdGV4dCA9IFwiXCI7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgc3RyaW5nLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG5cbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZigoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiA2KSB8IDE5Mik7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTIpIHwgMjI0KTtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjID4+IDYpICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRmdGV4dDtcbiAgICB9XG5cbiAgICB2YXIgeD1bXTtcbiAgICB2YXIgayxBQSxCQixDQyxERCxhLGIsYyxkO1xuICAgIHZhciBTMTE9NywgUzEyPTEyLCBTMTM9MTcsIFMxND0yMjtcbiAgICB2YXIgUzIxPTUsIFMyMj05ICwgUzIzPTE0LCBTMjQ9MjA7XG4gICAgdmFyIFMzMT00LCBTMzI9MTEsIFMzMz0xNiwgUzM0PTIzO1xuICAgIHZhciBTNDE9NiwgUzQyPTEwLCBTNDM9MTUsIFM0ND0yMTtcblxuICAgIHN0cmluZyA9IFV0ZjhFbmNvZGUoc3RyaW5nKTtcblxuICAgIHggPSBDb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKTtcblxuICAgIGEgPSAweDY3NDUyMzAxOyBiID0gMHhFRkNEQUI4OTsgYyA9IDB4OThCQURDRkU7IGQgPSAweDEwMzI1NDc2O1xuXG4gICAgZm9yIChrPTA7azx4Lmxlbmd0aDtrKz0xNikge1xuICAgICAgQUE9YTsgQkI9YjsgQ0M9YzsgREQ9ZDtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srMF0sIFMxMSwweEQ3NkFBNDc4KTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srMV0sIFMxMiwweEU4QzdCNzU2KTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srMl0sIFMxMywweDI0MjA3MERCKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srM10sIFMxNCwweEMxQkRDRUVFKTtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srNF0sIFMxMSwweEY1N0MwRkFGKTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srNV0sIFMxMiwweDQ3ODdDNjJBKTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srNl0sIFMxMywweEE4MzA0NjEzKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srN10sIFMxNCwweEZENDY5NTAxKTtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srOF0sIFMxMSwweDY5ODA5OEQ4KTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srOV0sIFMxMiwweDhCNDRGN0FGKTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srMTBdLFMxMywweEZGRkY1QkIxKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srMTFdLFMxNCwweDg5NUNEN0JFKTtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srMTJdLFMxMSwweDZCOTAxMTIyKTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srMTNdLFMxMiwweEZEOTg3MTkzKTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srMTRdLFMxMywweEE2Nzk0MzhFKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srMTVdLFMxNCwweDQ5QjQwODIxKTtcbiAgICAgIGE9R0coYSxiLGMsZCx4W2srMV0sIFMyMSwweEY2MUUyNTYyKTtcbiAgICAgIGQ9R0coZCxhLGIsYyx4W2srNl0sIFMyMiwweEMwNDBCMzQwKTtcbiAgICAgIGM9R0coYyxkLGEsYix4W2srMTFdLFMyMywweDI2NUU1QTUxKTtcbiAgICAgIGI9R0coYixjLGQsYSx4W2srMF0sIFMyNCwweEU5QjZDN0FBKTtcbiAgICAgIGE9R0coYSxiLGMsZCx4W2srNV0sIFMyMSwweEQ2MkYxMDVEKTtcbiAgICAgIGQ9R0coZCxhLGIsYyx4W2srMTBdLFMyMiwweDI0NDE0NTMpO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbaysxNV0sUzIzLDB4RDhBMUU2ODEpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbays0XSwgUzI0LDB4RTdEM0ZCQzgpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbays5XSwgUzIxLDB4MjFFMUNERTYpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbaysxNF0sUzIyLDB4QzMzNzA3RDYpO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbayszXSwgUzIzLDB4RjRENTBEODcpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbays4XSwgUzI0LDB4NDU1QTE0RUQpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbaysxM10sUzIxLDB4QTlFM0U5MDUpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbaysyXSwgUzIyLDB4RkNFRkEzRjgpO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbays3XSwgUzIzLDB4Njc2RjAyRDkpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbaysxMl0sUzI0LDB4OEQyQTRDOEEpO1xuICAgICAgYT1ISChhLGIsYyxkLHhbays1XSwgUzMxLDB4RkZGQTM5NDIpO1xuICAgICAgZD1ISChkLGEsYixjLHhbays4XSwgUzMyLDB4ODc3MUY2ODEpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbaysxMV0sUzMzLDB4NkQ5RDYxMjIpO1xuICAgICAgYj1ISChiLGMsZCxhLHhbaysxNF0sUzM0LDB4RkRFNTM4MEMpO1xuICAgICAgYT1ISChhLGIsYyxkLHhbaysxXSwgUzMxLDB4QTRCRUVBNDQpO1xuICAgICAgZD1ISChkLGEsYixjLHhbays0XSwgUzMyLDB4NEJERUNGQTkpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbays3XSwgUzMzLDB4RjZCQjRCNjApO1xuICAgICAgYj1ISChiLGMsZCxhLHhbaysxMF0sUzM0LDB4QkVCRkJDNzApO1xuICAgICAgYT1ISChhLGIsYyxkLHhbaysxM10sUzMxLDB4Mjg5QjdFQzYpO1xuICAgICAgZD1ISChkLGEsYixjLHhbayswXSwgUzMyLDB4RUFBMTI3RkEpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbayszXSwgUzMzLDB4RDRFRjMwODUpO1xuICAgICAgYj1ISChiLGMsZCxhLHhbays2XSwgUzM0LDB4NDg4MUQwNSk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzldLCBTMzEsMHhEOUQ0RDAzOSk7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzEyXSxTMzIsMHhFNkRCOTlFNSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzE1XSxTMzMsMHgxRkEyN0NGOCk7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzJdLCBTMzQsMHhDNEFDNTY2NSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzBdLCBTNDEsMHhGNDI5MjI0NCk7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzddLCBTNDIsMHg0MzJBRkY5Nyk7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzE0XSxTNDMsMHhBQjk0MjNBNyk7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzVdLCBTNDQsMHhGQzkzQTAzOSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzEyXSxTNDEsMHg2NTVCNTlDMyk7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzNdLCBTNDIsMHg4RjBDQ0M5Mik7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzEwXSxTNDMsMHhGRkVGRjQ3RCk7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzFdLCBTNDQsMHg4NTg0NUREMSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzhdLCBTNDEsMHg2RkE4N0U0Rik7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzE1XSxTNDIsMHhGRTJDRTZFMCk7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzZdLCBTNDMsMHhBMzAxNDMxNCk7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzEzXSxTNDQsMHg0RTA4MTFBMSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzRdLCBTNDEsMHhGNzUzN0U4Mik7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzExXSxTNDIsMHhCRDNBRjIzNSk7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzJdLCBTNDMsMHgyQUQ3RDJCQik7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzldLCBTNDQsMHhFQjg2RDM5MSk7XG4gICAgICBhPUFkZFVuc2lnbmVkKGEsQUEpO1xuICAgICAgYj1BZGRVbnNpZ25lZChiLEJCKTtcbiAgICAgIGM9QWRkVW5zaWduZWQoYyxDQyk7XG4gICAgICBkPUFkZFVuc2lnbmVkKGQsREQpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wID0gV29yZFRvSGV4KGEpK1dvcmRUb0hleChiKStXb3JkVG9IZXgoYykrV29yZFRvSGV4KGQpO1xuXG4gICAgcmV0dXJuIHRlbXAudG9Mb3dlckNhc2UoKTtcbiAgfVxufTtcblxuU0lQLlV0aWxzID0gVXRpbHM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGV2ZWxzID0ge1xuICAnZXJyb3InOiAwLFxuICAnd2Fybic6IDEsXG4gICdsb2cnOiAyLFxuICAnZGVidWcnOiAzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zb2xlKSB7XG5cbnZhciBMb2dnZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9nZ2VyLFxuICAgIGxldmVsID0gMixcbiAgICBidWlsdGluRW5hYmxlZCA9IHRydWUsXG4gICAgY29ubmVjdG9yID0gbnVsbDtcblxuICAgIHRoaXMubG9nZ2VycyA9IHt9O1xuXG4gICAgbG9nZ2VyID0gdGhpcy5nZXRMb2dnZXIoJ3NpcC5sb2dnZXJmYWN0b3J5Jyk7XG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgYnVpbHRpbkVuYWJsZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGJ1aWx0aW5FbmFibGVkOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGJ1aWx0aW5FbmFibGVkID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdpbnZhbGlkIFwiYnVpbHRpbkVuYWJsZWRcIiBwYXJhbWV0ZXIgdmFsdWU6ICcrIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGV2ZWw6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7cmV0dXJuIGxldmVsOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PTMpIHtcbiAgICAgICAgICBsZXZlbCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMykge1xuICAgICAgICAgIGxldmVsID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbHMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbdmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignaW52YWxpZCBcImxldmVsXCIgcGFyYW1ldGVyIHZhbHVlOiAnKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbm5lY3Rvcjoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtyZXR1cm4gY29ubmVjdG9yOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25uZWN0b3IgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbm5lY3RvciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignaW52YWxpZCBcImNvbm5lY3RvclwiIHBhcmFtZXRlciB2YWx1ZTogJysgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Mb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKHRhcmdldCwgY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcHJlZml4ID0gW25ldyBEYXRlKCksIGNhdGVnb3J5XTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHByZWZpeC5wdXNoKGxhYmVsKTtcbiAgICB9XG4gICAgY29udGVudCA9IHByZWZpeC5jb25jYXQoY29udGVudCkuam9pbignIHwgJyk7XG4gIH1cbiAgdGFyZ2V0LmNhbGwoY29uc29sZSwgY29udGVudCk7XG59O1xuXG5mdW5jdGlvbiBMb2dnZXIgKGxvZ2dlciwgY2F0ZWdvcnksIGxhYmVsKSB7XG4gIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuT2JqZWN0LmtleXMobGV2ZWxzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXROYW1lKSB7XG4gIExvZ2dlci5wcm90b3R5cGVbdGFyZ2V0TmFtZV0gPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHRoaXMubG9nZ2VyW3RhcmdldE5hbWVdKHRoaXMuY2F0ZWdvcnksIHRoaXMubGFiZWwsIGNvbnRlbnQpO1xuICB9O1xuXG4gIExvZ2dlckZhY3RvcnkucHJvdG90eXBlW3RhcmdldE5hbWVdID0gZnVuY3Rpb24gKGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmxldmVsID49IGxldmVsc1t0YXJnZXROYW1lXSkge1xuICAgICAgaWYgKHRoaXMuYnVpbHRpbkVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5wcmludChjb25zb2xlW3RhcmdldE5hbWVdLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IodGFyZ2V0TmFtZSwgY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcblxuTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oY2F0ZWdvcnksIGxhYmVsKSB7XG4gIHZhciBsb2dnZXI7XG5cbiAgaWYgKGxhYmVsICYmIHRoaXMubGV2ZWwgPT09IDMpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLCBjYXRlZ29yeSwgbGFiZWwpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV0pIHtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJzW2NhdGVnb3J5XTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIgPSBuZXcgTG9nZ2VyKHRoaXMsIGNhdGVnb3J5KTtcbiAgICB0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldID0gbG9nZ2VyO1xuICAgIHJldHVybiBsb2dnZXI7XG4gIH1cbn07XG5cbnJldHVybiBMb2dnZXJGYWN0b3J5O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTm9kZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uc29sZSkge1xuXG4vLyBEb24ndCB1c2UgYG5ldyBTSVAuRXZlbnRFbWl0dGVyKClgIGZvciBpbmhlcml0aW5nLlxuLy8gVXNlIE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3RveXBlKTtcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlciAoKSB7XG4gIE5vZGVFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZUV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogRXZlbnRFbWl0dGVyLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHdhcm5pbmcgPSAnJztcbiAgd2FybmluZyArPSAnU0lQLkV2ZW50RW1pdHRlciNvZmYgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIFNJUC5qcyB2ZXJzaW9ucy5cXG4nO1xuICB3YXJuaW5nICs9ICdQbGVhc2UgdXNlIHJlbW92ZUxpc3RlbmVyIG9yIHJlbW92ZUFsbExpc3RlbmVycyBpbnN0ZWFkLlxcbic7XG4gIHdhcm5pbmcgKz0gJ1NlZSBoZXJlIGZvciBtb3JlIGRldGFpbHM6XFxuJztcbiAgd2FybmluZyArPSAnaHR0cDovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19lbWl0dGVyX3JlbW92ZWxpc3RlbmVyX2V2ZW50X2xpc3RlbmVyJztcbiAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG5yZXR1cm4gRXZlbnRFbWl0dGVyO1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9FdmVudEVtaXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V2ZW50cy9ldmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBDb25zdGFudHNcbiAqL1xuXG4vKipcbiAqIFNJUCBDb25zdGFudHMuXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbikge1xucmV0dXJuIHtcbiAgVVNFUl9BR0VOVDogbmFtZSArJy8nKyB2ZXJzaW9uLFxuXG4gIC8vIFNJUCBzY2hlbWVcbiAgU0lQOiAgJ3NpcCcsXG4gIFNJUFM6ICdzaXBzJyxcblxuICAvLyBFbmQgYW5kIEZhaWx1cmUgY2F1c2VzXG4gIGNhdXNlczoge1xuICAgIC8vIEdlbmVyaWMgZXJyb3IgY2F1c2VzXG4gICAgQ09OTkVDVElPTl9FUlJPUjogICAgICAgICAnQ29ubmVjdGlvbiBFcnJvcicsXG4gICAgUkVRVUVTVF9USU1FT1VUOiAgICAgICAgICAnUmVxdWVzdCBUaW1lb3V0JyxcbiAgICBTSVBfRkFJTFVSRV9DT0RFOiAgICAgICAgICdTSVAgRmFpbHVyZSBDb2RlJyxcbiAgICBJTlRFUk5BTF9FUlJPUjogICAgICAgICAgICdJbnRlcm5hbCBFcnJvcicsXG5cbiAgICAvLyBTSVAgZXJyb3IgY2F1c2VzXG4gICAgQlVTWTogICAgICAgICAgICAgICAgICAgICAnQnVzeScsXG4gICAgUkVKRUNURUQ6ICAgICAgICAgICAgICAgICAnUmVqZWN0ZWQnLFxuICAgIFJFRElSRUNURUQ6ICAgICAgICAgICAgICAgJ1JlZGlyZWN0ZWQnLFxuICAgIFVOQVZBSUxBQkxFOiAgICAgICAgICAgICAgJ1VuYXZhaWxhYmxlJyxcbiAgICBOT1RfRk9VTkQ6ICAgICAgICAgICAgICAgICdOb3QgRm91bmQnLFxuICAgIEFERFJFU1NfSU5DT01QTEVURTogICAgICAgJ0FkZHJlc3MgSW5jb21wbGV0ZScsXG4gICAgSU5DT01QQVRJQkxFX1NEUDogICAgICAgICAnSW5jb21wYXRpYmxlIFNEUCcsXG4gICAgQVVUSEVOVElDQVRJT05fRVJST1I6ICAgICAnQXV0aGVudGljYXRpb24gRXJyb3InLFxuICAgIERJQUxPR19FUlJPUjogICAgICAgICAgICAgJ0RpYWxvZyBFcnJvcicsXG5cbiAgICAvLyBTZXNzaW9uIGVycm9yIGNhdXNlc1xuICAgIFdFQlJUQ19OT1RfU1VQUE9SVEVEOiAgICAgJ1dlYlJUQyBOb3QgU3VwcG9ydGVkJyxcbiAgICBXRUJSVENfRVJST1I6ICAgICAgICAgICAgICdXZWJSVEMgRXJyb3InLFxuICAgIENBTkNFTEVEOiAgICAgICAgICAgICAgICAgJ0NhbmNlbGVkJyxcbiAgICBOT19BTlNXRVI6ICAgICAgICAgICAgICAgICdObyBBbnN3ZXInLFxuICAgIEVYUElSRVM6ICAgICAgICAgICAgICAgICAgJ0V4cGlyZXMnLFxuICAgIE5PX0FDSzogICAgICAgICAgICAgICAgICAgJ05vIEFDSycsXG4gICAgTk9fUFJBQ0s6ICAgICAgICAgICAgICAgICAnTm8gUFJBQ0snLFxuICAgIFVTRVJfREVOSUVEX01FRElBX0FDQ0VTUzogJ1VzZXIgRGVuaWVkIE1lZGlhIEFjY2VzcycsXG4gICAgQkFEX01FRElBX0RFU0NSSVBUSU9OOiAgICAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJyxcbiAgICBSVFBfVElNRU9VVDogICAgICAgICAgICAgICdSVFAgVGltZW91dCdcbiAgfSxcblxuICBzdXBwb3J0ZWQ6IHtcbiAgICBVTlNVUFBPUlRFRDogICAgICAgICdub25lJyxcbiAgICBTVVBQT1JURUQ6ICAgICAgICAgICdzdXBwb3J0ZWQnLFxuICAgIFJFUVVJUkVEOiAgICAgICAgICAgJ3JlcXVpcmVkJ1xuICB9LFxuXG4gIFNJUF9FUlJPUl9DQVVTRVM6IHtcbiAgICBSRURJUkVDVEVEOiBbMzAwLDMwMSwzMDIsMzA1LDM4MF0sXG4gICAgQlVTWTogWzQ4Niw2MDBdLFxuICAgIFJFSkVDVEVEOiBbNDAzLDYwM10sXG4gICAgTk9UX0ZPVU5EOiBbNDA0LDYwNF0sXG4gICAgVU5BVkFJTEFCTEU6IFs0ODAsNDEwLDQwOCw0MzBdLFxuICAgIEFERFJFU1NfSU5DT01QTEVURTogWzQ4NF0sXG4gICAgSU5DT01QQVRJQkxFX1NEUDogWzQ4OCw2MDZdLFxuICAgIEFVVEhFTlRJQ0FUSU9OX0VSUk9SOls0MDEsNDA3XVxuICB9LFxuXG4gIC8vIFNJUCBNZXRob2RzXG4gIEFDSzogICAgICAgICdBQ0snLFxuICBCWUU6ICAgICAgICAnQllFJyxcbiAgQ0FOQ0VMOiAgICAgJ0NBTkNFTCcsXG4gIElORk86ICAgICAgICdJTkZPJyxcbiAgSU5WSVRFOiAgICAgJ0lOVklURScsXG4gIE1FU1NBR0U6ICAgICdNRVNTQUdFJyxcbiAgTk9USUZZOiAgICAgJ05PVElGWScsXG4gIE9QVElPTlM6ICAgICdPUFRJT05TJyxcbiAgUkVHSVNURVI6ICAgJ1JFR0lTVEVSJyxcbiAgVVBEQVRFOiAgICAgJ1VQREFURScsXG4gIFNVQlNDUklCRTogICdTVUJTQ1JJQkUnLFxuICBSRUZFUjogICAgICAnUkVGRVInLFxuICBQUkFDSzogICAgICAnUFJBQ0snLFxuXG4gIC8qIFNJUCBSZXNwb25zZSBSZWFzb25zXG4gICAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVyc1xuICAgKiBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdmVyc2F0aWNhL092ZXJTSVAvYmxvYi9tYXN0ZXIvbGliL292ZXJzaXAvc2lwL2NvbnN0YW50cy5yYiNMN1xuICAgKi9cbiAgUkVBU09OX1BIUkFTRToge1xuICAgIDEwMDogJ1RyeWluZycsXG4gICAgMTgwOiAnUmluZ2luZycsXG4gICAgMTgxOiAnQ2FsbCBJcyBCZWluZyBGb3J3YXJkZWQnLFxuICAgIDE4MjogJ1F1ZXVlZCcsXG4gICAgMTgzOiAnU2Vzc2lvbiBQcm9ncmVzcycsXG4gICAgMTk5OiAnRWFybHkgRGlhbG9nIFRlcm1pbmF0ZWQnLCAgLy8gZHJhZnQtaWV0Zi1zaXBjb3JlLTE5OVxuICAgIDIwMDogJ09LJyxcbiAgICAyMDI6ICdBY2NlcHRlZCcsICAvLyBSRkMgMzI2NVxuICAgIDIwNDogJ05vIE5vdGlmaWNhdGlvbicsICAvL1JGQyA1ODM5XG4gICAgMzAwOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxOiAnTW92ZWQgUGVybWFuZW50bHknLFxuICAgIDMwMjogJ01vdmVkIFRlbXBvcmFyaWx5JyxcbiAgICAzMDU6ICdVc2UgUHJveHknLFxuICAgIDM4MDogJ0FsdGVybmF0aXZlIFNlcnZpY2UnLFxuICAgIDQwMDogJ0JhZCBSZXF1ZXN0JyxcbiAgICA0MDE6ICdVbmF1dGhvcml6ZWQnLFxuICAgIDQwMjogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMzogJ0ZvcmJpZGRlbicsXG4gICAgNDA0OiAnTm90IEZvdW5kJyxcbiAgICA0MDU6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgIDQwNjogJ05vdCBBY2NlcHRhYmxlJyxcbiAgICA0MDc6ICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG4gICAgNDA4OiAnUmVxdWVzdCBUaW1lb3V0JyxcbiAgICA0MTA6ICdHb25lJyxcbiAgICA0MTI6ICdDb25kaXRpb25hbCBSZXF1ZXN0IEZhaWxlZCcsICAvLyBSRkMgMzkwM1xuICAgIDQxMzogJ1JlcXVlc3QgRW50aXR5IFRvbyBMYXJnZScsXG4gICAgNDE0OiAnUmVxdWVzdC1VUkkgVG9vIExvbmcnLFxuICAgIDQxNTogJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnLFxuICAgIDQxNjogJ1Vuc3VwcG9ydGVkIFVSSSBTY2hlbWUnLFxuICAgIDQxNzogJ1Vua25vd24gUmVzb3VyY2UtUHJpb3JpdHknLCAgLy8gUkZDIDQ0MTJcbiAgICA0MjA6ICdCYWQgRXh0ZW5zaW9uJyxcbiAgICA0MjE6ICdFeHRlbnNpb24gUmVxdWlyZWQnLFxuICAgIDQyMjogJ1Nlc3Npb24gSW50ZXJ2YWwgVG9vIFNtYWxsJywgIC8vIFJGQyA0MDI4XG4gICAgNDIzOiAnSW50ZXJ2YWwgVG9vIEJyaWVmJyxcbiAgICA0Mjg6ICdVc2UgSWRlbnRpdHkgSGVhZGVyJywgIC8vIFJGQyA0NDc0XG4gICAgNDI5OiAnUHJvdmlkZSBSZWZlcnJlciBJZGVudGl0eScsICAvLyBSRkMgMzg5MlxuICAgIDQzMDogJ0Zsb3cgRmFpbGVkJywgIC8vIFJGQyA1NjI2XG4gICAgNDMzOiAnQW5vbnltaXR5IERpc2FsbG93ZWQnLCAgLy8gUkZDIDUwNzlcbiAgICA0MzY6ICdCYWQgSWRlbnRpdHktSW5mbycsICAvLyBSRkMgNDQ3NFxuICAgIDQzNzogJ1Vuc3VwcG9ydGVkIENlcnRpZmljYXRlJywgIC8vIFJGQyA0NzQ0XG4gICAgNDM4OiAnSW52YWxpZCBJZGVudGl0eSBIZWFkZXInLCAgLy8gUkZDIDQ3NDRcbiAgICA0Mzk6ICdGaXJzdCBIb3AgTGFja3MgT3V0Ym91bmQgU3VwcG9ydCcsICAvLyBSRkMgNTYyNlxuICAgIDQ0MDogJ01heC1CcmVhZHRoIEV4Y2VlZGVkJywgIC8vIFJGQyA1MzkzXG4gICAgNDY5OiAnQmFkIEluZm8gUGFja2FnZScsICAvLyBkcmFmdC1pZXRmLXNpcGNvcmUtaW5mby1ldmVudHNcbiAgICA0NzA6ICdDb25zZW50IE5lZWRlZCcsICAvLyBSRkMgNTM2MFxuICAgIDQ3ODogJ1VucmVzb2x2YWJsZSBEZXN0aW5hdGlvbicsICAvLyBDdXN0b20gY29kZSBjb3BpZWQgZnJvbSBLYW1haWxpby5cbiAgICA0ODA6ICdUZW1wb3JhcmlseSBVbmF2YWlsYWJsZScsXG4gICAgNDgxOiAnQ2FsbC9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdCcsXG4gICAgNDgyOiAnTG9vcCBEZXRlY3RlZCcsXG4gICAgNDgzOiAnVG9vIE1hbnkgSG9wcycsXG4gICAgNDg0OiAnQWRkcmVzcyBJbmNvbXBsZXRlJyxcbiAgICA0ODU6ICdBbWJpZ3VvdXMnLFxuICAgIDQ4NjogJ0J1c3kgSGVyZScsXG4gICAgNDg3OiAnUmVxdWVzdCBUZXJtaW5hdGVkJyxcbiAgICA0ODg6ICdOb3QgQWNjZXB0YWJsZSBIZXJlJyxcbiAgICA0ODk6ICdCYWQgRXZlbnQnLCAgLy8gUkZDIDMyNjVcbiAgICA0OTE6ICdSZXF1ZXN0IFBlbmRpbmcnLFxuICAgIDQ5MzogJ1VuZGVjaXBoZXJhYmxlJyxcbiAgICA0OTQ6ICdTZWN1cml0eSBBZ3JlZW1lbnQgUmVxdWlyZWQnLCAgLy8gUkZDIDMzMjlcbiAgICA1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG4gICAgNTAyOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuICAgIDUwNDogJ1NlcnZlciBUaW1lLW91dCcsXG4gICAgNTA1OiAnVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICA1MTM6ICdNZXNzYWdlIFRvbyBMYXJnZScsXG4gICAgNTgwOiAnUHJlY29uZGl0aW9uIEZhaWx1cmUnLCAgLy8gUkZDIDMzMTJcbiAgICA2MDA6ICdCdXN5IEV2ZXJ5d2hlcmUnLFxuICAgIDYwMzogJ0RlY2xpbmUnLFxuICAgIDYwNDogJ0RvZXMgTm90IEV4aXN0IEFueXdoZXJlJyxcbiAgICA2MDY6ICdOb3QgQWNjZXB0YWJsZSdcbiAgfSxcblxuICAvKiBTSVAgT3B0aW9uIFRhZ3NcbiAgICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzL3NpcC1wYXJhbWV0ZXJzLnhodG1sI3NpcC1wYXJhbWV0ZXJzLTRcbiAgICovXG4gIE9QVElPTl9UQUdTOiB7XG4gICAgJzEwMHJlbCc6ICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzI2MlxuICAgIDE5OTogICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDYyMjhcbiAgICBhbnN3ZXJtb2RlOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1MzczXG4gICAgJ2Vhcmx5LXNlc3Npb24nOiAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzk1OVxuICAgIGV2ZW50bGlzdDogICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQ2NjJcbiAgICBleHBsaWNpdHN1YjogICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQy1pZXRmLXNpcGNvcmUtcmVmZXItZXhwbGljaXQtc3Vic2NyaXB0aW9uLTAzXG4gICAgJ2Zyb20tY2hhbmdlJzogICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDkxNlxuICAgICdnZW9sb2NhdGlvbi1odHRwJzogICAgICAgICB0cnVlLCAgLy8gUkZDIDY0NDJcbiAgICAnZ2VvbG9jYXRpb24tc2lwJzogICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2NDQyXG4gICAgZ2luOiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjE0MFxuICAgIGdydXU6ICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDU2MjdcbiAgICBoaXN0aW5mbzogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA3MDQ0XG4gICAgaWNlOiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTc2OFxuICAgIGpvaW46ICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM5MTFcbiAgICAnbXVsdGlwbGUtcmVmZXInOiAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1MzY4XG4gICAgbm9yZWZlcnN1YjogICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDQ4OFxuICAgIG5vc3ViOiAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDLWlldGYtc2lwY29yZS1yZWZlci1leHBsaWNpdC1zdWJzY3JpcHRpb24tMDNcbiAgICBvdXRib3VuZDogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1NjI2XG4gICAgcGF0aDogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMyN1xuICAgIHBvbGljeTogICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDY3OTRcbiAgICBwcmVjb25kaXRpb246ICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzEyXG4gICAgcHJlZjogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzg0MFxuICAgIHByaXZhY3k6ICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMjNcbiAgICAncmVjaXBpZW50LWxpc3QtaW52aXRlJzogICAgdHJ1ZSwgIC8vIFJGQyA1MzY2XG4gICAgJ3JlY2lwaWVudC1saXN0LW1lc3NhZ2UnOiAgIHRydWUsICAvLyBSRkMgNTM2NVxuICAgICdyZWNpcGllbnQtbGlzdC1zdWJzY3JpYmUnOiB0cnVlLCAgLy8gUkZDIDUzNjdcbiAgICByZXBsYWNlczogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzODkxXG4gICAgJ3Jlc291cmNlLXByaW9yaXR5JzogICAgICAgIHRydWUsICAvLyBSRkMgNDQxMlxuICAgICdzZHAtYW5hdCc6ICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQwOTJcbiAgICAnc2VjLWFncmVlJzogICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzI5XG4gICAgdGRpYWxvZzogICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDUzOFxuICAgIHRpbWVyOiAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQwMjhcbiAgICB1dWk6ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAgIC8vIFJGQyA3NDMzXG4gIH1cbn07XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9Db25zdGFudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4Y2VwdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNJUCBFeGNlcHRpb25zLlxuICogQGF1Z21lbnRzIFNJUFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ29uZmlndXJhdGlvbkVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24ocGFyYW1ldGVyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb2RlID0gMTtcbiAgICAgIHRoaXMubmFtZSA9ICdDT05GSUdVUkFUSU9OX0VSUk9SJztcbiAgICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5tZXNzYWdlID0gKCF0aGlzLnZhbHVlKT8gJ01pc3NpbmcgcGFyYW1ldGVyOiAnKyB0aGlzLnBhcmFtZXRlciA6ICdJbnZhbGlkIHZhbHVlICcrIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpICsnIGZvciBwYXJhbWV0ZXIgXCInKyB0aGlzLnBhcmFtZXRlciArJ1wiJztcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpLFxuXG4gIEludmFsaWRTdGF0ZUVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICB0aGlzLmNvZGUgPSAyO1xuICAgICAgdGhpcy5uYW1lID0gJ0lOVkFMSURfU1RBVEVfRVJST1InO1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAnSW52YWxpZCBzdGF0dXM6ICcgKyBzdGF0dXM7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKSxcblxuICBOb3RTdXBwb3J0ZWRFcnJvcjogKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuY29kZSA9IDM7XG4gICAgICB0aGlzLm5hbWUgPSAnTk9UX1NVUFBPUlRFRF9FUlJPUic7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH07XG4gICAgZXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH0oKSksXG5cbiAgR2V0RGVzY3JpcHRpb25FcnJvcjogKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuY29kZSA9IDQ7XG4gICAgICB0aGlzLm5hbWUgPSAnR0VUX0RFU0NSSVBUSU9OX0VSUk9SJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRXhjZXB0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFRJTUVSU1xuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICovXG52YXJcbiAgVDEgPSA1MDAsXG4gIFQyID0gNDAwMCxcbiAgVDQgPSA1MDAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGltZXJzKSB7XG4gIHZhciBUaW1lcnMgPSB7XG4gICAgVDE6IFQxLFxuICAgIFQyOiBUMixcbiAgICBUNDogVDQsXG4gICAgVElNRVJfQjogNjQgKiBUMSxcbiAgICBUSU1FUl9EOiAwICAqIFQxLFxuICAgIFRJTUVSX0Y6IDY0ICogVDEsXG4gICAgVElNRVJfSDogNjQgKiBUMSxcbiAgICBUSU1FUl9JOiAwICAqIFQxLFxuICAgIFRJTUVSX0o6IDAgICogVDEsXG4gICAgVElNRVJfSzogMCAgKiBUNCxcbiAgICBUSU1FUl9MOiA2NCAqIFQxLFxuICAgIFRJTUVSX006IDY0ICogVDEsXG4gICAgVElNRVJfTjogNjQgKiBUMSxcbiAgICBQUk9WSVNJT05BTF9SRVNQT05TRV9JTlRFUlZBTDogNjAwMDAgIC8vIFNlZSBSRkMgMzI2MSBTZWN0aW9uIDEzLjMuMS4xXG4gIH07XG5cbiAgWydzZXRUaW1lb3V0JywgJ2NsZWFyVGltZW91dCcsICdzZXRJbnRlcnZhbCcsICdjbGVhckludGVydmFsJ11cbiAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBjYW4ndCBqdXN0IHVzZSB0aW1lcnNbbmFtZV0uYmluZCh0aW1lcnMpIHNpbmNlIGl0IGJ5cGFzc2VzIGphc21pbmUnc1xuICAgIC8vIGNsb2NrLW1vY2tpbmdcbiAgICBUaW1lcnNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGltZXJzW25hbWVdLmFwcGx5KHRpbWVycywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gVGltZXJzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVGltZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgTWVzc2FnZSBQYXJzZXJcbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgYW5kIHBhcnNlIGV2ZXJ5IGhlYWRlciBvZiBhIFNJUCBtZXNzYWdlLlxuICogQGF1Z21lbnRzIFNJUFxuICogQG5hbWVzcGFjZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBQYXJzZXI7XG5cbmZ1bmN0aW9uIGdldEhlYWRlcihkYXRhLCBoZWFkZXJTdGFydCkge1xuICB2YXJcbiAgICAvLyAnc3RhcnQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgc3RhcnQgPSBoZWFkZXJTdGFydCxcbiAgICAvLyAnZW5kJyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIGVuZCA9IDAsXG4gICAgLy8gJ3BhcnRpYWwgZW5kJyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIHBhcnRpYWxFbmQgPSAwO1xuXG4gIC8vRW5kIG9mIG1lc3NhZ2UuXG4gIGlmIChkYXRhLnN1YnN0cmluZyhzdGFydCwgc3RhcnQgKyAyKS5tYXRjaCgvKF5cXHJcXG4pLykpIHtcbiAgICByZXR1cm4gLTI7XG4gIH1cblxuICB3aGlsZShlbmQgPT09IDApIHtcbiAgICAvLyBQYXJ0aWFsIEVuZCBvZiBIZWFkZXIuXG4gICAgcGFydGlhbEVuZCA9IGRhdGEuaW5kZXhPZignXFxyXFxuJywgc3RhcnQpO1xuXG4gICAgLy8gJ2luZGV4T2YnIHJldHVybnMgLTEgaWYgdGhlIHZhbHVlIHRvIGJlIGZvdW5kIG5ldmVyIG9jY3Vycy5cbiAgICBpZiAocGFydGlhbEVuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsRW5kO1xuICAgIH1cblxuICAgIGlmKCFkYXRhLnN1YnN0cmluZyhwYXJ0aWFsRW5kICsgMiwgcGFydGlhbEVuZCArIDQpLm1hdGNoKC8oXlxcclxcbikvKSAmJiBkYXRhLmNoYXJBdChwYXJ0aWFsRW5kICsgMikubWF0Y2goLyheXFxzKykvKSkge1xuICAgICAgLy8gTm90IHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2UuIENvbnRpbnVlIGZyb20gdGhlIG5leHQgcG9zaXRpb24uXG4gICAgICBzdGFydCA9IHBhcnRpYWxFbmQgKyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBwYXJ0aWFsRW5kO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKG1lc3NhZ2UsIGRhdGEsIGhlYWRlclN0YXJ0LCBoZWFkZXJFbmQpIHtcbiAgdmFyIGhlYWRlciwgaWR4LCBsZW5ndGgsIHBhcnNlZCxcbiAgICBoY29sb25JbmRleCA9IGRhdGEuaW5kZXhPZignOicsIGhlYWRlclN0YXJ0KSxcbiAgICBoZWFkZXJOYW1lID0gZGF0YS5zdWJzdHJpbmcoaGVhZGVyU3RhcnQsIGhjb2xvbkluZGV4KS50cmltKCksXG4gICAgaGVhZGVyVmFsdWUgPSBkYXRhLnN1YnN0cmluZyhoY29sb25JbmRleCArIDEsIGhlYWRlckVuZCkudHJpbSgpO1xuXG4gIC8vIElmIGhlYWRlci1maWVsZCBpcyB3ZWxsLWtub3duLCBwYXJzZSBpdC5cbiAgc3dpdGNoKGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3ZpYSc6XG4gICAgY2FzZSAndic6XG4gICAgICBtZXNzYWdlLmFkZEhlYWRlcigndmlhJywgaGVhZGVyVmFsdWUpO1xuICAgICAgaWYobWVzc2FnZS5nZXRIZWFkZXJzKCd2aWEnKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignVmlhJyk7XG4gICAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICAgIG1lc3NhZ2UudmlhID0gcGFyc2VkO1xuICAgICAgICAgIG1lc3NhZ2UudmlhX2JyYW5jaCA9IHBhcnNlZC5icmFuY2g7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmcm9tJzpcbiAgICBjYXNlICdmJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdmcm9tJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignZnJvbScpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UuZnJvbSA9IHBhcnNlZDtcbiAgICAgICAgbWVzc2FnZS5mcm9tX3RhZyA9IHBhcnNlZC5nZXRQYXJhbSgndGFnJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0byc6XG4gICAgY2FzZSAndCc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcigndG8nLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd0bycpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UudG8gPSBwYXJzZWQ7XG4gICAgICAgIG1lc3NhZ2UudG9fdGFnID0gcGFyc2VkLmdldFBhcmFtKCd0YWcnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY29yZC1yb3V0ZSc6XG4gICAgICBwYXJzZWQgPSBTSVAuR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgJ1JlY29yZF9Sb3V0ZScpO1xuXG4gICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBwYXJzZWQubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHBhcnNlZFtpZHhdO1xuICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcigncmVjb3JkLXJvdXRlJywgaGVhZGVyVmFsdWUuc3Vic3RyaW5nKGhlYWRlci5wb3NpdGlvbiwgaGVhZGVyLm9mZnNldCkpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlcnNbJ1JlY29yZC1Sb3V0ZSddW21lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJykubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NhbGwtaWQnOlxuICAgIGNhc2UgJ2knOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NhbGwtaWQnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjYWxsLWlkJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5jYWxsX2lkID0gaGVhZGVyVmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb250YWN0JzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKGhlYWRlclZhbHVlLCAnQ29udGFjdCcpO1xuXG4gICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBwYXJzZWQubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHBhcnNlZFtpZHhdO1xuICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcignY29udGFjdCcsIGhlYWRlclZhbHVlLnN1YnN0cmluZyhoZWFkZXIucG9zaXRpb24sIGhlYWRlci5vZmZzZXQpKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzWydDb250YWN0J11bbWVzc2FnZS5nZXRIZWFkZXJzKCdjb250YWN0JykubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnQtbGVuZ3RoJzpcbiAgICBjYXNlICdsJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb250ZW50LXR5cGUnOlxuICAgIGNhc2UgJ2MnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY3NlcSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY3NlcScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NzZXEnKTtcbiAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLmNzZXEgPSBwYXJzZWQudmFsdWU7XG4gICAgICB9XG4gICAgICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICAgICAgbWVzc2FnZS5tZXRob2QgPSBwYXJzZWQubWV0aG9kO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWF4LWZvcndhcmRzJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdtYXgtZm9yd2FyZHMnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdtYXgtZm9yd2FyZHMnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3d3dy1hdXRoZW50aWNhdGUnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3d3dy1hdXRoZW50aWNhdGUnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcm94eS1hdXRoZW50aWNhdGUnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3Byb3h5LWF1dGhlbnRpY2F0ZScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3Byb3h5LWF1dGhlbnRpY2F0ZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVmZXItdG8nOlxuICAgIGNhc2UgJ3InOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3JlZmVyLXRvJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcigncmVmZXItdG8nKTtcbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5yZWZlcl90byA9IHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBEbyBub3QgcGFyc2UgdGhpcyBoZWFkZXIuXG4gICAgICBtZXNzYWdlLnNldEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSAwO1xuICB9XG5cbiAgaWYgKHBhcnNlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAnZXJyb3IgcGFyc2luZyBoZWFkZXIgXCInKyBoZWFkZXJOYW1lICsnXCInXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKiogUGFyc2UgU0lQIE1lc3NhZ2VcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgU0lQIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nZ2VyIG9iamVjdC5cbiAqIEByZXR1cm5zIHtTSVAuSW5jb21pbmdSZXF1ZXN0fFNJUC5JbmNvbWluZ1Jlc3BvbnNlfHVuZGVmaW5lZH1cbiAqL1xuUGFyc2VyID0ge307XG5QYXJzZXIucGFyc2VNZXNzYWdlID0gZnVuY3Rpb24oZGF0YSwgdWEpIHtcbiAgdmFyIG1lc3NhZ2UsIGZpcnN0TGluZSwgY29udGVudExlbmd0aCwgYm9keVN0YXJ0LCBwYXJzZWQsXG4gICAgaGVhZGVyU3RhcnQgPSAwLFxuICAgIGhlYWRlckVuZCA9IGRhdGEuaW5kZXhPZignXFxyXFxuJyksXG4gICAgbG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAucGFyc2VyJyk7XG5cbiAgaWYoaGVhZGVyRW5kID09PSAtMSkge1xuICAgIGxvZ2dlci53YXJuKCdubyBDUkxGIGZvdW5kLCBub3QgYSBTSVAgbWVzc2FnZSwgZGlzY2FyZGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUGFyc2UgZmlyc3QgbGluZS4gQ2hlY2sgaWYgaXQgaXMgYSBSZXF1ZXN0IG9yIGEgUmVwbHkuXG4gIGZpcnN0TGluZSA9IGRhdGEuc3Vic3RyaW5nKDAsIGhlYWRlckVuZCk7XG4gIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKGZpcnN0TGluZSwgJ1JlcXVlc3RfUmVzcG9uc2UnKTtcblxuICBpZihwYXJzZWQgPT09IC0xKSB7XG4gICAgbG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgZmlyc3QgbGluZSBvZiBTSVAgbWVzc2FnZTogXCInICsgZmlyc3RMaW5lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYoIXBhcnNlZC5zdGF0dXNfY29kZSkge1xuICAgIG1lc3NhZ2UgPSBuZXcgU0lQLkluY29taW5nUmVxdWVzdCh1YSk7XG4gICAgbWVzc2FnZS5tZXRob2QgPSBwYXJzZWQubWV0aG9kO1xuICAgIG1lc3NhZ2UucnVyaSA9IHBhcnNlZC51cmk7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IG5ldyBTSVAuSW5jb21pbmdSZXNwb25zZSh1YSk7XG4gICAgbWVzc2FnZS5zdGF0dXNfY29kZSA9IHBhcnNlZC5zdGF0dXNfY29kZTtcbiAgICBtZXNzYWdlLnJlYXNvbl9waHJhc2UgPSBwYXJzZWQucmVhc29uX3BocmFzZTtcbiAgfVxuXG4gIG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG4gIGhlYWRlclN0YXJ0ID0gaGVhZGVyRW5kICsgMjtcblxuICAvKiBMb29wIG92ZXIgZXZlcnkgbGluZSBpbiBkYXRhLiBEZXRlY3QgdGhlIGVuZCBvZiBlYWNoIGhlYWRlciBhbmQgcGFyc2VcbiAgKiBpdCBvciBzaW1wbHkgYWRkIHRvIHRoZSBoZWFkZXJzIGNvbGxlY3Rpb24uXG4gICovXG4gIHdoaWxlKHRydWUpIHtcbiAgICBoZWFkZXJFbmQgPSBnZXRIZWFkZXIoZGF0YSwgaGVhZGVyU3RhcnQpO1xuXG4gICAgLy8gVGhlIFNJUCBtZXNzYWdlIGhhcyBub3JtYWxseSBmaW5pc2hlZC5cbiAgICBpZihoZWFkZXJFbmQgPT09IC0yKSB7XG4gICAgICBib2R5U3RhcnQgPSBoZWFkZXJTdGFydCArIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gZGF0YS5pbmRleE9mIHJldHVybmVkIC0xIGR1ZSB0byBhIG1hbGZvcm1lZCBtZXNzYWdlLlxuICAgIGVsc2UgaWYoaGVhZGVyRW5kID09PSAtMSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdtYWxmb3JtZWQgbWVzc2FnZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IHBhcnNlSGVhZGVyKG1lc3NhZ2UsIGRhdGEsIGhlYWRlclN0YXJ0LCBoZWFkZXJFbmQpO1xuXG4gICAgaWYocGFyc2VkICE9PSB0cnVlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IocGFyc2VkLmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoZWFkZXJTdGFydCA9IGhlYWRlckVuZCArIDI7XG4gIH1cblxuICAvKiBSRkMzMjYxIDE4LjMuXG4gICAqIElmIHRoZXJlIGFyZSBhZGRpdGlvbmFsIGJ5dGVzIGluIHRoZSB0cmFuc3BvcnQgcGFja2V0XG4gICAqIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBib2R5LCB0aGV5IE1VU1QgYmUgZGlzY2FyZGVkLlxuICAgKi9cbiAgaWYobWVzc2FnZS5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgbWVzc2FnZS5ib2R5ID0gZGF0YS5zdWJzdHIoYm9keVN0YXJ0LCBjb250ZW50TGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cmluZyhib2R5U3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5TSVAuUGFyc2VyID0gUGFyc2VyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvUGFyc2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgTWVzc2FnZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyXG4gIE91dGdvaW5nUmVxdWVzdCxcbiAgSW5jb21pbmdNZXNzYWdlLFxuICBJbmNvbWluZ1JlcXVlc3QsXG4gIEluY29taW5nUmVzcG9uc2U7XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZEhlYWRlciAocmVxdWVzdCkge1xuICB2YXIgYWxsb3dVbnJlZ2lzdGVyZWQgPSByZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24uaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncztcbiAgdmFyIG9wdGlvblRhZ3MgPSBbXTtcbiAgdmFyIG9wdGlvblRhZ1NldCA9IHt9O1xuXG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuUkVHSVNURVIpIHtcbiAgICBvcHRpb25UYWdzLnB1c2goJ3BhdGgnLCAnZ3J1dScpO1xuICB9IGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiZcbiAgICAgICAgICAgICAocmVxdWVzdC51YS5jb250YWN0LnB1Yl9ncnV1IHx8IHJlcXVlc3QudWEuY29udGFjdC50ZW1wX2dydXUpKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCdncnV1Jyk7XG4gIH1cblxuICBpZiAocmVxdWVzdC51YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgIG9wdGlvblRhZ3MucHVzaCgnMTAwcmVsJyk7XG4gIH1cbiAgaWYgKHJlcXVlc3QudWEuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgIG9wdGlvblRhZ3MucHVzaCgncmVwbGFjZXMnKTtcbiAgfVxuXG4gIG9wdGlvblRhZ3MucHVzaCgnb3V0Ym91bmQnKTtcblxuICBvcHRpb25UYWdzID0gb3B0aW9uVGFncy5jb25jYXQocmVxdWVzdC51YS5jb25maWd1cmF0aW9uLmV4dHJhU3VwcG9ydGVkKTtcblxuICBvcHRpb25UYWdzID0gb3B0aW9uVGFncy5maWx0ZXIoZnVuY3Rpb24ob3B0aW9uVGFnKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWQgPSBTSVAuQy5PUFRJT05fVEFHU1tvcHRpb25UYWddO1xuICAgIHZhciB1bmlxdWUgPSAhb3B0aW9uVGFnU2V0W29wdGlvblRhZ107XG4gICAgb3B0aW9uVGFnU2V0W29wdGlvblRhZ10gPSB0cnVlO1xuICAgIHJldHVybiAocmVnaXN0ZXJlZCB8fCBhbGxvd1VucmVnaXN0ZXJlZCkgJiYgdW5pcXVlO1xuICB9KTtcblxuICByZXR1cm4gJ1N1cHBvcnRlZDogJyArIG9wdGlvblRhZ3Muam9pbignLCAnKSArICdcXHJcXG4nO1xufVxuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBmb3Igb3V0Z29pbmcgU0lQIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIHJlcXVlc3QgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gcnVyaSByZXF1ZXN0IHVyaVxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGhhdmUgcHJpb3JpdHkgb3ZlciB1YS5jb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gKiA8YnI+XG4gKiAgLSBjc2VxLCBjYWxsX2lkLCBmcm9tX3RhZywgZnJvbV91cmksIGZyb21fZGlzcGxheU5hbWUsIHRvX3VyaSwgdG9fdGFnLCByb3V0ZV9zZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gZXh0cmEgaGVhZGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IFtib2R5XVxuICovXG5PdXRnb2luZ1JlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHJ1cmksIHVhLCBwYXJhbXMsIGV4dHJhSGVhZGVycywgYm9keSkge1xuICB2YXJcbiAgICB0byxcbiAgICBmcm9tLFxuICAgIGNhbGxfaWQsXG4gICAgY3NlcSxcbiAgICB0b191cmksXG4gICAgZnJvbV91cmk7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIC8vIE1hbmRhdG9yeSBwYXJhbWV0ZXJzIGNoZWNrXG4gIGlmKCFtZXRob2QgfHwgIXJ1cmkgfHwgIXVhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNpcG1lc3NhZ2UnKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMucnVyaSA9IHJ1cmk7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gKGV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgdGhpcy5zdGF0dXNDb2RlID0gcGFyYW1zLnN0YXR1c19jb2RlO1xuICB0aGlzLnJlYXNvblBocmFzZSA9IHBhcmFtcy5yZWFzb25fcGhyYXNlO1xuXG4gIC8vIEZpbGwgdGhlIENvbW1vbiBTSVAgUmVxdWVzdCBIZWFkZXJzXG5cbiAgLy8gUm91dGVcbiAgaWYgKHBhcmFtcy5yb3V0ZV9zZXQpIHtcbiAgICB0aGlzLnNldEhlYWRlcigncm91dGUnLCBwYXJhbXMucm91dGVfc2V0KTtcbiAgfSBlbHNlIGlmICh1YS5jb25maWd1cmF0aW9uLnVzZVByZWxvYWRlZFJvdXRlKXtcbiAgICB0aGlzLnNldEhlYWRlcigncm91dGUnLCB1YS50cmFuc3BvcnQuc2VydmVyLnNpcF91cmkpO1xuICB9XG5cbiAgLy8gVmlhXG4gIC8vIEVtcHR5IFZpYSBoZWFkZXIuIFdpbGwgYmUgZmlsbGVkIGJ5IHRoZSBjbGllbnQgdHJhbnNhY3Rpb24uXG4gIHRoaXMuc2V0SGVhZGVyKCd2aWEnLCAnJyk7XG5cbiAgLy8gTWF4LUZvcndhcmRzXG4gIHRoaXMuc2V0SGVhZGVyKCdtYXgtZm9yd2FyZHMnLCBTSVAuVUEuQy5NQVhfRk9SV0FSRFMpO1xuXG4gIC8vIFRvXG4gIHRvX3VyaSA9IHBhcmFtcy50b191cmkgfHwgcnVyaTtcbiAgdG8gPSAocGFyYW1zLnRvX2Rpc3BsYXlOYW1lIHx8IHBhcmFtcy50b19kaXNwbGF5TmFtZSA9PT0gMCkgPyAnXCInICsgcGFyYW1zLnRvX2Rpc3BsYXlOYW1lICsgJ1wiICcgOiAnJztcbiAgdG8gKz0gJzwnICsgKHRvX3VyaSAmJiB0b191cmkudG9SYXcgPyB0b191cmkudG9SYXcoKSA6IHRvX3VyaSkgKyAnPic7XG4gIHRvICs9IHBhcmFtcy50b190YWcgPyAnO3RhZz0nICsgcGFyYW1zLnRvX3RhZyA6ICcnO1xuICB0aGlzLnRvID0gbmV3IFNJUC5OYW1lQWRkckhlYWRlci5wYXJzZSh0byk7XG4gIHRoaXMuc2V0SGVhZGVyKCd0bycsIHRvKTtcblxuICAvLyBGcm9tXG4gIGZyb21fdXJpID0gcGFyYW1zLmZyb21fdXJpIHx8IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuICBpZiAocGFyYW1zLmZyb21fZGlzcGxheU5hbWUgfHwgcGFyYW1zLmZyb21fZGlzcGxheU5hbWUgPT09IDApIHtcbiAgICBmcm9tID0gJ1wiJyArIHBhcmFtcy5mcm9tX2Rpc3BsYXlOYW1lICsgJ1wiICc7XG4gIH0gZWxzZSBpZiAodWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZSkge1xuICAgIGZyb20gPSAnXCInICsgdWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZSArICdcIiAnO1xuICB9IGVsc2Uge1xuICAgIGZyb20gPSAnJztcbiAgfVxuICBmcm9tICs9ICc8JyArIChmcm9tX3VyaSAmJiBmcm9tX3VyaS50b1JhdyA/IGZyb21fdXJpLnRvUmF3KCkgOiBmcm9tX3VyaSkgKyAnPjt0YWc9JztcbiAgZnJvbSArPSBwYXJhbXMuZnJvbV90YWcgfHwgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB0aGlzLmZyb20gPSBuZXcgU0lQLk5hbWVBZGRySGVhZGVyLnBhcnNlKGZyb20pO1xuICB0aGlzLnNldEhlYWRlcignZnJvbScsIGZyb20pO1xuXG4gIC8vIENhbGwtSURcbiAgY2FsbF9pZCA9IHBhcmFtcy5jYWxsX2lkIHx8ICh1YS5jb25maWd1cmF0aW9uLnNpcGpzSWQgKyBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMTUpKTtcbiAgdGhpcy5jYWxsX2lkID0gY2FsbF9pZDtcbiAgdGhpcy5zZXRIZWFkZXIoJ2NhbGwtaWQnLCBjYWxsX2lkKTtcblxuICAvLyBDU2VxXG4gIGNzZXEgPSBwYXJhbXMuY3NlcSB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gIHRoaXMuY3NlcSA9IGNzZXE7XG4gIHRoaXMuc2V0SGVhZGVyKCdjc2VxJywgY3NlcSArICcgJyArIG1ldGhvZCk7XG59O1xuXG5PdXRnb2luZ1JlcXVlc3QucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogUmVwbGFjZSB0aGUgdGhlIGdpdmVuIGhlYWRlciBieSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IHZhbHVlIGhlYWRlciB2YWx1ZVxuICAgKi9cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIG5hbWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgdW5kZWZpbmVkIGlmIGhlYWRlciBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZ2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2V4cCwgaWR4LFxuICAgICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoLFxuICAgICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldO1xuXG4gICAgaWYoaGVhZGVyKSB7XG4gICAgICBpZihoZWFkZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlclswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKicgKyBuYW1lICsgJ1xcXFxzKjonLCdpJyk7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gdGhpcy5leHRyYUhlYWRlcnNbaWR4XTtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICByZXR1cm4gaGVhZGVyLnN1YnN0cmluZyhoZWFkZXIuaW5kZXhPZignOicpKzEpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFsbCB0aGUgaGVhZGVycyBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBnZXRIZWFkZXJzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkeCwgbGVuZ3RoLCByZWdleHAsXG4gICAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0sXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgIGlmKGhlYWRlcikge1xuICAgICAgbGVuZ3RoID0gaGVhZGVyLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICByZXN1bHQucHVzaChoZWFkZXJbaWR4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGg7XG4gICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqOicsJ2knKTtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLmV4dHJhSGVhZGVyc1tpZHhdO1xuICAgICAgICBpZiAocmVnZXhwLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGhlYWRlci5zdWJzdHJpbmcoaGVhZGVyLmluZGV4T2YoJzonKSsxKS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBleGlzdGVuY2Ugb2YgdGhlIGdpdmVuIGhlYWRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzSGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2V4cCwgaWR4LFxuICAgICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyonICsgbmFtZSArICdcXFxccyo6JywnaScpO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmIChyZWdleHAudGVzdCh0aGlzLmV4dHJhSGVhZGVyc1tpZHhdKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbXNnID0gJycsIGhlYWRlciwgbGVuZ3RoLCBpZHg7XG5cbiAgICBtc2cgKz0gdGhpcy5tZXRob2QgKyAnICcgKyAodGhpcy5ydXJpLnRvUmF3ID8gdGhpcy5ydXJpLnRvUmF3KCkgOiB0aGlzLnJ1cmkpICsgJyBTSVAvMi4wXFxyXFxuJztcblxuICAgIGZvciAoaGVhZGVyIGluIHRoaXMuaGVhZGVycykge1xuICAgICAgbGVuZ3RoID0gdGhpcy5oZWFkZXJzW2hlYWRlcl0ubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIG1zZyArPSBoZWFkZXIgKyAnOiAnICsgdGhpcy5oZWFkZXJzW2hlYWRlcl1baWR4XSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHRoaXMuZXh0cmFIZWFkZXJzLmxlbmd0aDtcbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIG1zZyArPSB0aGlzLmV4dHJhSGVhZGVyc1tpZHhdLnRyaW0oKSArJ1xcclxcbic7XG4gICAgfVxuXG4gICAgbXNnICs9IGdldFN1cHBvcnRlZEhlYWRlcih0aGlzKTtcbiAgICBtc2cgKz0gJ1VzZXItQWdlbnQ6ICcgKyB0aGlzLnVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nICsnXFxyXFxuJztcblxuICAgIGlmKHRoaXMuYm9keSkge1xuICAgICAgbGVuZ3RoID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aCh0aGlzLmJvZHkpO1xuICAgICAgbXNnICs9ICdDb250ZW50LUxlbmd0aDogJyArIGxlbmd0aCArICdcXHJcXG5cXHJcXG4nO1xuICAgICAgbXNnICs9IHRoaXMuYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnICs9ICdDb250ZW50LUxlbmd0aDogMFxcclxcblxcclxcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1zZztcbiAgfVxufTtcblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgZm9yIGluY29taW5nIFNJUCBtZXNzYWdlLlxuICovXG5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbigpe1xuICB0aGlzLmRhdGEgPSBudWxsO1xuICB0aGlzLmhlYWRlcnMgPSBudWxsO1xuICB0aGlzLm1ldGhvZCA9ICBudWxsO1xuICB0aGlzLnZpYSA9IG51bGw7XG4gIHRoaXMudmlhX2JyYW5jaCA9IG51bGw7XG4gIHRoaXMuY2FsbF9pZCA9IG51bGw7XG4gIHRoaXMuY3NlcSA9IG51bGw7XG4gIHRoaXMuZnJvbSA9IG51bGw7XG4gIHRoaXMuZnJvbV90YWcgPSBudWxsO1xuICB0aGlzLnRvID0gbnVsbDtcbiAgdGhpcy50b190YWcgPSBudWxsO1xuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICogSW5zZXJ0IGEgaGVhZGVyIG9mIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZSBpbnRvIHRoZSBsYXN0IHBvc2l0aW9uIG9mIHRoZVxuICAqIGhlYWRlciBhcnJheS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBoZWFkZXIgdmFsdWVcbiAgKi9cbiAgYWRkSGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBoZWFkZXIgPSB7IHJhdzogdmFsdWUgfTtcblxuICAgIG5hbWUgPSBTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpO1xuXG4gICAgaWYodGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0ucHVzaChoZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBuYW1lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIHNwZWNpZmllZCBoZWFkZXIsIG51bGwgaWYgaGVhZGVyIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldO1xuXG4gICAgaWYoaGVhZGVyKSB7XG4gICAgICBpZihoZWFkZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlclswXS5yYXc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVhZGVyL3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBhbGwgdGhlIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgKi9cbiAgZ2V0SGVhZGVyczogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZHgsIGxlbmd0aCxcbiAgICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYoIWhlYWRlcikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IGhlYWRlci5sZW5ndGg7XG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICByZXN1bHQucHVzaChoZWFkZXJbaWR4XS5yYXcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBoZWFkZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGhlYWRlciB3aXRoIGdpdmVuIG5hbWUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGhhc0hlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybih0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0pID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgb24gdGhlIGdpdmVuIGluZGV4LlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtpZHg9MF0gaGVhZGVyIGluZGV4XG4gICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IFBhcnNlZCBoZWFkZXIgb2JqZWN0LCB1bmRlZmluZWQgaWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCBvciBpbiBjYXNlIG9mIGEgcGFyc2luZyBlcnJvci5cbiAgKi9cbiAgcGFyc2VIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIGlkeCkge1xuICAgIHZhciBoZWFkZXIsIHZhbHVlLCBwYXJzZWQ7XG5cbiAgICBuYW1lID0gU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKTtcblxuICAgIGlkeCA9IGlkeCB8fCAwO1xuXG4gICAgaWYoIXRoaXMuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdoZWFkZXIgXCInICsgbmFtZSArICdcIiBub3QgcHJlc2VudCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZihpZHggPj0gdGhpcy5oZWFkZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdub3Qgc28gbWFueSBcIicgKyBuYW1lICsgJ1wiIGhlYWRlcnMgcHJlc2VudCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tuYW1lXVtpZHhdO1xuICAgIHZhbHVlID0gaGVhZGVyLnJhdztcblxuICAgIGlmKGhlYWRlci5wYXJzZWQpIHtcbiAgICAgIHJldHVybiBoZWFkZXIucGFyc2VkO1xuICAgIH1cblxuICAgIC8vc3Vic3RpdHV0ZSAnLScgYnkgJ18nIGZvciBncmFtbWFyIHJ1bGUgbWF0Y2hpbmcuXG4gICAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UodmFsdWUsIG5hbWUucmVwbGFjZSgvLS9nLCAnXycpKTtcblxuICAgIGlmKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXS5zcGxpY2UoaWR4LCAxKTsgLy9kZWxldGUgZnJvbSBoZWFkZXJzXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdlcnJvciBwYXJzaW5nIFwiJyArIG5hbWUgKyAnXCIgaGVhZGVyIGZpZWxkIHdpdGggdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNZXNzYWdlIEhlYWRlciBhdHRyaWJ1dGUgc2VsZWN0b3IuIEFsaWFzIG9mIHBhcnNlSGVhZGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2lkeD0wXSBoZWFkZXIgaW5kZXhcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IFBhcnNlZCBoZWFkZXIgb2JqZWN0LCB1bmRlZmluZWQgaWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCBvciBpbiBjYXNlIG9mIGEgcGFyc2luZyBlcnJvci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbWVzc2FnZS5zKCd2aWEnLDMpLnBvcnRcbiAgICovXG4gIHM6IGZ1bmN0aW9uKG5hbWUsIGlkeCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlSGVhZGVyKG5hbWUsIGlkeCk7XG4gIH0sXG5cbiAgLyoqXG4gICogUmVwbGFjZSB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBieSB0aGUgdmFsdWUuXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgaGVhZGVyIHZhbHVlXG4gICovXG4gIHNldEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaGVhZGVyID0geyByYXc6IHZhbHVlIH07XG4gICAgdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldID0gW2hlYWRlcl07XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQGF1Z21lbnRzIEluY29taW5nTWVzc2FnZVxuICogQGNsYXNzIENsYXNzIGZvciBpbmNvbWluZyBTSVAgcmVxdWVzdC5cbiAqL1xuSW5jb21pbmdSZXF1ZXN0ID0gZnVuY3Rpb24odWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zaXBtZXNzYWdlJyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG4gIHRoaXMucnVyaSA9IG51bGw7XG4gIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgdGhpcy5zZXJ2ZXJfdHJhbnNhY3Rpb24gPSBudWxsO1xufTtcbkluY29taW5nUmVxdWVzdC5wcm90b3R5cGUgPSBuZXcgSW5jb21pbmdNZXNzYWdlKCk7XG5cbi8qKlxuKiBTdGF0ZWZ1bCByZXBseS5cbiogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgc3RhdHVzIGNvZGVcbiogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiByZWFzb24gcGhyYXNlXG4qIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIGV4dHJhIGhlYWRlcnNcbiogQHBhcmFtIHtTdHJpbmd9IGJvZHkgYm9keVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBvblN1Y2Nlc3MgY2FsbGJhY2tcbiogQHBhcmFtIHtGdW5jdGlvbn0gW29uRmFpbHVyZV0gb25GYWlsdXJlIGNhbGxiYWNrXG4qL1xuSW5jb21pbmdSZXF1ZXN0LnByb3RvdHlwZS5yZXBseSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgZXh0cmFIZWFkZXJzLCBib2R5LCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICB2YXIgcnIsIHZpYXMsIGxlbmd0aCwgaWR4LCByZXNwb25zZSxcbiAgICB0byA9IHRoaXMuZ2V0SGVhZGVyKCdUbycpLFxuICAgIHIgPSAwLFxuICAgIHYgPSAwO1xuXG4gIHJlc3BvbnNlID0gU0lQLlV0aWxzLmJ1aWxkU3RhdHVzTGluZShjb2RlLCByZWFzb24pO1xuICBleHRyYUhlYWRlcnMgPSAoZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gIGlmKHRoaXMubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiYgY29kZSA+IDEwMCAmJiBjb2RlIDw9IDIwMCkge1xuICAgIHJyID0gdGhpcy5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKTtcbiAgICBsZW5ndGggPSByci5sZW5ndGg7XG5cbiAgICBmb3IocjsgciA8IGxlbmd0aDsgcisrKSB7XG4gICAgICByZXNwb25zZSArPSAnUmVjb3JkLVJvdXRlOiAnICsgcnJbcl0gKyAnXFxyXFxuJztcbiAgICB9XG4gIH1cblxuICB2aWFzID0gdGhpcy5nZXRIZWFkZXJzKCd2aWEnKTtcbiAgbGVuZ3RoID0gdmlhcy5sZW5ndGg7XG5cbiAgZm9yKHY7IHYgPCBsZW5ndGg7IHYrKykge1xuICAgIHJlc3BvbnNlICs9ICdWaWE6ICcgKyB2aWFzW3ZdICsgJ1xcclxcbic7XG4gIH1cblxuICBpZighdGhpcy50b190YWcgJiYgY29kZSA+IDEwMCkge1xuICAgIHRvICs9ICc7dGFnPScgKyBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIH0gZWxzZSBpZih0aGlzLnRvX3RhZyAmJiAhdGhpcy5zKCd0bycpLmhhc1BhcmFtKCd0YWcnKSkge1xuICAgIHRvICs9ICc7dGFnPScgKyB0aGlzLnRvX3RhZztcbiAgfVxuXG4gIHJlc3BvbnNlICs9ICdUbzogJyArIHRvICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdGcm9tOiAnICsgdGhpcy5nZXRIZWFkZXIoJ0Zyb20nKSArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ2FsbC1JRDogJyArIHRoaXMuY2FsbF9pZCArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ1NlcTogJyArIHRoaXMuY3NlcSArICcgJyArIHRoaXMubWV0aG9kICsgJ1xcclxcbic7XG5cbiAgbGVuZ3RoID0gZXh0cmFIZWFkZXJzLmxlbmd0aDtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgcmVzcG9uc2UgKz0gZXh0cmFIZWFkZXJzW2lkeF0udHJpbSgpICsnXFxyXFxuJztcbiAgfVxuXG4gIHJlc3BvbnNlICs9IGdldFN1cHBvcnRlZEhlYWRlcih0aGlzKTtcbiAgcmVzcG9uc2UgKz0gJ1VzZXItQWdlbnQ6ICcgKyB0aGlzLnVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nICsnXFxyXFxuJztcblxuICBpZihib2R5KSB7XG4gICAgbGVuZ3RoID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aChib2R5KTtcbiAgICByZXNwb25zZSArPSAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHBcXHJcXG4nO1xuICAgIHJlc3BvbnNlICs9ICdDb250ZW50LUxlbmd0aDogJyArIGxlbmd0aCArICdcXHJcXG5cXHJcXG4nO1xuICAgIHJlc3BvbnNlICs9IGJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgMCArICdcXHJcXG5cXHJcXG4nO1xuICB9XG5cbiAgdGhpcy5zZXJ2ZXJfdHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKGNvZGUsIHJlc3BvbnNlKS50aGVuKG9uU3VjY2Vzcywgb25GYWlsdXJlKTtcblxuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG4vKipcbiogU3RhdGVsZXNzIHJlcGx5LlxuKiBAcGFyYW0ge051bWJlcn0gY29kZSBzdGF0dXMgY29kZVxuKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIHJlYXNvbiBwaHJhc2VcbiovXG5JbmNvbWluZ1JlcXVlc3QucHJvdG90eXBlLnJlcGx5X3NsID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIHZhciB0bywgcmVzcG9uc2UsXG4gICAgdiA9IDAsXG4gICAgdmlhcyA9IHRoaXMuZ2V0SGVhZGVycygndmlhJyksXG4gICAgbGVuZ3RoID0gdmlhcy5sZW5ndGg7XG5cbiAgcmVzcG9uc2UgPSBTSVAuVXRpbHMuYnVpbGRTdGF0dXNMaW5lKGNvZGUsIHJlYXNvbik7XG5cbiAgZm9yKHY7IHYgPCBsZW5ndGg7IHYrKykge1xuICAgIHJlc3BvbnNlICs9ICdWaWE6ICcgKyB2aWFzW3ZdICsgJ1xcclxcbic7XG4gIH1cblxuICB0byA9IHRoaXMuZ2V0SGVhZGVyKCdUbycpO1xuXG4gIGlmKCF0aGlzLnRvX3RhZyAmJiBjb2RlID4gMTAwKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIFNJUC5VdGlscy5uZXdUYWcoKTtcbiAgfSBlbHNlIGlmKHRoaXMudG9fdGFnICYmICF0aGlzLnMoJ3RvJykuaGFzUGFyYW0oJ3RhZycpKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIHRoaXMudG9fdGFnO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gJ1RvOiAnICsgdG8gKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0Zyb206ICcgKyB0aGlzLmdldEhlYWRlcignRnJvbScpICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDYWxsLUlEOiAnICsgdGhpcy5jYWxsX2lkICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDU2VxOiAnICsgdGhpcy5jc2VxICsgJyAnICsgdGhpcy5tZXRob2QgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ1VzZXItQWdlbnQ6ICcgKyB0aGlzLnVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nICsnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgMCArICdcXHJcXG5cXHJcXG4nO1xuXG4gIHRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpO1xufTtcblxuXG4vKipcbiAqIEBhdWdtZW50cyBJbmNvbWluZ01lc3NhZ2VcbiAqIEBjbGFzcyBDbGFzcyBmb3IgaW5jb21pbmcgU0lQIHJlc3BvbnNlLlxuICovXG5JbmNvbWluZ1Jlc3BvbnNlID0gZnVuY3Rpb24odWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zaXBtZXNzYWdlJyk7XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuICB0aGlzLnN0YXR1c19jb2RlID0gbnVsbDtcbiAgdGhpcy5yZWFzb25fcGhyYXNlID0gbnVsbDtcbn07XG5JbmNvbWluZ1Jlc3BvbnNlLnByb3RvdHlwZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UoKTtcblxuU0lQLk91dGdvaW5nUmVxdWVzdCA9IE91dGdvaW5nUmVxdWVzdDtcblNJUC5JbmNvbWluZ1JlcXVlc3QgPSBJbmNvbWluZ1JlcXVlc3Q7XG5TSVAuSW5jb21pbmdSZXNwb25zZSA9IEluY29taW5nUmVzcG9uc2U7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TSVBNZXNzYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gMjIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgVVJJXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgVVJJLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NoZW1lXVxuICogQHBhcmFtIHtTdHJpbmd9IFt1c2VyXVxuICogQHBhcmFtIHtTdHJpbmd9IGhvc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcG9ydF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc11cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFVSSTtcblxuVVJJID0gZnVuY3Rpb24oc2NoZW1lLCB1c2VyLCBob3N0LCBwb3J0LCBwYXJhbWV0ZXJzLCBoZWFkZXJzKSB7XG4gIHZhciBwYXJhbSwgaGVhZGVyLCByYXcsIG5vcm1hbDtcblxuICAvLyBDaGVja3NcbiAgaWYoIWhvc3QpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIG9yIGludmFsaWQgXCJob3N0XCIgcGFyYW1ldGVyJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHBhcmFtZXRlcnNcbiAgc2NoZW1lID0gc2NoZW1lIHx8IFNJUC5DLlNJUDtcbiAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuXG4gIGZvciAocGFyYW0gaW4gcGFyYW1ldGVycykge1xuICAgIHRoaXMuc2V0UGFyYW0ocGFyYW0sIHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgfVxuXG4gIGZvciAoaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICB0aGlzLnNldEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gIH1cblxuICAvLyBSYXcgVVJJXG4gIHJhdyA9IHtcbiAgICBzY2hlbWU6IHNjaGVtZSxcbiAgICB1c2VyOiB1c2VyLFxuICAgIGhvc3Q6IGhvc3QsXG4gICAgcG9ydDogcG9ydFxuICB9O1xuXG4gIC8vIE5vcm1hbGl6ZWQgVVJJXG4gIG5vcm1hbCA9IHtcbiAgICBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLFxuICAgIHVzZXI6IHVzZXIsXG4gICAgaG9zdDogaG9zdC50b0xvd2VyQ2FzZSgpLFxuICAgIHBvcnQ6IHBvcnRcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgX25vcm1hbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbDsgfVxuICAgIH0sXG5cbiAgICBfcmF3OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmF3OyB9XG4gICAgfSxcblxuICAgIHNjaGVtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC5zY2hlbWU7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJhdy5zY2hlbWUgPSB2YWx1ZTtcbiAgICAgICAgbm9ybWFsLnNjaGVtZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVzZXI6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwudXNlcjsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgbm9ybWFsLnVzZXIgPSByYXcudXNlciA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBob3N0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLmhvc3Q7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJhdy5ob3N0ID0gdmFsdWU7XG4gICAgICAgIG5vcm1hbC5ob3N0ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYW9yOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnVzZXIgKyAnQCcgKyBub3JtYWwuaG9zdDsgfVxuICAgIH0sXG5cbiAgICBwb3J0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnBvcnQ7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG5vcm1hbC5wb3J0ID0gcmF3LnBvcnQgPSB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogKHBhcnNlSW50KHZhbHVlLDEwKSB8fCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuVVJJLnByb3RvdHlwZSA9IHtcbiAgc2V0UGFyYW06IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkgPyBudWxsIDogdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQYXJhbTogZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gIH0sXG5cbiAgaGFzUGFyYW06IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmKGtleSkge1xuICAgICAgcmV0dXJuICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoa2V5LnRvTG93ZXJDYXNlKCkpICYmIHRydWUpIHx8IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBkZWxldGVQYXJhbTogZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYXJQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuICB9LFxuXG4gIHNldEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0gPSAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gIH0sXG5cbiAgZ2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXTtcbiAgICB9XG4gIH0sXG5cbiAgaGFzSGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYobmFtZSkge1xuICAgICAgcmV0dXJuICh0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKSkgJiYgdHJ1ZSkgfHwgZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZUhlYWRlcjogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGhlYWRlciA9IFNJUC5VdGlscy5oZWFkZXJpemUoaGVhZGVyKTtcbiAgICBpZih0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLmhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYXJIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBVUkkoXG4gICAgICB0aGlzLl9yYXcuc2NoZW1lLFxuICAgICAgdGhpcy5fcmF3LnVzZXIsXG4gICAgICB0aGlzLl9yYXcuaG9zdCxcbiAgICAgIHRoaXMuX3Jhdy5wb3J0LFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpKSxcbiAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKSkpO1xuICB9LFxuXG4gIHRvUmF3OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fcmF3KTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nKHRoaXMuX25vcm1hbCk7XG4gIH0sXG5cbiAgX3RvU3RyaW5nOiBmdW5jdGlvbih1cmkpIHtcbiAgICB2YXIgaGVhZGVyLCBwYXJhbWV0ZXIsIGlkeCwgdXJpU3RyaW5nLCBoZWFkZXJzID0gW107XG5cbiAgICB1cmlTdHJpbmcgID0gdXJpLnNjaGVtZSArICc6JztcbiAgICAvLyBhZGQgc2xhc2hlcyBpZiBpdCdzIG5vdCBhIHNpcChzKSBVUklcbiAgICBpZiAoIXVyaS5zY2hlbWUudG9Mb3dlckNhc2UoKS5tYXRjaChcIl5zaXBzPyRcIikpIHtcbiAgICAgIHVyaVN0cmluZyArPSBcIi8vXCI7XG4gICAgfVxuICAgIGlmICh1cmkudXNlcikge1xuICAgICAgdXJpU3RyaW5nICs9IFNJUC5VdGlscy5lc2NhcGVVc2VyKHVyaS51c2VyKSArICdAJztcbiAgICB9XG4gICAgdXJpU3RyaW5nICs9IHVyaS5ob3N0O1xuICAgIGlmICh1cmkucG9ydCB8fCB1cmkucG9ydCA9PT0gMCkge1xuICAgICAgdXJpU3RyaW5nICs9ICc6JyArIHVyaS5wb3J0O1xuICAgIH1cblxuICAgIGZvciAocGFyYW1ldGVyIGluIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgdXJpU3RyaW5nICs9ICc7JyArIHBhcmFtZXRlcjtcblxuICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgIHVyaVN0cmluZyArPSAnPScrIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcihoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICBmb3IoaWR4IGluIHRoaXMuaGVhZGVyc1toZWFkZXJdKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChoZWFkZXIgKyAnPScgKyB0aGlzLmhlYWRlcnNbaGVhZGVyXVtpZHhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gJz8nICsgaGVhZGVycy5qb2luKCcmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaVN0cmluZztcbiAgfVxufTtcblxuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIGEgU0lQLlVSSSBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWZcbiAgKiBpdCBpcyBhbiBpbnZhbGlkIFVSSS5cbiAgKiBAcHVibGljXG4gICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICAqL1xuVVJJLnBhcnNlID0gZnVuY3Rpb24odXJpKSB7XG4gIHVyaSA9IFNJUC5HcmFtbWFyLnBhcnNlKHVyaSwnU0lQX1VSSScpO1xuXG4gIGlmICh1cmkgIT09IC0xKSB7XG4gICAgcmV0dXJuIHVyaTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5TSVAuVVJJID0gVVJJO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVVJJLmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgTmFtZUFkZHJIZWFkZXJcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIE5hbWUgQWRkcmVzcyBTSVAgaGVhZGVyLlxuICpcbiAqIEBwYXJhbSB7U0lQLlVSSX0gdXJpXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Rpc3BsYXlOYW1lXVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgTmFtZUFkZHJIZWFkZXI7XG5cbk5hbWVBZGRySGVhZGVyID0gZnVuY3Rpb24odXJpLCBkaXNwbGF5TmFtZSwgcGFyYW1ldGVycykge1xuICB2YXIgcGFyYW07XG5cbiAgLy8gQ2hlY2tzXG4gIGlmKCF1cmkgfHwgISh1cmkgaW5zdGFuY2VvZiBTSVAuVVJJKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBcInVyaVwiIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzXG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcblxuICBmb3IgKHBhcmFtIGluIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNldFBhcmFtKHBhcmFtLCBwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgZnJpZW5kbHlOYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5TmFtZSB8fCB1cmkuYW9yOyB9XG4gICAgfSxcblxuICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGlzcGxheU5hbWU7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGRpc3BsYXlOYW1lID0gKHZhbHVlID09PSAwKSA/ICcwJyA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuTmFtZUFkZHJIZWFkZXIucHJvdG90eXBlID0ge1xuICBzZXRQYXJhbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkgPyBudWxsIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIGdldFBhcmFtOiBTSVAuVVJJLnByb3RvdHlwZS5nZXRQYXJhbSxcbiAgaGFzUGFyYW06IFNJUC5VUkkucHJvdG90eXBlLmhhc1BhcmFtLFxuICBkZWxldGVQYXJhbTogU0lQLlVSSS5wcm90b3R5cGUuZGVsZXRlUGFyYW0sXG4gIGNsZWFyUGFyYW1zOiBTSVAuVVJJLnByb3RvdHlwZS5jbGVhclBhcmFtcyxcblxuICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lQWRkckhlYWRlcihcbiAgICAgIHRoaXMudXJpLmNsb25lKCksXG4gICAgICB0aGlzLmRpc3BsYXlOYW1lLFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpKSk7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5LCBwYXJhbWV0ZXI7XG5cbiAgICBib2R5ICA9ICh0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMuZGlzcGxheU5hbWUgPT09IDApID8gJ1wiJyArIHRoaXMuZGlzcGxheU5hbWUgKyAnXCIgJyA6ICcnO1xuICAgIGJvZHkgKz0gJzwnICsgdGhpcy51cmkudG9TdHJpbmcoKSArICc+JztcblxuICAgIGZvciAocGFyYW1ldGVyIGluIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgYm9keSArPSAnOycgKyBwYXJhbWV0ZXI7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXSAhPT0gbnVsbCkge1xuICAgICAgICBib2R5ICs9ICc9JysgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn07XG5cblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyBhIFNJUC5OYW1lQWRkckhlYWRlciBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWZcbiAgKiBpdCBpcyBhbiBpbnZhbGlkIE5hbWVBZGRySGVhZGVyLlxuICAqIEBwdWJsaWNcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZV9hZGRyX2hlYWRlclxuICAqL1xuTmFtZUFkZHJIZWFkZXIucGFyc2UgPSBmdW5jdGlvbihuYW1lX2FkZHJfaGVhZGVyKSB7XG4gIG5hbWVfYWRkcl9oZWFkZXIgPSBTSVAuR3JhbW1hci5wYXJzZShuYW1lX2FkZHJfaGVhZGVyLCdOYW1lX0FkZHJfSGVhZGVyJyk7XG5cbiAgaWYgKG5hbWVfYWRkcl9oZWFkZXIgIT09IC0xKSB7XG4gICAgcmV0dXJuIG5hbWVfYWRkcl9oZWFkZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuU0lQLk5hbWVBZGRySGVhZGVyID0gTmFtZUFkZHJIZWFkZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogU0lQIFRyYW5zYWN0aW9ucyBtb2R1bGUuXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyXG4gIEMgPSB7XG4gICAgLy8gVHJhbnNhY3Rpb24gc3RhdGVzXG4gICAgU1RBVFVTX1RSWUlORzogICAgIDEsXG4gICAgU1RBVFVTX1BST0NFRURJTkc6IDIsXG4gICAgU1RBVFVTX0NBTExJTkc6ICAgIDMsXG4gICAgU1RBVFVTX0FDQ0VQVEVEOiAgIDQsXG4gICAgU1RBVFVTX0NPTVBMRVRFRDogIDUsXG4gICAgU1RBVFVTX1RFUk1JTkFURUQ6IDYsXG4gICAgU1RBVFVTX0NPTkZJUk1FRDogIDcsXG5cbiAgICAvLyBUcmFuc2FjdGlvbiB0eXBlc1xuICAgIE5PTl9JTlZJVEVfQ0xJRU5UOiAnbmljdCcsXG4gICAgTk9OX0lOVklURV9TRVJWRVI6ICduaXN0JyxcbiAgICBJTlZJVEVfQ0xJRU5UOiAnaWN0JyxcbiAgICBJTlZJVEVfU0VSVkVSOiAnaXN0J1xuICB9O1xuXG5mdW5jdGlvbiBidWlsZFZpYUhlYWRlciAocmVxdWVzdF9zZW5kZXIsIHRyYW5zcG9ydCwgaWQpIHtcbiAgdmFyIHZpYTtcbiAgdmlhID0gJ1NJUC8yLjAvJyArIChyZXF1ZXN0X3NlbmRlci51YS5jb25maWd1cmF0aW9uLmhhY2tWaWFUY3AgPyAnVENQJyA6IHRyYW5zcG9ydC5zZXJ2ZXIuc2NoZW1lKTtcbiAgdmlhICs9ICcgJyArIHJlcXVlc3Rfc2VuZGVyLnVhLmNvbmZpZ3VyYXRpb24udmlhSG9zdCArICc7YnJhbmNoPScgKyBpZDtcbiAgaWYgKHJlcXVlc3Rfc2VuZGVyLnVhLmNvbmZpZ3VyYXRpb24uZm9yY2VScG9ydCkge1xuICAgIHZpYSArPSAnO3Jwb3J0JztcbiAgfVxuICByZXR1cm4gdmlhO1xufVxuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIE5vbiBJbnZpdGUgQ2xpZW50IFRyYW5zYWN0aW9uXG4qIEBwYXJhbSB7U0lQLlJlcXVlc3RTZW5kZXJ9IHJlcXVlc3Rfc2VuZGVyXG4qIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuKi9cbnZhciBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3Rfc2VuZGVyLCByZXF1ZXN0LCB0cmFuc3BvcnQpIHtcbiAgdmFyIHZpYTtcblxuICB0aGlzLnR5cGUgPSBDLk5PTl9JTlZJVEVfQ0xJRU5UO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy5pZCA9ICd6OWhHNGJLJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlciA9IHJlcXVlc3Rfc2VuZGVyO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIHRoaXMubG9nZ2VyID0gcmVxdWVzdF9zZW5kZXIudWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24ubmljdCcsIHRoaXMuaWQpO1xuXG4gIHZpYSA9IGJ1aWxkVmlhSGVhZGVyKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCd2aWEnLCB2aWEpO1xuXG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHIgPSB0aGlzO1xuXG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RSWUlORyk7XG4gIHRoaXMuRiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9GLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0YpO1xuXG4gIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMucmVxdWVzdCkpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIG5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5GKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5LKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9GID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgRiBleHBpcmVkIGZvciBub24tSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblJlcXVlc3RUaW1lb3V0KCk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyXG4gICAgdHIgPSB0aGlzLFxuICAgIHN0YXR1c19jb2RlID0gcmVzcG9uc2Uuc3RhdHVzX2NvZGU7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPCAyMDApIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1BST0NFRURJTkcpO1xuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NPTVBMRVRFRCk7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuRik7XG5cbiAgICAgICAgaWYoc3RhdHVzX2NvZGUgPT09IDQwOCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuSyA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9LLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIEludml0ZSBDbGllbnQgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuUmVxdWVzdFNlbmRlcn0gcmVxdWVzdF9zZW5kZXJcbiogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4qL1xudmFyIEludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdF9zZW5kZXIsIHJlcXVlc3QsIHRyYW5zcG9ydCkge1xuICB2YXIgdmlhLFxuICAgIHRyID0gdGhpcztcblxuICB0aGlzLnR5cGUgPSBDLklOVklURV9DTElFTlQ7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLmlkID0gJ3o5aEc0YksnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyID0gcmVxdWVzdF9zZW5kZXI7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgdGhpcy5sb2dnZXIgPSByZXF1ZXN0X3NlbmRlci51YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5pY3QnLCB0aGlzLmlkKTtcblxuICB2aWEgPSBidWlsZFZpYUhlYWRlcihyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCB0aGlzLmlkKTtcbiAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcigndmlhJywgdmlhKTtcblxuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLm5ld1RyYW5zYWN0aW9uKHRoaXMpO1xuXG4gIC8vIEFkZCB0aGUgY2FuY2VsIHByb3BlcnR5IHRvIHRoZSByZXF1ZXN0LlxuICAvL1dpbGwgYmUgY2FsbGVkIGZyb20gdGhlIHJlcXVlc3QgaW5zdGFuY2UsIG5vdCB0aGUgdHJhbnNhY3Rpb24gaXRzZWxmLlxuICB0aGlzLnJlcXVlc3QuY2FuY2VsID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgdHIuY2FuY2VsX3JlcXVlc3QodHIsIHJlYXNvbik7XG4gIH07XG59O1xuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHIgPSB0aGlzO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DQUxMSU5HKTtcbiAgdGhpcy5CID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0IuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfQik7XG5cbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5yZXF1ZXN0KSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZGVsZXRpbmcgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuRCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuTSk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcblxuICBpZiAodGhpcy5zdGF0ZSAhPT0gQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuLy8gUkZDIDYwMjYgNy4yXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfTSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIE0gZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkIpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG4vLyBSRkMgMzI2MSAxNy4xLjFcbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9CID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgQiBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQ0FMTElORykge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIub25SZXF1ZXN0VGltZW91dCgpO1xuICB9XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfRCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEQgZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kQUNLID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIHRyID0gdGhpcztcblxuICB0aGlzLmFjayA9ICdBQ0sgJyArIHRoaXMucmVxdWVzdC5ydXJpICsgJyBTSVAvMi4wXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ1ZpYTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydWaWEnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG5cbiAgaWYodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10pIHtcbiAgICB0aGlzLmFjayArPSAnUm91dGU6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snUm91dGUnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIH1cblxuICB0aGlzLmFjayArPSAnVG86ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3RvJykgKyAnXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0Zyb206ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snRnJvbSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0NhbGwtSUQ6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ2FsbC1JRCddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAwXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0NTZXE6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ1NlcSddLnRvU3RyaW5nKCkuc3BsaXQoJyAnKVswXTtcbiAgdGhpcy5hY2sgKz0gJyBBQ0tcXHJcXG5cXHJcXG4nO1xuXG4gIHRoaXMuRCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9ELmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0QpO1xuXG4gIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5hY2spO1xufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLmNhbmNlbF9yZXF1ZXN0ID0gZnVuY3Rpb24odHIsIHJlYXNvbikge1xuICB2YXIgcmVxdWVzdCA9IHRyLnJlcXVlc3Q7XG5cbiAgdGhpcy5jYW5jZWwgPSBTSVAuQy5DQU5DRUwgKyAnICcgKyByZXF1ZXN0LnJ1cmkgKyAnIFNJUC8yLjBcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnVmlhOiAnICsgcmVxdWVzdC5oZWFkZXJzWydWaWEnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG5cbiAgaWYodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10pIHtcbiAgICB0aGlzLmNhbmNlbCArPSAnUm91dGU6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB9XG5cbiAgdGhpcy5jYW5jZWwgKz0gJ1RvOiAnICsgcmVxdWVzdC5oZWFkZXJzWydUbyddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5jYW5jZWwgKz0gJ0Zyb206ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ0Zyb20nXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdDYWxsLUlEOiAnICsgcmVxdWVzdC5oZWFkZXJzWydDYWxsLUlEJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnQ1NlcTogJyArIHJlcXVlc3QuaGVhZGVyc1snQ1NlcSddLnRvU3RyaW5nKCkuc3BsaXQoJyAnKVswXSArXG4gICcgQ0FOQ0VMXFxyXFxuJztcblxuICBpZihyZWFzb24pIHtcbiAgICB0aGlzLmNhbmNlbCArPSAnUmVhc29uOiAnICsgcmVhc29uICsgJ1xcclxcbic7XG4gIH1cblxuICB0aGlzLmNhbmNlbCArPSAnQ29udGVudC1MZW5ndGg6IDBcXHJcXG5cXHJcXG4nO1xuXG4gIC8vIFNlbmQgb25seSBpZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlICg+MTAwKSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfUFJPQ0VFRElORykge1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5jYW5jZWwpO1xuICB9XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyXG4gIHRyID0gdGhpcyxcbiAgc3RhdHVzX2NvZGUgPSByZXNwb25zZS5zdGF0dXNfY29kZTtcblxuICBpZihzdGF0dXNfY29kZSA+PSAxMDAgJiYgc3RhdHVzX2NvZGUgPD0gMTk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ0FMTElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfUFJPQ0VFRElORyk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMuY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAyMDAgJiYgc3RhdHVzX2NvZGUgPD0gMjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ0FMTElORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQUNDRVBURUQpO1xuICAgICAgICB0aGlzLk0gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfTS5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9NKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQUNDRVBURUQ6XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMzAwICYmIHN0YXR1c19jb2RlIDw9IDY5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NBTExJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NPTVBMRVRFRCk7XG4gICAgICAgIHRoaXMuc2VuZEFDSyhyZXNwb25zZSk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgdGhpcy5zZW5kQUNLKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiAqIEBjbGFzcyBBQ0sgQ2xpZW50IFRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NJUC5SZXF1ZXN0U2VuZGVyfSByZXF1ZXN0X3NlbmRlclxuICogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuICovXG52YXIgQWNrQ2xpZW50VHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0X3NlbmRlciwgcmVxdWVzdCwgdHJhbnNwb3J0KSB7XG4gIHZhciB2aWE7XG5cbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMuaWQgPSAnejloRzRiSycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIgPSByZXF1ZXN0X3NlbmRlcjtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICB0aGlzLmxvZ2dlciA9IHJlcXVlc3Rfc2VuZGVyLnVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLm5pY3QnLCB0aGlzLmlkKTtcblxuICB2aWEgPSBidWlsZFZpYUhlYWRlcihyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCB0aGlzLmlkKTtcbiAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcigndmlhJywgdmlhKTtcbn07XG5BY2tDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQWNrQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5yZXF1ZXN0KSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG5BY2tDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZm9yIGFuIEFDSyBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbn07XG5cblxuLyoqXG4qIEBhdWdtZW50cyBTSVAuVHJhbnNhY3Rpb25zXG4qIEBjbGFzcyBOb24gSW52aXRlIFNlcnZlciBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVUF9IHVhXG4qL1xudmFyIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdCwgdWEpIHtcbiAgdGhpcy50eXBlID0gQy5OT05fSU5WSVRFX1NFUlZFUjtcbiAgdGhpcy5pZCA9IHJlcXVlc3QudmlhX2JyYW5jaDtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgdGhpcy50cmFuc3BvcnQgPSByZXF1ZXN0LnRyYW5zcG9ydDtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxhc3RfcmVzcG9uc2UgPSAnJztcbiAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24gPSB0aGlzO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24ubmlzdCcsIHRoaXMuaWQpO1xuXG4gIHRoaXMuc3RhdGUgPSBDLlNUQVRVU19UUllJTkc7XG5cbiAgdWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEogZXhwaXJlZCBmb3Igbm9uLUlOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudHJhbnNwb3J0RXJyb3IpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEVycm9yID0gdHJ1ZTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBub24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkopO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24oc3RhdHVzX2NvZGUsIHJlc3BvbnNlKSB7XG4gIHZhciB0ciA9IHRoaXM7XG4gIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuXG4gIGlmKHN0YXR1c19jb2RlID09PSAxMDApIHtcbiAgICAvKiBSRkMgNDMyMCA0LjFcbiAgICAgKiAnQSBTSVAgZWxlbWVudCBNVVNUIE5PVFxuICAgICAqIHNlbmQgYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggYVxuICAgICAqIFN0YXR1cy1Db2RlIG90aGVyIHRoYW4gMTAwIHRvIGEgbm9uLUlOVklURSByZXF1ZXN0LidcbiAgICAgKi9cbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1BST0NFRURJTkcpO1xuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpICB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMubGFzdF9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMjAwICYmIHN0YXR1c19jb2RlIDw9IDY5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuSiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9KLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0opO1xuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIEludml0ZSBTZXJ2ZXIgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlVBfSB1YVxuKi9cbnZhciBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3QsIHVhKSB7XG4gIHRoaXMudHlwZSA9IEMuSU5WSVRFX1NFUlZFUjtcbiAgdGhpcy5pZCA9IHJlcXVlc3QudmlhX2JyYW5jaDtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgdGhpcy50cmFuc3BvcnQgPSByZXF1ZXN0LnRyYW5zcG9ydDtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxhc3RfcmVzcG9uc2UgPSAnJztcbiAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24gPSB0aGlzO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24uaXN0JywgdGhpcy5pZCk7XG5cbiAgdGhpcy5zdGF0ZSA9IEMuU1RBVFVTX1BST0NFRURJTkc7XG5cbiAgdWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG5cbiAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gbnVsbDtcblxuICByZXF1ZXN0LnJlcGx5KDEwMCk7XG59O1xuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEggZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQ09NUExFVEVEKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybigndHJhbnNhY3Rpb25zJywgJ0FDSyBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiB3YXMgbmV2ZXIgcmVjZWl2ZWQsIGNhbGwgd2lsbCBiZSB0ZXJtaW5hdGVkJyk7XG4gIH1cblxuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG4vLyBSRkMgNjAyNiA3LjFcbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9MID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgTCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudHJhbnNwb3J0RXJyb3IpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEVycm9yID0gdHJ1ZTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICAgIGlmICh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIpO1xuICAgICAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkwpO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuSCk7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5JKTtcblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVzZW5kX3Byb3Zpc2lvbmFsID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMubGFzdF9yZXNwb25zZSkpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuLy8gSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbiBSRkMgMzI2MSAxNy4yLjFcbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihzdGF0dXNfY29kZSwgcmVzcG9uc2UpIHtcbiAgdmFyIHRyID0gdGhpcztcbiAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPj0gMTAwICYmIHN0YXR1c19jb2RlIDw9IDE5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdF9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZihzdGF0dXNfY29kZSA+IDEwMCAmJiBzdGF0dXNfY29kZSA8PSAxOTkgJiYgdGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfUFJPQ0VFRElORykge1xuICAgIC8vIFRyaWdnZXIgdGhlIHJlc2VuZFByb3Zpc2lvbmFsVGltZXIgb25seSBmb3IgdGhlIGZpcnN0IG5vbiAxMDAgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgaWYodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBTSVAuVGltZXJzLnNldEludGVydmFsKHRyLnJlc2VuZF9wcm92aXNpb25hbC5iaW5kKHRyKSxcbiAgICAgICAgU0lQLlRpbWVycy5QUk9WSVNJT05BTF9SRVNQT05TRV9JTlRFUlZBTCk7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMjAwICYmIHN0YXR1c19jb2RlIDw9IDI5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0FDQ0VQVEVEKTtcbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuTCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9MLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0wpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyKTtcbiAgICAgICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSBDLlNUQVRVU19BQ0NFUFRFRDpcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBwb2ludCB3aWxsIGJlIHJlYWNoZWQgZm9yIHByb2NlZWRpbmcgdHIuc3RhdGUgYWxzby5cbiAgICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMzAwICYmIHN0YXR1c19jb2RlIDw9IDY5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIGlmICh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyKTtcbiAgICAgICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgICB0aGlzLkggPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfSC5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9IKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogSU5WSVRFOlxuICogIF90cnVlXyBpZiByZXRyYW5zbWlzc2lvblxuICogIF9mYWxzZV8gbmV3IHJlcXVlc3RcbiAqXG4gKiBBQ0s6XG4gKiAgX3RydWVfICBBQ0sgdG8gbm9uMnh4IHJlc3BvbnNlXG4gKiAgX2ZhbHNlXyBBQ0sgbXVzdCBiZSBwYXNzZWQgdG8gVFUgKGFjY2VwdGVkIHN0YXRlKVxuICogICAgICAgICAgQUNLIHRvIDJ4eCByZXNwb25zZVxuICpcbiAqIENBTkNFTDpcbiAqICBfdHJ1ZV8gIG5vIG1hdGNoaW5nIGludml0ZSB0cmFuc2FjdGlvblxuICogIF9mYWxzZV8gbWF0Y2hpbmcgaW52aXRlIHRyYW5zYWN0aW9uIGFuZCBubyBmaW5hbCByZXNwb25zZSBzZW50XG4gKlxuICogT1RIRVI6XG4gKiAgX3RydWVfICByZXRyYW5zbWlzc2lvblxuICogIF9mYWxzZV8gbmV3IHJlcXVlc3RcbiAqL1xudmFyIGNoZWNrVHJhbnNhY3Rpb24gPSBmdW5jdGlvbih1YSwgcmVxdWVzdCkge1xuICB2YXIgdHI7XG5cbiAgc3dpdGNoKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbcmVxdWVzdC52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHN3aXRjaCh0ci5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgICAgIHRyLnRyYW5zcG9ydC5zZW5kKHRyLmxhc3RfcmVzcG9uc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MDI2IDcuMSBJbnZpdGUgcmV0cmFuc21pc3Npb25cbiAgICAgICAgICAgIC8vcmVjZWl2ZWQgd2hpbGUgaW4gQy5TVEFUVVNfQUNDRVBURUQgc3RhdGUuIEFic29yYiBpdC5cbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX0FDQ0VQVEVEOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLkFDSzpcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuXG4gICAgICAvLyBSRkMgNjAyNiA3LjFcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIGlmKHRyLnN0YXRlID09PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmKHRyLnN0YXRlID09PSBDLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICAgICAgICB0ci5zdGF0ZSA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICB0ci5JID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0kuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQUNLIHRvIDJYWCBSZXNwb25zZS5cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLkNBTkNFTDpcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseV9zbCgyMDApO1xuICAgICAgICBpZih0ci5zdGF0ZSA9PT0gQy5TVEFUVVNfUFJPQ0VFRElORykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg0ODEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG5cbiAgICAgIC8vIE5vbi1JTlZJVEUgU2VydmVyIFRyYW5zYWN0aW9uIFJGQyAzMjYxIDE3LjIuMlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMubmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgc3dpdGNoKHRyLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19DT01QTEVURUQ6XG4gICAgICAgICAgICB0ci50cmFuc3BvcnQuc2VuZCh0ci5sYXN0X3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNJUC5UcmFuc2FjdGlvbnMgPSB7XG4gIEM6IEMsXG4gIGNoZWNrVHJhbnNhY3Rpb246IGNoZWNrVHJhbnNhY3Rpb24sXG4gIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uOiBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbixcbiAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb246IEludml0ZUNsaWVudFRyYW5zYWN0aW9uLFxuICBBY2tDbGllbnRUcmFuc2FjdGlvbjogQWNrQ2xpZW50VHJhbnNhY3Rpb24sXG4gIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uOiBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbixcbiAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb246IEludml0ZVNlcnZlclRyYW5zYWN0aW9uXG59O1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9UcmFuc2FjdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBEaWFsb2dcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBkaWFsb2cuXG4gKiBAcGFyYW0ge1NJUC5SVENTZXNzaW9ufSBvd25lclxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fFNJUC5JbmNvbWluZ1Jlc3BvbnNlfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0VudW19IHR5cGUgVUFDIC8gVUFTXG4gKiBAcGFyYW0ge0VudW19IHN0YXRlIFNJUC5EaWFsb2cuQy5TVEFUVVNfRUFSTFkgLyBTSVAuRGlhbG9nLkMuU1RBVFVTX0NPTkZJUk1FRFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIFJlcXVlc3RTZW5kZXIgPSByZXF1aXJlKCcuL0RpYWxvZy9SZXF1ZXN0U2VuZGVyJykoU0lQKTtcblxudmFyIERpYWxvZyxcbiAgQyA9IHtcbiAgICAvLyBEaWFsb2cgc3RhdGVzXG4gICAgU1RBVFVTX0VBUkxZOiAgICAgICAxLFxuICAgIFNUQVRVU19DT05GSVJNRUQ6ICAgMlxuICB9O1xuXG4vLyBSRkMgMzI2MSAxMi4xXG5EaWFsb2cgPSBmdW5jdGlvbihvd25lciwgbWVzc2FnZSwgdHlwZSwgc3RhdGUpIHtcbiAgdmFyIGNvbnRhY3Q7XG5cbiAgdGhpcy51YWNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuICB0aGlzLnVhc19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG5cbiAgaWYoIW1lc3NhZ2UuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICd1bmFibGUgdG8gY3JlYXRlIGEgRGlhbG9nIHdpdGhvdXQgQ29udGFjdCBoZWFkZXIgZmllbGQnXG4gICAgfTtcbiAgfVxuXG4gIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgIHN0YXRlID0gKG1lc3NhZ2Uuc3RhdHVzX2NvZGUgPCAyMDApID8gQy5TVEFUVVNfRUFSTFkgOiBDLlNUQVRVU19DT05GSVJNRUQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3JlYXRlIGNvbmZpcm1lZCBkaWFsb2cgaWYgc3RhdGUgaXMgbm90IGRlZmluZWRcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgfVxuXG4gIGNvbnRhY3QgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjb250YWN0Jyk7XG5cbiAgLy8gUkZDIDMyNjEgMTIuMS4xXG4gIGlmKHR5cGUgPT09ICdVQVMnKSB7XG4gICAgdGhpcy5pZCA9IHtcbiAgICAgIGNhbGxfaWQ6IG1lc3NhZ2UuY2FsbF9pZCxcbiAgICAgIGxvY2FsX3RhZzogbWVzc2FnZS50b190YWcsXG4gICAgICByZW1vdGVfdGFnOiBtZXNzYWdlLmZyb21fdGFnLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsX2lkICsgdGhpcy5sb2NhbF90YWcgKyB0aGlzLnJlbW90ZV90YWc7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5yZW1vdGVfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcigndG8nKS51cmk7XG4gICAgdGhpcy5yZW1vdGVfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcignZnJvbScpLnVyaTtcbiAgICB0aGlzLnJlbW90ZV90YXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICB0aGlzLnJvdXRlX3NldCA9IG1lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJyk7XG4gICAgdGhpcy5pbnZpdGVfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICB9XG4gIC8vIFJGQyAzMjYxIDEyLjEuMlxuICBlbHNlIGlmKHR5cGUgPT09ICdVQUMnKSB7XG4gICAgdGhpcy5pZCA9IHtcbiAgICAgIGNhbGxfaWQ6IG1lc3NhZ2UuY2FsbF9pZCxcbiAgICAgIGxvY2FsX3RhZzogbWVzc2FnZS5mcm9tX3RhZyxcbiAgICAgIHJlbW90ZV90YWc6IG1lc3NhZ2UudG9fdGFnLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsX2lkICsgdGhpcy5sb2NhbF90YWcgKyB0aGlzLnJlbW90ZV90YWc7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5pbnZpdGVfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcignZnJvbScpLnVyaTtcbiAgICB0aGlzLnByYWNrZWQgPSBbXTtcbiAgICB0aGlzLnJlbW90ZV91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd0bycpLnVyaTtcbiAgICB0aGlzLnJlbW90ZV90YXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICB0aGlzLnJvdXRlX3NldCA9IG1lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJykucmV2ZXJzZSgpO1xuXG4gICAgLy9SRU5ERVJCT0RZXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0VBUkxZICYmICghb3duZXIuaGFzT2ZmZXIpKSB7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlciA9IG93bmVyLm1lZGlhSGFuZGxlckZhY3Rvcnkob3duZXIpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubG9nZ2VyID0gb3duZXIudWEuZ2V0TG9nZ2VyKCdzaXAuZGlhbG9nJywgdGhpcy5pZC50b1N0cmluZygpKTtcbiAgdGhpcy5vd25lciA9IG93bmVyO1xuICBvd25lci51YS5kaWFsb2dzW3RoaXMuaWQudG9TdHJpbmcoKV0gPSB0aGlzO1xuICB0aGlzLmxvZ2dlci5sb2coJ25ldyAnICsgdHlwZSArICcgZGlhbG9nIGNyZWF0ZWQgd2l0aCBzdGF0dXMgJyArICh0aGlzLnN0YXRlID09PSBDLlNUQVRVU19FQVJMWSA/ICdFQVJMWSc6ICdDT05GSVJNRUQnKSk7XG4gIG93bmVyLmVtaXQoJ2RpYWxvZycsIHRoaXMpO1xufTtcblxuRGlhbG9nLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U0lQLkluY29taW5nTWVzc2FnZX0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge0VudW19IFVBQy9VQVNcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgIHRoaXMuc3RhdGUgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2RpYWxvZyAnKyB0aGlzLmlkLnRvU3RyaW5nKCkgKycgIGNoYW5nZWQgdG8gQ09ORklSTUVEIHN0YXRlJyk7XG5cbiAgICBpZih0eXBlID09PSAnVUFDJykge1xuICAgICAgLy8gUkZDIDMyNjEgMTMuMi4yLjRcbiAgICAgIHRoaXMucm91dGVfc2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKS5yZXZlcnNlKCk7XG4gICAgfVxuICB9LFxuXG4gIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdkaWFsb2cgJyArIHRoaXMuaWQudG9TdHJpbmcoKSArICcgZGVsZXRlZCcpO1xuICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlciAmJiB0aGlzLnN0YXRlICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLm93bmVyLnVhLmRpYWxvZ3NbdGhpcy5pZC50b1N0cmluZygpXTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIHJlcXVlc3QgbWV0aG9kXG4gICogQHBhcmFtIHtPYmplY3R9IGV4dHJhSGVhZGVycyBleHRyYSBoZWFkZXJzXG4gICogQHJldHVybnMge1NJUC5PdXRnb2luZ1JlcXVlc3R9XG4gICovXG5cbiAgLy8gUkZDIDMyNjEgMTIuMi4xLjFcbiAgY3JlYXRlUmVxdWVzdDogZnVuY3Rpb24obWV0aG9kLCBleHRyYUhlYWRlcnMsIGJvZHkpIHtcbiAgICB2YXIgY3NlcSwgcmVxdWVzdDtcbiAgICBleHRyYUhlYWRlcnMgPSAoZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gICAgaWYoIXRoaXMubG9jYWxfc2VxbnVtKSB7IHRoaXMubG9jYWxfc2VxbnVtID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApOyB9XG5cbiAgICBjc2VxID0gKG1ldGhvZCA9PT0gU0lQLkMuQ0FOQ0VMIHx8IG1ldGhvZCA9PT0gU0lQLkMuQUNLKSA/IHRoaXMuaW52aXRlX3NlcW51bSA6IHRoaXMubG9jYWxfc2VxbnVtICs9IDE7XG5cbiAgICByZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QoXG4gICAgICBtZXRob2QsXG4gICAgICB0aGlzLnJlbW90ZV90YXJnZXQsXG4gICAgICB0aGlzLm93bmVyLnVhLCB7XG4gICAgICAgICdjc2VxJzogY3NlcSxcbiAgICAgICAgJ2NhbGxfaWQnOiB0aGlzLmlkLmNhbGxfaWQsXG4gICAgICAgICdmcm9tX3VyaSc6IHRoaXMubG9jYWxfdXJpLFxuICAgICAgICAnZnJvbV90YWcnOiB0aGlzLmlkLmxvY2FsX3RhZyxcbiAgICAgICAgJ3RvX3VyaSc6IHRoaXMucmVtb3RlX3VyaSxcbiAgICAgICAgJ3RvX3RhZyc6IHRoaXMuaWQucmVtb3RlX3RhZyxcbiAgICAgICAgJ3JvdXRlX3NldCc6IHRoaXMucm91dGVfc2V0XG4gICAgICB9LCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuXG4gICAgcmVxdWVzdC5kaWFsb2cgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gICogQHJldHVybnMge0Jvb2xlYW59XG4gICovXG5cbiAgLy8gUkZDIDMyNjEgMTIuMi4yXG4gIGNoZWNrSW5EaWFsb2dSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIXRoaXMucmVtb3RlX3NlcW51bSkge1xuICAgICAgdGhpcy5yZW1vdGVfc2VxbnVtID0gcmVxdWVzdC5jc2VxO1xuICAgIH0gZWxzZSBpZihyZXF1ZXN0LmNzZXEgPCB0aGlzLnJlbW90ZV9zZXFudW0pIHtcbiAgICAgICAgLy9EbyBub3QgdHJ5IHRvIHJlcGx5IHRvIGFuIEFDSyByZXF1ZXN0LlxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNTAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5jc2VxID09PSB0aGlzLmludml0ZV9zZXFudW0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmKHJlcXVlc3QuY3NlcSA+IHRoaXMucmVtb3RlX3NlcW51bSkge1xuICAgICAgdGhpcy5yZW1vdGVfc2VxbnVtID0gcmVxdWVzdC5jc2VxO1xuICAgIH1cblxuICAgIHN3aXRjaChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgLy8gUkZDMzI2MSAxNC4yIE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uIC1VQVMgQkVIQVZJT1ItXG4gICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgaWYgKHRoaXMudWFjX3BlbmRpbmdfcmVwbHkgPT09IHRydWUpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQ5MSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51YXNfcGVuZGluZ19yZXBseSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZXRyeUFmdGVyID0gKE1hdGgucmFuZG9tKCkgKiAxMCB8IDApICsgMTtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDUwMCwgbnVsbCwgWydSZXRyeS1BZnRlcjonICsgcmV0cnlBZnRlcl0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVhc19wZW5kaW5nX3JlcGx5ID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19BQ0NFUFRFRCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQ09NUExFVEVEIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG5cbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgc2VsZi51YXNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxmLnVhY19wZW5kaW5nX3JlcGx5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub3duZXIub25SZWFkeVRvUmVpbnZpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUkZDMzI2MSAxMi4yLjIgUmVwbGFjZSB0aGUgZGlhbG9nYHMgcmVtb3RlIHRhcmdldCBVUkkgaWYgdGhlIHJlcXVlc3QgaXMgYWNjZXB0ZWRcbiAgICAgICAgaWYocmVxdWVzdC5oYXNIZWFkZXIoJ2NvbnRhY3QnKSkge1xuICAgICAgICAgIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdGVfdGFyZ2V0ID0gcmVxdWVzdC5wYXJzZUhlYWRlcignY29udGFjdCcpLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuTk9USUZZOlxuICAgICAgICAvLyBSRkM2NjY1IDMuMiBSZXBsYWNlIHRoZSBkaWFsb2dgcyByZW1vdGUgdGFyZ2V0IFVSSSBpZiB0aGUgcmVxdWVzdCBpcyBhY2NlcHRlZFxuICAgICAgICBpZihyZXF1ZXN0Lmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgICAgICAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdGVfdGFyZ2V0ID0gcmVxdWVzdC5wYXJzZUhlYWRlcignY29udGFjdCcpLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBzZW5kUmVxdWVzdDogZnVuY3Rpb24oYXBwbGljYW50LCBtZXRob2QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhclxuICAgICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBudWxsLFxuICAgICAgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChtZXRob2QsIGV4dHJhSGVhZGVycywgYm9keSksXG4gICAgICByZXF1ZXN0X3NlbmRlciA9IG5ldyBSZXF1ZXN0U2VuZGVyKHRoaXMsIGFwcGxpY2FudCwgcmVxdWVzdCk7XG5cbiAgICByZXF1ZXN0X3NlbmRlci5zZW5kKCk7XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiAgKi9cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAvL0NoZWNrIGluLWRpYWxvZyByZXF1ZXN0XG4gICAgaWYoIXRoaXMuY2hlY2tJbkRpYWxvZ1JlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm93bmVyLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICB9XG59O1xuXG5EaWFsb2cuQyA9IEM7XG5TSVAuRGlhbG9nID0gRGlhbG9nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRGlhbG9ncy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBJbi1EaWFsb2cgUmVxdWVzdCBTZW5kZXJcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVAuRGlhbG9nXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYW4gSW4tZGlhbG9nIHJlcXVlc3Qgc2VuZGVyLlxuICogQHBhcmFtIHtTSVAuRGlhbG9nfSBkaWFsb2dcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcHBsaWNhbnRcbiAqIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgaW4tRGlhbG9nIFJlcXVlc3QgU2VuZGVyXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgUmVxdWVzdFNlbmRlcjtcblxuUmVxdWVzdFNlbmRlciA9IGZ1bmN0aW9uKGRpYWxvZywgYXBwbGljYW50LCByZXF1ZXN0KSB7XG5cbiAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gIHRoaXMuYXBwbGljYW50ID0gYXBwbGljYW50O1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIC8vIFJGQzMyNjEgMTQuMSBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvbi4gVUFDIEJlaGF2aW9yLlxuICB0aGlzLnJlYXR0ZW1wdCA9IGZhbHNlO1xuICB0aGlzLnJlYXR0ZW1wdFRpbWVyID0gbnVsbDtcbn07XG5cblJlcXVlc3RTZW5kZXIucHJvdG90eXBlID0ge1xuICBzZW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByZXF1ZXN0X3NlbmRlciA9IG5ldyBTSVAuUmVxdWVzdFNlbmRlcih0aGlzLCB0aGlzLmRpYWxvZy5vd25lci51YSk7XG5cbiAgICAgIHJlcXVlc3Rfc2VuZGVyLnNlbmQoKTtcblxuICAgIC8vIFJGQzMyNjEgMTQuMiBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvbiAtVUFDIEJFSEFWSU9SLVxuICAgIGlmICh0aGlzLnJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiYgcmVxdWVzdF9zZW5kZXIuY2xpZW50VHJhbnNhY3Rpb24uc3RhdGUgIT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5kaWFsb2cudWFjX3BlbmRpbmdfcmVwbHkgPSB0cnVlO1xuICAgICAgcmVxdWVzdF9zZW5kZXIuY2xpZW50VHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZCgpe1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19BQ0NFUFRFRCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19DT01QTEVURUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICBzZWxmLmRpYWxvZy51YWNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHNlbGYuZGlhbG9nLnVhc19wZW5kaW5nX3JlcGx5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5kaWFsb2cub3duZXIub25SZWFkeVRvUmVpbnZpdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblJlcXVlc3RUaW1lb3V0KCk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25UcmFuc3BvcnRFcnJvcigpO1xuICB9LFxuXG4gIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBSRkMzMjYxIDEyLjIuMS4yIDQwOCBvciA0ODEgaXMgcmVjZWl2ZWQgZm9yIGEgcmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0MDggfHwgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDQ4MSkge1xuICAgICAgdGhpcy5hcHBsaWNhbnQub25EaWFsb2dFcnJvcihyZXNwb25zZSk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDkxKSB7XG4gICAgICBpZiAodGhpcy5yZWF0dGVtcHQpIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdC5jc2VxLnZhbHVlID0gdGhpcy5kaWFsb2cubG9jYWxfc2VxbnVtICs9IDE7XG4gICAgICAgIHRoaXMucmVhdHRlbXB0VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hcHBsaWNhbnQub3duZXIuc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVhdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0X3NlbmRlci5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLmdldFJlYXR0ZW1wdFRpbWVvdXQoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxufTtcblxucmV0dXJuIFJlcXVlc3RTZW5kZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1ZXN0IFNlbmRlclxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgcmVxdWVzdCBzZW5kZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gYXBwbGljYW50XG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgUmVxdWVzdFNlbmRlcjtcblxuUmVxdWVzdFNlbmRlciA9IGZ1bmN0aW9uKGFwcGxpY2FudCwgdWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5yZXF1ZXN0c2VuZGVyJyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5hcHBsaWNhbnQgPSBhcHBsaWNhbnQ7XG4gIHRoaXMubWV0aG9kID0gYXBwbGljYW50LnJlcXVlc3QubWV0aG9kO1xuICB0aGlzLnJlcXVlc3QgPSBhcHBsaWNhbnQucmVxdWVzdDtcbiAgdGhpcy5jcmVkZW50aWFscyA9IG51bGw7XG4gIHRoaXMuY2hhbGxlbmdlZCA9IGZhbHNlO1xuICB0aGlzLnN0YWxlZCA9IGZhbHNlO1xuXG4gIC8vIElmIHVhIGlzIGluIGNsb3NpbmcgcHJvY2VzcyBvciBldmVuIGNsb3NlZCBqdXN0IGFsbG93IHNlbmRpbmcgQnllIGFuZCBBQ0tcbiAgaWYgKHVhLnN0YXR1cyA9PT0gU0lQLlVBLkMuU1RBVFVTX1VTRVJfQ0xPU0VEICYmICh0aGlzLm1ldGhvZCAhPT0gU0lQLkMuQllFIHx8IHRoaXMubWV0aG9kICE9PSBTSVAuQy5BQ0spKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbi8qKlxuKiBDcmVhdGUgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBhbmQgc2VuZCB0aGUgbWVzc2FnZS5cbiovXG5SZXF1ZXN0U2VuZGVyLnByb3RvdHlwZSA9IHtcbiAgc2VuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoKHRoaXMubWV0aG9kKSB7XG4gICAgICBjYXNlIFwiSU5WSVRFXCI6XG4gICAgICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLnJlcXVlc3QsIHRoaXMudWEudHJhbnNwb3J0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQUNLXCI6XG4gICAgICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5BY2tDbGllbnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLnJlcXVlc3QsIHRoaXMudWEudHJhbnNwb3J0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNsaWVudFRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24odGhpcywgdGhpcy5yZXF1ZXN0LCB0aGlzLnVhLnRyYW5zcG9ydCk7XG4gICAgfVxuICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24uc2VuZCgpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50VHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICogQ2FsbGJhY2sgZmlyZWQgd2hlbiByZWNlaXZpbmcgYSByZXF1ZXN0IHRpbWVvdXQgZXJyb3IgZnJvbSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLlxuICAqIFRvIGJlIHJlLWRlZmluZWQgYnkgdGhlIGFwcGxpY2FudC5cbiAgKiBAZXZlbnRcbiAgKi9cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25SZXF1ZXN0VGltZW91dCgpO1xuICB9LFxuXG4gIC8qKlxuICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gcmVjZWl2aW5nIGEgdHJhbnNwb3J0IGVycm9yIGZyb20gdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAgKiBUbyBiZSByZS1kZWZpbmVkIGJ5IHRoZSBhcHBsaWNhbnQuXG4gICogQGV2ZW50XG4gICovXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwbGljYW50Lm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgKiBDYWxsZWQgZnJvbSBjbGllbnQgdHJhbnNhY3Rpb24gd2hlbiByZWNlaXZpbmcgYSBjb3JyZWN0IHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0LlxuICAqIEF1dGhlbnRpY2F0ZSByZXF1ZXN0IGlmIG5lZWRlZCBvciBwYXNzIHRoZSByZXNwb25zZSBiYWNrIHRvIHRoZSBhcHBsaWNhbnQuXG4gICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXNwb25zZX0gcmVzcG9uc2VcbiAgKi9cbiAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBjc2VxLCBjaGFsbGVuZ2UsIGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUsXG4gICAgICBzdGF0dXNfY29kZSA9IHJlc3BvbnNlLnN0YXR1c19jb2RlO1xuXG4gICAgLypcbiAgICAqIEF1dGhlbnRpY2F0aW9uXG4gICAgKiBBdXRoZW50aWNhdGUgb25jZS4gX2NoYWxsZW5nZWRfIGZsYWcgdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBhdXRoZW50aWNhdGlvbnMuXG4gICAgKi9cbiAgICBpZiAoc3RhdHVzX2NvZGUgPT09IDQwMSB8fCBzdGF0dXNfY29kZSA9PT0gNDA3KSB7XG5cbiAgICAgIC8vIEdldCBhbmQgcGFyc2UgdGhlIGFwcHJvcHJpYXRlIFdXVy1BdXRoZW50aWNhdGUgb3IgUHJveHktQXV0aGVudGljYXRlIGhlYWRlci5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDAxKSB7XG4gICAgICAgIGNoYWxsZW5nZSA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgICAgIGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUgPSAnYXV0aG9yaXphdGlvbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFsbGVuZ2UgPSByZXNwb25zZS5wYXJzZUhlYWRlcigncHJveHktYXV0aGVudGljYXRlJyk7XG4gICAgICAgIGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUgPSAncHJveHktYXV0aG9yaXphdGlvbic7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBpdCBzZWVtcyBhIHZhbGlkIGNoYWxsZW5nZS5cbiAgICAgIGlmICghIGNoYWxsZW5nZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKHJlc3BvbnNlLnN0YXR1c19jb2RlICsgJyB3aXRoIHdyb25nIG9yIG1pc3NpbmcgY2hhbGxlbmdlLCBjYW5ub3QgYXV0aGVudGljYXRlJyk7XG4gICAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNoYWxsZW5nZWQgfHwgKCF0aGlzLnN0YWxlZCAmJiBjaGFsbGVuZ2Uuc3RhbGUgPT09IHRydWUpKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscykge1xuICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0aGlzLnVhLmNvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRpb25GYWN0b3J5KHRoaXMudWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNoYWxsZW5nZSBpcyByZWFsbHkgdmFsaWQuXG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5hdXRoZW50aWNhdGUodGhpcy5yZXF1ZXN0LCBjaGFsbGVuZ2UpKSB7XG4gICAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFsbGVuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY2hhbGxlbmdlLnN0YWxlKSB7XG4gICAgICAgICAgdGhpcy5zdGFsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gU0lQLkMuUkVHSVNURVIpIHtcbiAgICAgICAgICBjc2VxID0gdGhpcy5hcHBsaWNhbnQuY3NlcSArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdC5kaWFsb2cpe1xuICAgICAgICAgIGNzZXEgPSB0aGlzLnJlcXVlc3QuZGlhbG9nLmxvY2FsX3NlcW51bSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzZXEgPSB0aGlzLnJlcXVlc3QuY3NlcSArIDE7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0LmNzZXEgPSBjc2VxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ2NzZXEnLCBjc2VxICsnICcrIHRoaXMubWV0aG9kKTtcblxuICAgICAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUsIHRoaXMuY3JlZGVudGlhbHMudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbn07XG5cblNJUC5SZXF1ZXN0U2VuZGVyID0gUmVxdWVzdFNlbmRlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1JlcXVlc3RTZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnZhciBSZWdpc3RlckNvbnRleHQ7XG5cblJlZ2lzdGVyQ29udGV4dCA9IGZ1bmN0aW9uICh1YSkge1xuICB2YXIgcGFyYW1zID0ge30sXG4gICAgICByZWdJZCA9IDE7XG5cbiAgdGhpcy5yZWdpc3RyYXIgPSB1YS5jb25maWd1cmF0aW9uLnJlZ2lzdHJhclNlcnZlcjtcbiAgdGhpcy5leHBpcmVzID0gdWEuY29uZmlndXJhdGlvbi5yZWdpc3RlckV4cGlyZXM7XG5cblxuICAvLyBDb250YWN0IGhlYWRlclxuICB0aGlzLmNvbnRhY3QgPSB1YS5jb250YWN0LnRvU3RyaW5nKCk7XG5cbiAgaWYocmVnSWQpIHtcbiAgICB0aGlzLmNvbnRhY3QgKz0gJztyZWctaWQ9JysgcmVnSWQ7XG4gICAgdGhpcy5jb250YWN0ICs9ICc7K3NpcC5pbnN0YW5jZT1cIjx1cm46dXVpZDonKyB1YS5jb25maWd1cmF0aW9uLmluc3RhbmNlSWQrJz5cIic7XG4gIH1cblxuICAvLyBDYWxsLUlEIGFuZCBDU2VxIHZhbHVlcyBSRkMzMjYxIDEwLjJcbiAgdGhpcy5jYWxsX2lkID0gU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDIyKTtcbiAgdGhpcy5jc2VxID0gODA7XG5cbiAgdGhpcy50b191cmkgPSB1YS5jb25maWd1cmF0aW9uLnVyaTtcblxuICBwYXJhbXMudG9fdXJpID0gdGhpcy50b191cmk7XG4gIHBhcmFtcy50b19kaXNwbGF5TmFtZSA9IHVhLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWU7XG4gIHBhcmFtcy5jYWxsX2lkID0gdGhpcy5jYWxsX2lkO1xuICBwYXJhbXMuY3NlcSA9IHRoaXMuY3NlcTtcblxuICAvLyBFeHRlbmRzIENsaWVudENvbnRleHRcbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLkNsaWVudENvbnRleHQsIFt1YSwgJ1JFR0lTVEVSJywgdGhpcy5yZWdpc3RyYXIsIHtwYXJhbXM6IHBhcmFtc31dKTtcblxuICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuXG4gIC8vIFNldCBzdGF0dXNcbiAgdGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5yZWdpc3RlcmNvbnRleHQnKTtcbn07XG5cblJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcywgZXh0cmFIZWFkZXJzO1xuXG4gICAgLy8gSGFuZGxlIE9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGV4dHJhSGVhZGVycyA9ICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgdGhpcy5jb250YWN0ICsgJztleHBpcmVzPScgKyB0aGlzLmV4cGlyZXMpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJyArIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICAgIC8vIFNhdmUgb3JpZ2luYWwgZXh0cmFIZWFkZXJzIHRvIGJlIHVzZWQgaW4gLmNsb3NlXG4gICAgdGhpcy5jbG9zZUhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuY2xvc2VXaXRoSGVhZGVycyA/XG4gICAgICAodGhpcy5vcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSA6IFtdO1xuXG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFyIGNvbnRhY3QsIGV4cGlyZXMsXG4gICAgICAgIGNvbnRhY3RzID0gcmVzcG9uc2UuZ2V0SGVhZGVycygnY29udGFjdCcpLmxlbmd0aCxcbiAgICAgICAgY2F1c2U7XG5cbiAgICAgIC8vIERpc2NhcmQgcmVzcG9uc2VzIHRvIG9sZGVyIFJFR0lTVEVSL3VuLVJFR0lTVEVSIHJlcXVlc3RzLlxuICAgICAgaWYocmVzcG9uc2UuY3NlcSAhPT0gdGhpcy5jc2VxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgcmVnaXN0cmF0aW9uIHRpbWVyXG4gICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gbnVsbCkge1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcignZXhwaXJlcycpKSB7XG4gICAgICAgICAgICBleHBpcmVzID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdleHBpcmVzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VhcmNoIHRoZSBDb250YWN0IHBvaW50aW5nIHRvIHVzIGFuZCB1cGRhdGUgdGhlIGV4cGlyZXMgdmFsdWUgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgaWYgKCFjb250YWN0cykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2Fybignbm8gQ29udGFjdCBoZWFkZXIgaW4gcmVzcG9uc2UgdG8gUkVHSVNURVIsIHJlc3BvbnNlIGlnbm9yZWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlKGNvbnRhY3RzLS0pIHtcbiAgICAgICAgICAgIGNvbnRhY3QgPSByZXNwb25zZS5wYXJzZUhlYWRlcignY29udGFjdCcsIGNvbnRhY3RzKTtcbiAgICAgICAgICAgIGlmKGNvbnRhY3QudXJpLnVzZXIgPT09IHRoaXMudWEuY29udGFjdC51cmkudXNlcikge1xuICAgICAgICAgICAgICBleHBpcmVzID0gY29udGFjdC5nZXRQYXJhbSgnZXhwaXJlcycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRhY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29udGFjdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2Fybignbm8gQ29udGFjdCBoZWFkZXIgcG9pbnRpbmcgdG8gdXMsIHJlc3BvbnNlIGlnbm9yZWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFleHBpcmVzKSB7XG4gICAgICAgICAgICBleHBpcmVzID0gdGhpcy5leHBpcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlLVJlZ2lzdGVyIGJlZm9yZSB0aGUgZXhwaXJhdGlvbiBpbnRlcnZhbCBoYXMgZWxhcHNlZC5cbiAgICAgICAgICAvLyBGb3IgdGhhdCwgZGVjcmVhc2UgdGhlIGV4cGlyZXMgdmFsdWUuIGllOiAzIHNlY29uZHNcbiAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnJlZ2lzdGVyKHNlbGYub3B0aW9ucyk7XG4gICAgICAgICAgfSwgKGV4cGlyZXMgKiAxMDAwKSAtIDMwMDApO1xuICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oJ3JlZ2lzdHJhdGlvbiBleHBpcmVkJyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgIHNlbGYudW5yZWdpc3RlcmVkKG51bGwsIFNJUC5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBleHBpcmVzICogMTAwMCk7XG5cbiAgICAgICAgICAvL1NhdmUgZ3J1dSB2YWx1ZXNcbiAgICAgICAgICBpZiAoY29udGFjdC5oYXNQYXJhbSgndGVtcC1ncnV1JykpIHtcbiAgICAgICAgICAgIHRoaXMudWEuY29udGFjdC50ZW1wX2dydXUgPSBTSVAuVVJJLnBhcnNlKGNvbnRhY3QuZ2V0UGFyYW0oJ3RlbXAtZ3J1dScpLnJlcGxhY2UoL1wiL2csJycpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhY3QuaGFzUGFyYW0oJ3B1Yi1ncnV1JykpIHtcbiAgICAgICAgICAgIHRoaXMudWEuY29udGFjdC5wdWJfZ3J1dSA9IFNJUC5VUkkucGFyc2UoY29udGFjdC5nZXRQYXJhbSgncHViLWdydXUnKS5yZXBsYWNlKC9cIi9nLCcnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlZ2lzdGVyZWQnLCByZXNwb25zZSB8fCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSW50ZXJ2YWwgdG9vIGJyaWVmIFJGQzMyNjEgMTAuMi44XG4gICAgICAgIGNhc2UgL140MjMkLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICBpZihyZXNwb25zZS5oYXNIZWFkZXIoJ21pbi1leHBpcmVzJykpIHtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIG91ciByZWdpc3RyYXRpb24gaW50ZXJ2YWwgdG8gdGhlIHN1Z2dlc3RlZCBtaW5pbXVtXG4gICAgICAgICAgICB0aGlzLmV4cGlyZXMgPSByZXNwb25zZS5nZXRIZWFkZXIoJ21pbi1leHBpcmVzJyk7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRoZSByZWdpc3RyYXRpb24gYWdhaW4gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2UgeyAvL1RoaXMgcmVzcG9uc2UgTVVTVCBjb250YWluIGEgTWluLUV4cGlyZXMgaGVhZGVyIGZpZWxkXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCc0MjMgcmVzcG9uc2UgcmVjZWl2ZWQgZm9yIFJFR0lTVEVSIHdpdGhvdXQgTWluLUV4cGlyZXMnKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShyZXNwb25zZSwgU0lQLkMuY2F1c2VzLlNJUF9GQUlMVVJFX0NPREUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfTtcblxuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jc2VxKys7XG4gICAgdGhpcy5yZXF1ZXN0LmNzZXEgPSB0aGlzLmNzZXE7XG4gICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcignY3NlcScsIHRoaXMuY3NlcSArICcgUkVHSVNURVInKTtcbiAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgIHRoaXMuc2VuZCgpO1xuICB9LFxuXG4gIHJlZ2lzdHJhdGlvbkZhaWx1cmU6IGZ1bmN0aW9uIChyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlIHx8IG51bGwsIGNhdXNlIHx8IG51bGwpO1xuICB9LFxuXG4gIG9uVHJhbnNwb3J0Q2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRfYmVmb3JlID0gdGhpcy5yZWdpc3RlcmVkO1xuICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMucmVnaXN0ZXJlZCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblRyYW5zcG9ydENvbm5lY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWdpc3Rlcih0aGlzLm9wdGlvbnMpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFsbDogZmFsc2UsXG4gICAgICBleHRyYUhlYWRlcnM6IHRoaXMuY2xvc2VIZWFkZXJzXG4gICAgfTtcblxuICAgIHRoaXMucmVnaXN0ZXJlZF9iZWZvcmUgPSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgdGhpcy51bnJlZ2lzdGVyKG9wdGlvbnMpO1xuICB9LFxuXG4gIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZXh0cmFIZWFkZXJzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZighdGhpcy5yZWdpc3RlcmVkICYmICFvcHRpb25zLmFsbCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignYWxyZWFkeSB1bnJlZ2lzdGVyZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIENsZWFyIHRoZSByZWdpc3RyYXRpb24gdGltZXIuXG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYob3B0aW9ucy5hbGwpIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAqJyk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnRXhwaXJlczogMCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0ICsgJztleHBpcmVzPTAnKTtcbiAgICB9XG5cblxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciBjYXVzZTtcblxuICAgICAgc3dpdGNoKHRydWUpIHtcbiAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UpO1xuICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZChyZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICAgICAgdGhpcy51bnJlZ2lzdGVyZWQocmVzcG9uc2UsY2F1c2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSB1bnJlZ2lzdGVyZWQuLi5cbiAgICAgIC8vdGhpcy51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfTtcblxuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IHVucmVnaXN0ZXJlZC4uLlxuICAgICAgLy90aGlzLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfTtcblxuICAgIHRoaXMuY3NlcSsrO1xuICAgIHRoaXMucmVxdWVzdC5jc2VxID0gdGhpcy5jc2VxO1xuICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ2NzZXEnLCB0aGlzLmNzZXEgKyAnIFJFR0lTVEVSJyk7XG4gICAgdGhpcy5yZXF1ZXN0LmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcblxuICAgIHRoaXMuc2VuZCgpO1xuICB9LFxuXG4gIHVucmVnaXN0ZXJlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCd1bnJlZ2lzdGVyZWQnLCByZXNwb25zZSB8fCBudWxsLCBjYXVzZSB8fCBudWxsKTtcbiAgfVxuXG59O1xuXG5cblNJUC5SZWdpc3RlckNvbnRleHQgPSBSZWdpc3RlckNvbnRleHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9SZWdpc3RlckNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhSGFuZGxlclxuICovXG5cbi8qIE1lZGlhSGFuZGxlclxuICogQGNsYXNzIFBlZXJDb25uZWN0aW9uIGhlbHBlciBDbGFzcy5cbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoRXZlbnRFbWl0dGVyKSB7XG52YXIgTWVkaWFIYW5kbGVyID0gZnVuY3Rpb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAvLyBrZWVwIGpzaGludCBoYXBweVxuICBzZXNzaW9uID0gc2Vzc2lvbjtcbiAgb3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5NZWRpYUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gIGlzUmVhZHk6IHt2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeSAoKSB7fX0sXG5cbiAgY2xvc2U6IHt2YWx1ZTogZnVuY3Rpb24gY2xvc2UgKCkge319LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW21lZGlhSGludF0gQSBjdXN0b20gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG1lZGlhIHRvIGJlIHVzZWQgZHVyaW5nIHRoaXMgc2Vzc2lvbi5cbiAgICovXG4gIGdldERlc2NyaXB0aW9uOiB7dmFsdWU6IGZ1bmN0aW9uIGdldERlc2NyaXB0aW9uIChtZWRpYUhpbnQpIHtcbiAgICAvLyBrZWVwIGpzaGludCBoYXBweVxuICAgIG1lZGlhSGludCA9IG1lZGlhSGludDtcbiAgfX0sXG5cbiAgLyoqXG4gICogTWVzc2FnZSByZWNlcHRpb24uXG4gICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb25cbiAgKi9cbiAgc2V0RGVzY3JpcHRpb246IHt2YWx1ZTogZnVuY3Rpb24gc2V0RGVzY3JpcHRpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8ga2VlcCBqc2hpbnQgaGFwcHlcbiAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9fVxufSk7XG5cbnJldHVybiBNZWRpYUhhbmRsZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgQ2xpZW50Q29udGV4dDtcblxuQ2xpZW50Q29udGV4dCA9IGZ1bmN0aW9uICh1YSwgbWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gIC8vIFZhbGlkYXRlIGFyZ3VtZW50c1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICB9XG5cbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLmNsaWVudGNvbnRleHQnKTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRhcmdldCA9IHVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OiAnICsgb3JpZ2luYWxUYXJnZXQpO1xuICB9XG5cbiAgLyogT3B0aW9uc1xuICAgKiAtIGV4dHJhSGVhZGVyc1xuICAgKiAtIHBhcmFtc1xuICAgKiAtIGNvbnRlbnRUeXBlXG4gICAqIC0gYm9keVxuICAgKi9cbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUpIHtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyB0aGlzLmNvbnRlbnRUeXBlKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSByZXF1ZXN0XG4gIHRoaXMucmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyk7XG4gIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgdGhpcy5yZXF1ZXN0LmJvZHkgPSB0aGlzLmJvZHk7XG4gIH1cblxuICAvKiBTZXQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSByZXF1ZXN0ICovXG4gIHRoaXMubG9jYWxJZGVudGl0eSA9IHRoaXMucmVxdWVzdC5mcm9tO1xuICB0aGlzLnJlbW90ZUlkZW50aXR5ID0gdGhpcy5yZXF1ZXN0LnRvO1xuXG4gIHRoaXMuZGF0YSA9IHt9O1xufTtcbkNsaWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIChuZXcgU0lQLlJlcXVlc3RTZW5kZXIodGhpcywgdGhpcy51YSkpLnNlbmQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY2FuY2VsX3JlYXNvbiA9IFNJUC5VdGlscy5nZXRDYW5jZWxSZWFzb24ob3B0aW9ucy5zdGF0dXNfY29kZSwgb3B0aW9ucy5yZWFzb25fcGhyYXNlKTtcbiAgdGhpcy5yZXF1ZXN0LmNhbmNlbChjYW5jZWxfcmVhc29uKTtcblxuICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBjYXVzZSA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuXG4gIHN3aXRjaCh0cnVlKSB7XG4gICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgIGlmKHRoaXMudWEuYXBwbGljYW50c1t0aGlzXSkge1xuICAgICAgICBkZWxldGUgdGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZih0aGlzLnVhLmFwcGxpY2FudHNbdGhpc10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudWEuYXBwbGljYW50c1t0aGlzXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgncmVqZWN0ZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgYnJlYWs7XG4gIH1cblxufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbn07XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xufTtcblxuU0lQLkNsaWVudENvbnRleHQgPSBDbGllbnRDb250ZXh0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvQ2xpZW50Q29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBTZXJ2ZXJDb250ZXh0O1xuXG5TZXJ2ZXJDb250ZXh0ID0gZnVuY3Rpb24gKHVhLCByZXF1ZXN0KSB7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zZXJ2ZXJjb250ZXh0Jyk7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHVhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdWEpO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgfVxuICBpZiAocmVxdWVzdC5oYXNIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKSB7XG4gICAgdGhpcy5jb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgfVxuICB0aGlzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuXG4gIHRoaXMuZGF0YSA9IHt9O1xuXG4gIHRoaXMubG9jYWxJZGVudGl0eSA9IHJlcXVlc3QudG87XG4gIHRoaXMucmVtb3RlSWRlbnRpdHkgPSByZXF1ZXN0LmZyb207XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAob3B0aW9ucy5zdGF0dXNDb2RlID0gMTgwKTtcbiAgb3B0aW9ucy5taW5Db2RlID0gMTAwO1xuICBvcHRpb25zLm1heENvZGUgPSAxOTk7XG4gIG9wdGlvbnMuZXZlbnRzID0gWydwcm9ncmVzcyddO1xuICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAob3B0aW9ucy5zdGF0dXNDb2RlID0gMjAwKTtcbiAgb3B0aW9ucy5taW5Db2RlID0gMjAwO1xuICBvcHRpb25zLm1heENvZGUgPSAyOTk7XG4gIG9wdGlvbnMuZXZlbnRzID0gWydhY2NlcHRlZCddO1xuICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAob3B0aW9ucy5zdGF0dXNDb2RlID0gNDgwKTtcbiAgb3B0aW9ucy5taW5Db2RlID0gMzAwO1xuICBvcHRpb25zLm1heENvZGUgPSA2OTk7XG4gIG9wdGlvbnMuZXZlbnRzID0gWydyZWplY3RlZCcsICdmYWlsZWQnXTtcbiAgcmV0dXJuIHRoaXMucmVwbHkob3B0aW9ucyk7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5yZXBseSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBUaGlzIGlzIG9rYXksIHNvIGxvbmcgYXMgd2UgdHJlYXQgb3B0aW9ucyBhcyByZWFkLW9ubHkgaW4gdGhpcyBtZXRob2RcbiAgdmFyXG4gICAgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxMDAsXG4gICAgbWluQ29kZSA9IG9wdGlvbnMubWluQ29kZSB8fCAxMDAsXG4gICAgbWF4Q29kZSA9IG9wdGlvbnMubWF4Q29kZSB8fCA2OTksXG4gICAgcmVhc29uUGhyYXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShzdGF0dXNDb2RlLCBvcHRpb25zLnJlYXNvblBocmFzZSksXG4gICAgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10sXG4gICAgYm9keSA9IG9wdGlvbnMuYm9keSxcbiAgICBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCBbXSxcbiAgICByZXNwb25zZTtcblxuICBpZiAoc3RhdHVzQ29kZSA8IG1pbkNvZGUgfHwgc3RhdHVzQ29kZSA+IG1heENvZGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c0NvZGU6ICcgKyBzdGF0dXNDb2RlKTtcbiAgfVxuICByZXNwb25zZSA9IHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZW1pdChldmVudCwgcmVzcG9uc2UsIHJlYXNvblBocmFzZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xufTtcblxuU0lQLlNlcnZlckNvbnRleHQgPSBTZXJ2ZXJDb250ZXh0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU2VydmVyQ29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG5cbnZhciBEVE1GID0gcmVxdWlyZSgnLi9TZXNzaW9uL0RUTUYnKShTSVApO1xuXG52YXIgU2Vzc2lvbiwgSW52aXRlU2VydmVyQ29udGV4dCwgSW52aXRlQ2xpZW50Q29udGV4dCxcbiBDID0ge1xuICAgIC8vU2Vzc2lvbiBzdGF0ZXNcbiAgICBTVEFUVVNfTlVMTDogICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgIFNUQVRVU19JTlZJVEVfU0VOVDogICAgICAgICAgICAgICAgIDEsXG4gICAgU1RBVFVTXzFYWF9SRUNFSVZFRDogICAgICAgICAgICAgICAgMixcbiAgICBTVEFUVVNfSU5WSVRFX1JFQ0VJVkVEOiAgICAgICAgICAgICAzLFxuICAgIFNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVI6ICAgICAgICAgIDQsXG4gICAgU1RBVFVTX0FOU1dFUkVEOiAgICAgICAgICAgICAgICAgICAgNSxcbiAgICBTVEFUVVNfV0FJVElOR19GT1JfUFJBQ0s6ICAgICAgICAgICA2LFxuICAgIFNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s6ICAgICAgICAgICAgIDcsXG4gICAgU1RBVFVTX0NBTkNFTEVEOiAgICAgICAgICAgICAgICAgICAgOCxcbiAgICBTVEFUVVNfVEVSTUlOQVRFRDogICAgICAgICAgICAgICAgICA5LFxuICAgIFNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSzogMTAsXG4gICAgU1RBVFVTX0VBUkxZX01FRElBOiAgICAgICAgICAgICAgICAxMSxcbiAgICBTVEFUVVNfQ09ORklSTUVEOiAgICAgICAgICAgICAgICAgIDEyXG4gIH07XG5cbi8qXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIHJldHVybmluZyBTSVAuTWVkaWFIYW5kbGVyfSBbbWVkaWFIYW5kbGVyRmFjdG9yeV1cbiAqICAgICAgICAoU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgbWVkaWFIYW5kbGVyRmFjdG9yeSBhcmd1bWVudCBvZiB0aGUgVUEgY29uc3RydWN0b3IuKVxuICovXG5TZXNzaW9uID0gZnVuY3Rpb24gKG1lZGlhSGFuZGxlckZhY3RvcnkpIHtcbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19OVUxMO1xuICB0aGlzLmRpYWxvZyA9IG51bGw7XG4gIHRoaXMuZWFybHlEaWFsb2dzID0ge307XG4gIHRoaXMubWVkaWFIYW5kbGVyRmFjdG9yeSA9IG1lZGlhSGFuZGxlckZhY3RvcnkgfHwgU0lQLldlYlJUQy5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3Rvcnk7XG4gIC8vIHRoaXMubWVkaWFIYW5kbGVyIGdldHMgc2V0IGJ5IElDQy9JU0MgY29uc3RydWN0b3JzXG4gIHRoaXMuaGFzT2ZmZXIgPSBmYWxzZTtcbiAgdGhpcy5oYXNBbnN3ZXIgPSBmYWxzZTtcblxuICAvLyBTZXNzaW9uIFRpbWVyc1xuICB0aGlzLnRpbWVycyA9IHtcbiAgICBhY2tUaW1lcjogbnVsbCxcbiAgICBleHBpcmVzVGltZXI6IG51bGwsXG4gICAgaW52aXRlMnh4VGltZXI6IG51bGwsXG4gICAgdXNlck5vQW5zd2VyVGltZXI6IG51bGwsXG4gICAgcmVsMXh4VGltZXI6IG51bGwsXG4gICAgcHJhY2tUaW1lcjogbnVsbFxuICB9O1xuXG4gIC8vIFNlc3Npb24gaW5mb1xuICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gIHRoaXMudG9uZXMgPSBudWxsO1xuXG4gIC8vIE11dGUvSG9sZCBzdGF0ZVxuICB0aGlzLmxvY2FsX2hvbGQgPSBmYWxzZTtcbiAgdGhpcy5yZW1vdGVfaG9sZCA9IGZhbHNlO1xuXG4gIHRoaXMucGVuZGluZ19hY3Rpb25zID0ge1xuICAgIGFjdGlvbnM6IFtdLFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBpc1BlbmRpbmc6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgdmFyXG4gICAgICBpZHggPSAwLFxuICAgICAgbGVuZ3RoID0gdGhpcy5hY3Rpb25zLmxlbmd0aDtcblxuICAgICAgZm9yIChpZHg7IGlkeDxsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaWR4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5zaGlmdCgpO1xuICAgIH0sXG5cbiAgICBwdXNoOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFjdGlvbnMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhclxuICAgICAgaWR4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaWR4OyBpZHg8bGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2lkeF0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRoaXMuYWN0aW9ucy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICAgIGxlbmd0aCAtLTtcbiAgICAgICAgICBpZHgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgIH07XG5cbiAgdGhpcy5lYXJseV9zZHAgPSBudWxsO1xuICB0aGlzLnJlbDEwMCA9IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRDtcbn07XG5cblNlc3Npb24ucHJvdG90eXBlID0ge1xuICBkdG1mOiBmdW5jdGlvbih0b25lcywgb3B0aW9ucykge1xuICAgIHZhciB0b25lLCBkdG1mcyA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHRvbmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRvbmVzXG4gICAgaWYgKCh0eXBlb2YgdG9uZXMgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0b25lcyAhPT0gJ251bWJlcicpIHx8ICF0b25lcy50b1N0cmluZygpLm1hdGNoKC9eWzAtOUEtRCMqLF0rJC9pKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lczogJysgdG9uZXMpO1xuICAgIH1cblxuICAgIHRvbmVzID0gdG9uZXMudG9TdHJpbmcoKS5zcGxpdCgnJyk7XG5cbiAgICB3aGlsZSAodG9uZXMubGVuZ3RoID4gMCkgeyBkdG1mcy5wdXNoKG5ldyBEVE1GKHRoaXMsIHRvbmVzLnNoaWZ0KCksIG9wdGlvbnMpKTsgfVxuXG4gICAgaWYgKHRoaXMudG9uZXMpIHtcbiAgICAgIC8vIFRvbmVzIGFyZSBhbHJlYWR5IHF1ZXVlZCwganVzdCBhZGQgdG8gdGhlIHF1ZXVlXG4gICAgICB0aGlzLnRvbmVzID0gIHRoaXMudG9uZXMuY29uY2F0KGR0bWZzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzZW5kRFRNRiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkdG1mLCB0aW1lb3V0O1xuXG4gICAgICBpZiAoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQgfHwgIXNlbGYudG9uZXMgfHwgc2VsZi50b25lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gU3RvcCBzZW5kaW5nIERUTUZcbiAgICAgICAgc2VsZi50b25lcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBkdG1mID0gc2VsZi50b25lcy5zaGlmdCgpO1xuXG4gICAgICBpZiAodG9uZSA9PT0gJywnKSB7XG4gICAgICAgIHRpbWVvdXQgPSAyMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHRtZi5vbignZmFpbGVkJywgZnVuY3Rpb24oKXtzZWxmLnRvbmVzID0gbnVsbDt9KTtcbiAgICAgICAgZHRtZi5zZW5kKG9wdGlvbnMpO1xuICAgICAgICB0aW1lb3V0ID0gZHRtZi5kdXJhdGlvbiArIGR0bWYuaW50ZXJUb25lR2FwO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGltZW91dCBmb3IgdGhlIG5leHQgdG9uZVxuICAgICAgU0lQLlRpbWVycy5zZXRUaW1lb3V0KHNlbmREVE1GLCB0aW1lb3V0KTtcbiAgICB9O1xuXG4gICAgdGhpcy50b25lcyA9IGR0bWZzO1xuICAgIHNlbmREVE1GKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYnllOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRXJyb3I6IEF0dGVtcHRlZCB0byBzZW5kIEJZRSBpbiBhIHRlcm1pbmF0ZWQgc2Vzc2lvbi4nKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygndGVybWluYXRpbmcgU2Vzc2lvbicpO1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgJiYgKHN0YXR1c0NvZGUgPCAyMDAgfHwgc3RhdHVzQ29kZSA+PSA3MDApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c0NvZGU6ICcrIHN0YXR1c0NvZGUpO1xuICAgIH1cblxuICAgIG9wdGlvbnMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICByZXR1cm4gdGhpcy5cbiAgICAgIHNlbmRSZXF1ZXN0KFNJUC5DLkJZRSwgb3B0aW9ucykuXG4gICAgICB0ZXJtaW5hdGVkKCk7XG4gIH0sXG5cbiAgcmVmZXI6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICAgIHdpdGhSZXBsYWNlcyA9XG4gICAgICAgICAgdGFyZ2V0IGluc3RhbmNlb2YgU0lQLkludml0ZVNlcnZlckNvbnRleHQgfHxcbiAgICAgICAgICB0YXJnZXQgaW5zdGFuY2VvZiBTSVAuSW52aXRlQ2xpZW50Q29udGV4dCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICAvLyB0cmFuc2Zvcm0gYHRhcmdldGAgc28gdGhhdCBpdCBjYW4gYmUgYSBSZWZlci1UbyBoZWFkZXIgdmFsdWVcbiAgICBpZiAod2l0aFJlcGxhY2VzKSB7XG4gICAgICAvL0F0dGVuZGVkIFRyYW5zZmVyXG4gICAgICAvLyBCLnRyYW5zZmVyKEMpXG4gICAgICB0YXJnZXQgPSAnXCInICsgdGFyZ2V0LnJlbW90ZUlkZW50aXR5LmZyaWVuZGx5TmFtZSArICdcIiAnICtcbiAgICAgICAgJzwnICsgdGFyZ2V0LmRpYWxvZy5yZW1vdGVfdGFyZ2V0LnRvU3RyaW5nKCkgK1xuICAgICAgICAnP1JlcGxhY2VzPScgKyB0YXJnZXQuZGlhbG9nLmlkLmNhbGxfaWQgK1xuICAgICAgICAnJTNCdG8tdGFnJTNEJyArIHRhcmdldC5kaWFsb2cuaWQucmVtb3RlX3RhZyArXG4gICAgICAgICclM0Jmcm9tLXRhZyUzRCcgKyB0YXJnZXQuZGlhbG9nLmlkLmxvY2FsX3RhZyArICc+JztcbiAgICB9IGVsc2Uge1xuICAgICAgLy9CbGluZCBUcmFuc2ZlclxuICAgICAgLy8gbm9ybWFsaXplVGFyZ2V0IGFsbG93cyBpbnN0YW5jZXMgb2YgU0lQLlVSSSB0byBwYXNzIHRocm91Z2ggdW5hbHRlcmVkLFxuICAgICAgLy8gc28gdHJ5IHRvIG1ha2Ugb25lIGFoZWFkIG9mIHRpbWVcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhcmdldCA9IFNJUC5HcmFtbWFyLnBhcnNlKHRhcmdldCwgJ1JlZmVyX1RvJykudXJpIHx8IHRhcmdldDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCIucmVmZXIoKSBjYW5ub3QgcGFyc2UgUmVmZXJfVG8gZnJvbVwiLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIi4uLmZhbGxpbmcgdGhyb3VnaCB0byBub3JtYWxpemVUYXJnZXQoKVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGFyZ2V0IHZhbGlkaXR5XG4gICAgICB0YXJnZXQgPSB0aGlzLnVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQ6ICcgKyBvcmlnaW5hbFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlZmVyLVRvOiAnKyB0YXJnZXQpO1xuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuUkVGRVIsIHtcbiAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCAhIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSkgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmcgdXAgb25seSBpZiB3ZSB0cmFuc2ZlcnJlZCB0byBhIFNJUCBhZGRyZXNzXG4gICAgICAgIGlmICh3aXRoUmVwbGFjZXMgfHwgKHRhcmdldC5zY2hlbWUgJiYgdGFyZ2V0LnNjaGVtZS5tYXRjaChcIl5zaXBzPyRcIikpKSB7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZm9sbG93UmVmZXI6IGZ1bmN0aW9uIGZvbGxvd1JlZmVyIChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiByZWZlckxpc3RlbmVyIChjYWxsYmFjaywgcmVxdWVzdCkge1xuICAgICAgLy8gb3BlbiBub24tU0lQIFVSSXMgaWYgcG9zc2libGUgYW5kIGtlZXAgc2Vzc2lvbiBvcGVuXG4gICAgICB2YXIgcmVmZXJUbyA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ3JlZmVyLXRvJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gcmVmZXJUby51cmk7XG4gICAgICBpZiAoIXRhcmdldC5zY2hlbWUubWF0Y2goXCJec2lwcz8kXCIpKSB7XG4gICAgICAgIHZhciB0YXJnZXRTdHJpbmcgPSB0YXJnZXQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZpcm9ubWVudC5vcGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBlbnZpcm9ubWVudC5vcGVuKHRhcmdldFN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInJlZmVycmVkIHRvIG5vbi1TSVAgVVJJIGJ1dCBgb3BlbmAgaXNuJ3QgaW4gdGhlIGVudmlyb25tZW50OiBcIiArIHRhcmdldFN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG5cbiAgICAgIC8qIENvcHkgdGhlIFJlcGxhY2VzIHF1ZXJ5IGludG8gYSBSZXBsYWNlcyBoZWFkZXIgKi9cbiAgICAgIC8qIFRPRE8gLSBtYWtlIHN1cmUgd2UgZG9uJ3QgY29weSBhIHBvb3JseSBmb3JtYXR0ZWQgaGVhZGVyPyAqL1xuICAgICAgdmFyIHJlcGxhY2VzID0gdGFyZ2V0LmdldEhlYWRlcignUmVwbGFjZXMnKTtcbiAgICAgIGlmIChyZXBsYWNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXBsYWNlczogJyArIGRlY29kZVVSSUNvbXBvbmVudChyZXBsYWNlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb24ndCBlbWJlZCBoZWFkZXJzIGludG8gUmVxdWVzdC1VUkkgb2YgSU5WSVRFXG4gICAgICB0YXJnZXQuY2xlYXJIZWFkZXJzKCk7XG5cbiAgICAgIC8qXG4gICAgICAgIEhhcm1sZXNzIHJhY2UgY29uZGl0aW9uLiAgQm90aCBzaWRlcyBvZiBSRUZFUlxuICAgICAgICBtYXkgc2VuZCBhIEJZRSwgYnV0IGluIHRoZSBlbmQgdGhlIGRpYWxvZ3MgYXJlIGRlc3Ryb3llZC5cbiAgICAgICovXG4gICAgICB2YXIgZ2V0UmVmZXJNZWRpYSA9IHRoaXMubWVkaWFIYW5kbGVyLmdldFJlZmVyTWVkaWE7XG4gICAgICB2YXIgbWVkaWFIaW50ID0gZ2V0UmVmZXJNZWRpYSA/IGdldFJlZmVyTWVkaWEuY2FsbCh0aGlzLm1lZGlhSGFuZGxlcikgOiB0aGlzLm1lZGlhSGludDtcblxuICAgICAgU0lQLkhhY2tzLkNocm9tZS5nZXRzQ29uZnVzZWRBYm91dEdVTSh0aGlzKTtcblxuICAgICAgdmFyIHJlZmVyU2Vzc2lvbiA9IHRoaXMudWEuaW52aXRlKHRhcmdldCwge1xuICAgICAgICBtZWRpYTogbWVkaWFIaW50LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB0b19kaXNwbGF5TmFtZTogcmVmZXJUby5mcmllbmRseU5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnNcbiAgICAgIH0pO1xuXG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHJlcXVlc3QsIHJlZmVyU2Vzc2lvbik7XG5cbiAgICAgIHRoaXMudGVybWluYXRlKCk7XG4gICAgfS5iaW5kKHRoaXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBzZW5kUmVxdWVzdDogZnVuY3Rpb24obWV0aG9kLG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgbWV0aG9kLFxuICAgICAgdGhpcy5kaWFsb2cucmVtb3RlX3RhcmdldCxcbiAgICAgIHRoaXMudWEsXG4gICAgICB7XG4gICAgICAgIGNzZXE6IG9wdGlvbnMuY3NlcSB8fCAodGhpcy5kaWFsb2cubG9jYWxfc2VxbnVtICs9IDEpLFxuICAgICAgICBjYWxsX2lkOiB0aGlzLmRpYWxvZy5pZC5jYWxsX2lkLFxuICAgICAgICBmcm9tX3VyaTogdGhpcy5kaWFsb2cubG9jYWxfdXJpLFxuICAgICAgICBmcm9tX3RhZzogdGhpcy5kaWFsb2cuaWQubG9jYWxfdGFnLFxuICAgICAgICB0b191cmk6IHRoaXMuZGlhbG9nLnJlbW90ZV91cmksXG4gICAgICAgIHRvX3RhZzogdGhpcy5kaWFsb2cuaWQucmVtb3RlX3RhZyxcbiAgICAgICAgcm91dGVfc2V0OiB0aGlzLmRpYWxvZy5yb3V0ZV9zZXQsXG4gICAgICAgIHN0YXR1c0NvZGU6IG9wdGlvbnMuc3RhdHVzQ29kZSxcbiAgICAgICAgcmVhc29uUGhyYXNlOiBvcHRpb25zLnJlYXNvblBocmFzZVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdLFxuICAgICAgb3B0aW9ucy5ib2R5XG4gICAgKTtcblxuICAgIG5ldyBTSVAuUmVxdWVzdFNlbmRlcih7XG4gICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgfSxcbiAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgIH0sXG4gICAgICByZWNlaXZlUmVzcG9uc2U6IG9wdGlvbnMucmVjZWl2ZVJlc3BvbnNlIHx8IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYucmVjZWl2ZU5vbkludml0ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVhKS5zZW5kKCk7XG5cbiAgICAvLyBFbWl0IHRoZSByZXF1ZXN0IGV2ZW50XG4gICAgdGhpcy5lbWl0KG1ldGhvZC50b0xvd2VyQ2FzZSgpLCByZXF1ZXN0KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWR4O1xuXG4gICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBJTlZJVEUgc2Vzc2lvbiAnICsgdGhpcy5pZCk7XG5cbiAgICAvLyAxc3QgU3RlcC4gVGVybWluYXRlIG1lZGlhLlxuICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlcil7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8vIDJuZCBTdGVwLiBUZXJtaW5hdGUgc2lnbmFsaW5nLlxuXG4gICAgLy8gQ2xlYXIgc2Vzc2lvbiB0aW1lcnNcbiAgICBmb3IoaWR4IGluIHRoaXMudGltZXJzKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc1tpZHhdKTtcbiAgICB9XG5cbiAgICAvLyBUZXJtaW5hdGUgZGlhbG9nc1xuXG4gICAgLy8gVGVybWluYXRlIGNvbmZpcm1lZCBkaWFsb2dcbiAgICBpZih0aGlzLmRpYWxvZykge1xuICAgICAgdGhpcy5kaWFsb2cudGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5kaWFsb2c7XG4gICAgfVxuXG4gICAgLy8gVGVybWluYXRlIGVhcmx5IGRpYWxvZ3NcbiAgICBmb3IoaWR4IGluIHRoaXMuZWFybHlEaWFsb2dzKSB7XG4gICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZHhdLnRlcm1pbmF0ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZWFybHlEaWFsb2dzW2lkeF07XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19URVJNSU5BVEVEO1xuXG4gICAgZGVsZXRlIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY3JlYXRlRGlhbG9nOiBmdW5jdGlvbihtZXNzYWdlLCB0eXBlLCBlYXJseSkge1xuICAgIHZhciBkaWFsb2csIGVhcmx5X2RpYWxvZyxcbiAgICAgIGxvY2FsX3RhZyA9IG1lc3NhZ2VbKHR5cGUgPT09ICdVQVMnKSA/ICd0b190YWcnIDogJ2Zyb21fdGFnJ10sXG4gICAgICByZW1vdGVfdGFnID0gbWVzc2FnZVsodHlwZSA9PT0gJ1VBUycpID8gJ2Zyb21fdGFnJyA6ICd0b190YWcnXSxcbiAgICAgIGlkID0gbWVzc2FnZS5jYWxsX2lkICsgbG9jYWxfdGFnICsgcmVtb3RlX3RhZztcblxuICAgIGVhcmx5X2RpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzW2lkXTtcblxuICAgIC8vIEVhcmx5IERpYWxvZ1xuICAgIGlmIChlYXJseSkge1xuICAgICAgaWYgKGVhcmx5X2RpYWxvZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhcmx5X2RpYWxvZyA9IG5ldyBTSVAuRGlhbG9nKHRoaXMsIG1lc3NhZ2UsIHR5cGUsIFNJUC5EaWFsb2cuQy5TVEFUVVNfRUFSTFkpO1xuXG4gICAgICAgIC8vIERpYWxvZyBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cbiAgICAgICAgaWYoZWFybHlfZGlhbG9nLmVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZWFybHlfZGlhbG9nLmVycm9yKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChtZXNzYWdlLCBTSVAuQy5jYXVzZXMuSU5URVJOQUxfRVJST1IpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0gPSBlYXJseV9kaWFsb2c7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29uZmlybWVkIERpYWxvZ1xuICAgIGVsc2Uge1xuICAgICAgLy8gSW4gY2FzZSB0aGUgZGlhbG9nIGlzIGluIF9lYXJseV8gc3RhdGUsIHVwZGF0ZSBpdFxuICAgICAgaWYgKGVhcmx5X2RpYWxvZykge1xuICAgICAgICBlYXJseV9kaWFsb2cudXBkYXRlKG1lc3NhZ2UsIHR5cGUpO1xuICAgICAgICB0aGlzLmRpYWxvZyA9IGVhcmx5X2RpYWxvZztcbiAgICAgICAgZGVsZXRlIHRoaXMuZWFybHlEaWFsb2dzW2lkXTtcbiAgICAgICAgZm9yICh2YXIgZGlhIGluIHRoaXMuZWFybHlEaWFsb2dzKSB7XG4gICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbZGlhXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5lYXJseURpYWxvZ3NbZGlhXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBfY29uZmlybWVkXyBkaWFsb2dcbiAgICAgIGRpYWxvZyA9IG5ldyBTSVAuRGlhbG9nKHRoaXMsIG1lc3NhZ2UsIHR5cGUpO1xuXG4gICAgICBpZihkaWFsb2cuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZGlhbG9nLmVycm9yKTtcbiAgICAgICAgdGhpcy5mYWlsZWQobWVzc2FnZSwgU0lQLkMuY2F1c2VzLklOVEVSTkFMX0VSUk9SKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b190YWcgPSBtZXNzYWdlLnRvX3RhZztcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBDaGVjayBpZiBTZXNzaW9uIGlzIHJlYWR5IGZvciBhIHJlLUlOVklURVxuICAqXG4gICogQHJldHVybnMge0Jvb2xlYW59XG4gICovXG4gIGlzUmVhZHlUb1JlaW52aXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZWRpYUhhbmRsZXIuaXNSZWFkeSgpICYmXG4gICAgICAhdGhpcy5kaWFsb2cudWFjX3BlbmRpbmdfcmVwbHkgJiZcbiAgICAgICF0aGlzLmRpYWxvZy51YXNfcGVuZGluZ19yZXBseTtcbiAgfSxcblxuICAvKipcbiAgICogTXV0ZVxuICAgKi9cbiAgbXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciByZXQgPSB0aGlzLm1lZGlhSGFuZGxlci5tdXRlKG9wdGlvbnMpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMub25tdXRlKHJldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm11dGVcbiAgICovXG4gIHVubXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciByZXQgPSB0aGlzLm1lZGlhSGFuZGxlci51bm11dGUob3B0aW9ucyk7XG4gICAgaWYgKHJldCkge1xuICAgICAgdGhpcy5vbnVubXV0ZShyZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSG9sZFxuICAgKi9cbiAgaG9sZDogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhSGFuZGxlci5ob2xkKCk7XG5cbiAgICAvLyBDaGVjayBpZiBSVENTZXNzaW9uIGlzIHJlYWR5IHRvIHNlbmQgYSByZUlOVklURVxuICAgIGlmICghdGhpcy5pc1JlYWR5VG9SZWludml0ZSgpKSB7XG4gICAgICAvKiBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgJ3VuaG9sZCcgYWN0aW9uLCBjYW5jZWwgaXQgYW5kIGRvbid0IHF1ZXVlIHRoaXMgb25lXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpc24ndCBhbnkgJ2hvbGQnIGFjdGlvbiwgYWRkIHRoaXMgb25lIHRvIHRoZSBxdWV1ZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXMgYWxyZWFkeSBhICdob2xkJyBhY3Rpb24sIHNraXBcbiAgICAgICAqL1xuICAgICAgaWYgKHRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygndW5ob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucG9wKCd1bmhvbGQnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygnaG9sZCcpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ19hY3Rpb25zLnB1c2goJ2hvbGQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxfaG9sZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbmhvbGQoJ2xvY2FsJyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm1hbmdsZSA9IGZ1bmN0aW9uKGJvZHkpe1xuXG4gICAgICAvLyBEb24ndCByZWNlaXZlIG1lZGlhXG4gICAgICAvLyBUT0RPIC0gVGhpcyB3aWxsIGJyZWFrIGZvciBtZWRpYSBzdHJlYW1zIHdpdGggZGlmZmVyZW50IGRpcmVjdGlvbnMuXG4gICAgICBpZiAoISgvYT0oc2VuZHJlY3Z8c2VuZG9ubHl8cmVjdm9ubHl8aW5hY3RpdmUpLykudGVzdChib2R5KSkge1xuICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKC8obT1bXlxccl0qXFxyXFxuKS9nLCAnJDFhPXNlbmRvbmx5XFxyXFxuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKC9hPXNlbmRyZWN2XFxyXFxuL2csICdhPXNlbmRvbmx5XFxyXFxuJyk7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL2E9cmVjdm9ubHlcXHJcXG4vZywgJ2E9aW5hY3RpdmVcXHJcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcblxuICAgIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbmhvbGRcbiAgICovXG4gIHVuaG9sZDogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhSGFuZGxlci51bmhvbGQoKTtcblxuICAgIGlmICghdGhpcy5pc1JlYWR5VG9SZWludml0ZSgpKSB7XG4gICAgICAvKiBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgJ2hvbGQnIGFjdGlvbiwgY2FuY2VsIGl0IGFuZCBkb24ndCBxdWV1ZSB0aGlzIG9uZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXNuJ3QgYW55ICd1bmhvbGQnIGFjdGlvbiwgYWRkIHRoaXMgb25lIHRvIHRoZSBxdWV1ZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXMgYWxyZWFkeSBhICd1bmhvbGQnIGFjdGlvbiwgc2tpcFxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCdob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucG9wKCdob2xkJyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdfYWN0aW9ucy5pc1BlbmRpbmcoJ3VuaG9sZCcpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ19hY3Rpb25zLnB1c2goJ3VuaG9sZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbF9ob2xkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub251bmhvbGQoJ2xvY2FsJyk7XG5cbiAgICB0aGlzLnNlbmRSZWludml0ZShvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogaXNPbkhvbGRcbiAgICovXG4gIGlzT25Ib2xkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYWw6IHRoaXMubG9jYWxfaG9sZCxcbiAgICAgIHJlbW90ZTogdGhpcy5yZW1vdGVfaG9sZFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluIGRpYWxvZyBJTlZJVEUgUmVjZXB0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWNlaXZlUmVpbnZpdGU6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXJlcXVlc3QuYm9keSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJykgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbnZhbGlkIENvbnRlbnQtVHlwZScpO1xuICAgICAgcmVxdWVzdC5yZXBseSg0MTUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlcXVlc3QuYm9keSlcbiAgICAudGhlbih0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbi5iaW5kKHRoaXMubWVkaWFIYW5kbGVyLCB0aGlzLm1lZGlhSGludCkpXG4gICAgLnRoZW4oZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIFsnQ29udGFjdDogJyArIHNlbGYuY29udGFjdF0sIGJvZHksXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLO1xuICAgICAgICAgIHNlbGYuc2V0SW52aXRlMnh4VGltZXIocmVxdWVzdCwgYm9keSk7XG4gICAgICAgICAgc2VsZi5zZXRBQ0tUaW1lcigpO1xuXG4gICAgICAgICAgLy8gQXJlIHdlIGhvbGRpbmc/XG4gICAgICAgICAgdmFyIGhvbGQgPSAoL2E9KHNlbmRvbmx5fGluYWN0aXZlKS8pLnRlc3QocmVxdWVzdC5ib2R5KTtcblxuICAgICAgICAgIGlmIChzZWxmLnJlbW90ZV9ob2xkICYmICFob2xkKSB7XG4gICAgICAgICAgICBzZWxmLm9udW5ob2xkKCdyZW1vdGUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzZWxmLnJlbW90ZV9ob2xkICYmIGhvbGQpIHtcbiAgICAgICAgICAgIHNlbGYub25ob2xkKCdyZW1vdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLmNhdGNoKGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgdmFyIHN0YXR1c0NvZGU7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNJUC5FeGNlcHRpb25zLkdldERlc2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICBzdGF0dXNDb2RlID0gNDg4O1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5yZXBseShzdGF0dXNDb2RlKTtcbiAgICB9KTtcbiAgfSxcblxuICBzZW5kUmVpbnZpdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhclxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICBldmVudEhhbmRsZXJzID0gb3B0aW9ucy5ldmVudEhhbmRsZXJzIHx8IHt9LFxuICAgICAgbWFuZ2xlID0gb3B0aW9ucy5tYW5nbGUgfHwgbnVsbCxcbiAgICAgIHN1Y2NlZWRlZDtcblxuICAgIGlmIChldmVudEhhbmRsZXJzLnN1Y2NlZWRlZCkge1xuICAgICAgc3VjY2VlZGVkID0gZXZlbnRIYW5kbGVycy5zdWNjZWVkZWQ7XG4gICAgfVxuICAgIHRoaXMucmVpbnZpdGVTdWNjZWVkZWQgPSBmdW5jdGlvbigpe1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi50aW1lcnMuYWNrVGltZXIpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICBzdWNjZWVkZWQgJiYgc3VjY2VlZGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBpZiAoZXZlbnRIYW5kbGVycy5mYWlsZWQpIHtcbiAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQgPSBldmVudEhhbmRsZXJzLmZhaWxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHRoaXMuY29udGFjdCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJyk7XG5cbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IHRoaXMucmVjZWl2ZVJlaW52aXRlUmVzcG9uc2U7XG4gICAgLy9SRVZJU0lUXG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oc2VsZi5tZWRpYUhpbnQpXG4gICAgLnRoZW4obWFuZ2xlKVxuICAgIC50aGVuKFxuICAgICAgZnVuY3Rpb24oYm9keSl7XG4gICAgICAgIHNlbGYuZGlhbG9nLnNlbmRSZXF1ZXN0KHNlbGYsIFNJUC5DLklOVklURSwge1xuICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLmlzUmVhZHlUb1JlaW52aXRlKCkpIHtcbiAgICAgICAgICBzZWxmLm9uUmVhZHlUb1JlaW52aXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgfVxuICAgICk7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgY2FzZSBTSVAuQy5CWUU6XG4gICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnYnllJywgcmVxdWVzdCk7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CWUUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlLUlOVklURSByZWNlaXZlZCcpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZVJlaW52aXRlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5JTkZPOlxuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgICB2YXIgYm9keSwgdG9uZSwgZHVyYXRpb24sXG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpLFxuICAgICAgICAgICAgICByZWdfdG9uZSA9IC9eKFNpZ25hbFxccyo/PVxccyo/KShbMC05QS1EIypdezF9KShcXHMpPy4qLyxcbiAgICAgICAgICAgICAgcmVnX2R1cmF0aW9uID0gL14oRHVyYXRpb25cXHM/PVxccz8pKFswLTldezEsNH0pKFxccyk/LiovO1xuXG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUubWF0Y2goL15hcHBsaWNhdGlvblxcL2R0bWYtcmVsYXkvaSkpIHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSByZXF1ZXN0LmJvZHkuc3BsaXQoJ1xcclxcbicsIDIpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlZ190b25lLnRlc3QoYm9keVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9uZSA9IGJvZHlbMF0ucmVwbGFjZShyZWdfdG9uZSxcIiQyXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlZ19kdXJhdGlvbi50ZXN0KGJvZHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcGFyc2VJbnQoYm9keVsxXS5yZXBsYWNlKHJlZ19kdXJhdGlvbixcIiQyXCIpLCAxMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3IERUTUYodGhpcywgdG9uZSwge2R1cmF0aW9uOiBkdXJhdGlvbn0pLmluaXRfaW5jb21pbmcocmVxdWVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQxNSwgbnVsbCwgW1wiQWNjZXB0OiBhcHBsaWNhdGlvbi9kdG1mLXJlbGF5XCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLlJFRkVSOlxuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gIEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygnUkVGRVIgcmVjZWl2ZWQnKTtcbiAgICAgICAgICB2YXIgaGFzUmVmZXJMaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzKCdyZWZlcicpLmxlbmd0aCxcbiAgICAgICAgICAgICAgbm90aWZ5Qm9keTtcblxuICAgICAgICAgIGlmIChoYXNSZWZlckxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMiwgJ0FjY2VwdGVkJyk7XG4gICAgICAgICAgICBub3RpZnlCb2R5ID0gJ1NJUC8yLjAgMTAwIFRyeWluZyc7XG5cbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuTk9USUZZLCB7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVyczpbXG4gICAgICAgICAgICAgICAgJ0V2ZW50OiByZWZlcicsXG4gICAgICAgICAgICAgICAgJ1N1YnNjcmlwdGlvbi1TdGF0ZTogdGVybWluYXRlZCcsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZTogbWVzc2FnZS9zaXBmcmFnJ1xuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBib2R5OiBub3RpZnlCb2R5LFxuICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlZmVyJywgcmVxdWVzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJGQyAzNTE1LjIuNC4yOiAndGhlIFVBIE1BWSBkZWNsaW5lIHRoZSByZXF1ZXN0LidcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoNjAzLCAnRGVjbGluZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLk5PVElGWTpcbiAgICAgICAgcmVxdWVzdC5yZXBseSgyMDAsICdPSycpO1xuICAgICAgICB0aGlzLmVtaXQoJ25vdGlmeScsIHJlcXVlc3QpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VwdGlvbiBvZiBSZXNwb25zZSBmb3IgaW4tZGlhbG9nIElOVklURVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVjZWl2ZVJlaW52aXRlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG5cbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse2NzZXE6cmVzcG9uc2UuY3NlcX0pO1xuXG4gICAgICAgIGlmKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vUkVWSVNJVFxuICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgc2VsZi5yZWludml0ZVN1Y2NlZWRlZCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVpbnZpdGVGYWlsZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCgpO1xuICAgIH1cbiAgfSxcblxuICBhY2NlcHRBbmRUZXJtaW5hdGU6IGZ1bmN0aW9uKHJlc3BvbnNlLCBzdGF0dXNfY29kZSwgcmVhc29uX3BocmFzZSkge1xuICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcblxuICAgIGlmIChzdGF0dXNfY29kZSkge1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlYXNvbjogJyArIFNJUC5VdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZShzdGF0dXNfY29kZSwgcmVhc29uX3BocmFzZSkpO1xuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIG9uIGRpYWxvZyBjcmVhdGlvbiB3aWxsIGZpcmUgJ2ZhaWxlZCcgZXZlbnRcbiAgICBpZiAodGhpcy5kaWFsb2cgfHwgdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse2NzZXE6IHJlc3BvbnNlLmNzZXF9KTtcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQllFLCB7XG4gICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUkZDMzI2MSAxMy4zLjEuNFxuICAgKiBSZXNwb25zZSByZXRyYW5zbWlzc2lvbnMgY2Fubm90IGJlIGFjY29tcGxpc2hlZCBieSB0cmFuc2FjdGlvbiBsYXllclxuICAgKiAgc2luY2UgaXQgaXMgZGVzdHJveWVkIHdoZW4gcmVjZWl2aW5nIHRoZSBmaXJzdCAyeHggYW5zd2VyXG4gICAqL1xuICBzZXRJbnZpdGUyeHhUaW1lcjogZnVuY3Rpb24ocmVxdWVzdCwgYm9keSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdGltZW91dCA9IFNJUC5UaW1lcnMuVDE7XG5cbiAgICB0aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiBpbnZpdGUyeHhSZXRyYW5zbWlzc2lvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5sb2dnZXIubG9nKCdubyBBQ0sgcmVjZWl2ZWQsIGF0dGVtcHRpbmcgdG8gcmV0cmFuc21pdCBPSycpO1xuXG4gICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgWydDb250YWN0OiAnICsgc2VsZi5jb250YWN0XSwgYm9keSk7XG5cbiAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0ICogMiwgU0lQLlRpbWVycy5UMik7XG5cbiAgICAgIHNlbGYudGltZXJzLmludml0ZTJ4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGludml0ZTJ4eFJldHJhbnNtaXNzaW9uLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSxcblxuICAvKipcbiAgICogUkZDMzI2MSAxNC4yXG4gICAqIElmIGEgVUFTIGdlbmVyYXRlcyBhIDJ4eCByZXNwb25zZSBhbmQgbmV2ZXIgcmVjZWl2ZXMgYW4gQUNLLFxuICAgKiAgaXQgU0hPVUxEIGdlbmVyYXRlIGEgQllFIHRvIHRlcm1pbmF0ZSB0aGUgZGlhbG9nLlxuICAgKi9cbiAgc2V0QUNLVGltZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMudGltZXJzLmFja1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ25vIEFDSyByZWNlaXZlZCBmb3IgYW4gZXh0ZW5kZWQgcGVyaW9kIG9mIHRpbWUsIHRlcm1pbmF0aW5nIHRoZSBjYWxsJyk7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHNlbGYudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgICAgc2VsZi5zZW5kUmVxdWVzdChTSVAuQy5CWUUpO1xuICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLk5PX0FDSyk7XG4gICAgICB9XG4gICAgfSwgU0lQLlRpbWVycy5USU1FUl9IKTtcbiAgfSxcblxuICAvKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25SZWFkeVRvUmVpbnZpdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhY3Rpb24gPSB0aGlzLnBlbmRpbmdfYWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgaWYgKCFhY3Rpb24gfHwgIXRoaXNbYWN0aW9uLm5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1thY3Rpb24ubmFtZV0oKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH1cbiAgfSxcblxuICBvbkRpYWxvZ0Vycm9yOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25ob2xkOiBmdW5jdGlvbihvcmlnaW5hdG9yKSB7XG4gICAgdGhpc1tvcmlnaW5hdG9yID09PSAnbG9jYWwnID8gJ2xvY2FsX2hvbGQnIDogJ3JlbW90ZV9ob2xkJ10gPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnaG9sZCcsIHsgb3JpZ2luYXRvcjogb3JpZ2luYXRvciB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9udW5ob2xkOiBmdW5jdGlvbihvcmlnaW5hdG9yKSB7XG4gICAgdGhpc1tvcmlnaW5hdG9yID09PSAnbG9jYWwnID8gJ2xvY2FsX2hvbGQnIDogJ3JlbW90ZV9ob2xkJ10gPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3VuaG9sZCcsIHsgb3JpZ2luYXRvcjogb3JpZ2luYXRvciB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25tdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5lbWl0KCdtdXRlZCcsIHtcbiAgICAgIGF1ZGlvOiBvcHRpb25zLmF1ZGlvLFxuICAgICAgdmlkZW86IG9wdGlvbnMudmlkZW9cbiAgICB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb251bm11dGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ3VubXV0ZWQnLCB7XG4gICAgICBhdWRpbzogb3B0aW9ucy5hdWRpbyxcbiAgICAgIHZpZGVvOiBvcHRpb25zLnZpZGVvXG4gICAgfSk7XG4gIH0sXG5cbiAgZmFpbGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlIHx8IG51bGwsIGNhdXNlIHx8IG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlamVjdGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLmVtaXQoJ3JlamVjdGVkJyxcbiAgICAgIHJlc3BvbnNlIHx8IG51bGwsXG4gICAgICBjYXVzZSB8fCBudWxsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjYW5jZWxlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbWl0KCdjYW5jZWwnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBhY2NlcHRlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgY2F1c2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlLCBjYXVzZSk7XG5cbiAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAodGhpcy5yZXBsYWNlZSkge1xuICAgICAgdGhpcy5yZXBsYWNlZS5lbWl0KCdyZXBsYWNlZCcsIHRoaXMpO1xuICAgICAgdGhpcy5yZXBsYWNlZS50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdGVybWluYXRlZDogZnVuY3Rpb24obWVzc2FnZSwgY2F1c2UpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJyxcbiAgICAgIG1lc3NhZ2UgfHwgbnVsbCxcbiAgICAgIGNhdXNlIHx8IG51bGxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbm5lY3Rpbmc6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnLCB7IHJlcXVlc3Q6IHJlcXVlc3QgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cblNlc3Npb24uZGVzdWdhciA9IGZ1bmN0aW9uIGRlc3VnYXIob3B0aW9ucykge1xuICBpZiAoZW52aXJvbm1lbnQuSFRNTE1lZGlhRWxlbWVudCAmJiBvcHRpb25zIGluc3RhbmNlb2YgZW52aXJvbm1lbnQuSFRNTE1lZGlhRWxlbWVudCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtZWRpYToge1xuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiBvcHRpb25zLnRhZ05hbWUgPT09ICdWSURFTydcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyOiB7XG4gICAgICAgICAgcmVtb3RlOiBvcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBvcHRpb25zIHx8IHt9O1xufTtcblxuXG5TZXNzaW9uLkMgPSBDO1xuU0lQLlNlc3Npb24gPSBTZXNzaW9uO1xuXG5cbkludml0ZVNlcnZlckNvbnRleHQgPSBmdW5jdGlvbih1YSwgcmVxdWVzdCkge1xuICB2YXIgZXhwaXJlcyxcbiAgICBzZWxmID0gdGhpcyxcbiAgICBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSxcbiAgICBjb250ZW50RGlzcCA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKTtcblxuICAvLyBDaGVjayBib2R5IGFuZCBjb250ZW50IHR5cGVcbiAgaWYgKCghY29udGVudERpc3AgJiYgY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB8fCAoY29udGVudERpc3AgJiYgY29udGVudERpc3AudHlwZSA9PT0gJ3JlbmRlcicpKSB7XG4gICAgdGhpcy5yZW5kZXJib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgIHRoaXMucmVuZGVydHlwZSA9IGNvbnRlbnRUeXBlO1xuICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vc2RwJyAmJiAoY29udGVudERpc3AgJiYgY29udGVudERpc3AudHlwZSA9PT0gJ3Nlc3Npb24nKSkge1xuICAgIHJlcXVlc3QucmVwbHkoNDE1KTtcbiAgICAvL1RPRE86IGluc3RlYWQgb2YgNDE1LCBwYXNzIG9mZiB0byB0aGUgbWVkaWEgaGFuZGxlciwgd2hvIGNhbiB0aGVuIGRlY2lkZSBpZiB3ZSBjYW4gdXNlIGl0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9UT0RPOiBtb3ZlIHRoaXMgaW50byBtZWRpYSBoYW5kbGVyXG4gIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXF1ZXN0KTtcbiAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlcXVlc3QpO1xuXG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5TZXJ2ZXJDb250ZXh0LCBbdWEsIHJlcXVlc3RdKTtcbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLlNlc3Npb24sIFt1YS5jb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnldKTtcblxuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0lOVklURV9SRUNFSVZFRDtcbiAgdGhpcy5mcm9tX3RhZyA9IHJlcXVlc3QuZnJvbV90YWc7XG4gIHRoaXMuaWQgPSByZXF1ZXN0LmNhbGxfaWQgKyB0aGlzLmZyb21fdGFnO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB0aGlzLmNvbnRhY3QgPSB0aGlzLnVhLmNvbnRhY3QudG9TdHJpbmcoKTtcblxuICB0aGlzLnJlY2VpdmVOb25JbnZpdGVSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHt9OyAvLyBpbnRlbnRpb25hbCBuby1vcFxuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlc2VydmVyY29udGV4dCcsIHRoaXMuaWQpO1xuXG4gIC8vU2F2ZSB0aGUgc2Vzc2lvbiBpbnRvIHRoZSB1YSBzZXNzaW9ucyBjb2xsZWN0aW9uLlxuICB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdID0gdGhpcztcblxuICAvL0dldCB0aGUgRXhwaXJlcyBoZWFkZXIgdmFsdWUgaWYgZXhpc3RzXG4gIGlmKHJlcXVlc3QuaGFzSGVhZGVyKCdleHBpcmVzJykpIHtcbiAgICBleHBpcmVzID0gcmVxdWVzdC5nZXRIZWFkZXIoJ2V4cGlyZXMnKSAqIDEwMDA7XG4gIH1cblxuICAvL1NldCAxMDByZWwgaWYgbmVjZXNzYXJ5XG4gIGZ1bmN0aW9uIHNldDEwMHJlbChoLGMpIHtcbiAgICBpZiAocmVxdWVzdC5oYXNIZWFkZXIoaCkgJiYgcmVxdWVzdC5nZXRIZWFkZXIoaCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcxMDByZWwnKSA+PSAwKSB7XG4gICAgICBzZWxmLnJlbDEwMCA9IGM7XG4gICAgfVxuICB9XG4gIHNldDEwMHJlbCgncmVxdWlyZScsIFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCk7XG4gIHNldDEwMHJlbCgnc3VwcG9ydGVkJywgU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCk7XG5cbiAgLyogU2V0IHRoZSB0b190YWcgYmVmb3JlXG4gICAqIHJlcGx5aW5nIGEgcmVzcG9uc2UgY29kZSB0aGF0IHdpbGwgY3JlYXRlIGEgZGlhbG9nLlxuICAgKi9cbiAgcmVxdWVzdC50b190YWcgPSBTSVAuVXRpbHMubmV3VGFnKCk7XG5cbiAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICBpZighdGhpcy5jcmVhdGVEaWFsb2cocmVxdWVzdCwgJ1VBUycsIHRydWUpKSB7XG4gICAgcmVxdWVzdC5yZXBseSg1MDAsICdNaXNzaW5nIENvbnRhY3QgaGVhZGVyIGZpZWxkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9Jbml0aWFsaXplIE1lZGlhIFNlc3Npb25cbiAgdGhpcy5tZWRpYUhhbmRsZXIgPSB0aGlzLm1lZGlhSGFuZGxlckZhY3RvcnkodGhpcywge1xuICAgIFJUQ0NvbnN0cmFpbnRzOiB7XCJvcHRpb25hbFwiOiBbeydEdGxzU3J0cEtleUFncmVlbWVudCc6ICd0cnVlJ31dfVxuICB9KTtcblxuICBpZiAodGhpcy5tZWRpYUhhbmRsZXIgJiYgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcykge1xuICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRMb2NhbFN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlTmV3U2Vzc2lvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtleHRyYUhlYWRlcnM6IFsnQ29udGFjdDogJyArIHNlbGYuY29udGFjdF19O1xuXG4gICAgaWYgKHNlbGYucmVsMTAwICE9PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgIHNlbGYucHJvZ3Jlc3Mob3B0aW9ucyk7XG4gICAgfVxuICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSO1xuXG4gICAgLy8gU2V0IHVzZXJOb0Fuc3dlclRpbWVyXG4gICAgc2VsZi50aW1lcnMudXNlck5vQW5zd2VyVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICByZXF1ZXN0LnJlcGx5KDQwOCk7XG4gICAgICBzZWxmLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuTk9fQU5TV0VSKTtcbiAgICAgIHNlbGYudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuTk9fQU5TV0VSKTtcbiAgICB9LCBzZWxmLnVhLmNvbmZpZ3VyYXRpb24ubm9BbnN3ZXJUaW1lb3V0KTtcblxuICAgIC8qIFNldCBleHBpcmVzVGltZXJcbiAgICAgKiBSRkMzMjYxIDEzLjMuMVxuICAgICAqL1xuICAgIGlmIChleHBpcmVzKSB7XG4gICAgICBzZWxmLnRpbWVycy5leHBpcmVzVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4Nyk7XG4gICAgICAgICAgc2VsZi5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgIHNlbGYudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuRVhQSVJFUyk7XG4gICAgICAgIH1cbiAgICAgIH0sIGV4cGlyZXMpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgnaW52aXRlJyxyZXF1ZXN0KTtcbiAgfVxuXG4gIGlmICghcmVxdWVzdC5ib2R5IHx8IHRoaXMucmVuZGVyYm9keSkge1xuICAgIFNJUC5UaW1lcnMuc2V0VGltZW91dChmaXJlTmV3U2Vzc2lvbiwgMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgIC50aGVuKFxuICAgICAgZmlyZU5ld1Nlc3Npb24sXG4gICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybignaW52YWxpZCBTRFAnKTtcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbkludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlID0ge1xuICByZWplY3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ3JlamVjdGluZyBSVENTZXNzaW9uJyk7XG5cbiAgICBTSVAuU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMudGVybWluYXRlZCgpO1xuICB9LFxuXG4gIHRlcm1pbmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyXG4gICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgIGJvZHkgPSBvcHRpb25zLmJvZHksXG4gICAgZGlhbG9nLFxuICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiZcbiAgICAgICB0aGlzLnJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLnN0YXRlICE9PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIGRpYWxvZyA9IHRoaXMuZGlhbG9nO1xuXG4gICAgICB0aGlzLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLkFDSykge1xuICAgICAgICAgIHRoaXMucmVxdWVzdChTSVAuQy5CWUUsIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5yZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgICAgICAgU0lQLkMuQllFLFxuICAgICAgICAgICAgdGhpcy5kaWFsb2cucmVtb3RlX3RhcmdldCxcbiAgICAgICAgICAgIHRoaXMudWEsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICdjc2VxJzogdGhpcy5kaWFsb2cubG9jYWxfc2VxbnVtKz0xLFxuICAgICAgICAgICAgICAnY2FsbF9pZCc6IHRoaXMuZGlhbG9nLmlkLmNhbGxfaWQsXG4gICAgICAgICAgICAgICdmcm9tX3VyaSc6IHRoaXMuZGlhbG9nLmxvY2FsX3VyaSxcbiAgICAgICAgICAgICAgJ2Zyb21fdGFnJzogdGhpcy5kaWFsb2cuaWQubG9jYWxfdGFnLFxuICAgICAgICAgICAgICAndG9fdXJpJzogdGhpcy5kaWFsb2cucmVtb3RlX3VyaSxcbiAgICAgICAgICAgICAgJ3RvX3RhZyc6IHRoaXMuZGlhbG9nLmlkLnJlbW90ZV90YWcsXG4gICAgICAgICAgICAgICdyb3V0ZV9zZXQnOiB0aGlzLmRpYWxvZy5yb3V0ZV9zZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIG5ldyBTSVAuUmVxdWVzdFNlbmRlcihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5yZXF1ZXN0LFxuICAgICAgICAgICAgICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy51YVxuICAgICAgICAgICkuc2VuZCgpO1xuICAgICAgICAgIGRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZW1pdCgnYnllJywgdGhpcy5yZXF1ZXN0KTtcbiAgICAgIHRoaXMudGVybWluYXRlZCgpO1xuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBkaWFsb2cgaW50byAndGhpcycgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBzZW5kIHRoZSBpbi1kaWFsb2cgQllFIDotKVxuICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGRpYWxvZyBpbnRvICd1YScgc28gdGhlIEFDSyBjYW4gcmVhY2ggJ3RoaXMnIHNlc3Npb25cbiAgICAgIHRoaXMudWEuZGlhbG9nc1tkaWFsb2cuaWQudG9TdHJpbmcoKV0gPSBkaWFsb2c7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMuYnllKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlamVjdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5NZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gICAqL1xuICBwcm9ncmVzczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXJcbiAgICAgIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgwLFxuICAgICAgcmVhc29uUGhyYXNlID0gb3B0aW9ucy5yZWFzb25QaHJhc2UsXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICBpY2VTZXJ2ZXJzLFxuICAgICAgc3R1blNlcnZlcnMgPSBvcHRpb25zLnN0dW5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgICB0dXJuU2VydmVycyA9IG9wdGlvbnMudHVyblNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHksXG4gICAgICByZXNwb25zZTtcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiAxOTkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzQ29kZTogJyArIHN0YXR1c0NvZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChzdHVuU2VydmVycyB8fCB0dXJuU2VydmVycykge1xuICAgICAgaWYgKHN0dW5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsnc3R1blNlcnZlcnMnXShzdHVuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3R1blNlcnZlcnM6ICcrIHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0dW5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHVyblNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWyd0dXJuU2VydmVycyddKHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0dXJuU2VydmVyczogJysgdHVyblNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHVyblNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoe1xuICAgICAgICBzdHVuU2VydmVyczogdGhpcy5zdHVuU2VydmVycyxcbiAgICAgICAgdHVyblNlcnZlcnM6IHRoaXMudHVyblNlcnZlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvMTAwcmVsKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgICAgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODM7XG5cbiAgICAgIC8vIFNldCBzdGF0dXMgYW5kIGFkZCBleHRyYSBoZWFkZXJzXG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLO1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVxdWlyZTogMTAwcmVsJyk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUlNlcTogJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSk7XG5cbiAgICAgIC8vIFNhdmUgbWVkaWEgaGludCBmb3IgbGF0ZXIgKHJlZmVycmVkIHNlc3Npb25zKVxuICAgICAgdGhpcy5tZWRpYUhpbnQgPSBvcHRpb25zLm1lZGlhO1xuXG4gICAgICAvLyBHZXQgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24gdG8gYWRkIHRvIHByZWFjY2VwdCB3aXRoXG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihvcHRpb25zLm1lZGlhKVxuICAgICAgLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoYm9keSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmVhcmx5X3NkcCA9IGJvZHk7XG4gICAgICAgICAgdGhpc1t0aGlzLmhhc09mZmVyID8gJ2hhc0Fuc3dlcicgOiAnaGFzT2ZmZXInXSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBSZXRyYW5zbWl0IHVudGlsIHdlIGdldCBhIHJlc3BvbnNlIG9yIHdlIHRpbWUgb3V0IChzZWUgcHJhY2tUaW1lciBiZWxvdylcbiAgICAgICAgICB2YXIgdGltZW91dCA9IFNJUC5UaW1lcnMuVDE7XG4gICAgICAgICAgdGhpcy50aW1lcnMucmVsMXh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gcmVsMXh4UmV0cmFuc21pc3Npb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSwgbnVsbCwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgICAgICAgIHRpbWVvdXQgKj0gMjtcbiAgICAgICAgICAgIHRoaXMudGltZXJzLnJlbDF4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHJlbDF4eFJldHJhbnNtaXNzaW9uLmJpbmQodGhpcyksIHRpbWVvdXQpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGltZW91dCk7XG5cbiAgICAgICAgICAvLyBUaW1lb3V0IGFuZCByZWplY3QgSU5WSVRFIGlmIG5vIHJlc3BvbnNlXG4gICAgICAgICAgdGhpcy50aW1lcnMucHJhY2tUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdubyBQUkFDSyByZWNlaXZlZCwgcmVqZWN0aW5nIHRoZSBjYWxsJyk7XG4gICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5yZWwxeHhUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoNTA0KTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuTk9fUFJBQ0spO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgU0lQLlRpbWVycy5UMSAqIDY0KTtcblxuICAgICAgICAgIC8vIFNlbmQgdGhlIGluaXRpYWwgcmVzcG9uc2VcbiAgICAgICAgICByZXNwb25zZSA9IHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlLCByZWFzb25QaHJhc2UpO1xuICAgICAgICB9LmJpbmQodGhpcyksXG5cbiAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlICgpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoNDgwKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgKTtcbiAgICB9IC8vIGVuZCBkbzEwMHJlbFxuXG4gICAgZnVuY3Rpb24gbm9ybWFsUmVwbHkoKSB7XG4gICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSwgcmVhc29uUGhyYXNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlICE9PSAxMDAgJiZcbiAgICAgICAgKHRoaXMucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQgfHxcbiAgICAgICAgICh0aGlzLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCAmJiBvcHRpb25zLnJlbDEwMCkgfHxcbiAgICAgICAgICh0aGlzLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCAmJiAodGhpcy51YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSkpKSB7XG4gICAgICBkbzEwMHJlbC5hcHBseSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsUmVwbHkuYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAgICovXG4gIGFjY2VwdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKFNlc3Npb24uZGVzdWdhcihvcHRpb25zKSk7XG4gICAgU0lQLlV0aWxzLm9wdGlvbnNPdmVycmlkZShvcHRpb25zLCAnbWVkaWEnLCAnbWVkaWFDb25zdHJhaW50cycsIHRydWUsIHRoaXMubG9nZ2VyLCB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ubWVkaWEpO1xuICAgIHRoaXMubWVkaWFIaW50ID0gb3B0aW9ucy5tZWRpYTtcblxuICAgIC8vIGNvbW1lbnRlZCBvdXQgbm93LXVudXNlZCBob2xkLXJlbGF0ZWQgdmFyaWFibGVzIGZvciBqc2hpbnQuIFNlZSBiZWxvdy4gSk1GIDIwMTQtMS0yMVxuICAgIHZhclxuICAgICAgLy9pZHgsIGxlbmd0aCwgaGFzQXVkaW8sIGhhc1ZpZGVvLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LFxuICAgICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgIC8vbWVkaWFTdHJlYW0gPSBvcHRpb25zLm1lZGlhU3RyZWFtIHx8IG51bGwsXG4gICAgICBpY2VTZXJ2ZXJzLFxuICAgICAgc3R1blNlcnZlcnMgPSBvcHRpb25zLnN0dW5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgICB0dXJuU2VydmVycyA9IG9wdGlvbnMudHVyblNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIHNkcENyZWF0aW9uU3VjY2VlZGVkID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAvLyBydW4gZm9yIHJlcGx5IHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICByZXBseVN1Y2NlZWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG5cbiAgICAgICAgICAgIHNlbGYuc2V0SW52aXRlMnh4VGltZXIocmVxdWVzdCwgYm9keSk7XG4gICAgICAgICAgICBzZWxmLnNldEFDS1RpbWVyKCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIHJ1biBmb3IgcmVwbHkgZmFpbHVyZSBjYWxsYmFja1xuICAgICAgICAgIHJlcGx5RmFpbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hyb21lIG1pZ2h0IGNhbGwgb25hZGRzdHJlYW0gYmVmb3JlIGFjY2VwdCgpIGlzIGNhbGxlZCwgd2hpY2ggbWVhbnNcbiAgICAgICAgLy8gbWVkaWFIYW5kbGVyLnJlbmRlcigpIHdhcyBjYWxsZWQgd2l0aG91dCBhIHJlbmRlckhpbnQsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmUtcmVuZGVyIG5vdyB0aGF0IG1lZGlhSGludC5yZW5kZXIgaGFzIGJlZW4gc2V0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBDaHJvbWUgc2VlbXMgdG8gYmUgaW4gdGhlIHJpZ2h0IHJlZ2FyZGluZyB0aGlzLCBzZWVcbiAgICAgICAgLy8gaHR0cDovL2Rldi53My5vcmcvMjAxMS93ZWJydGMvZWRpdG9yL3dlYnJ0Yy5odG1sI3dpZGwtUlRDUGVlckNvbm5lY3Rpb24tb25hZGRzdHJlYW1cbiAgICAgICAgc2VsZi5tZWRpYUhhbmRsZXIucmVuZGVyKCk7XG5cbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcgKyBzZWxmLmNvbnRhY3QpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcgKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgaWYoIXNlbGYuaGFzT2ZmZXIpIHtcbiAgICAgICAgICBzZWxmLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2UgPSByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbHlTdWNjZWVkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbHlGYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIGlmIChzZWxmLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkgeyAvLyBEaWRuJ3QgZmFpbFxuICAgICAgICAgIHNlbGYuYWNjZXB0ZWQocmVzcG9uc2UsIFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UoMjAwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNkcENyZWF0aW9uRmFpbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIC0gZmFpbCBvdXQgb24gZXJyb3JcbiAgICAgICAgc2VsZi5yZXF1ZXN0LnJlcGx5KDQ4MCk7XG4gICAgICAgIC8vc2VsZi5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5VU0VSX0RFTklFRF9NRURJQV9BQ0NFU1MpO1xuICAgICAgICBzZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgc2VsZi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgfTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUikge1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19BTlNXRVJFRDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0dW5TZXJ2ZXJzIHx8IHR1cm5TZXJ2ZXJzKSAmJlxuICAgICAgICAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0VBUkxZX01FRElBICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykpIHtcbiAgICAgIGlmIChzdHVuU2VydmVycykge1xuICAgICAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3N0dW5TZXJ2ZXJzJ10oc3R1blNlcnZlcnMpO1xuICAgICAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0dW5TZXJ2ZXJzOiAnKyBzdHVuU2VydmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHVuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR1cm5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsndHVyblNlcnZlcnMnXSh0dXJuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdHVyblNlcnZlcnM6ICcrIHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR1cm5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci51cGRhdGVJY2VTZXJ2ZXJzKHtcbiAgICAgICAgc3R1blNlcnZlcnM6IHRoaXMuc3R1blNlcnZlcnMsXG4gICAgICAgIHR1cm5TZXJ2ZXJzOiB0aGlzLnR1cm5TZXJ2ZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gICAgaWYoIXRoaXMuY3JlYXRlRGlhbG9nKHJlcXVlc3QsICdVQVMnKSkge1xuICAgICAgcmVxdWVzdC5yZXBseSg1MDAsICdNaXNzaW5nIENvbnRhY3QgaGVhZGVyIGZpZWxkJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lcik7XG5cbiAgICAvLyB0aGlzIGhvbGQtcmVsYXRlZCBjb2RlIGJyZWFrcyBGRiBhY2NlcHRpbmcgbmV3IGNhbGxzIC0gSk1GIDIwMTQtMS0yMVxuICAgIC8qXG4gICAgbGVuZ3RoID0gdGhpcy5nZXRSZW1vdGVTdHJlYW1zKCkubGVuZ3RoO1xuXG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcygpW2lkeF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhc1ZpZGVvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKClbaWR4XS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFzQXVkaW8gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzQXVkaW8gJiYgdGhpcy5tZWRpYUNvbnN0cmFpbnRzLmF1ZGlvID09PSB0cnVlKSB7XG4gICAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgICAgIGlmIChtZWRpYVN0cmVhbSkge1xuICAgICAgICBsZW5ndGggPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sobWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVtpZHhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzVmlkZW8gJiYgdGhpcy5tZWRpYUNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgICAgIGlmIChtZWRpYVN0cmVhbSkge1xuICAgICAgICBsZW5ndGggPSBtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sobWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVtpZHhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgc2RwQ3JlYXRpb25TdWNjZWVkZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oc2VsZi5tZWRpYUhpbnQpXG4gICAgICAudGhlbihcbiAgICAgICAgc2RwQ3JlYXRpb25TdWNjZWVkZWQsXG4gICAgICAgIHNkcENyZWF0aW9uRmFpbGVkXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG5cbiAgICAvLyBJU0MgUkVDRUlWRSBSRVFVRVNUXG5cbiAgICBmdW5jdGlvbiBjb25maXJtU2Vzc2lvbigpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuXG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgIHRoaXMudW5tdXRlKCk7XG5cbiAgICAgIC8vIFRPRE8gLSB0aGlzIGxvZ2ljIGFzc3VtZXMgQ29udGVudC1EaXNwb3NpdGlvbiBkZWZhdWx0c1xuICAgICAgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICBpZiAoY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgdGhpcy5yZW5kZXJ0eXBlID0gY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBTSVAuQy5DQU5DRUw6XG4gICAgICAvKiBSRkMzMjYxIDE1IFN0YXRlcyB0aGF0IGEgVUFTIG1heSBoYXZlIGFjY2VwdGVkIGFuIGludml0YXRpb24gd2hpbGUgYSBDQU5DRUxcbiAgICAgICAqIHdhcyBpbiBwcm9ncmVzcyBhbmQgdGhhdCB0aGUgVUFDIE1BWSBjb250aW51ZSB3aXRoIHRoZSBzZXNzaW9uIGVzdGFibGlzaGVkIGJ5XG4gICAgICAgKiBhbnkgMnh4IHJlc3BvbnNlLCBvciBNQVkgdGVybWluYXRlIHdpdGggQllFLiBTSVAgZG9lcyBjb250aW51ZSB3aXRoIHRoZVxuICAgICAgICogZXN0YWJsaXNoZWQgc2Vzc2lvbi4gU28gdGhlIENBTkNFTCBpcyBwcm9jZXNzZWQgb25seSBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgeWV0XG4gICAgICAgKiBlc3RhYmxpc2hlZC5cbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgICogVGVybWluYXRlIHRoZSB3aG9sZSBzZXNzaW9uIGluIGNhc2UgdGhlIHVzZXIgZGlkbid0IGFjY2VwdCAob3IgeWV0IHRvIHNlbmQgdGhlIGFuc3dlcikgbm9yIHJlamVjdCB0aGVcbiAgICAgICAqcmVxdWVzdCBvcGVuaW5nIHRoZSBzZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0sgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSyB8fFxuICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRUQpIHtcblxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NBTkNFTEVEO1xuICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoNDg3KTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZChyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgICAgaWYocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgICAgIC8vIEFDSyBjb250YWlucyBhbnN3ZXIgdG8gYW4gSU5WSVRFIHcvbyBTRFAgbmVnb3RpYXRpb25cbiAgICAgICAgICAgIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIFNJUC5IYWNrcy5BbGxCcm93c2Vycy5tYXNrRHRscyhyZXF1ZXN0KTtcblxuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgIGNvbmZpcm1TZXNzaW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogJzQ4OCcsXG4gICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6ICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVhcmx5X3NkcCkge1xuICAgICAgICAgICAgY29uZmlybVNlc3Npb24uYXBwbHkodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVE9ETzogUGFzcyB0byBtZWRpYWhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25maXJtU2Vzc2lvbi5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVAuQy5QUkFDSzpcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0sgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgIC8vbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgIGlmKCF0aGlzLmhhc0Fuc3dlcikge1xuICAgICAgICAgIGlmKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJykgPT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5yZWwxeHhUaW1lcik7XG4gICAgICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucHJhY2tUaW1lcik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgIC8vUkVWSVNJVFxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZSgpO1xuICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICAgIC8vVE9ETzogU2VuZCB0byBtZWRpYSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAnNDg4JyxcbiAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogJ0JhZCBNZWRpYSBEZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAnNDg4JyxcbiAgICAgICAgICAgICAgcmVhc29uUGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucmVsMXh4VGltZXIpO1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnByYWNrVGltZXIpO1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcblxuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgIC8vUkVWSVNJVFxuICAgICAgICAgIHRoaXMubXV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdC5hcHBseSh0aGlzLCBbcmVxdWVzdF0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfVxuICB9XG5cbn07XG5cblNJUC5JbnZpdGVTZXJ2ZXJDb250ZXh0ID0gSW52aXRlU2VydmVyQ29udGV4dDtcblxuSW52aXRlQ2xpZW50Q29udGV4dCA9IGZ1bmN0aW9uKHVhLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoU2Vzc2lvbi5kZXN1Z2FyKG9wdGlvbnMpKTtcbiAgb3B0aW9ucy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMucGFyYW1zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHZhciBpY2VTZXJ2ZXJzLFxuICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICBzdHVuU2VydmVycyA9IG9wdGlvbnMuc3R1blNlcnZlcnMgfHwgbnVsbCxcbiAgICB0dXJuU2VydmVycyA9IG9wdGlvbnMudHVyblNlcnZlcnMgfHwgbnVsbCxcbiAgICBtZWRpYUhhbmRsZXJGYWN0b3J5ID0gb3B0aW9ucy5tZWRpYUhhbmRsZXJGYWN0b3J5IHx8IHVhLmNvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeSxcbiAgICBpc01lZGlhU3VwcG9ydGVkID0gbWVkaWFIYW5kbGVyRmFjdG9yeS5pc1N1cHBvcnRlZDtcblxuICAvLyBDaGVjayBXZWJSVEMgc3VwcG9ydFxuICBpZiAoaXNNZWRpYVN1cHBvcnRlZCAmJiAhaXNNZWRpYVN1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLk5vdFN1cHBvcnRlZEVycm9yKCdNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICB0aGlzLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7fTtcbiAgdGhpcy5pbnZpdGVXaXRob3V0U2RwID0gb3B0aW9ucy5pbnZpdGVXaXRob3V0U2RwIHx8IGZhbHNlO1xuXG4gIC8vIFNldCBhbm9ueW1vdXMgcHJvcGVydHlcbiAgdGhpcy5hbm9ueW1vdXMgPSBvcHRpb25zLmFub255bW91cyB8fCBmYWxzZTtcblxuICAvLyBDdXN0b20gZGF0YSB0byBiZSBzZW50IGVpdGhlciBpbiBJTlZJVEUgb3IgaW4gQUNLXG4gIHRoaXMucmVuZGVyYm9keSA9IG9wdGlvbnMucmVuZGVyYm9keSB8fCBudWxsO1xuICB0aGlzLnJlbmRlcnR5cGUgPSBvcHRpb25zLnJlbmRlcnR5cGUgfHwgJ3RleHQvcGxhaW4nO1xuXG4gIG9wdGlvbnMucGFyYW1zLmZyb21fdGFnID0gdGhpcy5mcm9tX3RhZztcblxuICAvKiBEbyBub3QgYWRkIDtvYiBpbiBpbml0aWFsIGZvcm1pbmcgZGlhbG9nIHJlcXVlc3RzIGlmIHRoZSByZWdpc3RyYXRpb24gb3ZlclxuICAgKiAgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBnb3QgYSBHUlVVIFVSSS5cbiAgICovXG4gIHRoaXMuY29udGFjdCA9IHVhLmNvbnRhY3QudG9TdHJpbmcoe1xuICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgb3V0Ym91bmQ6IHRoaXMuYW5vbnltb3VzID8gIXVhLmNvbnRhY3QudGVtcF9ncnV1IDogIXVhLmNvbnRhY3QucHViX2dydXVcbiAgfSk7XG5cbiAgaWYgKHRoaXMuYW5vbnltb3VzKSB7XG4gICAgb3B0aW9ucy5wYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSA9ICdBbm9ueW1vdXMnO1xuICAgIG9wdGlvbnMucGFyYW1zLmZyb21fdXJpID0gJ3NpcDphbm9ueW1vdXNAYW5vbnltb3VzLmludmFsaWQnO1xuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1AtUHJlZmVycmVkLUlkZW50aXR5OiAnKyB1YS5jb25maWd1cmF0aW9uLnVyaS50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUHJpdmFjeTogaWQnKTtcbiAgfVxuICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gIGlmICghdGhpcy5pbnZpdGVXaXRob3V0U2RwKSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJib2R5KSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHRoaXMucmVuZGVydHlwZSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtRGlzcG9zaXRpb246IHJlbmRlcjtoYW5kbGluZz1vcHRpb25hbCcpO1xuICB9XG5cbiAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVxdWlyZTogMTAwcmVsJyk7XG4gIH1cbiAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXF1aXJlOiByZXBsYWNlcycpO1xuICB9XG5cbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG5cbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLkNsaWVudENvbnRleHQsIFt1YSwgU0lQLkMuSU5WSVRFLCB0YXJnZXQsIG9wdGlvbnNdKTtcbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLlNlc3Npb24sIFttZWRpYUhhbmRsZXJGYWN0b3J5XSk7XG5cbiAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19OVUxMKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgfVxuXG4gIC8vIFNlc3Npb24gcGFyYW1ldGVyIGluaXRpYWxpemF0aW9uXG4gIHRoaXMuZnJvbV90YWcgPSBTSVAuVXRpbHMubmV3VGFnKCk7XG5cbiAgLy8gT3V0Z29pbmdTZXNzaW9uIHNwZWNpZmljIHBhcmFtZXRlcnNcbiAgdGhpcy5pc0NhbmNlbGVkID0gZmFsc2U7XG4gIHRoaXMucmVjZWl2ZWRfMTAwID0gZmFsc2U7XG5cbiAgdGhpcy5tZXRob2QgPSBTSVAuQy5JTlZJVEU7XG5cbiAgdGhpcy5yZWNlaXZlTm9uSW52aXRlUmVzcG9uc2UgPSB0aGlzLnJlY2VpdmVSZXNwb25zZTtcbiAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSB0aGlzLnJlY2VpdmVJbnZpdGVSZXNwb25zZTtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLmludml0ZWNsaWVudGNvbnRleHQnKTtcblxuICBpZiAoc3R1blNlcnZlcnMpIHtcbiAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3N0dW5TZXJ2ZXJzJ10oc3R1blNlcnZlcnMpO1xuICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHVuU2VydmVyczogJysgc3R1blNlcnZlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0dW5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICB9XG4gIH1cblxuICBpZiAodHVyblNlcnZlcnMpIHtcbiAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3R1cm5TZXJ2ZXJzJ10odHVyblNlcnZlcnMpO1xuICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0dXJuU2VydmVyczogJysgdHVyblNlcnZlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR1cm5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICB9XG4gIH1cblxuICB1YS5hcHBsaWNhbnRzW3RoaXNdID0gdGhpcztcblxuICB0aGlzLmlkID0gdGhpcy5yZXF1ZXN0LmNhbGxfaWQgKyB0aGlzLmZyb21fdGFnO1xuXG4gIC8vSW5pdGlhbGl6ZSBNZWRpYSBTZXNzaW9uXG4gIHRoaXMubWVkaWFIYW5kbGVyID0gdGhpcy5tZWRpYUhhbmRsZXJGYWN0b3J5KHRoaXMsIHtcbiAgICBSVENDb25zdHJhaW50czogdGhpcy5SVENDb25zdHJhaW50cyxcbiAgICBzdHVuU2VydmVyczogdGhpcy5zdHVuU2VydmVycyxcbiAgICB0dXJuU2VydmVyczogdGhpcy50dXJuU2VydmVyc1xuICB9KTtcblxuICBpZiAodGhpcy5tZWRpYUhhbmRsZXIgJiYgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcykge1xuICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRMb2NhbFN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gIH1cblxuICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKG9wdGlvbnMsICdtZWRpYScsICdtZWRpYUNvbnN0cmFpbnRzJywgdHJ1ZSwgdGhpcy5sb2dnZXIsIHRoaXMudWEuY29uZmlndXJhdGlvbi5tZWRpYSk7XG4gIHRoaXMubWVkaWFIaW50ID0gb3B0aW9ucy5tZWRpYTtcbn07XG5cbkludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlID0ge1xuICBpbnZpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvL1NhdmUgdGhlIHNlc3Npb24gaW50byB0aGUgdWEgc2Vzc2lvbnMgY29sbGVjdGlvbi5cbiAgICAvL05vdGU6IHBsYWNpbmcgaW4gY29uc3RydWN0b3IgYnJlYWtzIGNhbGwgdG8gcmVxdWVzdC5jYW5jZWwgb24gY2xvc2UuLi4gVXNlciBkb2VzIG5vdCBuZWVkIHRoaXMgYW55d2F5XG4gICAgdGhpcy51YS5zZXNzaW9uc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAvL05vdGU6IGR1ZSB0byB0aGUgd2F5IEZpcmVmb3ggaGFuZGxlcyBnVU0gY2FsbHMsIGl0IGlzIHJlY29tbWVuZGVkIHRvIG1ha2UgdGhlIGdVTSBjYWxsIGF0IHRoZSBhcHAgbGV2ZWxcbiAgICAvLyBhbmQgaGFuZCBzaXAuanMgYSBzdHJlYW0gYXMgdGhlIG1lZGlhSGludFxuICAgIGlmICh0aGlzLmludml0ZVdpdGhvdXRTZHApIHtcbiAgICAgIC8vanVzdCBzZW5kIGFuIGludml0ZSB3aXRoIG5vIHNkcC4uLlxuICAgICAgdGhpcy5yZXF1ZXN0LmJvZHkgPSBzZWxmLnJlbmRlcmJvZHk7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0lOVklURV9TRU5UO1xuICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uKHNlbGYubWVkaWFIaW50KVxuICAgICAgLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyhvZmZlcikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQ2FuY2VsZWQgfHwgc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgICAgc2VsZi5yZXF1ZXN0LmJvZHkgPSBvZmZlcjtcbiAgICAgICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX0lOVklURV9TRU5UO1xuICAgICAgICAgIHNlbGYuc2VuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUoKSB7XG4gICAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8uLi5mYWlsIG91dFxuICAgICAgICAgIC8vc2VsZi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlVTRVJfREVOSUVEX01FRElBX0FDQ0VTUyk7XG4gICAgICAgICAgLy9zZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICBzZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZUludml0ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBjYXVzZSwgLy9sb2NhbE1lZGlhLFxuICAgICAgc2Vzc2lvbiA9IHRoaXMsXG4gICAgICBpZCA9IHJlc3BvbnNlLmNhbGxfaWQgKyByZXNwb25zZS5mcm9tX3RhZyArIHJlc3BvbnNlLnRvX3RhZyxcbiAgICAgIGV4dHJhSGVhZGVycyA9IFtdLFxuICAgICAgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEIHx8IHJlc3BvbnNlLm1ldGhvZCAhPT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlhbG9nICYmIChyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPD0gMjk5KSkge1xuICAgICAgaWYgKGlkICE9PSB0aGlzLmRpYWxvZy5pZC50b1N0cmluZygpICkge1xuICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJywgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLkFDSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogU0lQLlV0aWxzLmdlbmVyYXRlRmFrZVNEUChyZXNwb25zZS5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5CWUUpO1xuXG4gICAgICAgIC8qIE5PVEU6IFRoaXMgZmFpbHMgYmVjYXVzZSB0aGUgZm9ya2luZyBwcm94eSBkb2VzIG5vdCByZWNvZ25pemUgdGhhdCBhbiB1bmFuc3dlcmFibGVcbiAgICAgICAgICogbGVnIChkdWUgdG8gcGVlckNvbm5lY3Rpb24gbGltaXRhdGlvbnMpIGhhcyBiZWVuIGFuc3dlcmVkIGZpcnN0LiBJZiB5b3VyIGZvcmtpbmdcbiAgICAgICAgICogcHJveHkgZG9lcyBub3QgaGFuZyB1cCBhbGwgdW5hbnN3ZXJlZCBicmFuY2hlcyBvbiB0aGUgZmlyc3QgYnJhbmNoIGFuc3dlcmVkLCByZW1vdmUgdGhpcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse2NzZXE6IHJlc3BvbnNlLmNzZXF9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgLy8gaW52aXRlIHcvbyBzZHAgaXMgd2FpdGluZyBmb3IgY2FsbGJhY2tcbiAgICAgICAgLy9hbiBpbnZpdGUgd2l0aCBzZHAgbXVzdCBnbyBvbiwgYW5kIGhhc0Fuc3dlciBpcyB0cnVlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaWFsb2cgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPCAyMDApIHtcbiAgICAgIC8qXG4gICAgICAgIEVhcmx5IG1lZGlhIGhhcyBiZWVuIHNldCB1cCB3aXRoIGF0IGxlYXN0IG9uZSBvdGhlciBkaWZmZXJlbnQgYnJhbmNoLFxuICAgICAgICBidXQgYSBmaW5hbCAyeHggcmVzcG9uc2UgaGFzbid0IGJlZW4gcmVjZWl2ZWRcbiAgICAgICovXG4gICAgICBpZiAodGhpcy5kaWFsb2cucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSAhPT0gLTEgfHxcbiAgICAgICAgICAodGhpcy5kaWFsb2cucHJhY2tlZFt0aGlzLmRpYWxvZy5wcmFja2VkLmxlbmd0aC0xXSA+PSByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSAmJiB0aGlzLmRpYWxvZy5wcmFja2VkLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVhcmx5RGlhbG9nc1tpZF0gJiYgIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJywgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQuaW5kZXhPZihyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSkgIT09IC0xIHx8XG4gICAgICAgICAgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkW3RoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aC0xXSA+PSByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSAmJiB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5sZW5ndGggPiAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSQWNrOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgKyAnICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSk7XG4gICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcblxuICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLlBSQUNLLCB7XG4gICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICBib2R5OiBTSVAuVXRpbHMuZ2VuZXJhdGVGYWtlU0RQKHJlc3BvbnNlLmJvZHkpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcm9jZWVkIHRvIGNhbmNlbGxhdGlvbiBpZiB0aGUgdXNlciByZXF1ZXN0ZWQuXG4gICAgaWYodGhpcy5pc0NhbmNlbGVkKSB7XG4gICAgICBpZihyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAxMDAgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPCAyMDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LmNhbmNlbCh0aGlzLmNhbmNlbFJlYXNvbik7XG4gICAgICAgIHRoaXMuY2FuY2VsZWQobnVsbCk7XG4gICAgICB9IGVsc2UgaWYocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlIDwgMjk5KSB7XG4gICAgICAgIHRoaXMuYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdieWUnLCB0aGlzLnJlcXVlc3QpO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAzMDApIHtcbiAgICAgICAgY2F1c2UgPSBTSVAuQy5SRUFTT05fUEhSQVNFW3Jlc3BvbnNlLnN0YXR1c19jb2RlXSB8fCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQ7XG4gICAgICAgIHRoaXMucmVqZWN0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKHRydWUpIHtcbiAgICAgIGNhc2UgL14xMDAkLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgdGhpcy5yZWNlaXZlZF8xMDAgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSkpOlxuICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggMXh4IHJlc3BvbnNlcyB3aXRob3V0IFRvIHRhZy5cbiAgICAgICAgaWYoIXJlc3BvbnNlLnRvX3RhZykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJzF4eCByZXNwb25zZSByZWNlaXZlZCB3aXRob3V0IHRvIHRhZycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIEVhcmx5IERpYWxvZyBpZiAxWFggY29tZXMgd2l0aCBjb250YWN0XG4gICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgICAgICAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnLCB0cnVlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU18xWFhfUkVDRUlWRUQ7XG5cbiAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdyZXF1aXJlJykgJiZcbiAgICAgICAgICAgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyZXF1aXJlJykuaW5kZXhPZignMTAwcmVsJykgIT09IC0xKSB7XG5cbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoaXMuZGlhbG9nIGlzIGFscmVhZHkgY29uZmlybWVkXG4gICAgICAgICAgaWYgKHRoaXMuZGlhbG9nIHx8ICF0aGlzLmVhcmx5RGlhbG9nc1tpZF0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkW3RoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aC0xXSA+PSByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSAmJiB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXNwb25zZSk7XG4gICAgICAgICAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlc3BvbnNlKTtcblxuICAgICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLlBSQUNLLCB7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzT2ZmZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG5cbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5QUkFDSywge1xuICAgICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubXV0ZSgpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQ4OCwgJ05vdCBBY2NlcHRhYmxlIEhlcmUnKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlYXJseURpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzW2lkXTtcbiAgICAgICAgICAgIHZhciBlYXJseU1lZGlhID0gZWFybHlEaWFsb2cubWVkaWFIYW5kbGVyO1xuXG4gICAgICAgICAgICBlYXJseURpYWxvZy5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuXG4gICAgICAgICAgICBlYXJseU1lZGlhLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAudGhlbihlYXJseU1lZGlhLmdldERlc2NyaXB0aW9uLmJpbmQoZWFybHlNZWRpYSwgc2Vzc2lvbi5tZWRpYUhpbnQpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gb25TdWNjZXNzKHNkcCkge1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnKTtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcbiAgICAgICAgICAgICAgZWFybHlEaWFsb2cuc2VuZFJlcXVlc3Qoc2Vzc2lvbiwgU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZHBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIG9uRmFpbHVyZShlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBmYWlsIG91dCBvbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHNlc3Npb24uZmFpbGVkKGd1bSBlcnJvcik7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnByYWNrZWQuc3BsaWNlKGVhcmx5RGlhbG9nLnByYWNrZWQuaW5kZXhPZihyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSksIDEpO1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIG5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybignaW52YWxpZCBTRFAnKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgdmFyIGNzZXEgPSB0aGlzLnJlcXVlc3QuY3NlcSArICcgJyArIHRoaXMucmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIGlmIChjc2VxICE9PSByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSAmJiB0aGlzLmRpYWxvZykge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgIHRoaXMudW5tdXRlKCk7XG4gICAgICAgICAgLypsb2NhbE1lZGlhID0gdGhpcy5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfSovXG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyB0aGlzLnJlbmRlcnR5cGUpO1xuICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSB0aGlzLnJlbmRlcmJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMuY3NlcSA9IHJlc3BvbnNlLmNzZXE7XG4gICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0ssIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhpcy5kaWFsb2cgaXMgYWxyZWFkeSBjb25maXJtZWRcbiAgICAgICAgaWYgKHRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBTSVAuSGFja3MuRmlyZWZveC5jYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2UocmVzcG9uc2UpO1xuICAgICAgICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVzcG9uc2UpO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW52aXRlIHdpdGhvdXQgc2RwXG4gICAgICAgIGlmICghdGhpcy5oYXNPZmZlcikge1xuICAgICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0gJiYgdGhpcy5lYXJseURpYWxvZ3NbaWRdLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhKSB7XG4gICAgICAgICAgICAvL1JFVklTSVRcbiAgICAgICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIgPSB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ubWVkaWFIYW5kbGVyO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywge2NzZXE6cmVzcG9uc2UuY3NlcX0pO1xuXG4gICAgICAgICAgICB0aGlzLnVubXV0ZSgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRoaXMuYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZighcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICB0aGlzLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSwgNDAwLCAnTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAudGhlbih0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbi5iaW5kKHRoaXMubWVkaWFIYW5kbGVyLCB0aGlzLm1lZGlhSGludCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiBvblN1Y2Nlc3Moc2RwKSB7XG4gICAgICAgICAgICAgIC8vdmFyIGxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIGlmKHNlc3Npb24uaXNDYW5jZWxlZCB8fCBzZXNzaW9uLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNkcCA9IFNJUC5IYWNrcy5GaXJlZm94Lmhhc01pc3NpbmdDTGluZUluU0RQKHNkcCk7XG5cbiAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgIHNlc3Npb24uaGFzQW5zd2VyID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBzZXNzaW9uLnVubXV0ZSgpO1xuICAgICAgICAgICAgICAvKmxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse1xuICAgICAgICAgICAgICAgIGJvZHk6IHNkcCxcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6WydDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcCddLFxuICAgICAgICAgICAgICAgIGNzZXE6cmVzcG9uc2UuY3NlcVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIG9uRmFpbHVyZShlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gZG8gc29tZXRoaW5nIGhlcmVcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKFwidGhlcmUgd2FzIGEgcHJvYmxlbVwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKCdpbnZhbGlkIFNEUCcpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucmVwbHkoNDg4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQW5zd2VyKXtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJib2R5KSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgc2Vzc2lvbi5yZW5kZXJ0eXBlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gdGhpcy5yZW5kZXJib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0MDAsICdNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307Ly8sbG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgIHNlc3Npb24udW5tdXRlKCk7XG4gICAgICAgICAgICAgIC8qbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5yZW5kZXJib2R5KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHNlc3Npb24ucmVuZGVydHlwZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gc2Vzc2lvbi5yZW5kZXJib2R5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wdGlvbnMuY3NlcSA9IHJlc3BvbnNlLmNzZXE7XG4gICAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgIHNlc3Npb24uYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0ODgsICdOb3QgQWNjZXB0YWJsZSBIZXJlJyk7XG4gICAgICAgICAgICAgIHNlc3Npb24uZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICAgIHRoaXMucmVqZWN0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgfVxuICB9LFxuXG4gIGNhbmNlbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2NhbmNlbGluZyBSVENTZXNzaW9uJyk7XG5cbiAgICB2YXIgY2FuY2VsX3JlYXNvbiA9IFNJUC5VdGlscy5nZXRDYW5jZWxSZWFzb24ob3B0aW9ucy5zdGF0dXNfY29kZSwgb3B0aW9ucy5yZWFzb25fcGhyYXNlKTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19OVUxMIHx8XG4gICAgICAgICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfSU5WSVRFX1NFTlQgJiYgIXRoaXMucmVjZWl2ZWRfMTAwKSkge1xuICAgICAgdGhpcy5pc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FuY2VsUmVhc29uID0gY2FuY2VsX3JlYXNvbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19JTlZJVEVfU0VOVCB8fFxuICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTXzFYWF9SRUNFSVZFRCB8fFxuICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuY2FuY2VsKGNhbmNlbF9yZWFzb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhbmNlbGVkKCk7XG4gIH0sXG5cbiAgdGVybWluYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLmJ5ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW5jZWwob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAvLyBJQ0MgUkVDRUlWRSBSRVFVRVNUXG5cbiAgICAvLyBSZWplY3QgQ0FOQ0VMc1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuQ0FOQ0VMKSB7XG4gICAgICAvLyBUT0RPOyBtYWtlIHRoaXMgYSBzd2l0Y2ggd2hlbiBpdCBnZXRzIGFkZGVkXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5BQ0sgJiYgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuYWNrVGltZXIpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICB0aGlzLnVubXV0ZSgpO1xuXG4gICAgICB0aGlzLmFjY2VwdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlc3Npb24ucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0LmFwcGx5KHRoaXMsIFtyZXF1ZXN0XSk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9XG4gIH1cblxufTtcblxuU0lQLkludml0ZUNsaWVudENvbnRleHQgPSBJbnZpdGVDbGllbnRDb250ZXh0O1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TZXNzaW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBEVE1GXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRFRNRlxuICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIERUTUYsXG4gIEMgPSB7XG4gICAgTUlOX0RVUkFUSU9OOiAgICAgICAgICAgIDcwLFxuICAgIE1BWF9EVVJBVElPTjogICAgICAgICAgICA2MDAwLFxuICAgIERFRkFVTFRfRFVSQVRJT046ICAgICAgICAxMDAsXG4gICAgTUlOX0lOVEVSX1RPTkVfR0FQOiAgICAgIDUwLFxuICAgIERFRkFVTFRfSU5URVJfVE9ORV9HQVA6ICA1MDBcbiAgfTtcblxuRFRNRiA9IGZ1bmN0aW9uKHNlc3Npb24sIHRvbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGR1cmF0aW9uLCBpbnRlclRvbmVHYXA7XG5cbiAgaWYgKHRvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIH1cblxuICB0aGlzLmxvZ2dlciA9IHNlc3Npb24udWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlY29udGV4dC5kdG1mJywgc2Vzc2lvbi5pZCk7XG4gIHRoaXMub3duZXIgPSBzZXNzaW9uO1xuICB0aGlzLmRpcmVjdGlvbiA9IG51bGw7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCBudWxsO1xuICBpbnRlclRvbmVHYXAgPSBvcHRpb25zLmludGVyVG9uZUdhcCB8fCBudWxsO1xuXG4gIC8vIENoZWNrIHRvbmUgdHlwZVxuICBpZiAodHlwZW9mIHRvbmUgPT09ICdzdHJpbmcnICkge1xuICAgIHRvbmUgPSB0b25lLnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvbmUgPT09ICdudW1iZXInKSB7XG4gICAgdG9uZSA9IHRvbmUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmU6ICcrIHRvbmUpO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG9uZSB2YWx1ZVxuICBpZiAoIXRvbmUubWF0Y2goL15bMC05QS1EIypdJC8pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lOiAnKyB0b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRvbmUgPSB0b25lO1xuICB9XG5cbiAgLy8gQ2hlY2sgZHVyYXRpb25cbiAgaWYgKGR1cmF0aW9uICYmICFTSVAuVXRpbHMuaXNEZWNpbWFsKGR1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9uZSBkdXJhdGlvbjogJysgZHVyYXRpb24pO1xuICB9IGVsc2UgaWYgKCFkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uID0gRFRNRi5DLkRFRkFVTFRfRFVSQVRJT047XG4gIH0gZWxzZSBpZiAoZHVyYXRpb24gPCBEVE1GLkMuTUlOX0RVUkFUSU9OKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignXCJkdXJhdGlvblwiIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIG1pbmltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byAnKyBEVE1GLkMuTUlOX0RVUkFUSU9OKyAnIG1pbGxpc2Vjb25kcycpO1xuICAgIGR1cmF0aW9uID0gRFRNRi5DLk1JTl9EVVJBVElPTjtcbiAgfSBlbHNlIGlmIChkdXJhdGlvbiA+IERUTUYuQy5NQVhfRFVSQVRJT04pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdcImR1cmF0aW9uXCIgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gJysgRFRNRi5DLk1BWF9EVVJBVElPTiArJyBtaWxsaXNlY29uZHMnKTtcbiAgICBkdXJhdGlvbiA9IERUTUYuQy5NQVhfRFVSQVRJT047XG4gIH0gZWxzZSB7XG4gICAgZHVyYXRpb24gPSBNYXRoLmFicyhkdXJhdGlvbik7XG4gIH1cbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG4gIC8vIENoZWNrIGludGVyVG9uZUdhcFxuICBpZiAoaW50ZXJUb25lR2FwICYmICFTSVAuVXRpbHMuaXNEZWNpbWFsKGludGVyVG9uZUdhcCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGludGVyVG9uZUdhcDogJysgaW50ZXJUb25lR2FwKTtcbiAgfSBlbHNlIGlmICghaW50ZXJUb25lR2FwKSB7XG4gICAgaW50ZXJUb25lR2FwID0gRFRNRi5DLkRFRkFVTFRfSU5URVJfVE9ORV9HQVA7XG4gIH0gZWxzZSBpZiAoaW50ZXJUb25lR2FwIDwgRFRNRi5DLk1JTl9JTlRFUl9UT05FX0dBUCkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1wiaW50ZXJUb25lR2FwXCIgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkLCBzZXR0aW5nIGl0IHRvICcrIERUTUYuQy5NSU5fSU5URVJfVE9ORV9HQVAgKycgbWlsbGlzZWNvbmRzJyk7XG4gICAgaW50ZXJUb25lR2FwID0gRFRNRi5DLk1JTl9JTlRFUl9UT05FX0dBUDtcbiAgfSBlbHNlIHtcbiAgICBpbnRlclRvbmVHYXAgPSBNYXRoLmFicyhpbnRlclRvbmVHYXApO1xuICB9XG4gIHRoaXMuaW50ZXJUb25lR2FwID0gaW50ZXJUb25lR2FwO1xufTtcbkRUTUYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cblxuRFRNRi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGV4dHJhSGVhZGVycywgYm9keTtcblxuICB0aGlzLmRpcmVjdGlvbiA9ICdvdXRnb2luZyc7XG5cbiAgLy8gQ2hlY2sgUlRDU2Vzc2lvbiBTdGF0dXNcbiAgaWYgKHRoaXMub3duZXIuc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQgJiZcbiAgICB0aGlzLm93bmVyLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMub3duZXIuc3RhdHVzKTtcbiAgfVxuXG4gIC8vIEdldCBEVE1GIG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzID8gb3B0aW9ucy5leHRyYUhlYWRlcnMuc2xpY2UoKSA6IFtdO1xuXG4gIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2R0bWYtcmVsYXknKTtcblxuICBib2R5ID0gXCJTaWduYWw9IFwiICsgdGhpcy50b25lICsgXCJcXHJcXG5cIjtcbiAgYm9keSArPSBcIkR1cmF0aW9uPSBcIiArIHRoaXMuZHVyYXRpb247XG5cbiAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5vd25lci5kaWFsb2cuc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuSU5GTywge1xuICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgIGJvZHk6IGJvZHlcbiAgfSk7XG5cbiAgdGhpcy5vd25lci5lbWl0KCdkdG1mJywgdGhpcy5yZXF1ZXN0LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIGNhdXNlO1xuXG4gIHN3aXRjaCh0cnVlKSB7XG4gICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgLy8gSWdub3JlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcy5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgdGhpcy5lbWl0KCdzdWNjZWVkZWQnLCB7XG4gICAgICAgIG9yaWdpbmF0b3I6ICdyZW1vdGUnLFxuICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gIHRoaXMub3duZXIub25SZXF1ZXN0VGltZW91dCgpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICB0aGlzLm93bmVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUub25EaWFsb2dFcnJvciA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICB0aGlzLm93bmVyLm9uRGlhbG9nRXJyb3IocmVzcG9uc2UpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5pbml0X2luY29taW5nID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICB0aGlzLmRpcmVjdGlvbiA9ICdpbmNvbWluZyc7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgcmVxdWVzdC5yZXBseSgyMDApO1xuXG4gIGlmICghdGhpcy50b25lIHx8ICF0aGlzLmR1cmF0aW9uKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignaW52YWxpZCBJTkZPIERUTUYgcmVjZWl2ZWQsIGRpc2NhcmRlZCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3duZXIuZW1pdCgnZHRtZicsIHJlcXVlc3QsIHRoaXMpO1xuICB9XG59O1xuXG5EVE1GLkMgPSBDO1xucmV0dXJuIERUTUY7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TZXNzaW9uL0RUTUYuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFN1YnNjcmliZXIgKFNJUC1TcGVjaWZpYyBFdmVudCBOb3RpZmljYXRpb25zIFJGQzY2NjUpXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgU3Vic2NyaXB0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblNJUC5TdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAodWEsIHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy5zdGF0ZSA9ICdpbml0JztcblxuICBpZiAoIWV2ZW50KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZlbnQgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBhIHN1YnNjcmlwdGlvbi4nKTtcbiAgfSBlbHNlIHtcbiAgICAvL1RPRE86IGNoZWNrIGZvciB2YWxpZCBldmVudHMgaGVyZSBwcm9iYWJseSBtYWtlIGEgbGlzdCBpbiBTSVAuQzsgb3IgbGVhdmUgaXQgdXAgdG8gYXBwIHRvIGNoZWNrP1xuICAgIC8vVGhlIGNoZWNrIG1heSBuZWVkIHRvL3Nob3VsZCBwcm9iYWJseSBvY2N1ciBvbiB0aGUgb3RoZXIgc2lkZSxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cblxuICBpZih0eXBlb2Ygb3B0aW9ucy5leHBpcmVzICE9PSAnbnVtYmVyJyl7XG4gICAgdWEubG9nZ2VyLndhcm4oJ2V4cGlyZXMgbXVzdCBiZSBhIG51bWJlci4gVXNpbmcgZGVmYXVsdCBvZiAzNjAwLicpO1xuICAgIHRoaXMuZXhwaXJlcyA9IDM2MDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuICB9XG5cbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnRXZlbnQ6ICcgKyB0aGlzLmV2ZW50KTtcbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnRXhwaXJlczogJyArIHRoaXMuZXhwaXJlcyk7XG5cbiAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgfVxuXG4gIHRoaXMuY29udGFjdCA9IHVhLmNvbnRhY3QudG9TdHJpbmcoKTtcblxuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5DbGllbnRDb250ZXh0LCBbdWEsIFNJUC5DLlNVQlNDUklCRSwgdGFyZ2V0LCBvcHRpb25zXSk7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zdWJzY3JpcHRpb24nKTtcblxuICB0aGlzLmRpYWxvZyA9IG51bGw7XG4gIHRoaXMudGltZXJzID0ge046IG51bGwsIHN1Yl9kdXJhdGlvbjogbnVsbH07XG4gIHRoaXMuZXJyb3JDb2RlcyAgPSBbNDA0LDQwNSw0MTAsNDE2LDQ4MCw0ODEsNDgyLDQ4Myw0ODQsNDg1LDQ4OSw1MDEsNjA0XTtcbn07XG5cblNJUC5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0ge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdWIgPSB0aGlzO1xuXG4gICAgIC8vdGhlc2Ugc3RhdGVzIHBvaW50IHRvIGFuIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiwgbm8gc3Vic2NyaWJlIGlzIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnYWN0aXZlJykge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG4gICAgdGhpcy50aW1lcnMuTiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIudGltZXJfZmlyZS5iaW5kKHN1YiksIFNJUC5UaW1lcnMuVElNRVJfTik7XG5cbiAgICB0aGlzLnNlbmQoKTtcblxuICAgIHRoaXMuc3RhdGUgPSAnbm90aWZ5X3dhaXQnO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAndGVybWluYXRlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ3BlbmRpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpYWxvZy5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5TVUJTQ1JJQkUsIHtcbiAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmJvZHlcbiAgICB9KTtcbiAgfSxcblxuICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIGV4cGlyZXMsIHN1YiA9IHRoaXMsXG4gICAgICAgIGNhdXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG5cbiAgICBpZiAoKHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMzAwKSB8fFxuICAgICAgICAodGhpcy5zdGF0ZSAhPT0gJ25vdGlmeV93YWl0JyAmJiB0aGlzLmVycm9yQ29kZXMuaW5kZXhPZihyZXNwb25zZS5zdGF0dXNfY29kZSkgIT09IC0xKSkge1xuICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAoL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKSl7XG4gICAgICBleHBpcmVzID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdFeHBpcmVzJyk7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcblxuICAgICAgaWYgKHRoaXMuY3JlYXRlQ29uZmlybWVkRGlhbG9nKHJlc3BvbnNlLCdVQUMnKSkge1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5kaWFsb2cuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIC8vIFVQREFURSBST1VURSBTRVQgVE8gQkUgQkFDS1dBUkRTIENPTVBBVElCTEU/XG4gICAgICB9XG5cbiAgICAgIGlmIChleHBpcmVzICYmIGV4cGlyZXMgPD0gdGhpcy5leHBpcmVzKSB7XG4gICAgICAgIC8vIFByZXNlcnZlIG5ldyBleHBpcmVzIHZhbHVlIGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICAgIHRoaXMuZXhwaXJlcyA9IGV4cGlyZXM7XG4gICAgICAgIHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIucmVmcmVzaC5iaW5kKHN1YiksIGV4cGlyZXMgKiA5MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFleHBpcmVzKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignRXhwaXJlcyBoZWFkZXIgbWlzc2luZyBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBTVUJTQ1JJQkUnKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuRVhQSVJFU19IRUFERVJfTUlTU0lORyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignRXhwaXJlcyBoZWFkZXIgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFIHdpdGggYSBoaWdoZXIgdmFsdWUgdGhhbiB0aGUgb25lIGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLklOVkFMSURfRVhQSVJFU19IRUFERVIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvL1VzZWQgdG8ganVzdCBpZ25vcmUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzOyBub3cgaWdub3JlcyBldmVyeXRoaW5nIGV4Y2VwdCBlcnJvckNvZGVzIGFuZCAyeHhcbiAgfSxcblxuICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdLCBzdWIgPSB0aGlzO1xuXG4gICAgdGhpcy5zdGF0ZSA9ICd0ZXJtaW5hdGVkJztcblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdFdmVudDogJyArIHRoaXMuZXZlbnQpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdFeHBpcmVzOiAwJyk7XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICAgIC8vbWFrZXMgc3VyZSBleHBpcmVzIGlzbid0IHNldCwgYW5kIG90aGVyIHR5cGljYWwgcmVzdWJzY3JpYmUgYmVoYXZpb3JcbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKCl7fTtcblxuICAgIHRoaXMuZGlhbG9nLnNlbmRSZXF1ZXN0KHRoaXMsIHRoaXMubWV0aG9kLCB7XG4gICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuYm9keVxuICAgIH0pO1xuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICB0aGlzLnRpbWVycy5OID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi50aW1lcl9maXJlLmJpbmQoc3ViKSwgU0lQLlRpbWVycy5USU1FUl9OKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aW1lcl9maXJlOiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAndGVybWluYXRlZCcpIHtcbiAgICAgIHRoaXMudGVybWluYXRlRGlhbG9nKCk7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAncGVuZGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuc3RhdGUgIT09ICdub3RpZnlfd2FpdCcgJiYgdGhpcy5zdGF0ZSAhPT0gJ3Rlcm1pbmF0ZWQnKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIGNyZWF0ZUNvbmZpcm1lZERpYWxvZzogZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgIHZhciBkaWFsb2c7XG5cbiAgICB0aGlzLnRlcm1pbmF0ZURpYWxvZygpO1xuICAgIGRpYWxvZyA9IG5ldyBTSVAuRGlhbG9nKHRoaXMsIG1lc3NhZ2UsIHR5cGUpO1xuXG4gICAgaWYoIWRpYWxvZy5lcnJvcikge1xuICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRGlhbG9nIG5vdCBjcmVhdGVkIGR1ZSB0byBhbiBlcnJvclxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0ZXJtaW5hdGVEaWFsb2c6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuZGlhbG9nKSB7XG4gICAgICBkZWxldGUgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuICAgICAgdGhpcy5kaWFsb2cudGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5kaWFsb2c7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHN1Yl9zdGF0ZSwgc3ViID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHNldEV4cGlyZXNUaW1lb3V0KCkge1xuICAgICAgaWYgKHN1Yl9zdGF0ZS5leHBpcmVzKSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHN1Yi50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICAgICAgc3ViX3N0YXRlLmV4cGlyZXMgPSBNYXRoLm1pbihzdWIuZXhwaXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChzdWJfc3RhdGUuZXhwaXJlcywgMCkpO1xuICAgICAgICBzdWIudGltZXJzLnN1Yl9kdXJhdGlvbiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIucmVmcmVzaC5iaW5kKHN1YiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViX3N0YXRlLmV4cGlyZXMgKiA5MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXRjaEV2ZW50KHJlcXVlc3QpKSB7IC8vY2hlY2tzIGV2ZW50IGFuZCBzdWJzY3JpcHRpb25fc3RhdGUgaGVhZGVyc1xuICAgICAgcmVxdWVzdC5yZXBseSg0ODkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1Yl9zdGF0ZSA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ1N1YnNjcmlwdGlvbi1TdGF0ZScpO1xuXG4gICAgcmVxdWVzdC5yZXBseSgyMDAsIFNJUC5DLlJFQVNPTl8yMDApO1xuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG5cbiAgICB0aGlzLmVtaXQoJ25vdGlmeScsIHtyZXF1ZXN0OiByZXF1ZXN0fSk7XG5cbiAgICAvLyBpZiB3ZSd2ZSBzZXQgc3RhdGUgdG8gdGVybWluYXRlZCwgbm8gZnVydGhlciBwcm9jZXNzaW5nIHNob3VsZCB0YWtlIHBsYWNlXG4gICAgLy8gYW5kIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gY2xlYW5pbmcgdXAgYWZ0ZXIgdGhlIGFwcHJvcHJpYXRlIE5PVElGWVxuICAgIGlmICh0aGlzLnN0YXRlID09PSAndGVybWluYXRlZCcpIHtcbiAgICAgIGlmIChzdWJfc3RhdGUuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZURpYWxvZygpO1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcblxuICAgICAgICBkZWxldGUgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3ViX3N0YXRlLnN0YXRlKSB7XG4gICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICB0aGlzLnN0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICAgIHNldEV4cGlyZXNUaW1lb3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnKSB7XG4gICAgICAgICAgc2V0RXhwaXJlc1RpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gJ3BlbmRpbmcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Rlcm1pbmF0ZWQnOlxuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgICAgICBpZiAoc3ViX3N0YXRlLnJlYXNvbikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygndGVybWluYXRpbmcgc3Vic2NyaXB0aW9uIHdpdGggcmVhc29uICcrIHN1Yl9zdGF0ZS5yZWFzb24pO1xuICAgICAgICAgIHN3aXRjaCAoc3ViX3N0YXRlLnJlYXNvbikge1xuICAgICAgICAgICAgY2FzZSAnZGVhY3RpdmF0ZWQnOlxuICAgICAgICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2JhdGlvbic6XG4gICAgICAgICAgICBjYXNlICdnaXZldXAnOlxuICAgICAgICAgICAgICBpZihzdWJfc3RhdGUucGFyYW1zICYmIHN1Yl9zdGF0ZS5wYXJhbXNbJ3JldHJ5LWFmdGVyJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnN1YnNjcmliZS5iaW5kKHN1YiksIHN1Yl9zdGF0ZS5wYXJhbXNbJ3JldHJ5LWFmdGVyJ10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnbm9yZXNvdXJjZSc6XG4gICAgICAgICAgICBjYXNlICdpbnZhcmlhbnQnOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgZmFpbGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uRGlhbG9nRXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIG1hdGNoRXZlbnQ6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgZXZlbnQ7XG5cbiAgICAvLyBDaGVjayBtYW5kYXRvcnkgaGVhZGVyIEV2ZW50XG4gICAgaWYgKCFyZXF1ZXN0Lmhhc0hlYWRlcignRXZlbnQnKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignbWlzc2luZyBFdmVudCBoZWFkZXInKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgbWFuZGF0b3J5IGhlYWRlciBTdWJzY3JpcHRpb24tU3RhdGVcbiAgICBpZiAoIXJlcXVlc3QuaGFzSGVhZGVyKCdTdWJzY3JpcHRpb24tU3RhdGUnKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignbWlzc2luZyBTdWJzY3JpcHRpb24tU3RhdGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZXZlbnQgaW4gTk9USUZZIG1hdGNoZXMgdGhlIGV2ZW50IGluIFNVQlNDUklCRVxuICAgIGV2ZW50ID0gcmVxdWVzdC5wYXJzZUhlYWRlcignZXZlbnQnKS5ldmVudDtcblxuICAgIGlmICh0aGlzLmV2ZW50ICE9PSBldmVudCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignZXZlbnQgbWF0Y2ggZmFpbGVkJyk7XG4gICAgICByZXF1ZXN0LnJlcGx5KDQ4MSwgJ0V2ZW50IE1hdGNoIEZhaWxlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TdWJzY3JpcHRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFdlYlJUQ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcbnZhciBXZWJSVEM7XG5cbldlYlJUQyA9IHt9O1xuXG5XZWJSVEMuTWVkaWFIYW5kbGVyID0gcmVxdWlyZSgnLi9XZWJSVEMvTWVkaWFIYW5kbGVyJykoU0lQKTtcbldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXIgPSByZXF1aXJlKCcuL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXInKShTSVAsIGVudmlyb25tZW50KTtcblxudmFyIF9pc1N1cHBvcnRlZDtcblxuV2ViUlRDLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gX2lzU3VwcG9ydGVkO1xuICB9XG5cbiAgV2ViUlRDLk1lZGlhU3RyZWFtID0gZW52aXJvbm1lbnQuTWVkaWFTdHJlYW07XG4gIFdlYlJUQy5nZXRVc2VyTWVkaWEgPSBlbnZpcm9ubWVudC5nZXRVc2VyTWVkaWE7XG4gIFdlYlJUQy5SVENQZWVyQ29ubmVjdGlvbiA9IGVudmlyb25tZW50LlJUQ1BlZXJDb25uZWN0aW9uO1xuICBXZWJSVEMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gZW52aXJvbm1lbnQuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuXG4gIGlmIChXZWJSVEMuUlRDUGVlckNvbm5lY3Rpb24gJiYgV2ViUlRDLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgIGlmIChXZWJSVEMuZ2V0VXNlck1lZGlhKSB7XG4gICAgICBXZWJSVEMuZ2V0VXNlck1lZGlhID0gU0lQLlV0aWxzLnByb21pc2lmeShlbnZpcm9ubWVudCwgJ2dldFVzZXJNZWRpYScpO1xuICAgIH1cbiAgICBfaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIF9pc1N1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBfaXNTdXBwb3J0ZWQ7XG59O1xuXG5yZXR1cm4gV2ViUlRDO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvV2ViUlRDLmpzXG4gKiogbW9kdWxlIGlkID0gMjM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNZWRpYUhhbmRsZXJcbiAqL1xuXG4vKiBNZWRpYUhhbmRsZXJcbiAqIEBjbGFzcyBQZWVyQ29ubmVjdGlvbiBoZWxwZXIgQ2xhc3MuXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1NJUC5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyfSBbb3B0aW9ucy5tZWRpYVN0cmVhbU1hbmFnZXJdXG4gKiAgICAgICAgVGhlIE1lZGlhU3RyZWFtTWFuYWdlciB0byBhY3F1aXJlL3JlbGVhc2Ugc3RyZWFtcyBmcm9tL3RvLlxuICogICAgICAgIElmIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IE1lZGlhU3RyZWFtTWFuYWdlciB3aWxsIGJlIHVzZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgTWVkaWFIYW5kbGVyID0gZnVuY3Rpb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLmxvZ2dlciA9IHNlc3Npb24udWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlY29udGV4dC5tZWRpYWhhbmRsZXInLCBzZXNzaW9uLmlkKTtcbiAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgdGhpcy5sb2NhbE1lZGlhID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IHRydWU7XG4gIHRoaXMubWVkaWFTdHJlYW1NYW5hZ2VyID0gb3B0aW9ucy5tZWRpYVN0cmVhbU1hbmFnZXIgfHwgbmV3IFNJUC5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyKHRoaXMubG9nZ2VyKTtcbiAgdGhpcy5hdWRpb011dGVkID0gZmFsc2U7XG4gIHRoaXMudmlkZW9NdXRlZCA9IGZhbHNlO1xuXG4gIC8vIG9sZCBpbml0KCkgZnJvbSBoZXJlIG9uXG4gIHZhciBzZXJ2ZXJzID0gdGhpcy5wcmVwYXJlSWNlU2VydmVycyhvcHRpb25zLnN0dW5TZXJ2ZXJzLCBvcHRpb25zLnR1cm5TZXJ2ZXJzKTtcbiAgdGhpcy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge307XG5cbiAgdGhpcy5pbml0UGVlckNvbm5lY3Rpb24oc2VydmVycywgdGhpcy5SVENDb25zdHJhaW50cyk7XG5cbiAgZnVuY3Rpb24gc2VsZkVtaXQobWgsIGV2ZW50KSB7XG4gICAgaWYgKG1oLm1lZGlhU3RyZWFtTWFuYWdlci5vbikge1xuICAgICAgbWgubWVkaWFTdHJlYW1NYW5hZ2VyLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1oLmVtaXQuYXBwbHkobWgsIFtldmVudF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNlbGZFbWl0KHRoaXMsICd1c2VyTWVkaWFSZXF1ZXN0Jyk7XG4gIHNlbGZFbWl0KHRoaXMsICd1c2VyTWVkaWEnKTtcbiAgc2VsZkVtaXQodGhpcywgJ3VzZXJNZWRpYUZhaWxlZCcpO1xufTtcblxuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5ID0gZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNZWRpYUhhbmRsZXIoc2Vzc2lvbiwgb3B0aW9ucyk7XG59O1xuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gU0lQLldlYlJUQy5pc1N1cHBvcnRlZCgpO1xufTtcblxuTWVkaWFIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLk1lZGlhSGFuZGxlci5wcm90b3R5cGUsIHtcbi8vIEZ1bmN0aW9ucyB0aGUgc2Vzc2lvbiBjYW4gdXNlXG4gIGlzUmVhZHk6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGlzUmVhZHkgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5O1xuICB9fSxcblxuICBjbG9zZToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBQZWVyQ29ubmVjdGlvbicpO1xuICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAvLyBoYXZlIHRvIGNoZWNrIHNpZ25hbGluZ1N0YXRlIHNpbmNlIHRoaXMuY2xvc2UoKSBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIFRPRE8gZmlndXJlIG91dCB3aHkgdGhhdCBoYXBwZW5zXG4gICAgaWYodGhpcy5wZWVyQ29ubmVjdGlvbiAmJiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuXG4gICAgICBpZih0aGlzLmxvY2FsTWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbU1hbmFnZXIucmVsZWFzZSh0aGlzLmxvY2FsTWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgfX0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U0lQLldlYlJUQy5NZWRpYVN0cmVhbSB8IChnZXRVc2VyTWVkaWEgY29uc3RyYWludHMpfSBbbWVkaWFIaW50XVxuICAgKiAgICAgICAgdGhlIE1lZGlhU3RyZWFtIChvciB0aGUgY29uc3RyYWludHMgZGVzY3JpYmluZyBpdCkgdG8gYmUgdXNlZCBmb3IgdGhlIHNlc3Npb25cbiAgICovXG4gIGdldERlc2NyaXB0aW9uOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXREZXNjcmlwdGlvbiAobWVkaWFIaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhY3F1aXJlID0gc2VsZi5tZWRpYVN0cmVhbU1hbmFnZXIuYWNxdWlyZTtcbiAgICBpZiAoYWNxdWlyZS5sZW5ndGggPiAxKSB7XG4gICAgICBhY3F1aXJlID0gU0lQLlV0aWxzLnByb21pc2lmeSh0aGlzLm1lZGlhU3RyZWFtTWFuYWdlciwgJ2FjcXVpcmUnLCB0cnVlKTtcbiAgICB9XG4gICAgbWVkaWFIaW50ID0gbWVkaWFIaW50IHx8IHt9O1xuICAgIGlmIChtZWRpYUhpbnQuZGF0YUNoYW5uZWwgPT09IHRydWUpIHtcbiAgICAgIG1lZGlhSGludC5kYXRhQ2hhbm5lbCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm1lZGlhSGludCA9IG1lZGlhSGludDtcblxuICAgIC8qXG4gICAgICogMS4gYWNxdWlyZSBzdHJlYW1zIChza2lwIGlmIE1lZGlhU3RyZWFtcyBwYXNzZWQgaW4pXG4gICAgICogMi4gYWRkU3RyZWFtc1xuICAgICAqIDMuIGNyZWF0ZU9mZmVyL2NyZWF0ZUFuc3dlclxuICAgICAqL1xuXG4gICAgdmFyIHN0cmVhbVByb21pc2U7XG4gICAgaWYgKHNlbGYubG9jYWxNZWRpYSkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdhbHJlYWR5IGhhdmUgbG9jYWwgbWVkaWEnKTtcbiAgICAgIHN0cmVhbVByb21pc2UgPSBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKHNlbGYubG9jYWxNZWRpYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdhY3F1aXJpbmcgbG9jYWwgbWVkaWEnKTtcbiAgICAgIHN0cmVhbVByb21pc2UgPSBhY3F1aXJlLmNhbGwoc2VsZi5tZWRpYVN0cmVhbU1hbmFnZXIsIG1lZGlhSGludClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gYWNxdWlyZVN1Y2NlZWRlZChzdHJlYW1zKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIubG9nKCdhY3F1aXJlZCBsb2NhbCBtZWRpYSBzdHJlYW1zJyk7XG4gICAgICAgICAgc2VsZi5sb2NhbE1lZGlhID0gc3RyZWFtcztcbiAgICAgICAgICBzZWxmLnNlc3Npb24uY29ubmVjdGluZygpO1xuICAgICAgICAgIHJldHVybiBzdHJlYW1zO1xuICAgICAgICB9LCBmdW5jdGlvbiBhY3F1aXJlRmFpbGVkKGVycikge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKCd1bmFibGUgdG8gYWNxdWlyZSBzdHJlYW1zJyk7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICBzZWxmLnNlc3Npb24uY29ubmVjdGluZygpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4odGhpcy5hZGRTdHJlYW1zLmJpbmQodGhpcykpXG4gICAgICA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmVhbVByb21pc2VcbiAgICAgIC50aGVuKGZ1bmN0aW9uIHN0cmVhbUFkZGl0aW9uU3VjY2VlZGVkKCkge1xuICAgICAgICBpZiAoc2VsZi5oYXNPZmZlcigncmVtb3RlJykpIHtcbiAgICAgICAgICBzZWxmLnBlZXJDb25uZWN0aW9uLm9uZGF0YWNoYW5uZWwgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBzZWxmLmRhdGFDaGFubmVsID0gZXZ0LmNoYW5uZWw7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2RhdGFDaGFubmVsJywgc2VsZi5kYXRhQ2hhbm5lbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYUhpbnQuZGF0YUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgICAgICBzZWxmLnBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgc2VsZi5kYXRhQ2hhbm5lbCA9IHNlbGYucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwoXG4gICAgICAgICAgICAnc2lwanMnLFxuICAgICAgICAgICAgbWVkaWFIaW50LmRhdGFDaGFubmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2RhdGFDaGFubmVsJywgc2VsZi5kYXRhQ2hhbm5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gc2VsZi5jcmVhdGVPZmZlck9yQW5zd2VyKHNlbGYuUlRDQ29uc3RyYWludHMpO1xuICAgICAgfSlcbiAgICA7XG4gIH19LFxuXG4gIC8qKlxuICAqIE1lc3NhZ2UgcmVjZXB0aW9uLlxuICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICogQHBhcmFtIHtTdHJpbmd9IHNkcFxuICAqL1xuICBzZXREZXNjcmlwdGlvbjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gc2V0RGVzY3JpcHRpb24gKHNkcCkge1xuICAgIHZhciByYXdEZXNjcmlwdGlvbiA9IHtcbiAgICAgIHR5cGU6IHRoaXMuaGFzT2ZmZXIoJ2xvY2FsJykgPyAnYW5zd2VyJyA6ICdvZmZlcicsXG4gICAgICBzZHA6IHNkcFxuICAgIH07XG5cbiAgICB0aGlzLmVtaXQoJ3NldERlc2NyaXB0aW9uJywgcmF3RGVzY3JpcHRpb24pO1xuXG4gICAgdmFyIGRlc2NyaXB0aW9uID0gbmV3IFNJUC5XZWJSVEMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHJhd0Rlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gU0lQLlV0aWxzLnByb21pc2lmeSh0aGlzLnBlZXJDb25uZWN0aW9uLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nKShkZXNjcmlwdGlvbik7XG4gIH19LFxuXG4gIC8qKlxuICAgKiBJZiB0aGUgU2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBNZWRpYUhhbmRsZXIgd2VyZSB0byBiZSByZWZlcnJlZCxcbiAgICogd2hhdCBtZWRpYUhpbnQgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIHRoZSBVQSdzIGludml0ZSBtZXRob2Q/XG4gICAqL1xuICBnZXRSZWZlck1lZGlhOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWZlck1lZGlhICgpIHtcbiAgICBmdW5jdGlvbiBoYXNUcmFja3MgKHRyYWNrR2V0dGVyLCBzdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdHJlYW1bdHJhY2tHZXR0ZXJdKCkubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3RoSGF2ZVRyYWNrcyAodHJhY2tHZXR0ZXIpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkuc29tZShoYXNUcmFja3MuYmluZChudWxsLCB0cmFja0dldHRlcikpICYmXG4gICAgICAgICAgICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zKCkuc29tZShoYXNUcmFja3MuYmluZChudWxsLCB0cmFja0dldHRlcikpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBhdWRpbzogYm90aEhhdmVUcmFja3MuY2FsbCh0aGlzLCAnZ2V0QXVkaW9UcmFja3MnKSxcbiAgICAgICAgdmlkZW86IGJvdGhIYXZlVHJhY2tzLmNhbGwodGhpcywgJ2dldFZpZGVvVHJhY2tzJylcbiAgICAgIH1cbiAgICB9O1xuICB9fSxcblxuICB1cGRhdGVJY2VTZXJ2ZXJzOiB7d3JpdGVhYmxlOnRydWUsIHZhbHVlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZXJ2ZXJzID0gdGhpcy5wcmVwYXJlSWNlU2VydmVycyhvcHRpb25zLnN0dW5TZXJ2ZXJzLCBvcHRpb25zLnR1cm5TZXJ2ZXJzKTtcbiAgICB0aGlzLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB0aGlzLlJUQ0NvbnN0cmFpbnRzO1xuXG4gICAgdGhpcy5pbml0UGVlckNvbm5lY3Rpb24oc2VydmVycywgdGhpcy5SVENDb25zdHJhaW50cyk7XG5cbiAgICAvKiBvbmNlIHVwZGF0ZUljZSBpcyBpbXBsZW1lbnRlZCBjb3JyZWN0bHksIHRoaXMgaXMgYmV0dGVyIHRoYW4gYWJvdmVcbiAgICAvL25vIG9wIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzXG4gICAgaWYgKCF0aGlzLnBlZXJDb25uZWN0aW9uLnVwZGF0ZUljZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24udXBkYXRlSWNlKHsnaWNlU2VydmVycyc6IHNlcnZlcnN9LCB0aGlzLlJUQ0NvbnN0cmFpbnRzKTtcbiAgICAqL1xuICB9fSxcblxuLy8gRnVuY3Rpb25zIHRoZSBzZXNzaW9uIGNhbiB1c2UsIGJ1dCBvbmx5IGJlY2F1c2UgaXQncyBjb252ZW5pZW50IGZvciB0aGUgYXBwbGljYXRpb25cbiAgaXNNdXRlZDoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaXNNdXRlZCAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvOiB0aGlzLmF1ZGlvTXV0ZWQsXG4gICAgICB2aWRlbzogdGhpcy52aWRlb011dGVkXG4gICAgfTtcbiAgfX0sXG5cbiAgbXV0ZToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gbXV0ZSAob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmdldExvY2FsU3RyZWFtcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgIGF1ZGlvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCxcbiAgICAgIHZpZGVvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMFxuICAgIH07XG5cbiAgICB2YXIgYXVkaW9NdXRlZCA9IGZhbHNlLFxuICAgICAgICB2aWRlb011dGVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hdWRpbyAmJiAhdGhpcy5hdWRpb011dGVkKSB7XG4gICAgICBhdWRpb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYXVkaW9NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy52aWRlbyAmJiAhdGhpcy52aWRlb011dGVkKSB7XG4gICAgICB2aWRlb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudmlkZW9NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyh0cnVlKTtcbiAgICB9XG5cbiAgICAvL1JFVklTSVRcbiAgICBpZiAoYXVkaW9NdXRlZCB8fCB2aWRlb011dGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpbzogYXVkaW9NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvTXV0ZWRcbiAgICAgIH07XG4gICAgICAvKnRoaXMuc2Vzc2lvbi5vbm11dGUoe1xuICAgICAgICBhdWRpbzogYXVkaW9NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvTXV0ZWRcbiAgICAgIH0pOyovXG4gICAgfVxuICB9fSxcblxuICB1bm11dGU6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHVubXV0ZSAob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmdldExvY2FsU3RyZWFtcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgIGF1ZGlvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCxcbiAgICAgIHZpZGVvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMFxuICAgIH07XG5cbiAgICB2YXIgYXVkaW9Vbk11dGVkID0gZmFsc2UsXG4gICAgICAgIHZpZGVvVW5NdXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgdGhpcy5hdWRpb011dGVkKSB7XG4gICAgICBhdWRpb1VuTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hdWRpb011dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudmlkZW8gJiYgdGhpcy52aWRlb011dGVkKSB7XG4gICAgICB2aWRlb1VuTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy52aWRlb011dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgLy9SRVZJU0lUXG4gICAgaWYgKGF1ZGlvVW5NdXRlZCB8fCB2aWRlb1VuTXV0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBhdWRpb1VuTXV0ZWQsXG4gICAgICAgIHZpZGVvOiB2aWRlb1VuTXV0ZWRcbiAgICAgIH07XG4gICAgICAvKnRoaXMuc2Vzc2lvbi5vbnVubXV0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb1VuTXV0ZWQsXG4gICAgICAgIHZpZGVvOiB2aWRlb1VuTXV0ZWRcbiAgICAgIH0pOyovXG4gICAgfVxuICB9fSxcblxuICBob2xkOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBob2xkICgpIHtcbiAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyh0cnVlKTtcbiAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyh0cnVlKTtcbiAgfX0sXG5cbiAgdW5ob2xkOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB1bmhvbGQgKCkge1xuICAgIGlmICghdGhpcy5hdWRpb011dGVkKSB7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZpZGVvTXV0ZWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKGZhbHNlKTtcbiAgICB9XG4gIH19LFxuXG4vLyBGdW5jdGlvbnMgdGhlIGFwcGxpY2F0aW9uIGNhbiB1c2UsIGJ1dCBub3QgdGhlIHNlc3Npb25cbiAgZ2V0TG9jYWxTdHJlYW1zOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMgKCkge1xuICAgIHZhciBwYyA9IHRoaXMucGVlckNvbm5lY3Rpb247XG4gICAgaWYgKHBjICYmIHBjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigncGVlckNvbm5lY3Rpb24gaXMgY2xvc2VkLCBnZXRMb2NhbFN0cmVhbXMgcmV0dXJuaW5nIFtdJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiAocGMuZ2V0TG9jYWxTdHJlYW1zICYmIHBjLmdldExvY2FsU3RyZWFtcygpKSB8fFxuICAgICAgcGMubG9jYWxTdHJlYW1zIHx8IFtdO1xuICB9fSxcblxuICBnZXRSZW1vdGVTdHJlYW1zOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zICgpIHtcbiAgICB2YXIgcGMgPSB0aGlzLnBlZXJDb25uZWN0aW9uO1xuICAgIGlmIChwYyAmJiBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCwgZ2V0UmVtb3RlU3RyZWFtcyByZXR1cm5pbmcgdGhpcy5fcmVtb3RlU3RyZWFtcycpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXM7XG4gICAgfVxuICAgIHJldHVybihwYy5nZXRSZW1vdGVTdHJlYW1zICYmIHBjLmdldFJlbW90ZVN0cmVhbXMoKSkgfHxcbiAgICAgIHBjLnJlbW90ZVN0cmVhbXMgfHwgW107XG4gIH19LFxuXG4gIHJlbmRlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyIChyZW5kZXJIaW50KSB7XG4gICAgcmVuZGVySGludCA9IHJlbmRlckhpbnQgfHwgKHRoaXMubWVkaWFIaW50ICYmIHRoaXMubWVkaWFIaW50LnJlbmRlcik7XG4gICAgaWYgKCFyZW5kZXJIaW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzdHJlYW1HZXR0ZXJzID0ge1xuICAgICAgbG9jYWw6ICdnZXRMb2NhbFN0cmVhbXMnLFxuICAgICAgcmVtb3RlOiAnZ2V0UmVtb3RlU3RyZWFtcydcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHN0cmVhbUdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGxvYykge1xuICAgICAgdmFyIHN0cmVhbUdldHRlciA9IHN0cmVhbUdldHRlcnNbbG9jXTtcbiAgICAgIHZhciBzdHJlYW1zID0gdGhpc1tzdHJlYW1HZXR0ZXJdKCk7XG4gICAgICBTSVAuV2ViUlRDLk1lZGlhU3RyZWFtTWFuYWdlci5yZW5kZXIoc3RyZWFtcywgcmVuZGVySGludFtsb2NdKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9fSxcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb25zXG4gIGhhc09mZmVyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBoYXNPZmZlciAod2hlcmUpIHtcbiAgICB2YXIgb2ZmZXJTdGF0ZSA9ICdoYXZlLScgKyB3aGVyZSArICctb2ZmZXInO1xuICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSBvZmZlclN0YXRlO1xuICAgIC8vIFRPRE8gY29uc2lkZXIgc2lnbmFsaW5nU3RhdGVzIHdpdGggJ3ByYW5zd2VyJz9cbiAgfX0sXG5cbiAgcHJlcGFyZUljZVNlcnZlcnM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVJY2VTZXJ2ZXJzIChzdHVuU2VydmVycywgdHVyblNlcnZlcnMpIHtcbiAgICB2YXIgc2VydmVycyA9IFtdLFxuICAgICAgY29uZmlnID0gdGhpcy5zZXNzaW9uLnVhLmNvbmZpZ3VyYXRpb247XG5cbiAgICBzdHVuU2VydmVycyA9IHN0dW5TZXJ2ZXJzIHx8IGNvbmZpZy5zdHVuU2VydmVycztcbiAgICB0dXJuU2VydmVycyA9IHR1cm5TZXJ2ZXJzIHx8IGNvbmZpZy50dXJuU2VydmVycztcblxuICAgIFtdLmNvbmNhdChzdHVuU2VydmVycykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICBzZXJ2ZXJzLnB1c2goeyd1cmxzJzogc2VydmVyfSk7XG4gICAgfSk7XG5cbiAgICBbXS5jb25jYXQodHVyblNlcnZlcnMpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgc2VydmVycy5wdXNoKHtcbiAgICAgICAgJ3VybHMnOiBzZXJ2ZXIudXJscyxcbiAgICAgICAgJ3VzZXJuYW1lJzogc2VydmVyLnVzZXJuYW1lLFxuICAgICAgICAnY3JlZGVudGlhbCc6IHNlcnZlci5wYXNzd29yZFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VydmVycztcbiAgfX0sXG5cbiAgaW5pdFBlZXJDb25uZWN0aW9uOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBpbml0UGVlckNvbm5lY3Rpb24oc2VydmVycywgUlRDQ29uc3RyYWludHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBjb25maWcgPSB0aGlzLnNlc3Npb24udWEuY29uZmlndXJhdGlvbjtcblxuICAgIHRoaXMub25JY2VDb21wbGV0ZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcbiAgICB0aGlzLm9uSWNlQ29tcGxldGVkLnByb21pc2UudGhlbihmdW5jdGlvbihwYykge1xuICAgICAgc2VsZi5lbWl0KCdpY2VHYXRoZXJpbmdDb21wbGV0ZScsIHBjKTtcbiAgICAgIGlmIChzZWxmLmljZUNoZWNraW5nVGltZXIpIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi5pY2VDaGVja2luZ1RpbWVyKTtcbiAgICAgICAgc2VsZi5pY2VDaGVja2luZ1RpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG5ldyBTSVAuV2ViUlRDLlJUQ1BlZXJDb25uZWN0aW9uKHsnaWNlU2VydmVycyc6IHNlcnZlcnN9LCBSVENDb25zdHJhaW50cyk7XG5cbiAgICAvLyBGaXJlZm94ICgzNS4wLjEpIHNvbWV0aW1lcyB0aHJvd3Mgb24gY2FsbHMgdG8gcGVlckNvbm5lY3Rpb24uZ2V0UmVtb3RlU3RyZWFtc1xuICAgIC8vIGV2ZW4gaWYgcGVlckNvbm5lY3Rpb24ub25hZGRzdHJlYW0gd2FzIGp1c3QgY2FsbGVkLiBJbiBvcmRlciB0byBtYWtlXG4gICAgLy8gTWVkaWFIYW5kbGVyLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zIHdvcmssIGtlZXAgdHJhY2sgb2YgdGhlbSBtYW51YWxseVxuICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ3N0cmVhbSBhZGRlZDogJysgZS5zdHJlYW0uaWQpO1xuICAgICAgc2VsZi5fcmVtb3RlU3RyZWFtcy5wdXNoKGUuc3RyZWFtKTtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICBzZWxmLmVtaXQoJ2FkZFN0cmVhbScsIGUpO1xuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9ucmVtb3Zlc3RyZWFtID0gZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdzdHJlYW0gcmVtb3ZlZDogJysgZS5zdHJlYW0uaWQpO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0SWNlQ2hlY2tpbmdUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5pY2VDaGVja2luZ1RpbWVyKSB7XG4gICAgICAgIHNlbGYuaWNlQ2hlY2tpbmdUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ1JUQ0ljZUNoZWNraW5nIFRpbWVvdXQgVHJpZ2dlcmVkIGFmdGVyICcrY29uZmlnLmljZUNoZWNraW5nVGltZW91dCsnIG1pbGxpc2Vjb25kcycpO1xuICAgICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMucGVlckNvbm5lY3Rpb24pLCBjb25maWcuaWNlQ2hlY2tpbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYuZW1pdCgnaWNlQ2FuZGlkYXRlJywgZSk7XG4gICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIubG9nKCdJQ0UgY2FuZGlkYXRlIHJlY2VpdmVkOiAnKyAoZS5jYW5kaWRhdGUuY2FuZGlkYXRlID09PSBudWxsID8gbnVsbCA6IGUuY2FuZGlkYXRlLmNhbmRpZGF0ZS50cmltKCkpKTtcbiAgICAgICAgc2VsZi5zdGFydEljZUNoZWNraW5nVGltZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdSVENJY2VHYXRoZXJpbmdTdGF0ZSBjaGFuZ2VkOiAnICsgdGhpcy5pY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2dhdGhlcmluZycpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdpY2VHYXRoZXJpbmcnLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgeyAgLy9uZWVkIGUgZm9yIGNvbW1lbnRlZCBvdXQgY2FzZVxuICAgICAgdmFyIHN0YXRlRXZlbnQ7XG5cbiAgICAgIGlmICh0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NoZWNraW5nJykge1xuICAgICAgICBzZWxmLnN0YXJ0SWNlQ2hlY2tpbmdUaW1lcigpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICBjYXNlICduZXcnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb24nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ2hlY2tpbmcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkNvbm5lY3RlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ29tcGxldGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25GYWlsZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ2xvc2VkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKCdVbmtub3duIGljZUNvbm5lY3Rpb24gc3RhdGU6JywgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoc3RhdGVFdmVudCwgdGhpcyk7XG5cbiAgICAgIC8vQnJpYSBzdGF0ZSBjaGFuZ2VzIGFyZSBhbHdheXMgY29ubmVjdGVkIC0+IGRpc2Nvbm5lY3RlZCAtPiBjb25uZWN0ZWQgb24gYWNjZXB0LCBzbyBzZXNzaW9uIGdldHMgdGVybWluYXRlZFxuICAgICAgLy9ub3JtYWwgY2FsbHMgc3dpdGNoIGZyb20gZmFpbGVkIHRvIGNvbm5lY3RlZCBpbiBzb21lIGNhc2VzLCBzbyBjaGVja2luZyBmb3IgZmFpbGVkIGFuZCB0ZXJtaW5hdGVkXG4gICAgICAvKmlmICh0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgc2VsZi5zZXNzaW9uLnRlcm1pbmF0ZSh7XG4gICAgICAgIGNhdXNlOiBTSVAuQy5jYXVzZXMuUlRQX1RJTUVPVVQsXG4gICAgICAgIHN0YXR1c19jb2RlOiAyMDAsXG4gICAgICAgIHJlYXNvbl9waHJhc2U6IFNJUC5DLmNhdXNlcy5SVFBfVElNRU9VVFxuICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGUuY3VycmVudFRhcmdldC5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2NvbXBsZXRlJyAmJiB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQodGhpcyk7XG4gICAgICB9Ki9cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ1BlZXJDb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQgdG8gXCInKyB0aGlzLnJlYWR5U3RhdGUgKydcIicpO1xuICAgIH07XG4gIH19LFxuXG4gIGNyZWF0ZU9mZmVyT3JBbnN3ZXI6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyT3JBbnN3ZXIgKGNvbnN0cmFpbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtZXRob2ROYW1lO1xuICAgIHZhciBwYyA9IHNlbGYucGVlckNvbm5lY3Rpb247XG5cbiAgICBzZWxmLnJlYWR5ID0gZmFsc2U7XG4gICAgbWV0aG9kTmFtZSA9IHNlbGYuaGFzT2ZmZXIoJ3JlbW90ZScpID8gJ2NyZWF0ZUFuc3dlcicgOiAnY3JlYXRlT2ZmZXInO1xuXG4gICAgcmV0dXJuIFNJUC5VdGlscy5wcm9taXNpZnkocGMsIG1ldGhvZE5hbWUsIHRydWUpKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4oU0lQLlV0aWxzLnByb21pc2lmeShwYywgJ3NldExvY2FsRGVzY3JpcHRpb24nKSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uIG9uU2V0TG9jYWxEZXNjcmlwdGlvblN1Y2Nlc3MoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuICAgICAgICBpZiAocGMuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdjb21wbGV0ZScgJiYgKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgcGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5wcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gcmVhZHlTdWNjZXNzICgpIHtcbiAgICAgICAgdmFyIHNkcCA9IHBjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXG4gICAgICAgIHNkcCA9IFNJUC5IYWNrcy5DaHJvbWUubmVlZHNFeHBsaWNpdGx5SW5hY3RpdmVTRFAoc2RwKTtcbiAgICAgICAgc2RwID0gU0lQLkhhY2tzLkFsbEJyb3dzZXJzLnVubWFza0R0bHMoc2RwKTtcblxuICAgICAgICB2YXIgc2RwV3JhcHBlciA9IHtcbiAgICAgICAgICB0eXBlOiBtZXRob2ROYW1lID09PSAnY3JlYXRlT2ZmZXInID8gJ29mZmVyJyA6ICdhbnN3ZXInLFxuICAgICAgICAgIHNkcDogc2RwXG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5lbWl0KCdnZXREZXNjcmlwdGlvbicsIHNkcFdyYXBwZXIpO1xuXG4gICAgICAgIHNlbGYucmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc2RwV3JhcHBlci5zZHA7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIG1ldGhvZEZhaWxlZCAoZSkge1xuICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgc2VsZi5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKGUpO1xuICAgICAgfSlcbiAgICA7XG4gIH19LFxuXG4gIGFkZFN0cmVhbXM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0cmVhbXMgKHN0cmVhbXMpIHtcbiAgICB0cnkge1xuICAgICAgc3RyZWFtcyA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICAgIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHN0cmVhbSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdlcnJvciBhZGRpbmcgc3RyZWFtJyk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoKTtcbiAgfX0sXG5cbiAgdG9nZ2xlTXV0ZUhlbHBlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTXV0ZUhlbHBlciAodHJhY2tHZXR0ZXIsIG11dGUpIHtcbiAgICB0aGlzLmdldExvY2FsU3RyZWFtcygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgc3RyZWFtW3RyYWNrR2V0dGVyXSgpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhbXV0ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9fSxcblxuICB0b2dnbGVNdXRlQXVkaW86IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU11dGVBdWRpbyAobXV0ZSkge1xuICAgIHRoaXMudG9nZ2xlTXV0ZUhlbHBlcignZ2V0QXVkaW9UcmFja3MnLCBtdXRlKTtcbiAgfX0sXG5cbiAgdG9nZ2xlTXV0ZVZpZGVvOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNdXRlVmlkZW8gKG11dGUpIHtcbiAgICB0aGlzLnRvZ2dsZU11dGVIZWxwZXIoJ2dldFZpZGVvVHJhY2tzJywgbXV0ZSk7XG4gIH19XG59KTtcblxuLy8gUmV0dXJuIHNpbmNlIGl0IHdpbGwgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZS5cbnJldHVybiBNZWRpYUhhbmRsZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9XZWJSVEMvTWVkaWFIYW5kbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNZWRpYVN0cmVhbU1hbmFnZXJcbiAqL1xuXG4vKiBNZWRpYVN0cmVhbU1hbmFnZXJcbiAqIEBjbGFzcyBNYW5hZ2VzIHRoZSBhY3F1aXNpdGlvbiBhbmQgcmVsZWFzZSBvZiBNZWRpYVN0cmVhbXMuXG4gKiBAcGFyYW0ge21lZGlhSGludH0gW2RlZmF1bHRNZWRpYUhpbnRdIFRoZSBtZWRpYUhpbnQgdG8gdXNlIGlmIG5vbmUgaXMgcHJvdmlkZWQgdG8gYWNxdWlyZSgpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcblxuLy8gRGVmYXVsdCBNZWRpYVN0cmVhbU1hbmFnZXIgcHJvdmlkZXMgc2luZ2xlLXVzZSBzdHJlYW1zIGNyZWF0ZWQgd2l0aCBnZXRVc2VyTWVkaWFcbnZhciBNZWRpYVN0cmVhbU1hbmFnZXIgPSBmdW5jdGlvbiBNZWRpYVN0cmVhbU1hbmFnZXIgKGxvZ2dlciwgZGVmYXVsdE1lZGlhSGludCkge1xuICBpZiAoIVNJUC5XZWJSVEMuaXNTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFcnJvcignTWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgdGhpcy5tZWRpYUhpbnQgPSBkZWZhdWx0TWVkaWFIaW50IHx8IHtcbiAgICBjb25zdHJhaW50czoge2F1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZX1cbiAgfTtcblxuICAvLyBtYXAgb2Ygc3RyZWFtcyB0byBhY3F1aXNpdGlvbiBtYW5uZXI6XG4gIC8vIHRydWUgLT4gcGFzc2VkIGluIGFzIG1lZGlhSGludC5zdHJlYW1cbiAgLy8gZmFsc2UgLT4gZ2V0VXNlck1lZGlhXG4gIHRoaXMuYWNxdWlzaXRpb25zID0ge307XG59O1xuTWVkaWFTdHJlYW1NYW5hZ2VyLnN0cmVhbUlkID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuY29uY2F0KHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpKVxuICAgIC5tYXAoZnVuY3Rpb24gdHJhY2tJZCAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICB9KVxuICAgIC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsoQXJyYXkgb2YpIE1lZGlhU3RyZWFtfSBzdHJlYW1zIC0gVGhlIHN0cmVhbXMgdG8gcmVuZGVyXG4gKlxuICogQHBhcmFtIHsoQXJyYXkgb2YpIEhUTUxNZWRpYUVsZW1lbnR9IGVsZW1lbnRzXG4gKiAgICAgICAgLSBUaGUgPGF1ZGlvPi88dmlkZW8+IGVsZW1lbnQocykgdGhhdCBzaG91bGQgcmVuZGVyIHRoZSBzdHJlYW1zXG4gKlxuICogRWFjaCBzdHJlYW0gaW4gc3RyZWFtcyByZW5kZXJzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gZWxlbWVudHMsXG4gKiB3cmFwcGluZyBhcm91bmQgZWxlbWVudHMgaWYgbmVlZGVkLlxuICovXG5NZWRpYVN0cmVhbU1hbmFnZXIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyIChzdHJlYW1zLCBlbGVtZW50cykge1xuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSAmJiAhZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudHMgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaE1lZGlhU3RyZWFtKGVsZW1lbnQsIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC5zcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbnZpcm9ubWVudC5yZXZva2VPYmplY3RVUkwoZWxlbWVudC5zcmMpO1xuICAgICAgZWxlbWVudC5zcmMgPSBlbnZpcm9ubWVudC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAoZWxlbWVudC5zcmNPYmplY3QgfHwgZWxlbWVudC5tb3pTcmNPYmplY3QpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBlbGVtZW50Lm1velNyY09iamVjdCA9IHN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlTWVkaWFQbGF5aW5nIChtZWRpYUVsZW1lbnQpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSAxMDA7XG4gICAgbWVkaWFFbGVtZW50LmVuc3VyZVBsYXlpbmdJbnRlcnZhbElkID0gU0lQLlRpbWVycy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWVkaWFFbGVtZW50LnBhdXNlZCkge1xuICAgICAgICBtZWRpYUVsZW1lbnQucGxheSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbChtZWRpYUVsZW1lbnQuZW5zdXJlUGxheWluZ0ludGVydmFsSWQpO1xuICAgICAgfVxuICAgIH0sIGludGVydmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaEFuZFBsYXkgKGVsZW1lbnRzLCBzdHJlYW0sIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWxlbWVudHMgPSBlbGVtZW50cygpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4ICUgZWxlbWVudHMubGVuZ3RoXTtcbiAgICAoZW52aXJvbm1lbnQuYXR0YWNoTWVkaWFTdHJlYW0gfHwgYXR0YWNoTWVkaWFTdHJlYW0pKGVsZW1lbnQsIHN0cmVhbSk7XG4gICAgZW5zdXJlTWVkaWFQbGF5aW5nKGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gW10uY29uY2F0IFwiY2FzdHNcIiBgZWxlbWVudHNgIGludG8gYW4gYXJyYXlcbiAgLy8gc28gZm9yRWFjaCB3b3JrcyBldmVuIGlmIGBlbGVtZW50c2Agd2FzIGEgc2luZ2xlIGVsZW1lbnRcbiAgZWxlbWVudHMgPSBbXS5jb25jYXQoZWxlbWVudHMpO1xuICBbXS5jb25jYXQoc3RyZWFtcykuZm9yRWFjaChhdHRhY2hBbmRQbGF5LmJpbmQobnVsbCwgZWxlbWVudHMpKTtcbn07XG5cbk1lZGlhU3RyZWFtTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gICdhY3F1aXJlJzoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gYWNxdWlyZSAobWVkaWFIaW50KSB7XG4gICAgbWVkaWFIaW50ID0gT2JqZWN0LmtleXMobWVkaWFIaW50IHx8IHt9KS5sZW5ndGggPyBtZWRpYUhpbnQgOiB0aGlzLm1lZGlhSGludDtcblxuICAgIHZhciBzYXZlU3VjY2VzcyA9IGZ1bmN0aW9uIChpc0hpbnRTdHJlYW0sIHN0cmVhbXMpIHtcbiAgICAgIHN0cmVhbXMgPSBbXS5jb25jYXQoc3RyZWFtcyk7XG4gICAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB2YXIgc3RyZWFtSWQgPSBNZWRpYVN0cmVhbU1hbmFnZXIuc3RyZWFtSWQoc3RyZWFtKTtcbiAgICAgICAgdGhpcy5hY3F1aXNpdGlvbnNbc3RyZWFtSWRdID0gISFpc0hpbnRTdHJlYW07XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKHN0cmVhbXMpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGlmIChtZWRpYUhpbnQuc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc2F2ZVN1Y2Nlc3ModHJ1ZSwgbWVkaWFIaW50LnN0cmVhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGF1ZGlvL3ZpZGVvIGVuYWJsZWQgaWYgbm8gbWVkaWFIaW50IGNhbiBiZSBmb3VuZC5cbiAgICAgIHZhciBjb25zdHJhaW50cyA9IG1lZGlhSGludC5jb25zdHJhaW50cyB8fFxuICAgICAgICAodGhpcy5tZWRpYUhpbnQgJiYgdGhpcy5tZWRpYUhpbnQuY29uc3RyYWludHMpIHx8XG4gICAgICAgIHthdWRpbzogdHJ1ZSwgdmlkZW86IHRydWV9O1xuXG4gICAgICB2YXIgZGVmZXJyZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcblxuICAgICAgLypcbiAgICAgICAqIE1ha2UgdGhlIGNhbGwgYXN5bmNocm9ub3VzLCBzbyB0aGF0IElDQ3MgaGF2ZSBhIGNoYW5jZVxuICAgICAgICogdG8gZGVmaW5lIGNhbGxiYWNrcyB0byBgdXNlck1lZGlhUmVxdWVzdGBcbiAgICAgICAqL1xuICAgICAgU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1c2VyTWVkaWFSZXF1ZXN0JywgY29uc3RyYWludHMpO1xuXG4gICAgICAgIHZhciBlbWl0VGhlbkNhbGwgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBjYWxsYmFja0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgIC8vIEVtaXQgd2l0aCBhbGwgb2YgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSByZWFsIGNhbGxiYWNrLlxuICAgICAgICAgIHZhciBuZXdBcmdzID0gW2V2ZW50TmFtZV0uY29uY2F0KGNhbGxiYWNrQXJncyk7XG5cbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgbmV3QXJncyk7XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmdzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbyB8fCBjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoXG4gICAgICAgICAgICBTSVAuV2ViUlRDLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBlbWl0VGhlbkNhbGwuYmluZCh0aGlzLCAndXNlck1lZGlhJywgc2F2ZVN1Y2Nlc3MuYmluZChudWxsLCBmYWxzZSkpLFxuICAgICAgICAgICAgICBlbWl0VGhlbkNhbGwuYmluZCh0aGlzLCAndXNlck1lZGlhRmFpbGVkJywgZnVuY3Rpb24oZSl7dGhyb3cgZTt9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTG9jYWwgc3RyZWFtcyB3ZXJlIGV4cGxpY2l0bHkgZXhjbHVkZWQuXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgfX0sXG5cbiAgJ3JlbGVhc2UnOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlIChzdHJlYW1zKSB7XG4gICAgc3RyZWFtcyA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgdmFyIHN0cmVhbUlkID0gTWVkaWFTdHJlYW1NYW5hZ2VyLnN0cmVhbUlkKHN0cmVhbSk7XG4gICAgICBpZiAodGhpcy5hY3F1aXNpdGlvbnNbc3RyZWFtSWRdID09PSBmYWxzZSkge1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuYWNxdWlzaXRpb25zW3N0cmVhbUlkXTtcbiAgICB9LCB0aGlzKTtcbiAgfX0sXG59KTtcblxuLy8gUmV0dXJuIHNpbmNlIGl0IHdpbGwgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZS5cbnJldHVybiBNZWRpYVN0cmVhbU1hbmFnZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9XZWJSVEMvTWVkaWFTdHJlYW1NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIFVzZXIgQWdlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIHJldHVybmluZyBTSVAuTWVkaWFIYW5kbGVyfSBbY29uZmlndXJhdGlvbi5tZWRpYUhhbmRsZXJGYWN0b3J5XVxuICogICAgICAgIEEgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJ5IGVhY2ggb2YgdGhlIFVBJ3MgU2Vzc2lvbnMgdG8gYnVpbGQgdGhlIE1lZGlhSGFuZGxlciBmb3IgdGhhdCBTZXNzaW9uLlxuICogICAgICAgIElmIG5vIChvciBhIGZhbHN5KSB2YWx1ZSBpcyBwcm92aWRlZCwgZWFjaCBTZXNzaW9uIHdpbGwgdXNlIGEgZGVmYXVsdCAoV2ViUlRDKSBNZWRpYUhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWd1cmF0aW9uLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG52YXIgVUEsXG4gIEMgPSB7XG4gICAgLy8gVUEgc3RhdHVzIGNvZGVzXG4gICAgU1RBVFVTX0lOSVQ6ICAgICAgICAgICAgICAgIDAsXG4gICAgU1RBVFVTX1NUQVJUSU5HOiAgICAgICAgICAgIDEsXG4gICAgU1RBVFVTX1JFQURZOiAgICAgICAgICAgICAgIDIsXG4gICAgU1RBVFVTX1VTRVJfQ0xPU0VEOiAgICAgICAgIDMsXG4gICAgU1RBVFVTX05PVF9SRUFEWTogICAgICAgICAgIDQsXG5cbiAgICAvLyBVQSBlcnJvciBjb2Rlc1xuICAgIENPTkZJR1VSQVRJT05fRVJST1I6ICAxLFxuICAgIE5FVFdPUktfRVJST1I6ICAgICAgICAyLFxuXG4gICAgQUxMT1dFRF9NRVRIT0RTOiBbXG4gICAgICAnQUNLJyxcbiAgICAgICdDQU5DRUwnLFxuICAgICAgJ0lOVklURScsXG4gICAgICAnTUVTU0FHRScsXG4gICAgICAnQllFJyxcbiAgICAgICdPUFRJT05TJyxcbiAgICAgICdJTkZPJyxcbiAgICAgICdOT1RJRlknLFxuICAgICAgJ1JFRkVSJ1xuICAgIF0sXG5cbiAgICBBQ0NFUFRFRF9CT0RZX1RZUEVTOiBbXG4gICAgICAnYXBwbGljYXRpb24vc2RwJyxcbiAgICAgICdhcHBsaWNhdGlvbi9kdG1mLXJlbGF5J1xuICAgIF0sXG5cbiAgICBNQVhfRk9SV0FSRFM6IDcwLFxuICAgIFRBR19MRU5HVEg6IDEwXG4gIH07XG5cblVBID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBmb3J3YXJkaW5nIGV2ZW50c1xuICBmdW5jdGlvbiBzZWxmRW1pdCh0eXBlKSB7XG4gICAgLy9yZWdpc3RyYXRpb25GYWlsZWQgaGFuZGxlciBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50cy4gQWxsb3cgZXZlbnQgaGFuZGxlcnMgdG8gYmUgaW52b2tlZCB3aXRoIGEgdmFyaWFibGUgbm8uIG9mIGFyZ3VtZW50c1xuICAgIHJldHVybiBzZWxmLmVtaXQuYmluZChzZWxmLCB0eXBlKTtcbiAgfVxuXG4gIC8vIFNldCBBY2NlcHRlZCBCb2R5IFR5cGVzXG4gIEMuQUNDRVBURURfQk9EWV9UWVBFUyA9IEMuQUNDRVBURURfQk9EWV9UWVBFUy50b1N0cmluZygpO1xuXG4gIHRoaXMubG9nID0gbmV3IFNJUC5Mb2dnZXJGYWN0b3J5KCk7XG4gIHRoaXMubG9nZ2VyID0gdGhpcy5nZXRMb2dnZXIoJ3NpcC51YScpO1xuXG4gIHRoaXMuY2FjaGUgPSB7XG4gICAgY3JlZGVudGlhbHM6IHt9XG4gIH07XG5cbiAgdGhpcy5jb25maWd1cmF0aW9uID0ge307XG4gIHRoaXMuZGlhbG9ncyA9IHt9O1xuXG4gIC8vVXNlciBhY3Rpb25zIG91dHNpZGUgYW55IHNlc3Npb24vZGlhbG9nIChNRVNTQUdFKVxuICB0aGlzLmFwcGxpY2FudHMgPSB7fTtcblxuICB0aGlzLmRhdGEgPSB7fTtcbiAgdGhpcy5zZXNzaW9ucyA9IHt9O1xuICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB0aGlzLmNvbnRhY3QgPSBudWxsO1xuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0lOSVQ7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xuICB0aGlzLnRyYW5zYWN0aW9ucyA9IHtcbiAgICBuaXN0OiB7fSxcbiAgICBuaWN0OiB7fSxcbiAgICBpc3Q6IHt9LFxuICAgIGljdDoge31cbiAgfTtcblxuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cyA9IDA7XG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlcnlUaW1lciA9IG51bGw7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHlwZSxcbiAgICAgICAgICB0cmFuc2FjdGlvbnMgPSBbJ25pc3QnLCduaWN0JywnaXN0JywnaWN0J10sXG4gICAgICAgICAgY291bnQgPSAwO1xuXG4gICAgICAgIGZvciAodHlwZSBpbiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBjb3VudCArPSBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbnNbdHlwZV1dKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5pY3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWyduaWN0J10pLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmlzdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ25pc3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpY3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWydpY3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWydpc3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIExvYWQgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAdGhyb3dzIHtTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3J9XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICovXG5cbiAgaWYoY29uZmlndXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlndXJhdGlvbiA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uID09PSAnc3RyaW5nJyB8fCBjb25maWd1cmF0aW9uIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgIHVyaTogY29uZmlndXJhdGlvblxuICAgIH07XG4gIH1cblxuICAvLyBBcHBseSBsb2cgY29uZmlndXJhdGlvbiBpZiBwcmVzZW50XG4gIGlmIChjb25maWd1cmF0aW9uLmxvZykge1xuICAgIGlmIChjb25maWd1cmF0aW9uLmxvZy5oYXNPd25Qcm9wZXJ0eSgnYnVpbHRpbkVuYWJsZWQnKSkge1xuICAgICAgdGhpcy5sb2cuYnVpbHRpbkVuYWJsZWQgPSBjb25maWd1cmF0aW9uLmxvZy5idWlsdGluRW5hYmxlZDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cuaGFzT3duUHJvcGVydHkoJ2xldmVsJykpIHtcbiAgICAgIHRoaXMubG9nLmxldmVsID0gY29uZmlndXJhdGlvbi5sb2cubGV2ZWw7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KCdjb25uZWN0b3InKSkge1xuICAgICAgdGhpcy5sb2cuY29ubmVjdG9yID0gY29uZmlndXJhdGlvbi5sb2cuY29ubmVjdG9yO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5sb2FkQ29uZmlnKGNvbmZpZ3VyYXRpb24pO1xuICB9IGNhdGNoKGUpIHtcbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX05PVF9SRUFEWTtcbiAgICB0aGlzLmVycm9yID0gQy5DT05GSUdVUkFUSU9OX0VSUk9SO1xuICAgIHRocm93IGU7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHJlZ2lzdGVyQ29udGV4dFxuICB0aGlzLnJlZ2lzdGVyQ29udGV4dCA9IG5ldyBTSVAuUmVnaXN0ZXJDb250ZXh0KHRoaXMpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vbignZmFpbGVkJywgc2VsZkVtaXQoJ3JlZ2lzdHJhdGlvbkZhaWxlZCcpKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQub24oJ3JlZ2lzdGVyZWQnLCBzZWxmRW1pdCgncmVnaXN0ZXJlZCcpKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQub24oJ3VucmVnaXN0ZXJlZCcsIHNlbGZFbWl0KCd1bnJlZ2lzdGVyZWQnKSk7XG5cbiAgaWYodGhpcy5jb25maWd1cmF0aW9uLmF1dG9zdGFydCkge1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52aXJvbm1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEdvb2dsZSBDaHJvbWUgUGFja2FnZWQgQXBwcyBkb24ndCBhbGxvdyAndW5sb2FkJyBsaXN0ZW5lcnM6XG4gICAgLy8gdW5sb2FkIGlzIG5vdCBhdmFpbGFibGUgaW4gcGFja2FnZWQgYXBwc1xuICAgIGlmICghKGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZSkpIHtcbiAgICAgIGVudmlyb25tZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIHRoaXMuc3RvcC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbn07XG5VQS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLy89PT09PT09PT09PT09PT09PVxuLy8gIEhpZ2ggTGV2ZWwgQVBJXG4vLz09PT09PT09PT09PT09PT09XG5cblVBLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyID0gdHJ1ZTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXIob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsXSB1bnJlZ2lzdGVyIGFsbCB1c2VyIGJpbmRpbmdzLlxuICpcbiAqL1xuVUEucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3RlciA9IGZhbHNlO1xuXG4gIHZhciBjb250ZXh0ID0gdGhpcy5yZWdpc3RlckNvbnRleHQ7XG4gIHRoaXMuYWZ0ZXJDb25uZWN0ZWQoY29udGV4dC51bnJlZ2lzdGVyLmJpbmQoY29udGV4dCwgb3B0aW9ucykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVUEucHJvdG90eXBlLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXJlZDtcbn07XG5cbi8qKlxuICogQ29ubmVjdGlvbiBzdGF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAqL1xuVUEucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRyYW5zcG9ydCA/IHRoaXMudHJhbnNwb3J0LmNvbm5lY3RlZCA6IGZhbHNlO1xufTtcblxuVUEucHJvdG90eXBlLmFmdGVyQ29ubmVjdGVkID0gZnVuY3Rpb24gYWZ0ZXJDb25uZWN0ZWQgKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub25jZSgnY29ubmVjdGVkJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYW4gb3V0Z29pbmcgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAqXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKlxuICovXG5VQS5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IFNJUC5JbnZpdGVDbGllbnRDb250ZXh0KHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5hZnRlckNvbm5lY3RlZChjb250ZXh0Lmludml0ZS5iaW5kKGNvbnRleHQpKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5VQS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgb3B0aW9ucykge1xuICB2YXIgc3ViID0gbmV3IFNJUC5TdWJzY3JpcHRpb24odGhpcywgdGFyZ2V0LCBldmVudCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5hZnRlckNvbm5lY3RlZChzdWIuc3Vic2NyaWJlLmJpbmQoc3ViKSk7XG4gIHJldHVybiBzdWI7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICpcbiAqL1xuVUEucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbih0YXJnZXQsIGJvZHksIG9wdGlvbnMpIHtcbiAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIH1cblxuICAvLyBUaGVyZSBpcyBubyBNZXNzYWdlIG1vZHVsZSwgc28gaXQgaXMgb2theSB0aGF0IHRoZSBVQSBoYW5kbGVzIGRlZmF1bHRzIGhlcmUuXG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuY29udGVudFR5cGUgfHwgKG9wdGlvbnMuY29udGVudFR5cGUgPSAndGV4dC9wbGFpbicpO1xuICBvcHRpb25zLmJvZHkgPSBib2R5O1xuXG4gIHJldHVybiB0aGlzLnJlcXVlc3QoU0lQLkMuTUVTU0FHRSwgdGFyZ2V0LCBvcHRpb25zKTtcbn07XG5cblVBLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciByZXEgPSBuZXcgU0lQLkNsaWVudENvbnRleHQodGhpcywgbWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gIHRoaXMuYWZ0ZXJDb25uZWN0ZWQocmVxLnNlbmQuYmluZChyZXEpKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogR3JhY2VmdWxseSBjbG9zZS5cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZXNzaW9uLCBzdWJzY3JpcHRpb24sIGFwcGxpY2FudCxcbiAgICB1YSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gdHJhbnNhY3Rpb25zTGlzdGVuZXIoKSB7XG4gICAgaWYgKHVhLm5pc3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCAmJiB1YS5uaWN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDApIHtcbiAgICAgICAgdWEucmVtb3ZlTGlzdGVuZXIoJ3RyYW5zYWN0aW9uRGVzdHJveWVkJywgdHJhbnNhY3Rpb25zTGlzdGVuZXIpO1xuICAgICAgICB1YS50cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubG9nZ2VyLmxvZygndXNlciByZXF1ZXN0ZWQgY2xvc3VyZS4uLicpO1xuXG4gIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1VBIGFscmVhZHkgY2xvc2VkJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDbGVhciB0cmFuc3BvcnRSZWNvdmVyeVRpbWVyXG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNwb3J0UmVjb3ZlcnlUaW1lcik7XG5cbiAgLy8gQ2xvc2UgcmVnaXN0ZXJDb250ZXh0XG4gIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyByZWdpc3RlckNvbnRleHQnKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQuY2xvc2UoKTtcblxuICAvLyBSdW4gIF90ZXJtaW5hdGVfIG9uIGV2ZXJ5IFNlc3Npb25cbiAgZm9yKHNlc3Npb24gaW4gdGhpcy5zZXNzaW9ucykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBzZXNzaW9uICcgKyBzZXNzaW9uKTtcbiAgICB0aGlzLnNlc3Npb25zW3Nlc3Npb25dLnRlcm1pbmF0ZSgpO1xuICB9XG5cbiAgLy9SdW4gX2Nsb3NlXyBvbiBldmVyeSBTdWJzY3JpcHRpb25cbiAgZm9yKHN1YnNjcmlwdGlvbiBpbiB0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3Vuc3Vic2NyaWJpbmcgZnJvbSBzdWJzY3JpcHRpb24gJyArIHN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbl0uY2xvc2UoKTtcbiAgfVxuXG4gIC8vIFJ1biAgX2Nsb3NlXyBvbiBldmVyeSBhcHBsaWNhbnRcbiAgZm9yKGFwcGxpY2FudCBpbiB0aGlzLmFwcGxpY2FudHMpIHtcbiAgICB0aGlzLmFwcGxpY2FudHNbYXBwbGljYW50XS5jbG9zZSgpO1xuICB9XG5cbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19VU0VSX0NMT1NFRDtcblxuICAvKlxuICAgKiBJZiB0aGUgcmVtYWluaW5nIHRyYW5zYWN0aW9ucyBhcmUgYWxsIElOVklURSB0cmFuc2FjdGlvbnMsIHRoZXJlIGlzIG5vIG5lZWQgdG9cbiAgICogd2FpdCBhbnltb3JlIGJlY2F1c2UgZXZlcnkgc2Vzc2lvbiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBieSB0aGlzIG1ldGhvZC5cbiAgICogLSBsb2NhbGx5IG9yaWdpbmF0ZWQgc2Vzc2lvbnMgd2hlcmUgdGVybWluYXRlZCAoQ0FOQ0VMIG9yIEJZRSlcbiAgICogLSByZW1vdGVseSBvcmlnaW5hdGVkIHNlc3Npb25zIHdoZXJlIHJlamVjdGVkICg0WFgpIG9yIHRlcm1pbmF0ZWQgKEJZRSlcbiAgICogUmVtYWluaW5nIElOVklURSB0cmFuc2FjdGlvbnMgYmVsb25nIHRobyBzZXNzaW9ucyB0aGF0IHdoZXJlIGFuc3dlcmVkLiBUaGlzIGFyZSBpblxuICAgKiAnYWNjZXB0ZWQnIHN0YXRlIGR1ZSB0byB0aW1lcnMgJ0wnIGFuZCAnTScgZGVmaW5lZCBpbiBbUkZDIDYwMjZdXG4gICAqL1xuICBpZiAodGhpcy5uaXN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDAgJiYgdGhpcy5uaWN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDApIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbigndHJhbnNhY3Rpb25EZXN0cm95ZWQnLCB0cmFuc2FjdGlvbnNMaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29ubmVjdCB0byB0aGUgV1Mgc2VydmVyIGlmIHN0YXR1cyA9IFNUQVRVU19JTklULlxuICogUmVzdW1lIFVBIGFmdGVyIGJlaW5nIGNsb3NlZC5cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VydmVyO1xuXG4gIHRoaXMubG9nZ2VyLmxvZygndXNlciByZXF1ZXN0ZWQgc3RhcnR1cC4uLicpO1xuICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0lOSVQpIHtcbiAgICBzZXJ2ZXIgPSB0aGlzLmdldE5leHRXc1NlcnZlcigpO1xuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfU1RBUlRJTkc7XG4gICAgbmV3IFNJUC5UcmFuc3BvcnQodGhpcywgc2VydmVyKTtcbiAgfSBlbHNlIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygncmVzdW1pbmcnKTtcbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1JFQURZO1xuICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfU1RBUlRJTkcpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ1VBIGlzIGluIFNUQVJUSU5HIHN0YXR1cywgbm90IG9wZW5pbmcgbmV3IGNvbm5lY3Rpb24nKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfUkVBRFkpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ1VBIGlzIGluIFJFQURZIHN0YXR1cywgbm90IHJlc3VtaW5nJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Nvbm5lY3Rpb24gaXMgZG93bi4gQXV0by1SZWNvdmVyeSBzeXN0ZW0gaXMgdHJ5aW5nIHRvIGNvbm5lY3QnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBzdHJpbmcgaW50byBhIHZhbGlkIFNJUCByZXF1ZXN0IFVSSVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqXG4gKiBAcmV0dXJucyB7U0lQLlVSSXx1bmRlZmluZWR9XG4gKi9cblVBLnByb3RvdHlwZS5ub3JtYWxpemVUYXJnZXQgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIFNJUC5VdGlscy5ub3JtYWxpemVUYXJnZXQodGFyZ2V0LCB0aGlzLmNvbmZpZ3VyYXRpb24uaG9zdHBvcnRQYXJhbXMpO1xufTtcblxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vICBQcml2YXRlIChGb3IgaW50ZXJuYWwgdXNlKVxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblVBLnByb3RvdHlwZS5zYXZlQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihjcmVkZW50aWFscykge1xuICB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW2NyZWRlbnRpYWxzLnJlYWxtXSA9IHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbY3JlZGVudGlhbHMucmVhbG1dIHx8IHt9O1xuICB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW2NyZWRlbnRpYWxzLnJlYWxtXVtjcmVkZW50aWFscy51cmldID0gY3JlZGVudGlhbHM7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VQS5wcm90b3R5cGUuZ2V0Q3JlZGVudGlhbHMgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciByZWFsbSwgY3JlZGVudGlhbHM7XG5cbiAgcmVhbG0gPSByZXF1ZXN0LnJ1cmkuaG9zdDtcblxuICBpZiAodGhpcy5jYWNoZS5jcmVkZW50aWFsc1tyZWFsbV0gJiYgdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tyZWFsbV1bcmVxdWVzdC5ydXJpXSkge1xuICAgIGNyZWRlbnRpYWxzID0gdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tyZWFsbV1bcmVxdWVzdC5ydXJpXTtcbiAgICBjcmVkZW50aWFscy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgfVxuXG4gIHJldHVybiBjcmVkZW50aWFscztcbn07XG5cblVBLnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbihjYXRlZ29yeSwgbGFiZWwpIHtcbiAgcmV0dXJuIHRoaXMubG9nLmdldExvZ2dlcihjYXRlZ29yeSwgbGFiZWwpO1xufTtcblxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRXZlbnQgSGFuZGxlcnNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVHJhbnNwb3J0IENsb3NlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQGV2ZW50XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqL1xuVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0Q2xvc2VkID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gIC8vIFJ1biBfb25UcmFuc3BvcnRFcnJvcl8gY2FsbGJhY2sgb24gZXZlcnkgY2xpZW50IHRyYW5zYWN0aW9uIHVzaW5nIF90cmFuc3BvcnRfXG4gIHZhciB0eXBlLCBpZHgsIGxlbmd0aCxcbiAgICBjbGllbnRfdHJhbnNhY3Rpb25zID0gWyduaWN0JywgJ2ljdCcsICduaXN0JywgJ2lzdCddO1xuXG4gIHRyYW5zcG9ydC5zZXJ2ZXIuc3RhdHVzID0gU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19ESVNDT05ORUNURUQ7XG4gIHRoaXMubG9nZ2VyLmxvZygnY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJysgU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19ESVNDT05ORUNURUQpO1xuXG4gIGxlbmd0aCA9IGNsaWVudF90cmFuc2FjdGlvbnMubGVuZ3RoO1xuICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgbGVuZ3RoOyB0eXBlKyspIHtcbiAgICBmb3IoaWR4IGluIHRoaXMudHJhbnNhY3Rpb25zW2NsaWVudF90cmFuc2FjdGlvbnNbdHlwZV1dKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0aW9uc1tjbGllbnRfdHJhbnNhY3Rpb25zW3R5cGVdXVtpZHhdLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICAvLyBDbG9zZSBzZXNzaW9ucyBpZiBHUlVVIGlzIG5vdCBiZWluZyB1c2VkXG4gIGlmICghdGhpcy5jb250YWN0LnB1Yl9ncnV1KSB7XG4gICAgdGhpcy5jbG9zZVNlc3Npb25zT25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG5cbn07XG5cbi8qKlxuICogVW5yZWNvdmVyYWJsZSB0cmFuc3BvcnQgZXZlbnQuXG4gKiBDb25uZWN0aW9uIHJlYXR0ZW1wdCBsb2dpYyBoYXMgYmVlbiBkb25lIGFuZCBkaWRuJ3Qgc3VjY2Vzcy5cbiAqIEBwcml2YXRlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICovXG5VQS5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICB2YXIgc2VydmVyO1xuXG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2VydmVyLndzX3VyaSArICcgZmFpbGVkIHwgY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJysgU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19FUlJPUik7XG5cbiAgLy8gQ2xvc2Ugc2Vzc2lvbnMuXG4gIC8vTWFyayB0aGlzIHRyYW5zcG9ydCBhcyAnZG93bidcbiAgdHJhbnNwb3J0LnNlcnZlci5zdGF0dXMgPSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0VSUk9SO1xuXG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJywge1xuICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0XG4gIH0pO1xuXG4gIC8vIHRyeSB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIFVBIGlzbid0IGNsb3NlZFxuICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXJ2ZXIgPSB0aGlzLmdldE5leHRXc1NlcnZlcigpO1xuXG4gIGlmKHNlcnZlcikge1xuICAgIG5ldyBTSVAuVHJhbnNwb3J0KHRoaXMsIHNlcnZlcik7XG4gIH1lbHNlIHtcbiAgICB0aGlzLmNsb3NlU2Vzc2lvbnNPblRyYW5zcG9ydEVycm9yKCk7XG4gICAgaWYgKCF0aGlzLmVycm9yIHx8IHRoaXMuZXJyb3IgIT09IEMuTkVUV09SS19FUlJPUikge1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19OT1RfUkVBRFk7XG4gICAgICB0aGlzLmVycm9yID0gQy5ORVRXT1JLX0VSUk9SO1xuICAgIH1cbiAgICAvLyBUcmFuc3BvcnQgUmVjb3ZlcnkgcHJvY2Vzc1xuICAgIHRoaXMucmVjb3ZlclRyYW5zcG9ydCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBjb25uZWN0aW9uIGV2ZW50LlxuICogQHByaXZhdGVcbiAqIEBldmVudFxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnQuXG4gKi9cblVBLnByb3RvdHlwZS5vblRyYW5zcG9ydENvbm5lY3RlZCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBSZXNldCB0cmFuc3BvcnQgcmVjb3ZlcnkgY291bnRlclxuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cyA9IDA7XG5cbiAgdHJhbnNwb3J0LnNlcnZlci5zdGF0dXMgPSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX1JFQURZO1xuICB0aGlzLmxvZ2dlci5sb2coJ2Nvbm5lY3Rpb24gc3RhdGUgc2V0IHRvICcrIFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfUkVBRFkpO1xuXG4gIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfUkVBRFk7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xuXG4gIGlmKHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3Rlcikge1xuICAgIHRoaXMuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZWdpc3RlckNvbnRleHQub25UcmFuc3BvcnRDb25uZWN0ZWQoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnLCB7XG4gICAgdHJhbnNwb3J0OiB0cmFuc3BvcnRcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVHJhbnNwb3J0IGNvbm5lY3RpbmcgZXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqICNwYXJhbSB7SW50ZWdlcn0gYXR0ZW1wdHMuXG4gKi9cbiAgVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0Q29ubmVjdGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgYXR0ZW1wdHMpIHtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnLCB7XG4gICAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydCxcbiAgICAgIGF0dGVtcHRzOiBhdHRlbXB0c1xuICAgIH0pO1xuICB9O1xuXG5cbi8qKlxuICogbmV3IFRyYW5zYWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uLlxuICovXG5VQS5wcm90b3R5cGUubmV3VHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICB0aGlzLnRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbi50eXBlXVt0cmFuc2FjdGlvbi5pZF0gPSB0cmFuc2FjdGlvbjtcbiAgdGhpcy5lbWl0KCduZXdUcmFuc2FjdGlvbicsIHt0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb259KTtcbn07XG5cblxuLyoqXG4gKiBkZXN0cm95IFRyYW5zYWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uLlxuICovXG5VQS5wcm90b3R5cGUuZGVzdHJveVRyYW5zYWN0aW9uID0gZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgZGVsZXRlIHRoaXMudHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uLnR5cGVdW3RyYW5zYWN0aW9uLmlkXTtcbiAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbkRlc3Ryb3llZCcsIHtcbiAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgfSk7XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gcmVjZWl2ZVJlcXVlc3Rcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFJlcXVlc3QgcmVjZXB0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0LlxuICovXG5VQS5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciBkaWFsb2csIHNlc3Npb24sIG1lc3NhZ2UsXG4gICAgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QsXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgcmVwbGFjZXMsXG4gICAgcmVwbGFjZWREaWFsb2csXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gcnVyaU1hdGNoZXMgKHVyaSkge1xuICAgIHJldHVybiB1cmkgJiYgdXJpLnVzZXIgPT09IHJlcXVlc3QucnVyaS51c2VyO1xuICB9XG5cbiAgLy8gQ2hlY2sgdGhhdCByZXF1ZXN0IFVSSSBwb2ludHMgdG8gdXNcbiAgaWYoIShydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24udXJpKSB8fFxuICAgICAgIHJ1cmlNYXRjaGVzKHRoaXMuY29udGFjdC51cmkpIHx8XG4gICAgICAgcnVyaU1hdGNoZXModGhpcy5jb250YWN0LnB1Yl9ncnV1KSB8fFxuICAgICAgIHJ1cmlNYXRjaGVzKHRoaXMuY29udGFjdC50ZW1wX2dydXUpKSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1JlcXVlc3QtVVJJIGRvZXMgbm90IHBvaW50IHRvIHVzJyk7XG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBTSVAuQy5BQ0spIHtcbiAgICAgIHJlcXVlc3QucmVwbHlfc2woNDA0KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2hlY2sgcmVxdWVzdCBVUkkgc2NoZW1lXG4gIGlmKHJlcXVlc3QucnVyaS5zY2hlbWUgPT09IFNJUC5DLlNJUFMpIHtcbiAgICByZXF1ZXN0LnJlcGx5X3NsKDQxNik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2hlY2sgdHJhbnNhY3Rpb25cbiAgaWYoU0lQLlRyYW5zYWN0aW9ucy5jaGVja1RyYW5zYWN0aW9uKHRoaXMsIHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogUkZDMzI2MSAxMi4yLjJcbiAgICogUmVxdWVzdHMgdGhhdCBkbyBub3QgY2hhbmdlIGluIGFueSB3YXkgdGhlIHN0YXRlIG9mIGEgZGlhbG9nIG1heSBiZVxuICAgKiByZWNlaXZlZCB3aXRoaW4gYSBkaWFsb2cgKGZvciBleGFtcGxlLCBhbiBPUFRJT05TIHJlcXVlc3QpLlxuICAgKiBUaGV5IGFyZSBwcm9jZXNzZWQgYXMgaWYgdGhleSBoYWQgYmVlbiByZWNlaXZlZCBvdXRzaWRlIHRoZSBkaWFsb2cuXG4gICAqL1xuICBpZihtZXRob2QgPT09IFNJUC5DLk9QVElPTlMpIHtcbiAgICBuZXcgU0lQLlRyYW5zYWN0aW9ucy5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB0aGlzKTtcbiAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgW1xuICAgICAgJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSxcbiAgICAgICdBY2NlcHQ6ICcrIEMuQUNDRVBURURfQk9EWV9UWVBFU1xuICAgIF0pO1xuICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gU0lQLkMuTUVTU0FHRSkge1xuICAgIG1lc3NhZ2UgPSBuZXcgU0lQLlNlcnZlckNvbnRleHQodGhpcywgcmVxdWVzdCk7XG4gICAgbWVzc2FnZS5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgIG1lc3NhZ2UuY29udGVudF90eXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpIHx8ICd0ZXh0L3BsYWluJztcblxuICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgfSBlbHNlIGlmIChtZXRob2QgIT09IFNJUC5DLklOVklURSAmJlxuICAgICAgICAgICAgIG1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgLy8gTGV0IHRob3NlIG1ldGhvZHMgcGFzcyB0aHJvdWdoIHRvIG5vcm1hbCBwcm9jZXNzaW5nIGZvciBub3cuXG4gICAgdHJhbnNhY3Rpb24gPSBuZXcgU0lQLlNlcnZlckNvbnRleHQodGhpcywgcmVxdWVzdCk7XG4gIH1cblxuICAvLyBJbml0aWFsIFJlcXVlc3RcbiAgaWYoIXJlcXVlc3QudG9fdGFnKSB7XG4gICAgc3dpdGNoKG1ldGhvZCkge1xuICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgIHJlcGxhY2VzID1cbiAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgIT09IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCAmJlxuICAgICAgICAgIHJlcXVlc3QucGFyc2VIZWFkZXIoJ3JlcGxhY2VzJyk7XG5cbiAgICAgICAgaWYgKHJlcGxhY2VzKSB7XG4gICAgICAgICAgcmVwbGFjZWREaWFsb2cgPSB0aGlzLmRpYWxvZ3NbcmVwbGFjZXMuY2FsbF9pZCArIHJlcGxhY2VzLnJlcGxhY2VzX3RvX3RhZyArIHJlcGxhY2VzLnJlcGxhY2VzX2Zyb21fdGFnXTtcblxuICAgICAgICAgIGlmICghcmVwbGFjZWREaWFsb2cpIHtcbiAgICAgICAgICAgIC8vUmVwbGFjZWQgaGVhZGVyIHdpdGhvdXQgYSBtYXRjaGluZyBkaWFsb2csIHJlamVjdFxuICAgICAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg0ODEsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZWREaWFsb2cub3duZXIuc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDYwMywgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlZERpYWxvZy5zdGF0ZSA9PT0gU0lQLkRpYWxvZy5DLlNUQVRVU19DT05GSVJNRUQgJiYgcmVwbGFjZXMuZWFybHlfb25seSkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg0ODYsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc01lZGlhU3VwcG9ydGVkID0gdGhpcy5jb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnkuaXNTdXBwb3J0ZWQ7XG4gICAgICAgIGlmKCFpc01lZGlhU3VwcG9ydGVkIHx8IGlzTWVkaWFTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIHNlc3Npb24gPSBuZXcgU0lQLkludml0ZVNlcnZlckNvbnRleHQodGhpcywgcmVxdWVzdCk7XG4gICAgICAgICAgc2Vzc2lvbi5yZXBsYWNlZSA9IHJlcGxhY2VkRGlhbG9nICYmIHJlcGxhY2VkRGlhbG9nLm93bmVyO1xuICAgICAgICAgIHNlc3Npb24ub24oJ2ludml0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdpbnZpdGUnLCB0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdJTlZJVEUgcmVjZWl2ZWQgYnV0IFdlYlJUQyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg0ODgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5CWUU6XG4gICAgICAgIC8vIE91dCBvZiBkaWFsb2cgQllFIHJlY2VpdmVkXG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLkNBTkNFTDpcbiAgICAgICAgc2Vzc2lvbiA9IHRoaXMuZmluZFNlc3Npb24ocmVxdWVzdCk7XG4gICAgICAgIGlmKHNlc3Npb24pIHtcbiAgICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3JlY2VpdmVkIENBTkNFTCByZXF1ZXN0IGZvciBhIG5vbiBleGlzdGVudCBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLkFDSzpcbiAgICAgICAgLyogQWJzb3JiIGl0LlxuICAgICAgICAgKiBBQ0sgcmVxdWVzdCB3aXRob3V0IGEgY29ycmVzcG9uZGluZyBJbnZpdGUgVHJhbnNhY3Rpb25cbiAgICAgICAgICogYW5kIHdpdGhvdXQgVG8gdGFnLlxuICAgICAgICAgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXF1ZXN0LnJlcGx5KDQwNSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBJbi1kaWFsb2cgcmVxdWVzdFxuICBlbHNlIHtcbiAgICBkaWFsb2cgPSB0aGlzLmZpbmREaWFsb2cocmVxdWVzdCk7XG5cbiAgICBpZihkaWFsb2cpIHtcbiAgICAgIGlmIChtZXRob2QgPT09IFNJUC5DLklOVklURSkge1xuICAgICAgICBuZXcgU0lQLlRyYW5zYWN0aW9ucy5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5yZWNlaXZlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gU0lQLkMuTk9USUZZKSB7XG4gICAgICBzZXNzaW9uID0gdGhpcy5maW5kU2Vzc2lvbihyZXF1ZXN0KTtcbiAgICAgIGlmKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3JlY2VpdmVkIE5PVElGWSByZXF1ZXN0IGZvciBhIG5vbiBleGlzdGVudCBzZXNzaW9uJyk7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDgxLCAnU3Vic2NyaXB0aW9uIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFJGQzMyNjEgMTIuMi4yXG4gICAgICogUmVxdWVzdCB3aXRoIHRvIHRhZywgYnV0IG5vIG1hdGNoaW5nIGRpYWxvZyBmb3VuZC5cbiAgICAgKiBFeGNlcHRpb246IEFDSyBmb3IgYW4gSW52aXRlIHJlcXVlc3QgZm9yIHdoaWNoIGEgZGlhbG9nIGhhcyBub3RcbiAgICAgKiBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZWxzZSB7XG4gICAgICBpZihtZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4MSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLz09PT09PT09PT09PT09PT09XG4vLyBVdGlsc1xuLy89PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCB0aGUgc2Vzc2lvbiB0byB3aGljaCB0aGUgcmVxdWVzdCBiZWxvbmdzIHRvLCBpZiBhbnkuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0LlxuICogQHJldHVybnMge1NJUC5PdXRnb2luZ1Nlc3Npb258U0lQLkluY29taW5nU2Vzc2lvbnxudWxsfVxuICovXG5VQS5wcm90b3R5cGUuZmluZFNlc3Npb24gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHJldHVybiB0aGlzLnNlc3Npb25zW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QuZnJvbV90YWddIHx8XG4gICAgICAgICAgdGhpcy5zZXNzaW9uc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LnRvX3RhZ10gfHxcbiAgICAgICAgICBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpYWxvZyB0byB3aGljaCB0aGUgcmVxdWVzdCBiZWxvbmdzIHRvLCBpZiBhbnkuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fVxuICogQHJldHVybnMge1NJUC5EaWFsb2d8bnVsbH1cbiAqL1xuVUEucHJvdG90eXBlLmZpbmREaWFsb2cgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHJldHVybiB0aGlzLmRpYWxvZ3NbcmVxdWVzdC5jYWxsX2lkICsgcmVxdWVzdC5mcm9tX3RhZyArIHJlcXVlc3QudG9fdGFnXSB8fFxuICAgICAgICAgIHRoaXMuZGlhbG9nc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LnRvX3RhZyArIHJlcXVlc3QuZnJvbV90YWddIHx8XG4gICAgICAgICAgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIG5leHQgc2VydmVyIHRvIHdoaWNoIGNvbm5lY3QuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH0gd3Nfc2VydmVyXG4gKi9cblVBLnByb3RvdHlwZS5nZXROZXh0V3NTZXJ2ZXIgPSBmdW5jdGlvbigpIHtcbiAgLy8gT3JkZXIgc2VydmVycyBieSB3ZWlnaHRcbiAgdmFyIGlkeCwgbGVuZ3RoLCB3c19zZXJ2ZXIsXG4gICAgY2FuZGlkYXRlcyA9IFtdO1xuXG4gIGxlbmd0aCA9IHRoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnMubGVuZ3RoO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICB3c19zZXJ2ZXIgPSB0aGlzLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzW2lkeF07XG5cbiAgICBpZiAod3Nfc2VydmVyLnN0YXR1cyA9PT0gU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19FUlJPUikge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FuZGlkYXRlcy5wdXNoKHdzX3NlcnZlcik7XG4gICAgfSBlbHNlIGlmICh3c19zZXJ2ZXIud2VpZ2h0ID4gY2FuZGlkYXRlc1swXS53ZWlnaHQpIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBbd3Nfc2VydmVyXTtcbiAgICB9IGVsc2UgaWYgKHdzX3NlcnZlci53ZWlnaHQgPT09IGNhbmRpZGF0ZXNbMF0ud2VpZ2h0KSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2god3Nfc2VydmVyKTtcbiAgICB9XG4gIH1cblxuICBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjYW5kaWRhdGVzLmxlbmd0aCk7XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXNbaWR4XTtcbn07XG5cbi8qKlxuICogQ2xvc2UgYWxsIHNlc3Npb25zIG9uIHRyYW5zcG9ydCBlcnJvci5cbiAqIEBwcml2YXRlXG4gKi9cblVBLnByb3RvdHlwZS5jbG9zZVNlc3Npb25zT25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWR4O1xuXG4gIC8vIFJ1biBfdHJhbnNwb3J0RXJyb3JfIGZvciBldmVyeSBTZXNzaW9uXG4gIGZvcihpZHggaW4gdGhpcy5zZXNzaW9ucykge1xuICAgIHRoaXMuc2Vzc2lvbnNbaWR4XS5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbiAgLy8gQ2FsbCByZWdpc3RlckNvbnRleHQgX29uVHJhbnNwb3J0Q2xvc2VkX1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vblRyYW5zcG9ydENsb3NlZCgpO1xufTtcblxuVUEucHJvdG90eXBlLnJlY292ZXJUcmFuc3BvcnQgPSBmdW5jdGlvbih1YSkge1xuICB2YXIgaWR4LCBsZW5ndGgsIGssIG5leHRSZXRyeSwgY291bnQsIHNlcnZlcjtcblxuICB1YSA9IHVhIHx8IHRoaXM7XG4gIGNvdW50ID0gdWEudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzO1xuXG4gIGxlbmd0aCA9IHVhLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzLmxlbmd0aDtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgdWEuY29uZmlndXJhdGlvbi53c1NlcnZlcnNbaWR4XS5zdGF0dXMgPSAwO1xuICB9XG5cbiAgc2VydmVyID0gdWEuZ2V0TmV4dFdzU2VydmVyKCk7XG5cbiAgayA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLGNvdW50KSkgKzEpO1xuICBuZXh0UmV0cnkgPSBrICogdWEuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDtcblxuICBpZiAobmV4dFJldHJ5ID4gdWEuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygndGltZSBmb3IgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQgZXhjZWVkcyBjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCwgcmVzZXR0aW5nIGNvdW50ZXInKTtcbiAgICBuZXh0UmV0cnkgPSB1YS5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsO1xuICAgIGNvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMubG9nZ2VyLmxvZygnbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQgaW4gJysgbmV4dFJldHJ5ICsnIHNlY29uZHMnKTtcblxuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJ5VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoXG4gICAgZnVuY3Rpb24oKXtcbiAgICAgIHVhLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cyA9IGNvdW50ICsgMTtcbiAgICAgIG5ldyBTSVAuVHJhbnNwb3J0KHVhLCBzZXJ2ZXIpO1xuICAgIH0sIG5leHRSZXRyeSAqIDEwMDApO1xufTtcblxuZnVuY3Rpb24gY2hlY2tBdXRoZW50aWNhdGlvbkZhY3RvcnkgKGF1dGhlbnRpY2F0aW9uRmFjdG9yeSkge1xuICBpZiAoIShhdXRoZW50aWNhdGlvbkZhY3RvcnkgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFhdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSkge1xuICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZSAoKSB7XG4gICAgICByZXR1cm4gU0lQLlV0aWxzLlByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGxvYWQuXG4gKiBAcHJpdmF0ZVxuICogcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuVUEucHJvdG90eXBlLmxvYWRDb25maWcgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG4gIC8vIFNldHRpbmdzIGFuZCBkZWZhdWx0IHZhbHVlc1xuICB2YXIgcGFyYW1ldGVyLCB2YWx1ZSwgY2hlY2tlZF92YWx1ZSwgaG9zdHBvcnRQYXJhbXMsIHJlZ2lzdHJhclNlcnZlcixcbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIC8qIEhvc3QgYWRkcmVzc1xuICAgICAgKiBWYWx1ZSB0byBiZSBzZXQgaW4gVmlhIHNlbnRfYnkgYW5kIGhvc3QgcGFydCBvZiBDb250YWN0IEZRRE5cbiAgICAgICovXG4gICAgICB2aWFIb3N0OiBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMTIpICsgJy5pbnZhbGlkJyxcblxuICAgICAgdXJpOiBuZXcgU0lQLlVSSSgnc2lwJywgJ2Fub255bW91cy4nICsgU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDYpLCAnYW5vbnltb3VzLmludmFsaWQnLCBudWxsLCBudWxsKSxcbiAgICAgIHdzU2VydmVyczogW3tcbiAgICAgICAgc2NoZW1lOiAnV1NTJyxcbiAgICAgICAgc2lwX3VyaTogJzxzaXA6ZWRnZS5zaXAub25zaXAuY29tO3RyYW5zcG9ydD13cztscj4nLFxuICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgd3NfdXJpOiAnd3NzOi8vZWRnZS5zaXAub25zaXAuY29tJ1xuICAgICAgfV0sXG5cbiAgICAgIC8vIFBhc3N3b3JkXG4gICAgICBwYXNzd29yZDogbnVsbCxcblxuICAgICAgLy8gUmVnaXN0cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgIHJlZ2lzdGVyRXhwaXJlczogNjAwLFxuICAgICAgcmVnaXN0ZXI6IHRydWUsXG4gICAgICByZWdpc3RyYXJTZXJ2ZXI6IG51bGwsXG5cbiAgICAgIC8vIFRyYW5zcG9ydCByZWxhdGVkIHBhcmFtZXRlcnNcbiAgICAgIHdzU2VydmVyTWF4UmVjb25uZWN0aW9uOiAzLFxuICAgICAgd3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0OiA0LFxuXG4gICAgICBjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDogMixcbiAgICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsOiAzMCxcblxuICAgICAga2VlcEFsaXZlSW50ZXJ2YWw6IDAsXG5cbiAgICAgIGV4dHJhU3VwcG9ydGVkOiBbXSxcblxuICAgICAgdXNlUHJlbG9hZGVkUm91dGU6IGZhbHNlLFxuXG4gICAgICAvL3N0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIFVzZXItQWdlbnQgcmVxdWVzdCBoZWFkZXJcbiAgICAgIHVzZXJBZ2VudFN0cmluZzogU0lQLkMuVVNFUl9BR0VOVCxcblxuICAgICAgLy8gU2Vzc2lvbiBwYXJhbWV0ZXJzXG4gICAgICBpY2VDaGVja2luZ1RpbWVvdXQ6IDUwMDAsXG4gICAgICBub0Fuc3dlclRpbWVvdXQ6IDYwLFxuICAgICAgc3R1blNlcnZlcnM6IFsnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMiddLFxuICAgICAgdHVyblNlcnZlcnM6IFtdLFxuXG4gICAgICAvLyBMb2dnaW5nIHBhcmFtZXRlcnNcbiAgICAgIHRyYWNlU2lwOiBmYWxzZSxcblxuICAgICAgLy8gSGFja3NcbiAgICAgIGhhY2tWaWFUY3A6IGZhbHNlLFxuICAgICAgaGFja0lwSW5Db250YWN0OiBmYWxzZSxcbiAgICAgIGhhY2tXc3NJblRyYW5zcG9ydDogZmFsc2UsXG4gICAgICBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzOiBmYWxzZSxcblxuICAgICAgY29udGFjdFRyYW5zcG9ydDogJ3dzJyxcbiAgICAgIGZvcmNlUnBvcnQ6IGZhbHNlLFxuXG4gICAgICAvL2F1dG9zdGFydGluZ1xuICAgICAgYXV0b3N0YXJ0OiB0cnVlLFxuXG4gICAgICAvL1JlbGlhYmxlIFByb3Zpc2lvbmFsIFJlc3BvbnNlc1xuICAgICAgcmVsMTAwOiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQsXG5cbiAgICAgIC8vIFJlcGxhY2VzIGhlYWRlciAoUkZDIDM4OTEpXG4gICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzODkxXG4gICAgICByZXBsYWNlczogU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVELFxuXG4gICAgICBtZWRpYUhhbmRsZXJGYWN0b3J5OiBTSVAuV2ViUlRDLk1lZGlhSGFuZGxlci5kZWZhdWx0RmFjdG9yeSxcblxuICAgICAgYXV0aGVudGljYXRpb25GYWN0b3J5OiBjaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeShmdW5jdGlvbiBhdXRoZW50aWNhdGlvbkZhY3RvcnkgKHVhKSB7XG4gICAgICAgIHJldHVybiBuZXcgU0lQLkRpZ2VzdEF1dGhlbnRpY2F0aW9uKHVhKTtcbiAgICAgIH0pXG4gICAgfTtcblxuICAvLyBQcmUtQ29uZmlndXJhdGlvblxuICBmdW5jdGlvbiBhbGlhc1VuZGVyc2NvcmVkIChwYXJhbWV0ZXIsIGxvZ2dlcikge1xuICAgIHZhciB1bmRlcnNjb3JlZCA9IHBhcmFtZXRlci5yZXBsYWNlKC8oW2Etel1bQS1aXSkvZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtWzBdICsgJ18nICsgbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBhcmFtZXRlciA9PT0gdW5kZXJzY29yZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFyYW1ldGVyID0gY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpO1xuICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHVuZGVyc2NvcmVkKSkge1xuICAgICAgbG9nZ2VyLndhcm4odW5kZXJzY29yZWQgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIHBhcmFtZXRlcik7XG4gICAgICBpZiAoaGFzUGFyYW1ldGVyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKHBhcmFtZXRlciArICcgb3ZlcnJpZGluZyAnICsgdW5kZXJzY29yZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXSA9IGhhc1BhcmFtZXRlciA/IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXSA6IGNvbmZpZ3VyYXRpb25bdW5kZXJzY29yZWRdO1xuICB9XG5cbiAgLy8gQ2hlY2sgTWFuZGF0b3J5IHBhcmFtZXRlcnNcbiAgZm9yKHBhcmFtZXRlciBpbiBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm1hbmRhdG9yeSkge1xuICAgIGFsaWFzVW5kZXJzY29yZWQocGFyYW1ldGVyLCB0aGlzLmxvZ2dlcik7XG4gICAgaWYoIWNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcbiAgICAgIGNoZWNrZWRfdmFsdWUgPSBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm1hbmRhdG9yeVtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgIGlmIChjaGVja2VkX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRfdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUoY29uZmlndXJhdGlvbiwgJ3JlbDEwMCcsICdyZWxpYWJsZScsIHRydWUsIHRoaXMubG9nZ2VyLCBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQpO1xuXG4gIHZhciBlbXB0eUFycmF5c0FsbG93ZWQgPSBbJ3N0dW5TZXJ2ZXJzJywgJ3R1cm5TZXJ2ZXJzJ107XG5cbiAgLy8gQ2hlY2sgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICBmb3IocGFyYW1ldGVyIGluIFVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWwpIHtcbiAgICBhbGlhc1VuZGVyc2NvcmVkKHBhcmFtZXRlciwgdGhpcy5sb2dnZXIpO1xuICAgIGlmKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG5cbiAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXksIGJ1dCBzaG91bGRuJ3QgYmUsIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwICYmIGVtcHR5QXJyYXlzQWxsb3dlZC5pbmRleE9mKHBhcmFtZXRlcikgPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbnVsbCwgZW1wdHkgc3RyaW5nLCBvciB1bmRlZmluZWQgdGhlbiBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHsgY29udGludWU7IH1cbiAgICAgIC8vIElmIGl0J3MgYSBudW1iZXIgd2l0aCBOYU4gdmFsdWUgdGhlbiBhbHNvIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgLy8gTk9URTogSlMgZG9lcyBub3QgYWxsb3cgXCJ2YWx1ZSA9PT0gTmFOXCIsIHRoZSBmb2xsb3dpbmcgZG9lcyB0aGUgd29yazpcbiAgICAgIGVsc2UgaWYodHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGNoZWNrZWRfdmFsdWUgPSBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsW3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgaWYgKGNoZWNrZWRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0aW5nc1twYXJhbWV0ZXJdID0gY2hlY2tlZF92YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXR5IENoZWNrc1xuXG4gIC8vIENvbm5lY3Rpb24gcmVjb3ZlcnkgaW50ZXJ2YWxzXG4gIGlmKHNldHRpbmdzLmNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsIDwgc2V0dGluZ3MuY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKCdjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCcsIHNldHRpbmdzLmNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKTtcbiAgfVxuXG4gIC8vIFBvc3QgQ29uZmlndXJhdGlvbiBQcm9jZXNzXG5cbiAgLy8gQWxsb3cgcGFzc2luZyAwIG51bWJlciBhcyBkaXNwbGF5TmFtZS5cbiAgaWYgKHNldHRpbmdzLmRpc3BsYXlOYW1lID09PSAwKSB7XG4gICAgc2V0dGluZ3MuZGlzcGxheU5hbWUgPSAnMCc7XG4gIH1cblxuICAvLyBJbnN0YW5jZS1pZCBmb3IgR1JVVVxuICBpZiAoIXNldHRpbmdzLmluc3RhbmNlSWQpIHtcbiAgICBzZXR0aW5ncy5pbnN0YW5jZUlkID0gU0lQLlV0aWxzLm5ld1VVSUQoKTtcbiAgfVxuXG4gIC8vIHNpcGpzSWQgaW5zdGFuY2UgcGFyYW1ldGVyLiBTdGF0aWMgcmFuZG9tIHRhZyBvZiBsZW5ndGggNVxuICBzZXR0aW5ncy5zaXBqc0lkID0gU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDUpO1xuXG4gIC8vIFN0cmluZyBjb250YWluaW5nIHNldHRpbmdzLnVyaSB3aXRob3V0IHNjaGVtZSBhbmQgdXNlci5cbiAgaG9zdHBvcnRQYXJhbXMgPSBzZXR0aW5ncy51cmkuY2xvbmUoKTtcbiAgaG9zdHBvcnRQYXJhbXMudXNlciA9IG51bGw7XG4gIHNldHRpbmdzLmhvc3Rwb3J0UGFyYW1zID0gaG9zdHBvcnRQYXJhbXMudG9SYXcoKS5yZXBsYWNlKC9ec2lwOi9pLCAnJyk7XG5cbiAgLyogQ2hlY2sgd2hldGhlciBhdXRob3JpemF0aW9uVXNlciBpcyBleHBsaWNpdGx5IGRlZmluZWQuXG4gICAqIFRha2UgJ3NldHRpbmdzLnVyaS51c2VyJyB2YWx1ZSBpZiBub3QuXG4gICAqL1xuICBpZiAoIXNldHRpbmdzLmF1dGhvcml6YXRpb25Vc2VyKSB7XG4gICAgc2V0dGluZ3MuYXV0aG9yaXphdGlvblVzZXIgPSBzZXR0aW5ncy51cmkudXNlcjtcbiAgfVxuXG4gIC8qIElmIG5vICdyZWdpc3RyYXJTZXJ2ZXInIGlzIHNldCB1c2UgdGhlICd1cmknIHZhbHVlIHdpdGhvdXQgdXNlciBwb3J0aW9uLiAqL1xuICBpZiAoIXNldHRpbmdzLnJlZ2lzdHJhclNlcnZlcikge1xuICAgIHJlZ2lzdHJhclNlcnZlciA9IHNldHRpbmdzLnVyaS5jbG9uZSgpO1xuICAgIHJlZ2lzdHJhclNlcnZlci51c2VyID0gbnVsbDtcbiAgICBzZXR0aW5ncy5yZWdpc3RyYXJTZXJ2ZXIgPSByZWdpc3RyYXJTZXJ2ZXI7XG4gIH1cblxuICAvLyBVc2VyIG5vQW5zd2VyVGltZW91dFxuICBzZXR0aW5ncy5ub0Fuc3dlclRpbWVvdXQgPSBzZXR0aW5ncy5ub0Fuc3dlclRpbWVvdXQgKiAxMDAwO1xuXG4gIC8vIFZpYSBIb3N0XG4gIGlmIChzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QpIHtcbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmhhY2tJcEluQ29udGFjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBzZXR0aW5ncy52aWFIb3N0ID0gU0lQLlV0aWxzLmdldFJhbmRvbVRlc3ROZXRJUCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGFja0lwSW5Db250YWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgc2V0dGluZ3MudmlhSG9zdCA9IHNldHRpbmdzLmhhY2tJcEluQ29udGFjdDtcbiAgICB9XG4gIH1cblxuICAvLyBDb250YWN0IHRyYW5zcG9ydCBwYXJhbWV0ZXJcbiAgaWYgKHNldHRpbmdzLmhhY2tXc3NJblRyYW5zcG9ydCkge1xuICAgIHNldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnQgPSAnd3NzJztcbiAgfVxuXG4gIHRoaXMuY29udGFjdCA9IHtcbiAgICBwdWJfZ3J1dTogbnVsbCxcbiAgICB0ZW1wX2dydXU6IG51bGwsXG4gICAgdXJpOiBuZXcgU0lQLlVSSSgnc2lwJywgU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDgpLCBzZXR0aW5ncy52aWFIb3N0LCBudWxsLCB7dHJhbnNwb3J0OiBzZXR0aW5ncy5jb250YWN0VHJhbnNwb3J0fSksXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhclxuICAgICAgICBhbm9ueW1vdXMgPSBvcHRpb25zLmFub255bW91cyB8fCBudWxsLFxuICAgICAgICBvdXRib3VuZCA9IG9wdGlvbnMub3V0Ym91bmQgfHwgbnVsbCxcbiAgICAgICAgY29udGFjdCA9ICc8JztcblxuICAgICAgaWYgKGFub255bW91cykge1xuICAgICAgICBjb250YWN0ICs9ICh0aGlzLnRlbXBfZ3J1dSB8fCAoJ3NpcDphbm9ueW1vdXNAYW5vbnltb3VzLmludmFsaWQ7dHJhbnNwb3J0PScrc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCkpLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWN0ICs9ICh0aGlzLnB1Yl9ncnV1IHx8IHRoaXMudXJpKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0Ym91bmQpIHtcbiAgICAgICAgY29udGFjdCArPSAnO29iJztcbiAgICAgIH1cblxuICAgICAgY29udGFjdCArPSAnPic7XG5cbiAgICAgIHJldHVybiBjb250YWN0O1xuICAgIH1cbiAgfTtcblxuICAvLyBtZWRpYSBvdmVycmlkZXMgbWVkaWFDb25zdHJhaW50c1xuICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKHNldHRpbmdzLCAnbWVkaWEnLCAnbWVkaWFDb25zdHJhaW50cycsIHRydWUsIHRoaXMubG9nZ2VyKTtcblxuICAvLyBGaWxsIHRoZSB2YWx1ZSBvZiB0aGUgY29uZmlndXJhdGlvbl9za2VsZXRvblxuICBmb3IocGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbltwYXJhbWV0ZXJdLnZhbHVlID0gc2V0dGluZ3NbcGFyYW1ldGVyXTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuY29uZmlndXJhdGlvbiwgVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbik7XG5cbiAgLy8gQ2xlYW4gVUEuY29uZmlndXJhdGlvbl9za2VsZXRvblxuICBmb3IocGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbltwYXJhbWV0ZXJdLnZhbHVlID0gJyc7XG4gIH1cblxuICB0aGlzLmxvZ2dlci5sb2coJ2NvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBhZnRlciB2YWxpZGF0aW9uOicpO1xuICBmb3IocGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgc3dpdGNoKHBhcmFtZXRlcikge1xuICAgICAgY2FzZSAndXJpJzpcbiAgICAgIGNhc2UgJ3JlZ2lzdHJhclNlcnZlcic6XG4gICAgICBjYXNlICdtZWRpYUhhbmRsZXJGYWN0b3J5JzpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCfCtyAnICsgcGFyYW1ldGVyICsgJzogJyArIHNldHRpbmdzW3BhcmFtZXRlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCfCtyAnICsgcGFyYW1ldGVyICsgJzogJyArICdOT1QgU0hPV04nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ8K3ICcgKyBwYXJhbWV0ZXIgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3NbcGFyYW1ldGVyXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBPYmplY3Qgc2tlbGV0b24uXG4gKiBAcHJpdmF0ZVxuICovXG5VQS5jb25maWd1cmF0aW9uX3NrZWxldG9uID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaWR4LCAgcGFyYW1ldGVyLFxuICAgIHNrZWxldG9uID0ge30sXG4gICAgcGFyYW1ldGVycyA9IFtcbiAgICAgIC8vIEludGVybmFsIHBhcmFtZXRlcnNcbiAgICAgIFwic2lwanNJZFwiLFxuICAgICAgXCJob3N0cG9ydFBhcmFtc1wiLFxuXG4gICAgICAvLyBPcHRpb25hbCB1c2VyIGNvbmZpZ3VyYWJsZSBwYXJhbWV0ZXJzXG4gICAgICBcInVyaVwiLFxuICAgICAgXCJ3c1NlcnZlcnNcIixcbiAgICAgIFwiYXV0aG9yaXphdGlvblVzZXJcIixcbiAgICAgIFwiY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWxcIixcbiAgICAgIFwiY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWxcIixcbiAgICAgIFwia2VlcEFsaXZlSW50ZXJ2YWxcIixcbiAgICAgIFwiZXh0cmFTdXBwb3J0ZWRcIixcbiAgICAgIFwiZGlzcGxheU5hbWVcIixcbiAgICAgIFwiaGFja1ZpYVRjcFwiLCAvLyBmYWxzZS5cbiAgICAgIFwiaGFja0lwSW5Db250YWN0XCIsIC8vZmFsc2VcbiAgICAgIFwiaGFja1dzc0luVHJhbnNwb3J0XCIsIC8vZmFsc2VcbiAgICAgIFwiaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnc1wiLCAvL2ZhbHNlXG4gICAgICBcImNvbnRhY3RUcmFuc3BvcnRcIiwgLy8gJ3dzJ1xuICAgICAgXCJmb3JjZVJwb3J0XCIsIC8vIGZhbHNlXG4gICAgICBcImljZUNoZWNraW5nVGltZW91dFwiLFxuICAgICAgXCJpbnN0YW5jZUlkXCIsXG4gICAgICBcIm5vQW5zd2VyVGltZW91dFwiLCAvLyAzMCBzZWNvbmRzLlxuICAgICAgXCJwYXNzd29yZFwiLFxuICAgICAgXCJyZWdpc3RlckV4cGlyZXNcIiwgLy8gNjAwIHNlY29uZHMuXG4gICAgICBcInJlZ2lzdHJhclNlcnZlclwiLFxuICAgICAgXCJyZWxpYWJsZVwiLFxuICAgICAgXCJyZWwxMDBcIixcbiAgICAgIFwicmVwbGFjZXNcIixcbiAgICAgIFwidXNlckFnZW50U3RyaW5nXCIsIC8vU0lQLkMuVVNFUl9BR0VOVFxuICAgICAgXCJhdXRvc3RhcnRcIixcbiAgICAgIFwic3R1blNlcnZlcnNcIixcbiAgICAgIFwidHJhY2VTaXBcIixcbiAgICAgIFwidHVyblNlcnZlcnNcIixcbiAgICAgIFwidXNlUHJlbG9hZGVkUm91dGVcIixcbiAgICAgIFwid3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb25cIixcbiAgICAgIFwid3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0XCIsXG4gICAgICBcIm1lZGlhSGFuZGxlckZhY3RvcnlcIixcbiAgICAgIFwibWVkaWFcIixcbiAgICAgIFwibWVkaWFDb25zdHJhaW50c1wiLFxuICAgICAgXCJhdXRoZW50aWNhdGlvbkZhY3RvcnlcIixcblxuICAgICAgLy8gUG9zdC1jb25maWd1cmF0aW9uIGdlbmVyYXRlZCBwYXJhbWV0ZXJzXG4gICAgICBcInZpYV9jb3JlX3ZhbHVlXCIsXG4gICAgICBcInZpYUhvc3RcIlxuICAgIF07XG5cbiAgZm9yKGlkeCBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpZHhdO1xuICAgIHNrZWxldG9uW3BhcmFtZXRlcl0gPSB7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHNrZWxldG9uWydyZWdpc3RlciddID0ge1xuICAgIHZhbHVlOiAnJyxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH07XG5cbiAgcmV0dXJuIHNrZWxldG9uO1xufSgpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGNoZWNrZXIuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuVUEuY29uZmlndXJhdGlvbl9jaGVjayA9IHtcbiAgbWFuZGF0b3J5OiB7XG4gIH0sXG5cbiAgb3B0aW9uYWw6IHtcblxuICAgIHVyaTogZnVuY3Rpb24odXJpKSB7XG4gICAgICB2YXIgcGFyc2VkO1xuXG4gICAgICBpZiAoISgvXnNpcDovaSkudGVzdCh1cmkpKSB7XG4gICAgICAgIHVyaSA9IFNJUC5DLlNJUCArICc6JyArIHVyaTtcbiAgICAgIH1cbiAgICAgIHBhcnNlZCA9IFNJUC5VUkkucGFyc2UodXJpKTtcblxuICAgICAgaWYoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYoIXBhcnNlZC51c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vTm90ZTogdGhpcyBmdW5jdGlvbiB1c2VkIHRvIGNhbGwgJ3RoaXMubG9nZ2VyLmVycm9yJyBidXQgY2FsbGluZyAndGhpcycgd2l0aCBhbnl0aGluZyBoZXJlIGlzIGludmFsaWRcbiAgICB3c1NlcnZlcnM6IGZ1bmN0aW9uKHdzU2VydmVycykge1xuICAgICAgdmFyIGlkeCwgbGVuZ3RoLCB1cmw7XG5cbiAgICAgIC8qIEFsbG93IGRlZmluaW5nIHdzU2VydmVycyBwYXJhbWV0ZXIgYXM6XG4gICAgICAgKiAgU3RyaW5nOiBcImhvc3RcIlxuICAgICAgICogIEFycmF5IG9mIFN0cmluZ3M6IFtcImhvc3QxXCIsIFwiaG9zdDJcIl1cbiAgICAgICAqICBBcnJheSBvZiBPYmplY3RzOiBbe3dzX3VyaTpcImhvc3QxXCIsIHdlaWdodDoxfSwge3dzX3VyaTpcImhvc3QyXCIsIHdlaWdodDowfV1cbiAgICAgICAqICBBcnJheSBvZiBPYmplY3RzIGFuZCBTdHJpbmdzOiBbe3dzX3VyaTpcImhvc3QxXCJ9LCBcImhvc3QyXCJdXG4gICAgICAgKi9cbiAgICAgIGlmICh0eXBlb2Ygd3NTZXJ2ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB3c1NlcnZlcnMgPSBbe3dzX3VyaTogd3NTZXJ2ZXJzfV07XG4gICAgICB9IGVsc2UgaWYgKHdzU2VydmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGxlbmd0aCA9IHdzU2VydmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd3NTZXJ2ZXJzW2lkeF0gPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHdzU2VydmVyc1tpZHhdID0ge3dzX3VyaTogd3NTZXJ2ZXJzW2lkeF19O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAod3NTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHdzU2VydmVycy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKCF3c1NlcnZlcnNbaWR4XS53c191cmkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdzU2VydmVyc1tpZHhdLndlaWdodCAmJiAhTnVtYmVyKHdzU2VydmVyc1tpZHhdLndlaWdodCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cmwgPSBTSVAuR3JhbW1hci5wYXJzZSh3c1NlcnZlcnNbaWR4XS53c191cmksICdhYnNvbHV0ZVVSSScpO1xuXG4gICAgICAgIGlmKHVybCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZihbJ3dzcycsICd3cycsICd1ZHAnXS5pbmRleE9mKHVybC5zY2hlbWUpIDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3c1NlcnZlcnNbaWR4XS5zaXBfdXJpID0gJzxzaXA6JyArIHVybC5ob3N0ICsgKHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJykgKyAnO3RyYW5zcG9ydD0nICsgdXJsLnNjaGVtZS5yZXBsYWNlKC9ed3NzJC9pLCAnd3MnKSArICc7bHI+JztcblxuICAgICAgICAgIGlmICghd3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0KSB7XG4gICAgICAgICAgICB3c1NlcnZlcnNbaWR4XS53ZWlnaHQgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdzU2VydmVyc1tpZHhdLnN0YXR1cyA9IDA7XG4gICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0uc2NoZW1lID0gdXJsLnNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd3NTZXJ2ZXJzO1xuICAgIH0sXG5cbiAgICBhdXRob3JpemF0aW9uVXNlcjogZnVuY3Rpb24oYXV0aG9yaXphdGlvblVzZXIpIHtcbiAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKCdcIicrIGF1dGhvcml6YXRpb25Vc2VyICsnXCInLCAncXVvdGVkX3N0cmluZycpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXV0aG9yaXphdGlvblVzZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsOiBmdW5jdGlvbihjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYoU0lQLlV0aWxzLmlzRGVjaW1hbChjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIoY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpO1xuICAgICAgICBpZih2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWw6IGZ1bmN0aW9uKGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZihTSVAuVXRpbHMuaXNEZWNpbWFsKGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbCk7XG4gICAgICAgIGlmKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24oZGlzcGxheU5hbWUpIHtcbiAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKCdcIicgKyBkaXNwbGF5TmFtZSArICdcIicsICdkaXNwbGF5TmFtZScpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tWaWFUY3A6IGZ1bmN0aW9uKGhhY2tWaWFUY3ApIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja1ZpYVRjcCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrVmlhVGNwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYWNrSXBJbkNvbnRhY3Q6IGZ1bmN0aW9uKGhhY2tJcEluQ29udGFjdCkge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrSXBJbkNvbnRhY3QgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gaGFja0lwSW5Db250YWN0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGhhY2tJcEluQ29udGFjdCA9PT0gJ3N0cmluZycgJiYgU0lQLkdyYW1tYXIucGFyc2UoaGFja0lwSW5Db250YWN0LCAnaG9zdCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gaGFja0lwSW5Db250YWN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpY2VDaGVja2luZ1RpbWVvdXQ6IGZ1bmN0aW9uKGljZUNoZWNraW5nVGltZW91dCkge1xuICAgICAgaWYoU0lQLlV0aWxzLmlzRGVjaW1hbChpY2VDaGVja2luZ1RpbWVvdXQpKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCg1MDAsIGljZUNoZWNraW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tXc3NJblRyYW5zcG9ydDogZnVuY3Rpb24oaGFja1dzc0luVHJhbnNwb3J0KSB7XG4gICAgICBpZiAodHlwZW9mIGhhY2tXc3NJblRyYW5zcG9ydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrV3NzSW5UcmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M6IGZ1bmN0aW9uKGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWN0VHJhbnNwb3J0OiBmdW5jdGlvbihjb250YWN0VHJhbnNwb3J0KSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnRhY3RUcmFuc3BvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjb250YWN0VHJhbnNwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmb3JjZVJwb3J0OiBmdW5jdGlvbihmb3JjZVJwb3J0KSB7XG4gICAgICBpZiAodHlwZW9mIGZvcmNlUnBvcnQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZm9yY2VScG9ydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5zdGFuY2VJZDogZnVuY3Rpb24oaW5zdGFuY2VJZCkge1xuICAgICAgaWYodHlwZW9mIGluc3RhbmNlSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCgvXnV1aWQ6L2kudGVzdChpbnN0YW5jZUlkKSkpIHtcbiAgICAgICAgaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQuc3Vic3RyKDUpO1xuICAgICAgfVxuXG4gICAgICBpZihTSVAuR3JhbW1hci5wYXJzZShpbnN0YW5jZUlkLCAndXVpZCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VJZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAga2VlcEFsaXZlSW50ZXJ2YWw6IGZ1bmN0aW9uKGtlZXBBbGl2ZUludGVydmFsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbChrZWVwQWxpdmVJbnRlcnZhbCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIoa2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4dHJhU3VwcG9ydGVkOiBmdW5jdGlvbihvcHRpb25UYWdzKSB7XG4gICAgICB2YXIgaWR4LCBsZW5ndGg7XG5cbiAgICAgIGlmICghKG9wdGlvblRhZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBvcHRpb25UYWdzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvblRhZ3NbaWR4XSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvblRhZ3M7XG4gICAgfSxcblxuICAgIG5vQW5zd2VyVGltZW91dDogZnVuY3Rpb24obm9BbnN3ZXJUaW1lb3V0KSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbChub0Fuc3dlclRpbWVvdXQpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKG5vQW5zd2VyVGltZW91dCk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFzc3dvcmQ6IGZ1bmN0aW9uKHBhc3N3b3JkKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHBhc3N3b3JkKTtcbiAgICB9LFxuXG4gICAgcmVsMTAwOiBmdW5jdGlvbihyZWwxMDApIHtcbiAgICAgIGlmKHJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQ7XG4gICAgICB9IGVsc2UgaWYgKHJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRDtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBsYWNlczogZnVuY3Rpb24ocmVwbGFjZXMpIHtcbiAgICAgIGlmKHJlcGxhY2VzID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRDtcbiAgICAgIH0gZWxzZSBpZiAocmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQ7XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHJlZ2lzdGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZWdpc3RlckV4cGlyZXM6IGZ1bmN0aW9uKHJlZ2lzdGVyRXhwaXJlcykge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwocmVnaXN0ZXJFeHBpcmVzKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihyZWdpc3RlckV4cGlyZXMpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlZ2lzdHJhclNlcnZlcjogZnVuY3Rpb24ocmVnaXN0cmFyU2VydmVyKSB7XG4gICAgICB2YXIgcGFyc2VkO1xuXG4gICAgICBpZih0eXBlb2YgcmVnaXN0cmFyU2VydmVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghL15zaXA6L2kudGVzdChyZWdpc3RyYXJTZXJ2ZXIpKSB7XG4gICAgICAgIHJlZ2lzdHJhclNlcnZlciA9IFNJUC5DLlNJUCArICc6JyArIHJlZ2lzdHJhclNlcnZlcjtcbiAgICAgIH1cbiAgICAgIHBhcnNlZCA9IFNJUC5VUkkucGFyc2UocmVnaXN0cmFyU2VydmVyKTtcblxuICAgICAgaWYoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYocGFyc2VkLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3R1blNlcnZlcnM6IGZ1bmN0aW9uKHN0dW5TZXJ2ZXJzKSB7XG4gICAgICB2YXIgaWR4LCBsZW5ndGgsIHN0dW5fc2VydmVyO1xuXG4gICAgICBpZiAodHlwZW9mIHN0dW5TZXJ2ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICBzdHVuU2VydmVycyA9IFtzdHVuU2VydmVyc107XG4gICAgICB9IGVsc2UgaWYgKCEoc3R1blNlcnZlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBzdHVuU2VydmVycy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgc3R1bl9zZXJ2ZXIgPSBzdHVuU2VydmVyc1tpZHhdO1xuICAgICAgICBpZiAoISgvXnN0dW5zPzovLnRlc3Qoc3R1bl9zZXJ2ZXIpKSkge1xuICAgICAgICAgIHN0dW5fc2VydmVyID0gJ3N0dW46JyArIHN0dW5fc2VydmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2Uoc3R1bl9zZXJ2ZXIsICdzdHVuX1VSSScpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHVuU2VydmVyc1tpZHhdID0gc3R1bl9zZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHVuU2VydmVycztcbiAgICB9LFxuXG4gICAgdHJhY2VTaXA6IGZ1bmN0aW9uKHRyYWNlU2lwKSB7XG4gICAgICBpZiAodHlwZW9mIHRyYWNlU2lwID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlU2lwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0dXJuU2VydmVyczogZnVuY3Rpb24odHVyblNlcnZlcnMpIHtcbiAgICAgIHZhciBpZHgsIGpkeCwgbGVuZ3RoLCB0dXJuX3NlcnZlciwgbnVtX3R1cm5fc2VydmVyX3VybHMsIHVybDtcblxuICAgICAgaWYgKHR1cm5TZXJ2ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHVyblNlcnZlcnMgPSBbdHVyblNlcnZlcnNdO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSB0dXJuU2VydmVycy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdHVybl9zZXJ2ZXIgPSB0dXJuU2VydmVyc1tpZHhdO1xuICAgICAgICAvL0JhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBBbGxvdyBkZWZpbmluZyB0aGUgdHVybl9zZXJ2ZXIgdXJsIHdpdGggdGhlICdzZXJ2ZXInIHByb3BlcnR5LlxuICAgICAgICBpZiAodHVybl9zZXJ2ZXIuc2VydmVyKSB7XG4gICAgICAgICAgdHVybl9zZXJ2ZXIudXJscyA9IFt0dXJuX3NlcnZlci5zZXJ2ZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dXJuX3NlcnZlci51cmxzIHx8ICF0dXJuX3NlcnZlci51c2VybmFtZSB8fCAhdHVybl9zZXJ2ZXIucGFzc3dvcmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHVybl9zZXJ2ZXIudXJscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgbnVtX3R1cm5fc2VydmVyX3VybHMgPSB0dXJuX3NlcnZlci51cmxzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0dXJuX3NlcnZlci51cmxzID0gW3R1cm5fc2VydmVyLnVybHNdO1xuICAgICAgICAgIG51bV90dXJuX3NlcnZlcl91cmxzID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoamR4ID0gMDsgamR4IDwgbnVtX3R1cm5fc2VydmVyX3VybHM7IGpkeCsrKSB7XG4gICAgICAgICAgdXJsID0gdHVybl9zZXJ2ZXIudXJsc1tqZHhdO1xuXG4gICAgICAgICAgaWYgKCEoL150dXJucz86Ly50ZXN0KHVybCkpKSB7XG4gICAgICAgICAgICB1cmwgPSAndHVybjonICsgdXJsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKHVybCwgJ3R1cm5fVVJJJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHVyblNlcnZlcnM7XG4gICAgfSxcblxuICAgIHVzZXJBZ2VudFN0cmluZzogZnVuY3Rpb24odXNlckFnZW50U3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHVzZXJBZ2VudFN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJBZ2VudFN0cmluZztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXNlUHJlbG9hZGVkUm91dGU6IGZ1bmN0aW9uKHVzZVByZWxvYWRlZFJvdXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHVzZVByZWxvYWRlZFJvdXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHVzZVByZWxvYWRlZFJvdXRlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB3c1NlcnZlck1heFJlY29ubmVjdGlvbjogZnVuY3Rpb24od3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb24pIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKHdzU2VydmVyTWF4UmVjb25uZWN0aW9uKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcih3c1NlcnZlck1heFJlY29ubmVjdGlvbik7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgd3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0OiBmdW5jdGlvbih3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIod3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdXRvc3RhcnQ6IGZ1bmN0aW9uKGF1dG9zdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBhdXRvc3RhcnQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gYXV0b3N0YXJ0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtZWRpYUhhbmRsZXJGYWN0b3J5OiBmdW5jdGlvbihtZWRpYUhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICBpZiAobWVkaWFIYW5kbGVyRmFjdG9yeSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBwcm9taXNpZmllZEZhY3RvcnkgPSBmdW5jdGlvbiBwcm9taXNpZmllZEZhY3RvcnkgKCkge1xuICAgICAgICAgIHZhciBtZWRpYUhhbmRsZXIgPSBtZWRpYUhhbmRsZXJGYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXRjaE1ldGhvZCAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG1lZGlhSGFuZGxlclttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmIChtZXRob2QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzRmlyc3QgPSBtZXRob2ROYW1lID09PSAnZ2V0RGVzY3JpcHRpb24nO1xuICAgICAgICAgICAgICBtZWRpYUhhbmRsZXJbbWV0aG9kTmFtZV0gPSBTSVAuVXRpbHMucHJvbWlzaWZ5KG1lZGlhSGFuZGxlciwgbWV0aG9kTmFtZSwgY2FsbGJhY2tzRmlyc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGNoTWV0aG9kKCdnZXREZXNjcmlwdGlvbicpO1xuICAgICAgICAgIHBhdGNoTWV0aG9kKCdzZXREZXNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgcmV0dXJuIG1lZGlhSGFuZGxlcjtcbiAgICAgICAgfTtcblxuICAgICAgICBwcm9taXNpZmllZEZhY3RvcnkuaXNTdXBwb3J0ZWQgPSBtZWRpYUhhbmRsZXJGYWN0b3J5LmlzU3VwcG9ydGVkO1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZpZWRGYWN0b3J5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdXRoZW50aWNhdGlvbkZhY3Rvcnk6IGNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5XG4gIH1cbn07XG5cblVBLkMgPSBDO1xuU0lQLlVBID0gVUE7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9VQS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFja3MgLSBUaGlzIGZpbGUgY29udGFpbnMgYWxsIG9mIHRoZSB0aGluZ3Mgd2VcbiAqIHdpc2ggd2UgZGlkbid0IGhhdmUgdG8gZG8sIGp1c3QgZm9yIGludGVyb3AuICBJdCBpcyBzaW1pbGFyIHRvXG4gKiBVdGlscywgd2hpY2ggcHJvdmlkZXMgYWN0dWFsbHkgdXNlZnVsIGFuZCByZWxldmFudCBmdW5jdGlvbnMgZm9yXG4gKiBhIFNJUCBsaWJyYXJ5LiBNZXRob2RzIGluIHRoaXMgZmlsZSBhcmUgZ3JvdXBlZCBieSB2ZW5kb3IsIHNvXG4gKiBhcyB0byBtb3N0IGVhc2lseSB0cmFjayB3aGVuIHBhcnRpY3VsYXIgaGFja3MgbWF5IG5vdCBiZSBuZWNlc3NhcnkgYW55bW9yZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxuLy9rZWVwIHRvIHF1aWV0IGpzaGludCwgYW5kIHJlbWFpbiBjb25zaXN0ZW50IHdpdGggb3RoZXIgZmlsZXNcblNJUCA9IFNJUDtcblxudmFyIEhhY2tzID0ge1xuICBBbGxCcm93c2Vyczoge1xuICAgIG1hc2tEdGxzOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgICBtZXNzYWdlLmJvZHkgPSBtZXNzYWdlLmJvZHkucmVwbGFjZSgvIFVEUFxcL1RMU1xcL1JUUFxcL1NBVlAvZ21pLCBcIiBSVFAvU0FWUFwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVubWFza0R0bHM6IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIC8qKlxuICAgICAgICogQ2hyb21lIGRvZXMgbm90IGhhbmRsZSBEVExTIGNvcnJlY3RseSAoQ2FuYXJheSBkb2VzLCBidXQgbm90IHByb2R1Y3Rpb24pXG4gICAgICAgKiBrZWVwaW5nIENocm9tZSBhcyBTREVTIHVudGlsIERUTFMgaXMgZml4ZWQgKGNvbW1lbnQgb3V0ICdpc19vcGVyYScgY29uZGl0aW9uKVxuICAgICAgICpcbiAgICAgICAqIFVQREFURTogTWF5IDIxLCAyMDE0XG4gICAgICAgKiBDaHJvbWUgMzUgbm93IHByb3Blcmx5IGRlZmF1bHRzIHRvIERUTFMuICBPbmx5IE9wZXJhIHJlbWFpbnMgdXNpbmcgU0RFU1xuICAgICAgICpcbiAgICAgICAqIFVQREFURTogMjAxNC0wOS0yNFxuICAgICAgICogT3BlcmEgbm93IHN1cHBvcnRzIERUTFMgYnkgZGVmYXVsdCBhcyB3ZWxsLlxuICAgICAgICpcbiAgICAgICAqKi9cbiAgICAgIHJldHVybiBzZHAucmVwbGFjZSgvIFJUUFxcL1NBVlAvZ21pLCBcIiBVRFAvVExTL1JUUC9TQVZQXCIpO1xuICAgIH1cbiAgfSxcbiAgRmlyZWZveDoge1xuICAgIC8qIENvbmRpdGlvbiB0byBkZXRlY3QgaWYgaGFja3MgYXJlIGFwcGxpY2FibGUgKi9cbiAgICBpc0ZpcmVmb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbW96UlRDUGVlckNvbm5lY3Rpb24gIT09ICd1bmRlZmluZWQnO1xuICAgIH0sXG5cbiAgICBjYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2U6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAodGhpcy5pc0ZpcmVmb3goKSAmJiBtZXNzYWdlLmJvZHkpIHtcbiAgICAgICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5LnJlcGxhY2UoLyBcXHJcXG4vZywgXCJcXHJcXG5cIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc01pc3NpbmdDTGluZUluU0RQOiBmdW5jdGlvbiAoc2RwKSB7XG4gICAgICAvKlxuICAgICAgICogVGhpcyBpcyBhIEZpcmVmb3ggaGFjayB0byBpbnNlcnQgdmFsaWQgc2RwIHdoZW4gZ2V0RGVzY3JpcHRpb24gaXNcbiAgICAgICAqIGNhbGxlZCB3aXRoIHRoZSBjb25zdHJhaW50IG9mZmVyVG9SZWNlaXZlVmlkZW8gPSBmYWxzZS5cbiAgICAgICAqIFdlIHNlYXJjaCBmb3IgZWl0aGVyIGEgYy1saW5lIGF0IHRoZSB0b3Agb2YgdGhlIHNkcCBhYm92ZSBhbGxcbiAgICAgICAqIG0tbGluZXMuIElmIHRoYXQgZG9lcyBub3QgZXhpc3QgdGhlbiB3ZSBzZWFyY2ggZm9yIGEgYy1saW5lXG4gICAgICAgKiBiZW5lYXRoIGVhY2ggbS1saW5lLiBJZiBpdCBpcyBtaXNzaW5nIGEgYy1saW5lLCB3ZSBpbnNlcnRcbiAgICAgICAqIGEgZmFrZSBjLWxpbmUgd2l0aCB0aGUgaXAgYWRkcmVzcyAwLjAuMC4wLiBUaGlzIGlzIHRoZW4gdmFsaWRcbiAgICAgICAqIHNkcCBhbmQgbm8gbWVkaWEgd2lsbCBiZSBzZW50IGZvciB0aGF0IG0tbGluZS5cbiAgICAgICAqXG4gICAgICAgKiBWYWxpZCBTRFAgaXM6XG4gICAgICAgKiBtPVxuICAgICAgICogaT1cbiAgICAgICAqIGM9XG4gICAgICAgKi9cbiAgICAgIHZhciBpbnNlcnRBdCwgbWxpbmVzO1xuICAgICAgaWYgKHNkcC5pbmRleE9mKCdjPScpID4gc2RwLmluZGV4T2YoJ209JykpIHtcblxuICAgICAgICAvLyBGaW5kIGFsbCBtPSBsaW5lc1xuICAgICAgICBtbGluZXMgPSBzZHAubWF0Y2goL209LipcXHJcXG4uKi9nKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG1saW5lcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgLy8gSWYgaXQgaGFzIGFuIGk9IGxpbmUsIGNoZWNrIGlmIHRoZSBuZXh0IGxpbmUgaXMgdGhlIGM9IGxpbmVcbiAgICAgICAgICBpZiAobWxpbmVzW2ldLnRvU3RyaW5nKCkuc2VhcmNoKC9pPS4qLykgPj0gMCkge1xuICAgICAgICAgICAgaW5zZXJ0QXQgPSBzZHAuaW5kZXhPZihtbGluZXNbaV0udG9TdHJpbmcoKSkrbWxpbmVzW2ldLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNkcC5zdWJzdHIoaW5zZXJ0QXQsMikhPT0nYz0nKSB7XG4gICAgICAgICAgICAgIHNkcCA9IHNkcC5zdWJzdHIoMCxpbnNlcnRBdCkgKyAnXFxyXFxuYz1JTiBJUDQgMC4wLjAuMCcgKyBzZHAuc3Vic3RyKGluc2VydEF0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGVsc2UgYWRkIHRoZSBDIGxpbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgICAgfSBlbHNlIGlmIChtbGluZXNbaV0udG9TdHJpbmcoKS5zZWFyY2goL2M9LiovKSA8IDApIHtcbiAgICAgICAgICAgIGluc2VydEF0ID0gc2RwLmluZGV4T2YobWxpbmVzW2ldLnRvU3RyaW5nKCkubWF0Y2goLy4qLykpK21saW5lc1tpXS50b1N0cmluZygpLm1hdGNoKC8uKi8pLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgc2RwID0gc2RwLnN1YnN0cigwLGluc2VydEF0KSArICdcXHJcXG5jPUlOIElQNCAwLjAuMC4wJyArIHNkcC5zdWJzdHIoaW5zZXJ0QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9LFxuICB9LFxuXG4gIENocm9tZToge1xuICAgIG5lZWRzRXhwbGljaXRseUluYWN0aXZlU0RQOiBmdW5jdGlvbiAoc2RwKSB7XG4gICAgICB2YXIgc3ViLCBpbmRleDtcblxuICAgICAgaWYgKEhhY2tzLkZpcmVmb3guaXNGaXJlZm94KCkpIHsgLy8gRml4IHRoaXMgaW4gRmlyZWZveCBiZWZvcmUgc2VuZGluZ1xuICAgICAgICBpbmRleCA9IHNkcC5pbmRleE9mKCdtPXZpZGVvIDAnKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHN1YiA9IHNkcC5zdWJzdHIoaW5kZXgpO1xuICAgICAgICAgIHN1YiA9IHN1Yi5yZXBsYWNlKC9cXHJcXG5jPUlOIElQNC4qXFxyXFxuJC8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcclxcbmM9SU4gSVA0IDAuMC4wLjBcXHJcXG5hPWluYWN0aXZlXFxyXFxuJyk7XG4gICAgICAgICAgcmV0dXJuIHNkcC5zdWJzdHIoMCwgaW5kZXgpICsgc3ViO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH0sXG5cbiAgICBnZXRzQ29uZnVzZWRBYm91dEdVTTogZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgIGlmIChzZXNzaW9uLm1lZGlhSGFuZGxlcikge1xuICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnJldHVybiBIYWNrcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9IYWNrcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW5jb21pbmcgU0lQIE1lc3NhZ2UgU2FuaXR5IENoZWNrXG4gKi9cblxuLyoqXG4gKiBTSVAgbWVzc2FnZSBzYW5pdHkgY2hlY2suXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U0lQLkluY29taW5nTWVzc2FnZX0gbWVzc2FnZVxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIHNhbml0eUNoZWNrLFxuIGxvZ2dlcixcbiBtZXNzYWdlLCB1YSwgdHJhbnNwb3J0LFxuIHJlcXVlc3RzID0gW10sXG4gcmVzcG9uc2VzID0gW10sXG4gYWxsID0gW107XG5cbi8vIFJlcGx5XG5mdW5jdGlvbiByZXBseShzdGF0dXNfY29kZSkge1xuICB2YXIgdG8sXG4gICAgcmVzcG9uc2UgPSBTSVAuVXRpbHMuYnVpbGRTdGF0dXNMaW5lKHN0YXR1c19jb2RlKSxcbiAgICB2aWFzID0gbWVzc2FnZS5nZXRIZWFkZXJzKCd2aWEnKSxcbiAgICBsZW5ndGggPSB2aWFzLmxlbmd0aCxcbiAgICBpZHggPSAwO1xuXG4gIGZvcihpZHg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICByZXNwb25zZSArPSBcIlZpYTogXCIgKyB2aWFzW2lkeF0gKyBcIlxcclxcblwiO1xuICB9XG5cbiAgdG8gPSBtZXNzYWdlLmdldEhlYWRlcignVG8nKTtcblxuICBpZighbWVzc2FnZS50b190YWcpIHtcbiAgICB0byArPSAnO3RhZz0nICsgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gXCJUbzogXCIgKyB0byArIFwiXFxyXFxuXCI7XG4gIHJlc3BvbnNlICs9IFwiRnJvbTogXCIgKyBtZXNzYWdlLmdldEhlYWRlcignRnJvbScpICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJDYWxsLUlEOiBcIiArIG1lc3NhZ2UuY2FsbF9pZCArIFwiXFxyXFxuXCI7XG4gIHJlc3BvbnNlICs9IFwiQ1NlcTogXCIgKyBtZXNzYWdlLmNzZXEgKyBcIiBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJcXHJcXG5cIjtcblxuICB0cmFuc3BvcnQuc2VuZChyZXNwb25zZSk7XG59XG5cbi8qXG4gKiBTYW5pdHkgQ2hlY2sgZm9yIGluY29taW5nIE1lc3NhZ2VzXG4gKlxuICogUmVxdWVzdHM6XG4gKiAgLSBfcmZjMzI2MV84XzJfMl8xXyBSZWNlaXZlIGEgUmVxdWVzdCB3aXRoIGEgbm9uIHN1cHBvcnRlZCBVUkkgc2NoZW1lXG4gKiAgLSBfcmZjMzI2MV8xNl8zXzRfIFJlY2VpdmUgYSBSZXF1ZXN0IGFscmVhZHkgc2VudCBieSB1c1xuICogICBEb2VzIG5vdCBsb29rIGF0IHZpYSBzZW50LWJ5IGJ1dCBhdCBzaXBqc0lkLCB3aGljaCBpcyBpbnNlcnRlZCBhc1xuICogICBhIHByZWZpeCBpbiBhbGwgaW5pdGlhbCByZXF1ZXN0cyBnZW5lcmF0ZWQgYnkgdGhlIHVhXG4gKiAgLSBfcmZjMzI2MV8xOF8zX3JlcXVlc3RfIEJvZHkgQ29udGVudC1MZW5ndGhcbiAqICAtIF9yZmMzMjYxXzhfMl8yXzJfIE1lcmdlZCBSZXF1ZXN0c1xuICpcbiAqIFJlc3BvbnNlczpcbiAqICAtIF9yZmMzMjYxXzhfMV8zXzNfIE11bHRpcGxlIFZpYSBoZWFkZXJzXG4gKiAgLSBfcmZjMzI2MV8xOF8xXzJfIHNlbnQtYnkgbWlzbWF0Y2hcbiAqICAtIF9yZmMzMjYxXzE4XzNfcmVzcG9uc2VfIEJvZHkgQ29udGVudC1MZW5ndGhcbiAqXG4gKiBBbGw6XG4gKiAgLSBNaW5pbXVtIGhlYWRlcnMgaW4gYSBTSVAgbWVzc2FnZVxuICovXG5cbi8vIFNhbml0eSBDaGVjayBmdW5jdGlvbnMgZm9yIHJlcXVlc3RzXG5mdW5jdGlvbiByZmMzMjYxXzhfMl8yXzEoKSB7XG4gIGlmKCFtZXNzYWdlLnJ1cmkgfHwgbWVzc2FnZS5ydXJpLnNjaGVtZSAhPT0gJ3NpcCcpIHtcbiAgICByZXBseSg0MTYpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE2XzNfNCgpIHtcbiAgaWYoIW1lc3NhZ2UudG9fdGFnKSB7XG4gICAgaWYobWVzc2FnZS5jYWxsX2lkLnN1YnN0cigwLCA1KSA9PT0gdWEuY29uZmlndXJhdGlvbi5zaXBqc0lkKSB7XG4gICAgICByZXBseSg0ODIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE4XzNfcmVxdWVzdCgpIHtcbiAgdmFyIGxlbiA9IFNJUC5VdGlscy5zdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KSxcbiAgY29udGVudExlbmd0aCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcpO1xuXG4gIGlmKGxlbiA8IGNvbnRlbnRMZW5ndGgpIHtcbiAgICByZXBseSg0MDApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzhfMl8yXzIoKSB7XG4gIHZhciB0ciwgaWR4LFxuICAgIGZyb21UYWcgPSBtZXNzYWdlLmZyb21fdGFnLFxuICAgIGNhbGxfaWQgPSBtZXNzYWdlLmNhbGxfaWQsXG4gICAgY3NlcSA9IG1lc3NhZ2UuY3NlcTtcblxuICBpZighbWVzc2FnZS50b190YWcpIHtcbiAgICBpZihtZXNzYWdlLm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbbWVzc2FnZS52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihpZHggaW4gdWEudHJhbnNhY3Rpb25zLmlzdCkge1xuICAgICAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtpZHhdO1xuICAgICAgICAgIGlmKHRyLnJlcXVlc3QuZnJvbV90YWcgPT09IGZyb21UYWcgJiYgdHIucmVxdWVzdC5jYWxsX2lkID09PSBjYWxsX2lkICYmIHRyLnJlcXVlc3QuY3NlcSA9PT0gY3NlcSkge1xuICAgICAgICAgICAgcmVwbHkoNDgyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMubmlzdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGlkeCBpbiB1YS50cmFuc2FjdGlvbnMubmlzdCkge1xuICAgICAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLm5pc3RbaWR4XTtcbiAgICAgICAgICBpZih0ci5yZXF1ZXN0LmZyb21fdGFnID09PSBmcm9tVGFnICYmIHRyLnJlcXVlc3QuY2FsbF9pZCA9PT0gY2FsbF9pZCAmJiB0ci5yZXF1ZXN0LmNzZXEgPT09IGNzZXEpIHtcbiAgICAgICAgICAgIHJlcGx5KDQ4Mik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFNhbml0eSBDaGVjayBmdW5jdGlvbnMgZm9yIHJlc3BvbnNlc1xuZnVuY3Rpb24gcmZjMzI2MV84XzFfM18zKCkge1xuICBpZihtZXNzYWdlLmdldEhlYWRlcnMoJ3ZpYScpLmxlbmd0aCA+IDEpIHtcbiAgICBsb2dnZXIud2FybignTW9yZSB0aGFuIG9uZSBWaWEgaGVhZGVyIGZpZWxkIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlLiBEcm9wcGluZyB0aGUgcmVzcG9uc2UnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmZjMzI2MV8xOF8xXzIoKSB7XG4gIHZhciB2aWFIb3N0ID0gdWEuY29uZmlndXJhdGlvbi52aWFIb3N0O1xuICBpZihtZXNzYWdlLnZpYS5ob3N0ICE9PSB2aWFIb3N0IHx8IG1lc3NhZ2UudmlhLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGxvZ2dlci53YXJuKCdWaWEgc2VudC1ieSBpbiB0aGUgcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggVUEgVmlhIGhvc3QgdmFsdWUuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE4XzNfcmVzcG9uc2UoKSB7XG4gIHZhclxuICAgIGxlbiA9IFNJUC5VdGlscy5zdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KSxcbiAgICBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cbiAgICBpZihsZW4gPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybignTWVzc2FnZSBib2R5IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSB2YWx1ZSBpbiBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gU2FuaXR5IENoZWNrIGZ1bmN0aW9ucyBmb3IgcmVxdWVzdHMgYW5kIHJlc3BvbnNlc1xuZnVuY3Rpb24gbWluaW11bUhlYWRlcnMoKSB7XG4gIHZhclxuICAgIG1hbmRhdG9yeUhlYWRlcnMgPSBbJ2Zyb20nLCAndG8nLCAnY2FsbF9pZCcsICdjc2VxJywgJ3ZpYSddLFxuICAgIGlkeCA9IG1hbmRhdG9yeUhlYWRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlKGlkeC0tKSB7XG4gICAgaWYoIW1lc3NhZ2UuaGFzSGVhZGVyKG1hbmRhdG9yeUhlYWRlcnNbaWR4XSkpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdNaXNzaW5nIG1hbmRhdG9yeSBoZWFkZXIgZmllbGQgOiAnKyBtYW5kYXRvcnlIZWFkZXJzW2lkeF0gKycuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfOF8yXzJfMSk7XG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfMTZfM180KTtcbnJlcXVlc3RzLnB1c2gocmZjMzI2MV8xOF8zX3JlcXVlc3QpO1xucmVxdWVzdHMucHVzaChyZmMzMjYxXzhfMl8yXzIpO1xuXG5yZXNwb25zZXMucHVzaChyZmMzMjYxXzhfMV8zXzMpO1xucmVzcG9uc2VzLnB1c2gocmZjMzI2MV8xOF8xXzIpO1xucmVzcG9uc2VzLnB1c2gocmZjMzI2MV8xOF8zX3Jlc3BvbnNlKTtcblxuYWxsLnB1c2gobWluaW11bUhlYWRlcnMpO1xuXG5zYW5pdHlDaGVjayA9IGZ1bmN0aW9uKG0sIHUsIHQpIHtcbiAgdmFyIGxlbiwgcGFzcztcblxuICBtZXNzYWdlID0gbTtcbiAgdWEgPSB1O1xuICB0cmFuc3BvcnQgPSB0O1xuXG4gIGxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNhbml0eWNoZWNrJyk7XG5cbiAgbGVuID0gYWxsLmxlbmd0aDtcbiAgd2hpbGUobGVuLS0pIHtcbiAgICBwYXNzID0gYWxsW2xlbl0obWVzc2FnZSk7XG4gICAgaWYocGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVxdWVzdCkge1xuICAgIGxlbiA9IHJlcXVlc3RzLmxlbmd0aDtcbiAgICB3aGlsZShsZW4tLSkge1xuICAgICAgcGFzcyA9IHJlcXVlc3RzW2xlbl0obWVzc2FnZSk7XG4gICAgICBpZihwYXNzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICBsZW4gPSByZXNwb25zZXMubGVuZ3RoO1xuICAgIHdoaWxlKGxlbi0tKSB7XG4gICAgICBwYXNzID0gcmVzcG9uc2VzW2xlbl0obWVzc2FnZSk7XG4gICAgICBpZihwYXNzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9FdmVyeXRoaW5nIGlzIE9LXG4gIHJldHVybiB0cnVlO1xufTtcblxuU0lQLnNhbml0eUNoZWNrID0gc2FuaXR5Q2hlY2s7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TYW5pdHlDaGVjay5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgRGlnZXN0IEF1dGhlbnRpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBTSVAgRGlnZXN0IEF1dGhlbnRpY2F0aW9uLlxuICogQGF1Z21lbnRzIFNJUC5cbiAqIEBmdW5jdGlvbiBEaWdlc3QgQXV0aGVudGljYXRpb25cbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChVdGlscykge1xudmFyIERpZ2VzdEF1dGhlbnRpY2F0aW9uO1xuXG5EaWdlc3RBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uKHVhKSB7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXBqcy5kaWdlc3RhdXRoZW50aWNhdGlvbicpO1xuICB0aGlzLnVzZXJuYW1lID0gdWEuY29uZmlndXJhdGlvbi5hdXRob3JpemF0aW9uVXNlcjtcbiAgdGhpcy5wYXNzd29yZCA9IHVhLmNvbmZpZ3VyYXRpb24ucGFzc3dvcmQ7XG4gIHRoaXMuY25vbmNlID0gbnVsbDtcbiAgdGhpcy5uYyA9IDA7XG4gIHRoaXMubmNIZXggPSAnMDAwMDAwMDAnO1xuICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbn07XG5cblxuLyoqXG4qIFBlcmZvcm1zIERpZ2VzdCBhdXRoZW50aWNhdGlvbiBnaXZlbiBhIFNJUCByZXF1ZXN0IGFuZCB0aGUgY2hhbGxlbmdlXG4qIHJlY2VpdmVkIGluIGEgcmVzcG9uc2UgdG8gdGhhdCByZXF1ZXN0LlxuKiBSZXR1cm5zIHRydWUgaWYgY3JlZGVudGlhbHMgd2VyZSBzdWNjZXNzZnVsbHkgZ2VuZXJhdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4qXG4qIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge09iamVjdH0gY2hhbGxlbmdlXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIGNoYWxsZW5nZSkge1xuICAvLyBJbnNwZWN0IGFuZCB2YWxpZGF0ZSB0aGUgY2hhbGxlbmdlLlxuXG4gIHRoaXMuYWxnb3JpdGhtID0gY2hhbGxlbmdlLmFsZ29yaXRobTtcbiAgdGhpcy5yZWFsbSA9IGNoYWxsZW5nZS5yZWFsbTtcbiAgdGhpcy5ub25jZSA9IGNoYWxsZW5nZS5ub25jZTtcbiAgdGhpcy5vcGFxdWUgPSBjaGFsbGVuZ2Uub3BhcXVlO1xuICB0aGlzLnN0YWxlID0gY2hhbGxlbmdlLnN0YWxlO1xuXG4gIGlmICh0aGlzLmFsZ29yaXRobSkge1xuICAgIGlmICh0aGlzLmFsZ29yaXRobSAhPT0gJ01ENScpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRoIERpZ2VzdCBhbGdvcml0aG0gZGlmZmVyZW50IHRoYW4gXCJNRDVcIiwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFsZ29yaXRobSA9ICdNRDUnO1xuICB9XG5cbiAgaWYgKCEgdGhpcy5yZWFsbSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCByZWFsbSwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghIHRoaXMubm9uY2UpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3Qgbm9uY2UsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyAncW9wJyBjYW4gY29udGFpbiBhIGxpc3Qgb2YgdmFsdWVzIChBcnJheSkuIExldCdzIGNob29zZSBqdXN0IG9uZS5cbiAgaWYgKGNoYWxsZW5nZS5xb3ApIHtcbiAgICBpZiAoY2hhbGxlbmdlLnFvcC5pbmRleE9mKCdhdXRoJykgPiAtMSkge1xuICAgICAgdGhpcy5xb3AgPSAnYXV0aCc7XG4gICAgfSBlbHNlIGlmIChjaGFsbGVuZ2UucW9wLmluZGV4T2YoJ2F1dGgtaW50JykgPiAtMSkge1xuICAgICAgdGhpcy5xb3AgPSAnYXV0aC1pbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgJ3FvcCcgaXMgcHJlc2VudCBidXQgZG9lcyBub3QgY29udGFpbiAnYXV0aCcgb3IgJ2F1dGgtaW50Jywgc28gYWJvcnQgaGVyZS5cbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCBxb3AgZGlmZmVyZW50IHRoYW4gXCJhdXRoXCIgb3IgXCJhdXRoLWludFwiLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMucW9wID0gbnVsbDtcbiAgfVxuXG4gIC8vIEZpbGwgb3RoZXIgYXR0cmlidXRlcy5cblxuICB0aGlzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICB0aGlzLnVyaSA9IHJlcXVlc3QucnVyaTtcbiAgdGhpcy5jbm9uY2UgPSBVdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxMik7XG4gIHRoaXMubmMgKz0gMTtcbiAgdGhpcy51cGRhdGVOY0hleCgpO1xuXG4gIC8vIG5jLXZhbHVlID0gOExIRVguIE1heCB2YWx1ZSA9ICdGRkZGRkZGRicuXG4gIGlmICh0aGlzLm5jID09PSA0Mjk0OTY3Mjk2KSB7XG4gICAgdGhpcy5uYyA9IDE7XG4gICAgdGhpcy5uY0hleCA9ICcwMDAwMDAwMSc7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlIERpZ2VzdCBcInJlc3BvbnNlXCIgdmFsdWUuXG4gIHRoaXMuY2FsY3VsYXRlUmVzcG9uc2UoKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4qIEdlbmVyYXRlIERpZ2VzdCAncmVzcG9uc2UnIHZhbHVlLlxuKiBAcHJpdmF0ZVxuKi9cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVSZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGExLCBoYTI7XG5cbiAgLy8gSEExID0gTUQ1KEExKSA9IE1ENSh1c2VybmFtZTpyZWFsbTpwYXNzd29yZClcbiAgaGExID0gVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMudXNlcm5hbWUgKyBcIjpcIiArIHRoaXMucmVhbG0gKyBcIjpcIiArIHRoaXMucGFzc3dvcmQpO1xuXG4gIGlmICh0aGlzLnFvcCA9PT0gJ2F1dGgnKSB7XG4gICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJKVxuICAgIGhhMiA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkpO1xuICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpub25jZUNvdW50OmNyZWRlbnRpYWxzTm9uY2U6cW9wOkhBMilcbiAgICB0aGlzLnJlc3BvbnNlID0gVXRpbHMuY2FsY3VsYXRlTUQ1KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgdGhpcy5uY0hleCArIFwiOlwiICsgdGhpcy5jbm9uY2UgKyBcIjphdXRoOlwiICsgaGEyKTtcblxuICB9IGVsc2UgaWYgKHRoaXMucW9wID09PSAnYXV0aC1pbnQnKSB7XG4gICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJOk1ENShlbnRpdHlCb2R5KSlcbiAgICBoYTIgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpICsgXCI6XCIgKyBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5ib2R5ID8gdGhpcy5ib2R5IDogXCJcIikpO1xuICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpub25jZUNvdW50OmNyZWRlbnRpYWxzTm9uY2U6cW9wOkhBMilcbiAgICB0aGlzLnJlc3BvbnNlID0gVXRpbHMuY2FsY3VsYXRlTUQ1KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgdGhpcy5uY0hleCArIFwiOlwiICsgdGhpcy5jbm9uY2UgKyBcIjphdXRoLWludDpcIiArIGhhMik7XG5cbiAgfSBlbHNlIGlmICh0aGlzLnFvcCA9PT0gbnVsbCkge1xuICAgIC8vIEhBMiA9IE1ENShBMikgPSBNRDUobWV0aG9kOmRpZ2VzdFVSSSlcbiAgICBoYTIgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6SEEyKVxuICAgIHRoaXMucmVzcG9uc2UgPSBVdGlscy5jYWxjdWxhdGVNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyBoYTIpO1xuICB9XG59O1xuXG5cbi8qKlxuKiBSZXR1cm4gdGhlIFByb3h5LUF1dGhvcml6YXRpb24gb3IgV1dXLUF1dGhvcml6YXRpb24gaGVhZGVyIHZhbHVlLlxuKi9cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aF9wYXJhbXMgPSBbXTtcblxuICBpZiAoISB0aGlzLnJlc3BvbnNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBmaWVsZCBkb2VzIG5vdCBleGlzdCwgY2Fubm90IGdlbmVyYXRlIEF1dGhvcml6YXRpb24gaGVhZGVyJyk7XG4gIH1cblxuICBhdXRoX3BhcmFtcy5wdXNoKCdhbGdvcml0aG09JyArIHRoaXMuYWxnb3JpdGhtKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgndXNlcm5hbWU9XCInICsgdGhpcy51c2VybmFtZSArICdcIicpO1xuICBhdXRoX3BhcmFtcy5wdXNoKCdyZWFsbT1cIicgKyB0aGlzLnJlYWxtICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ25vbmNlPVwiJyArIHRoaXMubm9uY2UgKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgndXJpPVwiJyArIHRoaXMudXJpICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ3Jlc3BvbnNlPVwiJyArIHRoaXMucmVzcG9uc2UgKyAnXCInKTtcbiAgaWYgKHRoaXMub3BhcXVlKSB7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgnb3BhcXVlPVwiJyArIHRoaXMub3BhcXVlICsgJ1wiJyk7XG4gIH1cbiAgaWYgKHRoaXMucW9wKSB7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgncW9wPScgKyB0aGlzLnFvcCk7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgnY25vbmNlPVwiJyArIHRoaXMuY25vbmNlICsgJ1wiJyk7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgnbmM9JyArIHRoaXMubmNIZXgpO1xuICB9XG5cbiAgcmV0dXJuICdEaWdlc3QgJyArIGF1dGhfcGFyYW1zLmpvaW4oJywgJyk7XG59O1xuXG5cbi8qKlxuKiBHZW5lcmF0ZSB0aGUgJ25jJyB2YWx1ZSBhcyByZXF1aXJlZCBieSBEaWdlc3QgaW4gdGhpcy5uY0hleCBieSByZWFkaW5nIHRoaXMubmMuXG4qIEBwcml2YXRlXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLnVwZGF0ZU5jSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoZXggPSBOdW1iZXIodGhpcy5uYykudG9TdHJpbmcoMTYpO1xuICB0aGlzLm5jSGV4ID0gJzAwMDAwMDAwJy5zdWJzdHIoMCwgOC1oZXgubGVuZ3RoKSArIGhleDtcbn07XG5cbnJldHVybiBEaWdlc3RBdXRoZW50aWNhdGlvbjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBHcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyL2Rpc3QvR3JhbW1hcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxucmV0dXJuIHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlQ3VzdG9tIChpbnB1dCwgc3RhcnRSdWxlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7c3RhcnRSdWxlOiBzdGFydFJ1bGUsIFNJUDogU0lQfTtcbiAgICB0cnkge1xuICAgICAgR3JhbW1hci5wYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmRhdGE7XG4gIH1cbn07XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0dyYW1tYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuICB9XG5cbiAgcGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICAgIHBlZyRzdGFydFJ1bGVJbmRpY2VzID0geyBDb250YWN0OiAxMTgsIE5hbWVfQWRkcl9IZWFkZXI6IDE1NSwgUmVjb3JkX1JvdXRlOiAxNzUsIFJlcXVlc3RfUmVzcG9uc2U6IDgxLCBTSVBfVVJJOiA0NSwgU3Vic2NyaXB0aW9uX1N0YXRlOiAxODUsIFN1cHBvcnRlZDogMTkwLCBSZXF1aXJlOiAxODEsIFZpYTogMTkzLCBhYnNvbHV0ZVVSSTogODQsIENhbGxfSUQ6IDExNywgQ29udGVudF9EaXNwb3NpdGlvbjogMTI5LCBDb250ZW50X0xlbmd0aDogMTM0LCBDb250ZW50X1R5cGU6IDEzNSwgQ1NlcTogMTQ1LCBkaXNwbGF5TmFtZTogMTIxLCBFdmVudDogMTQ4LCBGcm9tOiAxNTAsIGhvc3Q6IDUyLCBNYXhfRm9yd2FyZHM6IDE1MywgTWluX1NFOiAyMTIsIFByb3h5X0F1dGhlbnRpY2F0ZTogMTU2LCBxdW90ZWRfc3RyaW5nOiA0MCwgUmVmZXJfVG86IDE3NywgUmVwbGFjZXM6IDE3OCwgU2Vzc2lvbl9FeHBpcmVzOiAyMDksIHN0dW5fVVJJOiAyMTYsIFRvOiAxOTEsIHR1cm5fVVJJOiAyMjMsIHV1aWQ6IDIyNiwgV1dXX0F1dGhlbnRpY2F0ZTogMjA4LCBjaGFsbGVuZ2U6IDE1NyB9LFxuICAgICAgICBwZWckc3RhcnRSdWxlSW5kZXggICA9IDExOCxcblxuICAgICAgICBwZWckY29uc3RzID0gW1xuICAgICAgICAgIFwiXFxyXFxuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxyXFxuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcclxcXFxuXFxcIlwiIH0sXG4gICAgICAgICAgL15bMC05XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTldXCIsIGRlc2NyaXB0aW9uOiBcIlswLTldXCIgfSxcbiAgICAgICAgICAvXlthLXpBLVpdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWl1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWl1cIiB9LFxuICAgICAgICAgIC9eWzAtOWEtZkEtRl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05YS1mQS1GXVwiLCBkZXNjcmlwdGlvbjogXCJbMC05YS1mQS1GXVwiIH0sXG4gICAgICAgICAgL15bXFwwLVxceEZGXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcMC1cXFxceEZGXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXDAtXFxcXHhGRl1cIiB9LFxuICAgICAgICAgIC9eW1wiXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFwiXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcIl1cIiB9LFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiBcIiwgZGVzY3JpcHRpb246IFwiXFxcIiBcXFwiXCIgfSxcbiAgICAgICAgICBcIlxcdFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXHRcXFwiXCIgfSxcbiAgICAgICAgICAvXlthLXpBLVowLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWjAtOV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOV1cIiB9LFxuICAgICAgICAgIFwiO1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjtcIiwgZGVzY3JpcHRpb246IFwiXFxcIjtcXFwiXCIgfSxcbiAgICAgICAgICBcIi9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIvXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIvXFxcIlwiIH0sXG4gICAgICAgICAgXCI/XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiP1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiP1xcXCJcIiB9LFxuICAgICAgICAgIFwiOlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgICAgICBcIkBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJAXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJAXFxcIlwiIH0sXG4gICAgICAgICAgXCImXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiJlxcXCJcIiB9LFxuICAgICAgICAgIFwiPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj1cXFwiXCIgfSxcbiAgICAgICAgICBcIitcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIrXFxcIlwiIH0sXG4gICAgICAgICAgXCIkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiJFxcXCJcIiB9LFxuICAgICAgICAgIFwiLFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIixcIiwgZGVzY3JpcHRpb246IFwiXFxcIixcXFwiXCIgfSxcbiAgICAgICAgICBcIi1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCItXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCItXFxcIlwiIH0sXG4gICAgICAgICAgXCJfXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiX1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiX1xcXCJcIiB9LFxuICAgICAgICAgIFwiLlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgICAgICBcIiFcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIhXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIhXFxcIlwiIH0sXG4gICAgICAgICAgXCJ+XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiflwiLCBkZXNjcmlwdGlvbjogXCJcXFwiflxcXCJcIiB9LFxuICAgICAgICAgIFwiKlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIipcIiwgZGVzY3JpcHRpb246IFwiXFxcIipcXFwiXCIgfSxcbiAgICAgICAgICBcIidcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCInXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCInXFxcIlwiIH0sXG4gICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKFxcXCJcIiB9LFxuICAgICAgICAgIFwiKVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgICAgICBwZWckRkFJTEVELFxuICAgICAgICAgIFwiJVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiVcIiwgZGVzY3JpcHRpb246IFwiXFxcIiVcXFwiXCIgfSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIiBcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gJzonOyB9LFxuICAgICAgICAgIC9eWyEtfl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIS1+XVwiLCBkZXNjcmlwdGlvbjogXCJbIS1+XVwiIH0sXG4gICAgICAgICAgL15bXFx4ODAtXFx1RkZGRl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXHg4MC1cXFxcdUZGRkZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDgwLVxcXFx1RkZGRl1cIiB9LFxuICAgICAgICAgIC9eW1xceDgwLVxceEJGXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDgwLVxcXFx4QkZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDgwLVxcXFx4QkZdXCIgfSxcbiAgICAgICAgICAvXlthLWZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtZl1cIiwgZGVzY3JpcHRpb246IFwiW2EtZl1cIiB9LFxuICAgICAgICAgIFwiYFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImBcIiwgZGVzY3JpcHRpb246IFwiXFxcImBcXFwiXCIgfSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI8XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI8XFxcIlwiIH0sXG4gICAgICAgICAgXCI+XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPlxcXCJcIiB9LFxuICAgICAgICAgIFwiXFxcXFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFxcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcXFxcIlwiIH0sXG4gICAgICAgICAgXCJbXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiW1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiW1xcXCJcIiB9LFxuICAgICAgICAgIFwiXVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl1cIiwgZGVzY3JpcHRpb246IFwiXFxcIl1cXFwiXCIgfSxcbiAgICAgICAgICBcIntcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ7XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ7XFxcIlwiIH0sXG4gICAgICAgICAgXCJ9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwifVwiLCBkZXNjcmlwdGlvbjogXCJcXFwifVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIipcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIvXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiPVwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIihcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIpXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiPlwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIjxcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIsXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiO1wiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIjpcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCJcXFwiXCI7IH0sXG4gICAgICAgICAgL15bIS0nXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlshLSddXCIsIGRlc2NyaXB0aW9uOiBcIlshLSddXCIgfSxcbiAgICAgICAgICAvXlsqLVtdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyotW11cIiwgZGVzY3JpcHRpb246IFwiWyotW11cIiB9LFxuICAgICAgICAgIC9eW1xcXS1+XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcXS1+XVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXF0tfl1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzOyB9LFxuICAgICAgICAgIC9eWyMtW10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIy1bXVwiLCBkZXNjcmlwdGlvbjogXCJbIy1bXVwiIH0sXG4gICAgICAgICAgL15bXFwwLVxcdF0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXDAtXFxcXHRdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcMC1cXFxcdF1cIiB9LFxuICAgICAgICAgIC9eW1xceDBCLVxcZl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXHgwQi1cXFxcZl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4MEItXFxcXGZdXCIgfSxcbiAgICAgICAgICAvXltcXHgwRS1/XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDBFLX9dXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDBFLX9dXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IG9wdGlvbnMuU0lQLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IG9wdGlvbnMuU0lQLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTSVBfVVJJJykgeyBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEudXJpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInNpcHNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzaXBzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzaXBzXFxcIlwiIH0sXG4gICAgICAgICAgXCJzaXBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzaXBcIiwgZGVzY3JpcHRpb246IFwiXFxcInNpcFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHVyaV9zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWUgPSB1cmlfc2NoZW1lOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVzZXIgPSBkZWNvZGVVUklDb21wb25lbnQodGV4dCgpLnNsaWNlKDAsIC0xKSk7fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXNzd29yZCA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YS5ob3N0OyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnZG9tYWluJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIC9eW2EtekEtWjAtOV9cXC1dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWjAtOV9cXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOV9cXFxcLV1cIiB9LFxuICAgICAgICAgIC9eW2EtekEtWjAtOVxcLV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05XFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVowLTlcXFxcLV1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCI6OlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjo6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6OlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2Nic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2NCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIFwiMjVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIyNVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMjVcXFwiXCIgfSxcbiAgICAgICAgICAvXlswLTVdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtNV1cIiwgZGVzY3JpcHRpb246IFwiWzAtNV1cIiB9LFxuICAgICAgICAgIFwiMlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjJcIiwgZGVzY3JpcHRpb246IFwiXFxcIjJcXFwiXCIgfSxcbiAgICAgICAgICAvXlswLTRdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtNF1cIiwgZGVzY3JpcHRpb246IFwiWzAtNF1cIiB9LFxuICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjFcIiwgZGVzY3JpcHRpb246IFwiXFxcIjFcXFwiXCIgfSxcbiAgICAgICAgICAvXlsxLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzEtOV1cIiwgZGVzY3JpcHRpb246IFwiWzEtOV1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwb3J0LmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wb3J0ID0gcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3J0OyB9LFxuICAgICAgICAgIFwidHJhbnNwb3J0PVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRyYW5zcG9ydD1cIiwgZGVzY3JpcHRpb246IFwiXFxcInRyYW5zcG9ydD1cXFwiXCIgfSxcbiAgICAgICAgICBcInVkcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVkcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidWRwXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0Y3BcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0Y3BcIiwgZGVzY3JpcHRpb246IFwiXFxcInRjcFxcXCJcIiB9LFxuICAgICAgICAgIFwic2N0cFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNjdHBcIiwgZGVzY3JpcHRpb246IFwiXFxcInNjdHBcXFwiXCIgfSxcbiAgICAgICAgICBcInRsc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRsc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidGxzXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWyd0cmFuc3BvcnQnXSA9IHRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICAgIFwidXNlcj1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1c2VyPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidXNlcj1cXFwiXCIgfSxcbiAgICAgICAgICBcInBob25lXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicGhvbmVcIiwgZGVzY3JpcHRpb246IFwiXFxcInBob25lXFxcIlwiIH0sXG4gICAgICAgICAgXCJpcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImlwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpcFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ3VzZXInXSA9IHVzZXIudG9Mb3dlckNhc2UoKTsgfSxcbiAgICAgICAgICBcIm1ldGhvZD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtZXRob2Q9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtZXRob2Q9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydtZXRob2QnXSA9IG1ldGhvZDsgfSxcbiAgICAgICAgICBcInR0bD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0dGw9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dGw9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odHRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWyd0dGwnXSA9IHR0bDsgfSxcbiAgICAgICAgICBcIm1hZGRyPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1hZGRyPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibWFkZHI9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obWFkZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ21hZGRyJ10gPSBtYWRkcjsgfSxcbiAgICAgICAgICBcImxyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibHJcIiwgZGVzY3JpcHRpb246IFwiXFxcImxyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydsciddID0gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHBhcmFtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1twYXJhbS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCk7fSxcbiAgICAgICAgICBmdW5jdGlvbihobmFtZSwgaHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhuYW1lID0gaG5hbWUuam9pbignJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHZhbHVlID0gaHZhbHVlLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKSBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXSA9IFtodmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0ucHVzaChodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG90cyBvZiB0ZXN0cyBmYWlsIGlmIHRoaXMgaXNuJ3QgZ3VhcmRlZC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdSZWZlcl9UbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IG9wdGlvbnMuU0lQLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCIvL1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi8vXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIvL1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZT0gdGV4dCgpOyB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlNJUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiU0lQXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2lwX3ZlcnNpb24gPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCJJTlZJVEVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJJTlZJVEVcIiwgZGVzY3JpcHRpb246IFwiXFxcIklOVklURVxcXCJcIiB9LFxuICAgICAgICAgIFwiQUNLXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQUNLXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJBQ0tcXFwiXCIgfSxcbiAgICAgICAgICBcIlZYQUNIXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVlhBQ0hcIiwgZGVzY3JpcHRpb246IFwiXFxcIlZYQUNIXFxcIlwiIH0sXG4gICAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiT1BUSU9OU1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiT1BUSU9OU1xcXCJcIiB9LFxuICAgICAgICAgIFwiQllFXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQllFXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJCWUVcXFwiXCIgfSxcbiAgICAgICAgICBcIkNBTkNFTFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkNBTkNFTFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiQ0FOQ0VMXFxcIlwiIH0sXG4gICAgICAgICAgXCJSRUdJU1RFUlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlJFR0lTVEVSXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJSRUdJU1RFUlxcXCJcIiB9LFxuICAgICAgICAgIFwiU1VCU0NSSUJFXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiU1VCU0NSSUJFXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJTVUJTQ1JJQkVcXFwiXCIgfSxcbiAgICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk5PVElGWVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiTk9USUZZXFxcIlwiIH0sXG4gICAgICAgICAgXCJSRUZFUlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlJFRkVSXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJSRUZFUlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubWV0aG9kID0gdGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YS5tZXRob2Q7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oc3RhdHVzX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc3RhdHVzX2NvZGUgPSBwYXJzZUludChzdGF0dXNfY29kZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlYXNvbl9waHJhc2UgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCwgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXJbaWR4XS5wYXJzZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIpIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIucHVzaCggeyAncG9zaXRpb24nOiBwZWckY3VyclBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvZmZzZXQnOiBvZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJzZWQnOiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWUgPSB0ZXh0KCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5TmFtZVswXSA9PT0gJ1xcXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lLnN1YnN0cmluZygxLCBkaXNwbGF5TmFtZS5sZW5ndGgtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lOyB9LFxuICAgICAgICAgIFwicVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInFcIiwgZGVzY3JpcHRpb246IFwiXFxcInFcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWydxJ10gPSBxOyB9LFxuICAgICAgICAgIFwiZXhwaXJlc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImV4cGlyZXNcIiwgZGVzY3JpcHRpb246IFwiXFxcImV4cGlyZXNcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihleHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWydleHBpcmVzJ10gPSBleHBpcmVzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGRlbHRhX3NlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZGVsdGFfc2Vjb25kcy5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgXCIwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRleHQoKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1twYXJhbS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO30sXG4gICAgICAgICAgXCJyZW5kZXJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZW5kZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlbmRlclxcXCJcIiB9LFxuICAgICAgICAgIFwic2Vzc2lvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNlc3Npb25cIiwgZGVzY3JpcHRpb246IFwiXFxcInNlc3Npb25cXFwiXCIgfSxcbiAgICAgICAgICBcImljb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpY29uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpY29uXFxcIlwiIH0sXG4gICAgICAgICAgXCJhbGVydFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFsZXJ0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhbGVydFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdDb250ZW50X0Rpc3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50eXBlID0gdGV4dCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoYW5kbGluZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImhhbmRsaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJoYW5kbGluZ1xcXCJcIiB9LFxuICAgICAgICAgIFwib3B0aW9uYWxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJvcHRpb25hbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwib3B0aW9uYWxcXFwiXCIgfSxcbiAgICAgICAgICBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVxdWlyZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlcXVpcmVkXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gcGFyc2VJbnQobGVuZ3RoLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGV4dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGV4dFxcXCJcIiB9LFxuICAgICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpbWFnZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaW1hZ2VcXFwiXCIgfSxcbiAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXVkaW9cIiwgZGVzY3JpcHRpb246IFwiXFxcImF1ZGlvXFxcIlwiIH0sXG4gICAgICAgICAgXCJ2aWRlb1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInZpZGVvXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ2aWRlb1xcXCJcIiB9LFxuICAgICAgICAgIFwiYXBwbGljYXRpb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXBwbGljYXRpb25cXFwiXCIgfSxcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtZXNzYWdlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtZXNzYWdlXFxcIlwiIH0sXG4gICAgICAgICAgXCJtdWx0aXBhcnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtdWx0aXBhcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcIm11bHRpcGFydFxcXCJcIiB9LFxuICAgICAgICAgIFwieC1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ4LVwiLCBkZXNjcmlwdGlvbjogXCJcXFwieC1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihjc2VxX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlPXBhcnNlSW50KGNzZXFfdmFsdWUuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV4cGlyZXMpIHtvcHRpb25zLmRhdGEgPSBleHBpcmVzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50X3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ldmVudCA9IGV2ZW50X3R5cGUudG9Mb3dlckNhc2UoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZykge29wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJyx0YWcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwidGFnXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGFnXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0YWdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0YWcpIHtvcHRpb25zLmRhdGEudGFnID0gdGFnOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGZvcndhcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gcGFyc2VJbnQoZm9yd2FyZHMuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG1pbl9leHBpcmVzKSB7b3B0aW9ucy5kYXRhID0gbWluX2V4cGlyZXM7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkaWdlc3RcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJEaWdlc3RcIiwgZGVzY3JpcHRpb246IFwiXFxcIkRpZ2VzdFxcXCJcIiB9LFxuICAgICAgICAgIFwicmVhbG1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWFsbVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVhbG1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZWFsbSkgeyBvcHRpb25zLmRhdGEucmVhbG0gPSByZWFsbTsgfSxcbiAgICAgICAgICBcImRvbWFpblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRvbWFpblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZG9tYWluXFxcIlwiIH0sXG4gICAgICAgICAgXCJub25jZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm5vbmNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJub25jZVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG5vbmNlKSB7IG9wdGlvbnMuZGF0YS5ub25jZT1ub25jZTsgfSxcbiAgICAgICAgICBcIm9wYXF1ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm9wYXF1ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwib3BhcXVlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ob3BhcXVlKSB7IG9wdGlvbnMuZGF0YS5vcGFxdWU9b3BhcXVlOyB9LFxuICAgICAgICAgIFwic3RhbGVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzdGFsZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwic3RhbGVcXFwiXCIgfSxcbiAgICAgICAgICBcInRydWVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0cnVlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0cnVlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IG9wdGlvbnMuZGF0YS5zdGFsZT10cnVlOyB9LFxuICAgICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJmYWxzZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZmFsc2VcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgb3B0aW9ucy5kYXRhLnN0YWxlPWZhbHNlOyB9LFxuICAgICAgICAgIFwiYWxnb3JpdGhtXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYWxnb3JpdGhtXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhbGdvcml0aG1cXFwiXCIgfSxcbiAgICAgICAgICBcIm1kNVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk1ENVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiTUQ1XFxcIlwiIH0sXG4gICAgICAgICAgXCJtZDUtc2Vzc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk1ENS1zZXNzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJNRDUtc2Vzc1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuYWxnb3JpdGhtPWFsZ29yaXRobS50b1VwcGVyQ2FzZSgpOyB9LFxuICAgICAgICAgIFwicW9wXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicW9wXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJxb3BcXFwiXCIgfSxcbiAgICAgICAgICBcImF1dGgtaW50XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXV0aC1pbnRcIiwgZGVzY3JpcHRpb246IFwiXFxcImF1dGgtaW50XFxcIlwiIH0sXG4gICAgICAgICAgXCJhdXRoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXV0aFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXV0aFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHFvcF92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5xb3AgfHwgKG9wdGlvbnMuZGF0YS5xb3A9W10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5xb3AucHVzaChxb3BfdmFsdWUudG9Mb3dlckNhc2UoKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocmFja192YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZT1wYXJzZUludChyYWNrX3ZhbHVlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcltpZHhdLnBhcnNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcikgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKCB7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mZnNldCc6IG9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcnNlZCc6IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO30sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvcHRpb25zLmRhdGEucmVwbGFjZXNfZnJvbV90YWcgJiYgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxfaWQ6IG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImZyb20tdGFnXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZnJvbS10YWdcIiwgZGVzY3JpcHRpb246IFwiXFxcImZyb20tdGFnXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZnJvbV90YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX2Zyb21fdGFnID0gZnJvbV90YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwidG8tdGFnXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG8tdGFnXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0by10YWdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0b190YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZyA9IHRvX3RhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlYXJseS1vbmx5XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZWFybHktb25seVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZWFybHktb25seVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZWFybHlfb25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHIpIHtyZXR1cm4gcjt9LFxuICAgICAgICAgIGZ1bmN0aW9uKGZpcnN0LCByZXN0KSB7IHJldHVybiBsaXN0KGZpcnN0LCByZXN0KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdSZXF1aXJlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJzZXFfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudmFsdWU9cGFyc2VJbnQocnNlcV92YWx1ZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgXCJhY3RpdmVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhY3RpdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcImFjdGl2ZVxcXCJcIiB9LFxuICAgICAgICAgIFwicGVuZGluZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInBlbmRpbmdcIiwgZGVzY3JpcHRpb246IFwiXFxcInBlbmRpbmdcXFwiXCIgfSxcbiAgICAgICAgICBcInRlcm1pbmF0ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0ZXJtaW5hdGVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0ZXJtaW5hdGVkXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnN0YXRlID0gdGV4dCgpOyB9LFxuICAgICAgICAgIFwicmVhc29uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVhc29uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWFzb25cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYXNvbiAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuZGF0YS5yZWFzb24gPSByZWFzb247IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJlcyAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuZGF0YS5leHBpcmVzID0gZXhwaXJlczsgfSxcbiAgICAgICAgICBcInJldHJ5X2FmdGVyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmV0cnlfYWZ0ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJldHJ5X2FmdGVyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocmV0cnlfYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJldHJ5X2FmdGVyICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLnJldHJ5X2FmdGVyID0gcmV0cnlfYWZ0ZXI7IH0sXG4gICAgICAgICAgXCJkZWFjdGl2YXRlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRlYWN0aXZhdGVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkZWFjdGl2YXRlZFxcXCJcIiB9LFxuICAgICAgICAgIFwicHJvYmF0aW9uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicHJvYmF0aW9uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJwcm9iYXRpb25cXFwiXCIgfSxcbiAgICAgICAgICBcInJlamVjdGVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVqZWN0ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlamVjdGVkXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0aW1lb3V0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGltZW91dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGltZW91dFxcXCJcIiB9LFxuICAgICAgICAgIFwiZ2l2ZXVwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZ2l2ZXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJnaXZldXBcXFwiXCIgfSxcbiAgICAgICAgICBcIm5vcmVzb3VyY2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJub3Jlc291cmNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJub3Jlc291cmNlXFxcIlwiIH0sXG4gICAgICAgICAgXCJpbnZhcmlhbnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpbnZhcmlhbnRcIiwgZGVzY3JpcHRpb246IFwiXFxcImludmFyaWFudFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1N1cHBvcnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBvcHRpb25zLmRhdGEudGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZykge29wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJyx0YWcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInR0bFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR0bFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHRsXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3R0bF92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHRsID0gdmlhX3R0bF92YWx1ZTsgfSxcbiAgICAgICAgICBcIm1hZGRyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibWFkZHJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1hZGRyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX21hZGRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tYWRkciA9IHZpYV9tYWRkcjsgfSxcbiAgICAgICAgICBcInJlY2VpdmVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVjZWl2ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlY2VpdmVkXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3JlY2VpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWNlaXZlZCA9IHZpYV9yZWNlaXZlZDsgfSxcbiAgICAgICAgICBcImJyYW5jaFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImJyYW5jaFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYnJhbmNoXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX2JyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuYnJhbmNoID0gdmlhX2JyYW5jaDsgfSxcbiAgICAgICAgICBcInJwb3J0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicnBvcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJwb3J0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiByZXNwb25zZV9wb3J0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucnBvcnQgPSByZXNwb25zZV9wb3J0LmpvaW4oJycpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucHJvdG9jb2wgPSB2aWFfcHJvdG9jb2w7IH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVURQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJVRFBcXFwiXCIgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJUQ1BcIiwgZGVzY3JpcHRpb246IFwiXFxcIlRDUFxcXCJcIiB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlRMU1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiVExTXFxcIlwiIH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiU0NUUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiU0NUUFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHZpYV90cmFuc3BvcnQ7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9zZW50X2J5X3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBvcnQgPSBwYXJzZUludCh2aWFfc2VudF9ieV9wb3J0LmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbih0dGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR0bC5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZGVsdGFTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1Nlc3Npb25fRXhwaXJlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZGVsdGFTZWNvbmRzID0gZGVsdGFTZWNvbmRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVmcmVzaGVyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVmcmVzaGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWZyZXNoZXJcXFwiXCIgfSxcbiAgICAgICAgICBcInVhc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVhc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidWFzXFxcIlwiIH0sXG4gICAgICAgICAgXCJ1YWNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1YWNcIiwgZGVzY3JpcHRpb246IFwiXFxcInVhY1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1Nlc3Npb25fRXhwaXJlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVmcmVzaGVyID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZGVsdGFTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ01pbl9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzdHVuc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN0dW5zXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzdHVuc1xcXCJcIiB9LFxuICAgICAgICAgIFwic3R1blwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN0dW5cIiwgZGVzY3JpcHRpb246IFwiXFxcInN0dW5cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHNjaGVtZTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gaG9zdDsgfSxcbiAgICAgICAgICBcIj90cmFuc3BvcnQ9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiP3RyYW5zcG9ydD1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj90cmFuc3BvcnQ9XFxcIlwiIH0sXG4gICAgICAgICAgXCJ0dXJuc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR1cm5zXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dXJuc1xcXCJcIiB9LFxuICAgICAgICAgIFwidHVyblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR1cm5cIiwgZGVzY3JpcHRpb246IFwiXFxcInR1cm5cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH1cbiAgICAgICAgXSxcblxuICAgICAgICBwZWckYnl0ZWNvZGUgPSBbXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4gXFxcIlxcXCIyIDMhXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwXFxcIlxcXCJcXFwiMSEzI1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMCRcXFwiXFxcIjEhMyVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAmXFxcIlxcXCIxITMnXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3JyojIFxcXCI3KFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMChcXFwiXFxcIjEhMylcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAqXFxcIlxcXCIxITMrXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuLFxcXCJcXFwiMiwzLVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLi5cXFwiXFxcIjIuMy9cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAwXFxcIlxcXCIxITMxXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuMlxcXCJcXFwiMjIzMypcXHg4OSBcXFwiLjRcXFwiXFxcIjI0MzUqfSBcXFwiLjZcXFwiXFxcIjI2MzcqcSBcXFwiLjhcXFwiXFxcIjI4MzkqZSBcXFwiLjpcXFwiXFxcIjI6MzsqWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcpKiMgXFxcIjcsXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuRlxcXCJcXFwiMkYzRyp9IFxcXCIuSFxcXCJcXFwiMkgzSSpxIFxcXCIuSlxcXCJcXFwiMkozSyplIFxcXCIuTFxcXCJcXFwiMkwzTSpZIFxcXCIuTlxcXCJcXFwiMk4zTypNIFxcXCIuUFxcXCJcXFwiMlAzUSpBIFxcXCIuUlxcXCJcXFwiMlIzUyo1IFxcXCIuVFxcXCJcXFwiMlQzVSopIFxcXCIuVlxcXCJcXFwiMlYzV1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISEuWVxcXCJcXFwiMlkzWis3JDcjKy0lNyMrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhISBcXFxcNyQsIyY3JFxcXCIrLSQ3ICsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytAJCBcXFxcNyQrJiQsIyY3JFxcXCJcXFwiXFxcIiBYKyclNFxcXCI2XVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNy4qIyBcXFwiIFtcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcnKiMgXFxcIjcoLCkmNycqIyBcXFwiNyhcXFwiK0EkLjhcXFwiXFxcIjI4MzkrMSU3LysnJTQjNl4jICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISEgXFxcXDcyKyYkLCMmNzJcXFwiXFxcIlxcXCIgWCtvJCBcXFxcISBcXFxcNy4sIyY3LlxcXCIrLSQ3MisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCxAJiEgXFxcXDcuLCMmNy5cXFwiKy0kNzIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBfXFxcIlxcXCIxITNgKiMgXFxcIjczXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwYVxcXCJcXFwiMSEzYlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMGNcXFwiXFxcIjEhM2RcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjchKikgXFxcIjBlXFxcIlxcXCIxITNmXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KSpcXHg5NSBcXFwiLkZcXFwiXFxcIjJGM0cqXFx4ODkgXFxcIi5KXFxcIlxcXCIySjNLKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPK1xceDlFJCxcXHg5QiY3KSpcXHg5NSBcXFwiLkZcXFwiXFxcIjJGM0cqXFx4ODkgXFxcIi5KXFxcIlxcXCIySjNLKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNykqXFx4ODkgXFxcIi5GXFxcIlxcXCIyRjNHKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPK1xceDkyJCxcXHg4RiY3KSpcXHg4OSBcXFwiLkZcXFwiXFxcIjJGM0cqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM09cXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuVFxcXCJcXFwiMlQzVSpcXHhFMyBcXFwiLlZcXFwiXFxcIjJWM1cqXFx4RDcgXFxcIi5pXFxcIlxcXCIyaTNqKlxceENCIFxcXCIua1xcXCJcXFwiMmszbCpcXHhCRiBcXFwiLjpcXFwiXFxcIjI6MzsqXFx4QjMgXFxcIi5EXFxcIlxcXCIyRDNFKlxceEE3IFxcXCIuMlxcXCJcXFwiMjIzMypcXHg5QiBcXFwiLjhcXFwiXFxcIjI4MzkqXFx4OEYgXFxcIi5tXFxcIlxcXCIybTNuKlxceDgzIFxcXCI3Jip9IFxcXCIuNFxcXCJcXFwiMjQzNSpxIFxcXCIub1xcXCJcXFwiMm8zcCplIFxcXCIucVxcXCJcXFwiMnEzcipZIFxcXCIuNlxcXCJcXFwiMjYzNypNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuc1xcXCJcXFwiMnMzdCo1IFxcXCIudVxcXCJcXFwiMnUzdiopIFxcXCI3JyojIFxcXCI3KFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNykqXFx1MDEyQiBcXFwiLkZcXFwiXFxcIjJGM0cqXFx1MDExRiBcXFwiLkpcXFwiXFxcIjJKM0sqXFx1MDExMyBcXFwiLkxcXFwiXFxcIjJMM00qXFx1MDEwNyBcXFwiLllcXFwiXFxcIjJZM1oqXFx4RkIgXFxcIi5QXFxcIlxcXCIyUDNRKlxceEVGIFxcXCIuSFxcXCJcXFwiMkgzSSpcXHhFMyBcXFwiLkBcXFwiXFxcIjJAM0EqXFx4RDcgXFxcIi5nXFxcIlxcXCIyZzNoKlxceENCIFxcXCIuUlxcXCJcXFwiMlIzUypcXHhCRiBcXFwiLk5cXFwiXFxcIjJOM08qXFx4QjMgXFxcIi5UXFxcIlxcXCIyVDNVKlxceEE3IFxcXCIuVlxcXCJcXFwiMlYzVypcXHg5QiBcXFwiLmlcXFwiXFxcIjJpM2oqXFx4OEYgXFxcIi5rXFxcIlxcXCIyazNsKlxceDgzIFxcXCIuOFxcXCJcXFwiMjgzOSp3IFxcXCIubVxcXCJcXFwiMm0zbiprIFxcXCI3JiplIFxcXCIuNFxcXCJcXFwiMjQzNSpZIFxcXCIub1xcXCJcXFwiMm8zcCpNIFxcXCIucVxcXCJcXFwiMnEzcipBIFxcXCIuNlxcXCJcXFwiMjYzNyo1IFxcXCIuc1xcXCJcXFwiMnMzdCopIFxcXCIudVxcXCJcXFwiMnUzditcXHUwMTM0JCxcXHUwMTMxJjcpKlxcdTAxMkIgXFxcIi5GXFxcIlxcXCIyRjNHKlxcdTAxMUYgXFxcIi5KXFxcIlxcXCIySjNLKlxcdTAxMTMgXFxcIi5MXFxcIlxcXCIyTDNNKlxcdTAxMDcgXFxcIi5ZXFxcIlxcXCIyWTNaKlxceEZCIFxcXCIuUFxcXCJcXFwiMlAzUSpcXHhFRiBcXFwiLkhcXFwiXFxcIjJIM0kqXFx4RTMgXFxcIi5AXFxcIlxcXCIyQDNBKlxceEQ3IFxcXCIuZ1xcXCJcXFwiMmczaCpcXHhDQiBcXFwiLlJcXFwiXFxcIjJSM1MqXFx4QkYgXFxcIi5OXFxcIlxcXCIyTjNPKlxceEIzIFxcXCIuVFxcXCJcXFwiMlQzVSpcXHhBNyBcXFwiLlZcXFwiXFxcIjJWM1cqXFx4OUIgXFxcIi5pXFxcIlxcXCIyaTNqKlxceDhGIFxcXCIua1xcXCJcXFwiMmszbCpcXHg4MyBcXFwiLjhcXFwiXFxcIjI4MzkqdyBcXFwiLm1cXFwiXFxcIjJtM24qayBcXFwiNyYqZSBcXFwiLjRcXFwiXFxcIjI0MzUqWSBcXFwiLm9cXFwiXFxcIjJvM3AqTSBcXFwiLnFcXFwiXFxcIjJxM3IqQSBcXFwiLjZcXFwiXFxcIjI2MzcqNSBcXFwiLnNcXFwiXFxcIjJzM3QqKSBcXFwiLnVcXFwiXFxcIjJ1M3ZcXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuUFxcXCJcXFwiMlAzUSsxJTcvKyclNCM2dyMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuNFxcXCJcXFwiMjQzNSsxJTcvKyclNCM2eCMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuPlxcXCJcXFwiMj4zPysxJTcvKyclNCM2eSMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuVFxcXCJcXFwiMlQzVSsxJTcvKyclNCM2eiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuVlxcXCJcXFwiMlYzVysxJTcvKyclNCM2eyMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLmtcXFwiXFxcIjJrM2wrMSQ3LysnJTRcXFwiNnxcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Lys3JC5pXFxcIlxcXCIyaTNqKyclNFxcXCI2fVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLkRcXFwiXFxcIjJEM0UrMSU3LysnJTQjNn4jICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLjJcXFwiXFxcIjIyMzMrMSU3LysnJTQjNn8jICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLjhcXFwiXFxcIjI4MzkrMSU3LysnJTQjNlxceDgwIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LysxJDcmKyclNFxcXCI2XFx4ODFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3JisxJDcvKyclNFxcXCI2XFx4ODFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3PStXJCBcXFxcN0cqKSBcXFwiN0sqIyBcXFwiN0YsLyY3RyopIFxcXCI3SyojIFxcXCI3RlxcXCIrLSU3PisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwXFx4ODJcXFwiXFxcIjEhM1xceDgzKkEgXFxcIjBcXHg4NFxcXCJcXFwiMSEzXFx4ODUqNSBcXFwiMFxceDg2XFxcIlxcXCIxITNcXHg4NyopIFxcXCI3MyojIFxcXCI3LlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3LytVJDcmK0slIFxcXFw3SiojIFxcXCI3SywpJjdKKiMgXFxcIjdLXFxcIistJTcmKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rYCQ3JitWJSEgXFxcXDdKKiMgXFxcIjdLLCkmN0oqIyBcXFwiN0tcXFwiKyEgKCUrMiU3JisoJTQkNlxceDg4JCEhJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcuKkcgXFxcIi5MXFxcIlxcXCIyTDNNKjsgXFxcIjBcXHg4OVxcXCJcXFwiMSEzXFx4OEEqLyBcXFwiMFxceDg2XFxcIlxcXCIxITNcXHg4NyojIFxcXCI3M1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5tXFxcIlxcXCIybTNuK0skMFxceDhCXFxcIlxcXCIxITNcXHg4Qyo1IFxcXCIwXFx4OERcXFwiXFxcIjEhM1xceDhFKikgXFxcIjBcXHg4RlxcXCJcXFwiMSEzXFx4OTArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TitRJC44XFxcIlxcXCIyODM5K0ElN08qIyBcXFwiIFsrMSU3UysnJTQkNlxceDkxJCAlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdOK2skLjhcXFwiXFxcIjI4MzkrWyU3TyojIFxcXCIgWytLJTdTK0ElN18rNyU3bCojIFxcXCIgWysnJTQmNlxceDkyJiAlJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4OTNcXFwiXFxcIjEkM1xceDk0KikgXFxcIi9cXHg5NVxcXCJcXFwiMSMzXFx4OTYrJyA0ITZcXHg5NyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3UCtiJCEuOFxcXCJcXFwiMjgzOSstJDdSKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKzclLjpcXFwiXFxcIjI6MzsrJyU0IzZcXHg5OCMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDcrKikgXFxcIjctKiMgXFxcIjdRKzIkLC8mNysqKSBcXFwiNy0qIyBcXFwiN1FcXFwiXFxcIlxcXCIgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLjxcXFwiXFxcIjI8Mz0qcSBcXFwiLj5cXFwiXFxcIjI+Mz8qZSBcXFwiLkBcXFwiXFxcIjJAM0EqWSBcXFwiLkJcXFwiXFxcIjJCM0MqTSBcXFwiLkRcXFwiXFxcIjJEM0UqQSBcXFwiLjJcXFwiXFxcIjIyMzMqNSBcXFwiLjZcXFwiXFxcIjI2MzcqKSBcXFwiLjRcXFwiXFxcIjI0MzVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcrKl8gXFxcIjctKlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFLGUmNysqXyBcXFwiNy0qWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcXFwiKyYgNCE2XFx4OTkhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3VCtOJCEuOFxcXCJcXFwiMjgzOSstJDdeKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1UqKSBcXFwiN1xcXFwqIyBcXFwiN1grJiA0ITZcXHg5QSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcITdWKzMkLkpcXFwiXFxcIjJKM0srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhN1YrMyQuSlxcXCJcXFwiMkozSysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrRyQ3Vys9JS5KXFxcIlxcXCIySjNLKiMgXFxcIiBbKyclNCM2XFx4OUIjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFwwXFx4OUNcXFwiXFxcIjEhM1xceDlEKywkLCkmMFxceDlDXFxcIlxcXCIxITNcXHg5RFxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhMCRcXFwiXFxcIjEhMyUrQSQgXFxcXDBcXHg5RVxcXCJcXFwiMSEzXFx4OUYsKSYwXFx4OUVcXFwiXFxcIjEhM1xceDlGXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5vXFxcIlxcXCIybzNwK0EkN1krNyUucVxcXCJcXFwiMnEzcisnJTQjNlxceEEwIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhN1orXFx4QkYkLjhcXFwiXFxcIjI4MzkrXFx4QUYlN1orXFx4QTUlLjhcXFwiXFxcIjI4MzkrXFx4OTUlN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJSctJSQtIyBYJCwjIFgkKyMgWCQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDgzOCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK1xceEFGJDdaK1xceEE1JS44XFxcIlxcXCIyODM5K1xceDk1JTdaK1xceDhCJS44XFxcIlxcXCIyODM5K3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnLCUkLCMgWCQrIyBYJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNzk1IFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrXFx4OTUkN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScqJSQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDcwQyBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK3skN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDY5RCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK2EkN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScmJSQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA2NDggXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitHJDdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDYwRCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0kN1srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqXFx1MDVFQyBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqXFx1MDVDQiBcXFwiITdaK1xceEE1JC5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK1xceDk1JTdaK1xceDhCJS44XFxcIlxcXCIyODM5K3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKyUkKyMgWCQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDUzOCBcXFwiITdaK1xceEI2JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDhCJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKiUkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA0OTQgXFxcIiE3WitcXHhDNyQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg5QyUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytxJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScpJSQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTAzREYgXFxcIiE3WitcXHhEOCQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhBRCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg4MiUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytXJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyglJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTAzMTkgXFxcIiE3WitcXHhFOSQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhCRSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg5MyUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytoJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKz0lLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSU3WysjJScnJSQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDI0MiBcXFwiITdaK1xcdTAxMTQkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4RTklIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4QkUlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4OTMlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsraCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWys9JS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0lN1orIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDE0MCBcXFwiITdaK1xcdTAxMzUkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx1MDEwQSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhERiUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhCNCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg4OSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyteJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKzMlLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrJiA0ITZcXHhBMyEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcjK1MkNyMqIyBcXFwiIFsrQyU3IyojIFxcXCIgWyszJTcjKiMgXFxcIiBbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdaKz0kLjhcXFwiXFxcIjI4MzkrLSU3WisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdcXFxcXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN10rdSQuSlxcXCJcXFwiMkozSytlJTddK1slLkpcXFwiXFxcIjJKM0srSyU3XStBJS5KXFxcIlxcXCIySjNLKzElN10rJyU0JzZcXHhBNCcgJSQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4QTVcXFwiXFxcIjJcXHhBNTNcXHhBNiszJDBcXHhBN1xcXCJcXFwiMSEzXFx4QTgrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqXFx4QTAgXFxcIiEuXFx4QTlcXFwiXFxcIjJcXHhBOTNcXHhBQSs9JDBcXHhBQlxcXCJcXFwiMSEzXFx4QUMrLSU3ISsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKm8gXFxcIiEuXFx4QURcXFwiXFxcIjJcXHhBRDNcXHhBRSs3JDchKy0lNyErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCpEIFxcXCIhMFxceEFGXFxcIlxcXCIxITNcXHhCMCstJDchKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjchXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITchKiMgXFxcIiBbK2MkNyEqIyBcXFwiIFsrUyU3ISojIFxcXCIgWytDJTchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrJyA0ITZcXHhCMSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcIS4yXFxcIlxcXCIyMjMzKy0kN2ArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjJcXFwiXFxcIjIyMzMrLSQ3YCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdhKkEgXFxcIjdiKjsgXFxcIjdjKjUgXFxcIjdkKi8gXFxcIjdlKikgXFxcIjdmKiMgXFxcIjdnXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEIyXFxcIlxcXCIxKjNcXHhCMytiJC9cXHhCNFxcXCJcXFwiMSMzXFx4QjUqRyBcXFwiL1xceEI2XFxcIlxcXCIxIzNcXHhCNyo7IFxcXCIvXFx4QjhcXFwiXFxcIjEkM1xceEI5Ki8gXFxcIi9cXHhCQVxcXCJcXFwiMSMzXFx4QkIqIyBcXFwiNzYrKCU0XFxcIjZcXHhCQ1xcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QkRcXFwiXFxcIjElM1xceEJFK0okL1xceEJGXFxcIlxcXCIxJTNcXHhDMCovIFxcXCIvXFx4QzFcXFwiXFxcIjFcXFwiM1xceEMyKiMgXFxcIjc2KyglNFxcXCI2XFx4QzNcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEM0XFxcIlxcXCIxJzNcXHhDNSsyJDdcXHg4RisoJTRcXFwiNlxceEM2XFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDN1xcXCJcXFwiMSQzXFx4QzgrMiQ3XFx4RUYrKCU0XFxcIjZcXHhDOVxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4Q0FcXFwiXFxcIjEmM1xceENCKzIkN1QrKCU0XFxcIjZcXHhDQ1xcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4Q0RcXFwiXFxcIjFcXFwiM1xceENFK1IkIS4+XFxcIlxcXCIyPjM/Ky0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHhDRlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdoK1QkIS4+XFxcIlxcXCIyPjM/Ky0kN2krIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrKSU0XFxcIjZcXHhEMFxcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3aismJCwjJjdqXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN2orJiQsIyY3alxcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdrKikgXFxcIjcrKiMgXFxcIjctXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIub1xcXCJcXFwiMm8zcCplIFxcXCIucVxcXCJcXFwiMnEzcipZIFxcXCIuNFxcXCJcXFwiMjQzNSpNIFxcXCIuOFxcXCJcXFwiMjgzOSpBIFxcXCIuPFxcXCJcXFwiMjwzPSo1IFxcXCIuQFxcXCJcXFwiMkAzQSopIFxcXCIuQlxcXCJcXFwiMkIzQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS42XFxcIlxcXCIyNjM3K3UkN20rayUgXFxcXCEuPFxcXCJcXFwiMjwzPSstJDdtKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS48XFxcIlxcXCIyPDM9Ky0kN20rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3bitDJC4+XFxcIlxcXCIyPjM/KzMlN28rKSU0IzZcXHhEMSNcXFwiXFxcIiAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN3AqKSBcXFwiNysqIyBcXFwiNy0rMiQsLyY3cCopIFxcXCI3KyojIFxcXCI3LVxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDdwKikgXFxcIjcrKiMgXFxcIjctLC8mN3AqKSBcXFwiNysqIyBcXFwiNy1cXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIub1xcXCJcXFwiMm8zcCplIFxcXCIucVxcXCJcXFwiMnEzcipZIFxcXCIuNFxcXCJcXFwiMjQzNSpNIFxcXCIuNlxcXCJcXFwiMjYzNypBIFxcXCIuOFxcXCJcXFwiMjgzOSo1IFxcXCIuQFxcXCJcXFwiMkAzQSopIFxcXCIuQlxcXCJcXFwiMkIzQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceDkwKiMgXFxcIjdyXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDhGK0skNycrQSU3cys3JTcnKy0lN1xceDg0KyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3TSojIFxcXCI3dFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd/K0ckLjhcXFwiXFxcIjI4MzkrNyU3dSojIFxcXCI3eCsnJTQjNlxceEQyIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3diojIFxcXCI3dytOJCEuNlxcXCJcXFwiMjYzNystJDdcXHg4MysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhEM1xcXCJcXFwiMlxceEQzM1xceEQ0Kz0kN1xceDgwKzMlN3cqIyBcXFwiIFsrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS40XFxcIlxcXCIyNDM1Ky0kN3srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3eis1JCBcXFxcN3ksIyY3eVxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcqKikgXFxcIjcrKiMgXFxcIjctXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3KypcXHg4RiBcXFwiNy0qXFx4ODkgXFxcIi4yXFxcIlxcXCIyMjMzKn0gXFxcIi42XFxcIlxcXCIyNjM3KnEgXFxcIi44XFxcIlxcXCIyODM5KmUgXFxcIi46XFxcIlxcXCIyOjM7KlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN3wrayQgXFxcXCEuNFxcXCJcXFwiMjQzNSstJDd8KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS40XFxcIlxcXCIyNDM1Ky0kN3wrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3fiwjJjd+XFxcIitrJCBcXFxcIS4yXFxcIlxcXCIyMjMzKy0kN30rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjJcXFwiXFxcIjIyMzMrLSQ3fSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN34sIyY3flxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcrKncgXFxcIjctKnEgXFxcIi44XFxcIlxcXCIyODM5KmUgXFxcIi46XFxcIlxcXCIyOjM7KlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcXCIrXFx4OEQkIFxcXFw3XFxcIipHIFxcXCI3ISpBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuRlxcXCJcXFwiMkYzRyopIFxcXCIuSlxcXCJcXFwiMkozSyxNJjdcXFwiKkcgXFxcIjchKkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5GXFxcIlxcXCIyRjNHKikgXFxcIi5KXFxcIlxcXCIySjNLXFxcIisnJTRcXFwiNlxceEQ1XFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4ODEqIyBcXFwiN1xceDgyXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITdPKzMkLjpcXFwiXFxcIjI6MzsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrLSQ3UysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgW1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3KypcXHg4MyBcXFwiNy0qfSBcXFwiLkJcXFwiXFxcIjJCM0MqcSBcXFwiLkRcXFwiXFxcIjJEM0UqZSBcXFwiLjJcXFwiXFxcIjIyMzMqWSBcXFwiLjhcXFwiXFxcIjI4MzkqTSBcXFwiLjpcXFwiXFxcIjI6MzsqQSBcXFwiLjxcXFwiXFxcIjI8Mz0qNSBcXFwiLj5cXFwiXFxcIjI+Mz8qKSBcXFwiLkBcXFwiXFxcIjJAM0ErXFx4OEMkLFxceDg5JjcrKlxceDgzIFxcXCI3LSp9IFxcXCIuQlxcXCJcXFwiMkIzQypxIFxcXCIuRFxcXCJcXFwiMkQzRSplIFxcXCIuMlxcXCJcXFwiMjIzMypZIFxcXCIuOFxcXCJcXFwiMjgzOSpNIFxcXCIuOlxcXCJcXFwiMjozOypBIFxcXCIuPFxcXCJcXFwiMjwzPSo1IFxcXCIuPlxcXCJcXFwiMj4zPyopIFxcXCIuQFxcXCJcXFwiMkAzQVxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDd5LCMmN3lcXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceDk1XFxcIlxcXCIxIzNcXHhENit5JC40XFxcIlxcXCIyNDM1K2klIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrUCUuSlxcXCJcXFwiMkozSytAJSBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKyclNCU2XFx4RDclICUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhEOFxcXCJcXFwiMlxceEQ4M1xceEQ5XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4REFcXFwiXFxcIjJcXHhEQTNcXHhEQlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceERDXFxcIlxcXCIyXFx4REMzXFx4RERcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhERVxcXCJcXFwiMlxceERFM1xceERGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTBcXFwiXFxcIjJcXHhFMDNcXHhFMVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEUyXFxcIlxcXCIyXFx4RTIzXFx4RTNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFNFxcXCJcXFwiMlxceEU0M1xceEU1XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTZcXFwiXFxcIjJcXHhFNjNcXHhFN1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEU4XFxcIlxcXCIyXFx4RTgzXFx4RTlcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFQVxcXCJcXFwiMlxceEVBM1xceEVCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDg1KlMgXFxcIjdcXHg4NipNIFxcXCI3XFx4ODgqRyBcXFwiN1xceDg5KkEgXFxcIjdcXHg4QSo7IFxcXCI3XFx4OEIqNSBcXFwiN1xceDhDKi8gXFxcIjdcXHg4RCopIFxcXCI3XFx4OEUqIyBcXFwiNzYrJiA0ITZcXHhFQyEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4NCtLJDcnK0ElN1xceDkxKzclNycrLSU3XFx4OTMrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTIrJyA0ITZcXHhFRCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3ISs3JDchKy0lNyErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyoqQSBcXFwiNysqOyBcXFwiNy0qNSBcXFwiNzMqLyBcXFwiNzQqKSBcXFwiNycqIyBcXFwiNygsRyY3KipBIFxcXCI3Kyo7IFxcXCI3LSo1IFxcXCI3MyovIFxcXCI3NCopIFxcXCI3JyojIFxcXCI3KFxcXCIrJiA0ITZcXHhFRSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhCNStfJCBcXFxcITdBKy0kN1xceEI1KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEI1KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc5K1IkIS46XFxcIlxcXCIyOjM7Ky0kNzkrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHhFRlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc6KmogXFxcIiE3XFx4OTcrXyQgXFxcXCE3QSstJDdcXHg5NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHg5NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrJiA0ITZcXHhGMCEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKiMgXFxcIjdcXHg5OCtjJCBcXFxcITdCKy0kN1xceDlBKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlBKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxceEYxXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk5KiMgXFxcIiBbK0EkN0ArNyU3TSstJTc/KyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NitfJCBcXFxcITcuKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhNy4rLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN0grJyA0ITZcXHhGMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHg5QiopIFxcXCI3XFx4OUMqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEYzXFxcIlxcXCIxITNcXHhGNCs8JDc8KzIlN1xceDlFKyglNCM2XFx4RjUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4RjZcXFwiXFxcIjEnM1xceEY3KzwkNzwrMiU3XFx4OUQrKCU0IzZcXHhGOCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx4RjkhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEZBXFxcIlxcXCIyXFx4RkEzXFx4RkIreCQhLkpcXFwiXFxcIjJKM0srUyQ3ISojIFxcXCIgWytDJTchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyclNFxcXCI2XFx4RkNcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3NitOJCE3PCstJDdcXHhBMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyspJTRcXFwiNlxceEZEXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjc2KikgXFxcIjdUKiMgXFxcIjdIXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEEyK18kIFxcXFwhN0IrLSQ3XFx4QTMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4QTMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEZFXFxcIlxcXCIxJjNcXHhGRipHIFxcXCIvXFx1MDEwMFxcXCJcXFwiMSczXFx1MDEwMSo7IFxcXCIvXFx1MDEwMlxcXCJcXFwiMSQzXFx1MDEwMyovIFxcXCIvXFx1MDEwNFxcXCJcXFwiMSUzXFx1MDEwNSojIFxcXCI3NismIDQhNlxcdTAxMDYhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhBNCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEwN1xcXCJcXFwiMSgzXFx1MDEwOCtPJDc8K0UlL1xcdTAxMDlcXFwiXFxcIjEoM1xcdTAxMEEqLyBcXFwiL1xcdTAxMEJcXFwiXFxcIjEoM1xcdTAxMEMqIyBcXFwiNzYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K18kIFxcXFwhN0ErLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDEwRCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTgrJiA0ITZcXHUwMTBFISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEE5K3MkNzsraSU3XFx4QUUrXyUgXFxcXCE3QistJDdcXHhBRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhBRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QUEqIyBcXFwiN1xceEFCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIvXFx1MDEwRlxcXCJcXFwiMSQzXFx1MDExMCpTIFxcXCIvXFx1MDExMVxcXCJcXFwiMSUzXFx1MDExMipHIFxcXCIvXFx1MDExM1xcXCJcXFwiMSUzXFx1MDExNCo7IFxcXCIvXFx1MDExNVxcXCJcXFwiMSUzXFx1MDExNiovIFxcXCIvXFx1MDExN1xcXCJcXFwiMSszXFx1MDExOCojIFxcXCI3XFx4QUNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi9cXHUwMTE5XFxcIlxcXCIxJzNcXHUwMTFBKi8gXFxcIi9cXHUwMTFCXFxcIlxcXCIxKTNcXHUwMTFDKiMgXFxcIjdcXHhBQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzYqIyBcXFwiN1xceEFEXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMURcXFwiXFxcIjFcXFwiM1xcdTAxMUUrLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEFDKiMgXFxcIjc2XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrNyQ3PCstJTdcXHhCMCsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3NiojIFxcXCI3SFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhCMis3JDcuKy0lN1xceDhGKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxMUYhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlEKycgNCE2XFx1MDEyMCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QjUrZCQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrKCU0XFxcIjZcXHUwMTIxXFxcIiEhJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NytrJCBcXFxcIS5KXFxcIlxcXCIySjNLKy0kNzcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLkpcXFwiXFxcIjJKM0srLSQ3NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKiMgXFxcIjdcXHg5OCtjJCBcXFxcITdCKy0kN1xceEI3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEI3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxMjJcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCOCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyM1xcXCJcXFwiMSMzXFx1MDEyNCs8JDc8KzIlNzYrKCU0IzZcXHUwMTI1IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTI2ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCsnIDQhNlxcdTAxMjchISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3XFx4OTksIyY3XFx4OTlcXFwiK1xceDgxJDdAK3clN00rbSU3PytjJSBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTQlNlxcdTAxMjglICUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCRFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTI5XFxcIlxcXCIxJjNcXHUwMTJBK3MkNy4raSU3XFx4QzArXyUgXFxcXCE3QSstJDdcXHhDMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhDMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdcXHhCRVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K3MkNy4raSU3XFx4QkYrXyUgXFxcXCE3QSstJDdcXHhCRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhCRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrPSQ3PCszJTc2KiMgXFxcIjdIKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhDMSpHIFxcXCI3XFx4QzMqQSBcXFwiN1xceEM1KjsgXFxcIjdcXHhDNyo1IFxcXCI3XFx4QzgqLyBcXFwiN1xceEM5KikgXFxcIjdcXHhDQSojIFxcXCI3XFx4QkZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyQlxcXCJcXFwiMSUzXFx1MDEyQys3JDc8Ky0lN1xceEMyKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3SSsnIDQhNlxcdTAxMkQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMkVcXFwiXFxcIjEmM1xcdTAxMkYrXFx4QTUkNzwrXFx4OUIlN0QrXFx4OTElN1xceEM0K1xceDg3JSBcXFxcISBcXFxcNycrJiQsIyY3J1xcXCJcXFwiXFxcIiBYKy0kN1xceEM0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLEcmISBcXFxcNycrJiQsIyY3J1xcXCJcXFwiXFxcIiBYKy0kN1xceEM0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIistJTdFKyMlJyYlJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjd0KiMgXFxcIjd3XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMzBcXFwiXFxcIjElM1xcdTAxMzErNyQ3PCstJTdcXHhDNisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0krJyA0ITZcXHUwMTMyISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTMzXFxcIlxcXCIxJjNcXHUwMTM0KzwkNzwrMiU3SSsoJTQjNlxcdTAxMzUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzNlxcXCJcXFwiMSUzXFx1MDEzNytfJDc8K1UlIS9cXHUwMTM4XFxcIlxcXCIxJDNcXHUwMTM5KyYgNCE2XFx1MDEzQSEgJSo0IFxcXCIhL1xcdTAxM0JcXFwiXFxcIjElM1xcdTAxM0MrJiA0ITZcXHUwMTNEISAlKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzRVxcXCJcXFwiMSkzXFx1MDEzRitUJDc8K0olL1xcdTAxNDBcXFwiXFxcIjEjM1xcdTAxNDEqLyBcXFwiL1xcdTAxNDJcXFwiXFxcIjEoM1xcdTAxNDMqIyBcXFwiNzYrKCU0IzZcXHUwMTQ0IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNDVcXFwiXFxcIjEjM1xcdTAxNDYrXFx4OUUkNzwrXFx4OTQlN0QrXFx4OEElITdcXHhDQitrJCBcXFxcIS5EXFxcIlxcXCIyRDNFKy0kN1xceENCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS5EXFxcIlxcXCIyRDNFKy0kN1xceENCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCstJTdFKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNDdcXFwiXFxcIjEoM1xcdTAxNDgqLyBcXFwiL1xcdTAxNDlcXFwiXFxcIjEkM1xcdTAxNEEqIyBcXFwiNzYrJyA0ITZcXHUwMTRCISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K18kIFxcXFwhN0ErLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhDRStLJDcuK0ElN1xceENFKzclNy4rLSU3XFx4OEYrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxNEMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEQwK2MkIFxcXFwhN0ErLSQ3XFx4RDArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4RDArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE0RFxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5OCtjJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxNEVcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TCpUIFxcXCI3XFx4OTgqTiBcXFwiITdAKiMgXFxcIiBbKz0kN3QrMyU3PyojIFxcXCIgWysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYK2MkIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE0RlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhEMytjJCBcXFxcITdCKy0kN1xceEQ0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEQ0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxNTBcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTUrJiA0ITZcXHUwMTUxISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNTJcXFwiXFxcIjEoM1xcdTAxNTMrPCQ3PCsyJTc2KyglNCM2XFx1MDE1NCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCpqIFxcXCIhL1xcdTAxNTVcXFwiXFxcIjEmM1xcdTAxNTYrPCQ3PCsyJTc2KyglNCM2XFx1MDE1NyMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCo6IFxcXCIhL1xcdTAxNThcXFwiXFxcIjEqM1xcdTAxNTkrJiA0ITZcXHUwMTVBISAlKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NitvJCBcXFxcITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWCw9JiE3QSsyJDc2KyglNFxcXCI2XFx1MDE1QlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcXFwiKyklNFxcXCI2XFx1MDE1Q1xcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKycgNCE2XFx1MDE1RCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RDcrXyQgXFxcXCE3QSstJDdcXHhENysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhENysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTgrXyQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxNUUhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceERBK18kIFxcXFwhN0IrLSQ3XFx4REIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4REIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNUZcXFwiXFxcIjEmM1xcdTAxNjAqOyBcXFwiL1xcdTAxNjFcXFwiXFxcIjEnM1xcdTAxNjIqLyBcXFwiL1xcdTAxNjNcXFwiXFxcIjEqM1xcdTAxNjQqIyBcXFwiNzYrJiA0ITZcXHUwMTY1ISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNjZcXFwiXFxcIjEmM1xcdTAxNjcrPCQ3PCsyJTdcXHhEQysoJTQjNlxcdTAxNjgjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx4ODMgXFxcIiEvXFx4RjZcXFwiXFxcIjEnM1xceEY3KzwkNzwrMiU3XFx4OUQrKCU0IzZcXHUwMTY5IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKlMgXFxcIiEvXFx1MDE2QVxcXCJcXFwiMSszXFx1MDE2Qis8JDc8KzIlN1xceDlEKyglNCM2XFx1MDE2QyMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi9cXHUwMTZEXFxcIlxcXCIxKzNcXHUwMTZFKmsgXFxcIi9cXHUwMTZGXFxcIlxcXCIxKTNcXHUwMTcwKl8gXFxcIi9cXHUwMTcxXFxcIlxcXCIxKDNcXHUwMTcyKlMgXFxcIi9cXHUwMTczXFxcIlxcXCIxJzNcXHUwMTc0KkcgXFxcIi9cXHUwMTc1XFxcIlxcXCIxJjNcXHUwMTc2KjsgXFxcIi9cXHUwMTc3XFxcIlxcXCIxKjNcXHUwMTc4Ki8gXFxcIi9cXHUwMTc5XFxcIlxcXCIxKTNcXHUwMTdBKiMgXFxcIjc2XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3MSojIFxcXCIgW1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NitvJCBcXFxcITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWCw9JiE3QSsyJDc2KyglNFxcXCI2XFx1MDE1QlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcXFwiKyklNFxcXCI2XFx1MDE1Q1xcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKycgNCE2XFx1MDE3QiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TCojIFxcXCI3XFx4OTgrYyQgXFxcXCE3QistJDdcXHhFMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhFMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTdDXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QjgqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEUyK18kIFxcXFwhN0ErLSQ3XFx4RTIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4RTIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEU5K3MkNy4raSU3XFx4RUMrXyUgXFxcXCE3QistJDdcXHhFMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhFMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4RTQqOyBcXFwiN1xceEU1KjUgXFxcIjdcXHhFNiovIFxcXCI3XFx4RTcqKSBcXFwiN1xceEU4KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTdEXFxcIlxcXCIxIzNcXHUwMTdFKzwkNzwrMiU3XFx4RUYrKCU0IzZcXHUwMTdGIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODBcXFwiXFxcIjElM1xcdTAxODErPCQ3PCsyJTdUKyglNCM2XFx1MDE4MiMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTgzXFxcIlxcXCIxKDNcXHUwMTg0K0IkNzwrOCU3XFxcXCojIFxcXCI3WSsoJTQjNlxcdTAxODUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4NlxcXCJcXFwiMSYzXFx1MDE4Nys8JDc8KzIlNzYrKCU0IzZcXHUwMTg4IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODlcXFwiXFxcIjElM1xcdTAxOEErVCQhNzwrNSQgXFxcXDchLCMmNyFcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyclNFxcXCI2XFx1MDE4QlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhFQStLJDc7K0ElNzYrNyU3OystJTdcXHhFQisjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHg5NVxcXCJcXFwiMSMzXFx4RDYqIyBcXFwiNzYrJyA0ITZcXHUwMThDISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhCNFxcXCJcXFwiMSMzXFx1MDE4RCpHIFxcXCIvXFx4QjZcXFwiXFxcIjEjM1xcdTAxOEUqOyBcXFwiL1xceEJBXFxcIlxcXCIxIzNcXHUwMThGKi8gXFxcIi9cXHhCOFxcXCJcXFwiMSQzXFx1MDE5MCojIFxcXCI3NisnIDQhNlxcdTAxOTEhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEVEK0gkITdDKy0kN1xceEVFKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1UqKSBcXFwiN1xcXFwqIyBcXFwiN1grJiA0ITZcXHUwMTkyISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITchKiMgXFxcIiBbK2MkNyEqIyBcXFwiIFsrUyU3ISojIFxcXCIgWytDJTchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrJyA0ITZcXHUwMTkzISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3IStDJDchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCsnIDQhNlxcdTAxOTQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QkRcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrZCQgXFxcXCE3QistJDdcXHhGMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhGMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrKCU0XFxcIjZcXHUwMTk1XFxcIiEhJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEYzKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHUwMTk2XFxcIlxcXCIyXFx1MDE5NjNcXHUwMTk3K04kNzwrRCUuXFx1MDE5OFxcXCJcXFwiMlxcdTAxOTgzXFx1MDE5OSopIFxcXCIuXFx1MDE5QVxcXCJcXFwiMlxcdTAxOUEzXFx1MDE5QisoJTQjNlxcdTAxOUMjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrZCQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrKCU0XFxcIjZcXHUwMTlEXFxcIiEhJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2KzckNzArLSU3XFx4RjYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3MiopIFxcXCI3NCojIFxcXCI3LiwvJjcyKikgXFxcIjc0KiMgXFxcIjcuXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3JSwjJjclXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhGOSs9JC44XFxcIlxcXCIyODM5Ky0lN1xceEZBKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE5RVxcXCJcXFwiMSUzXFx1MDE5RiopIFxcXCIvXFx1MDFBMFxcXCJcXFwiMSQzXFx1MDFBMSsnIDQhNlxcdTAxQTIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEZCK04kIS44XFxcIlxcXCIyODM5Ky0kN14rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFxcXCopIFxcXCI3WCojIFxcXCI3XFx4ODIrJyA0ITZcXHUwMUEzISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN1xceEZEKikgXFxcIjctKiMgXFxcIjdcXHhGRSwvJjdcXHhGRCopIFxcXCI3LSojIFxcXCI3XFx4RkVcXFwiKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXFwiKlMgXFxcIjchKk0gXFxcIi5GXFxcIlxcXCIyRjNHKkEgXFxcIi5KXFxcIlxcXCIySjNLKjUgXFxcIi5IXFxcIlxcXCIySDNJKikgXFxcIi5OXFxcIlxcXCIyTjNPXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuTFxcXCJcXFwiMkwzTSpcXHg5NSBcXFwiLkJcXFwiXFxcIjJCM0MqXFx4ODkgXFxcIi48XFxcIlxcXCIyPDM9Kn0gXFxcIi5SXFxcIlxcXCIyUjNTKnEgXFxcIi5UXFxcIlxcXCIyVDNVKmUgXFxcIi5WXFxcIlxcXCIyVjNXKlkgXFxcIi5QXFxcIlxcXCIyUDNRKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5EXFxcIlxcXCIyRDNFKjUgXFxcIi4yXFxcIlxcXCIyMjMzKikgXFxcIi4+XFxcIlxcXCIyPjM/XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDAraCQuOFxcXCJcXFwiMjgzOStYJTdcXHhGQStOJSEuXFx1MDFBNFxcXCJcXFwiMlxcdTAxQTQzXFx1MDFBNSstJDdcXHhFQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDFBNlxcXCJcXFwiMSUzXFx1MDFBNyopIFxcXCIvXFx1MDFBOFxcXCJcXFwiMSQzXFx1MDFBOSsnIDQhNlxcdTAxQTIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEVCK1EkL1xceEI0XFxcIlxcXCIxIzNcXHhCNSo3IFxcXCIvXFx4QjZcXFwiXFxcIjEjM1xceEI3KisgXFxcIiBcXFxcNyssIyY3K1xcXCIrJyU0XFxcIjZcXHUwMUFBXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDQrXFx4OEYkLkZcXFwiXFxcIjJGM0crfyU3XFx1MDEwMyt1JS5GXFxcIlxcXCIyRjNHK2UlN1xcdTAxMDMrWyUuRlxcXCJcXFwiMkYzRytLJTdcXHUwMTAzK0ElLkZcXFwiXFxcIjJGM0crMSU3XFx1MDEwNSsnJTQpNlxcdTAxQUIpICUkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcjK0EkNyMrNyU3IystJTcjKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHUwMTAzKy0kN1xcdTAxMDMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwMys3JDdcXHUwMTAzKy0lN1xcdTAxMDMrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKVxuICAgICAgICBdLFxuXG4gICAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfSxcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgICBwZWckc2lsZW50RmFpbHMgICAgICA9IDAsXG5cbiAgICAgICAgcGVnJHJlc3VsdDtcblxuICAgIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVJbmRpY2VzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHBlZyRzdGFydFJ1bGVJbmRleCA9IHBlZyRzdGFydFJ1bGVJbmRpY2VzW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckcmVwb3J0ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlcG9ydGVkUG9zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykubGluZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2x1bW4oKSB7XG4gICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykuY29sdW1uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICAgIG51bGwsXG4gICAgICAgIFt7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIG51bGwsIHBlZyRyZXBvcnRlZFBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgICAgZnVuY3Rpb24gYWR2YW5jZShkZXRhaWxzLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBwLCBjaDtcblxuICAgICAgICBmb3IgKHAgPSBzdGFydFBvczsgcCA8IGVuZFBvczsgcCsrKSB7XG4gICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMuc2VlbkNSKSB7IGRldGFpbHMubGluZSsrOyB9XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7XG4gICAgICAgIGlmIChwZWckY2FjaGVkUG9zID4gcG9zKSB7XG4gICAgICAgICAgcGVnJGNhY2hlZFBvcyA9IDA7XG4gICAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2UocGVnJGNhY2hlZFBvc0RldGFpbHMsIHBlZyRjYWNoZWRQb3MsIHBvcyk7XG4gICAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlscztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgZXhwZWN0ZWQsIHBvcykge1xuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciBpID0gMTtcblxuICAgICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYS5kZXNjcmlwdGlvbiA8IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChleHBlY3RlZFtpIC0gMV0gPT09IGV4cGVjdGVkW2ldKSB7XG4gICAgICAgICAgICBleHBlY3RlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykge1xuICAgICAgICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuXG4gICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICAgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAgICAnXFxcXFwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAgICdcXFxcdCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICAgJ1xcXFxuJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywgICAnXFxcXGYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAgICdcXFxccicpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRVxceDBGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDgwLVxceEZGXS9nLCAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMTgwLVxcdTBGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdTAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MTA4MC1cXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUnICArIGhleChjaCk7IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRGVzY3MgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcbiAgICAgICAgICAgIGV4cGVjdGVkRGVzYywgZm91bmREZXNjLCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGV4cGVjdGVkRGVzY3NbaV0gPSBleHBlY3RlZFtpXS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdGVkRGVzYyA9IGV4cGVjdGVkLmxlbmd0aCA+IDFcbiAgICAgICAgICA/IGV4cGVjdGVkRGVzY3Muc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXVxuICAgICAgICAgIDogZXhwZWN0ZWREZXNjc1swXTtcblxuICAgICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFwiXFxcIlwiICsgc3RyaW5nRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcblxuICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkRGVzYyArIFwiIGJ1dCBcIiArIGZvdW5kRGVzYyArIFwiIGZvdW5kLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpLFxuICAgICAgICAgIGZvdW5kICAgICAgPSBwb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocG9zKSA6IG51bGw7XG5cbiAgICAgIGlmIChleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcG9zRGV0YWlscy5saW5lLFxuICAgICAgICBwb3NEZXRhaWxzLmNvbHVtblxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckZGVjb2RlKHMpIHtcbiAgICAgIHZhciBiYyA9IG5ldyBBcnJheShzLmxlbmd0aCksIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJjW2ldID0gcy5jaGFyQ29kZUF0KGkpIC0gMzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VSdWxlKGluZGV4KSB7XG4gICAgICB2YXIgYmMgICAgPSBwZWckYnl0ZWNvZGVbaW5kZXhdLFxuICAgICAgICAgIGlwICAgID0gMCxcbiAgICAgICAgICBpcHMgICA9IFtdLFxuICAgICAgICAgIGVuZCAgID0gYmMubGVuZ3RoLFxuICAgICAgICAgIGVuZHMgID0gW10sXG4gICAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgICBwYXJhbXMsIGk7XG5cbiAgICAgIGZ1bmN0aW9uIHByb3RlY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iamVjdCkgPT09IFwiW29iamVjdCBBcnJheV1cIiA/IFtdIDogb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB3aGlsZSAoaXAgPCBlbmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGJjW2lwXSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHByb3RlY3QocGVnJGNvbnN0c1tiY1tpcCArIDFdXSkpO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCAtPSBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoLTIsIDEpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wdXNoKHN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAxXSwgYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChpbnB1dC5zdWJzdHJpbmcoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sIHBlZyRjdXJyUG9zKSk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwKTtcblxuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMiArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpcCArPSAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBwZWckY29uc3RzW2JjW2lwICsgMV1dKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0udGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRGQUlMRUQpO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGNvbnN0c1tiY1tpcCArIDFdXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBiY1tpcCArIDFdXTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcGFyYW1zID0gYmMuc2xpY2UoaXAgKyA0LCBpcCArIDQgKyBiY1tpcCArIDNdKTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJjW2lwICsgM107IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBwYXJhbXNbaV1dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKFxuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCAtIGJjW2lwICsgMl0sXG4gICAgICAgICAgICAgICAgYmNbaXAgKyAyXSxcbiAgICAgICAgICAgICAgICBwZWckY29uc3RzW2JjW2lwICsgMV1dLmFwcGx5KG51bGwsIHBhcmFtcylcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJHBhcnNlUnVsZShiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGNvZGU6IFwiICsgYmNbaXBdICsgXCIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbmQgPSBlbmRzLnBvcCgpO1xuICAgICAgICAgIGlwID0gaXBzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9XG5cblxuICAgICAgb3B0aW9ucy5kYXRhID0ge307IC8vIE9iamVjdCB0byB3aGljaCBoZWFkZXIgYXR0cmlidXRlcyB3aWxsIGJlIGFzc2lnbmVkIGR1cmluZyBwYXJzaW5nXG5cbiAgICAgIGZ1bmN0aW9uIGxpc3QgKGZpcnN0LCByZXN0KSB7XG4gICAgICAgIHJldHVybiBbZmlyc3RdLmNvbmNhdChyZXN0KTtcbiAgICAgIH1cblxuXG4gICAgcGVnJHJlc3VsdCA9IHBlZyRwYXJzZVJ1bGUocGVnJHN0YXJ0UnVsZUluZGV4KTtcblxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICAgIHBhcnNlOiAgICAgICBwYXJzZVxuICB9O1xufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvR3JhbW1hci9kaXN0L0dyYW1tYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9wbGV2ZWwgPSBnbG9iYWwud2luZG93IHx8IGdsb2JhbDtcblxuZnVuY3Rpb24gZ2V0UHJlZml4ZWRQcm9wZXJ0eSAob2JqZWN0LCBuYW1lKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FwaXRhbGl6ZWROYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gIHZhciBwcmVmaXhlZE5hbWVzID0gW25hbWUsICd3ZWJraXQnICsgY2FwaXRhbGl6ZWROYW1lLCAnbW96JyArIGNhcGl0YWxpemVkTmFtZV07XG4gIGZvciAodmFyIGkgaW4gcHJlZml4ZWROYW1lcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IG9iamVjdFtwcmVmaXhlZE5hbWVzW2ldXTtcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eS5iaW5kKG9iamVjdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJTb2NrZXQ6IHRvcGxldmVsLldlYlNvY2tldCxcbiAgVHJhbnNwb3J0OiByZXF1aXJlKCcuL1RyYW5zcG9ydCcpLFxuICBvcGVuOiB0b3BsZXZlbC5vcGVuLFxuICBQcm9taXNlOiB0b3BsZXZlbC5Qcm9taXNlLFxuICB0aW1lcnM6IHRvcGxldmVsLFxuXG4gIC8vIENvbnNvbGUgaXMgbm90IGRlZmluZWQgaW4gRUNNQVNjcmlwdCwgc28ganVzdCBpbiBjYXNlLi4uXG4gIGNvbnNvbGU6IHRvcGxldmVsLmNvbnNvbGUgfHwge1xuICAgIGRlYnVnOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBsb2c6IGZ1bmN0aW9uICgpIHt9LFxuICAgIHdhcm46IGZ1bmN0aW9uICgpIHt9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7fVxuICB9LFxuXG4gIE1lZGlhU3RyZWFtOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnTWVkaWFTdHJlYW0nKSxcbiAgZ2V0VXNlck1lZGlhOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLm5hdmlnYXRvciwgJ2dldFVzZXJNZWRpYScpLFxuICBSVENQZWVyQ29ubmVjdGlvbjogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ1JUQ1BlZXJDb25uZWN0aW9uJyksXG4gIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ1JUQ1Nlc3Npb25EZXNjcmlwdGlvbicpLFxuXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwsICdhZGRFdmVudExpc3RlbmVyJyksXG4gIEhUTUxNZWRpYUVsZW1lbnQ6IHRvcGxldmVsLkhUTUxNZWRpYUVsZW1lbnQsXG5cbiAgYXR0YWNoTWVkaWFTdHJlYW06IHRvcGxldmVsLmF0dGFjaE1lZGlhU3RyZWFtLFxuICBjcmVhdGVPYmplY3RVUkw6IHRvcGxldmVsLlVSTCAmJiB0b3BsZXZlbC5VUkwuY3JlYXRlT2JqZWN0VVJMLFxuICByZXZva2VPYmplY3RVUkw6IHRvcGxldmVsLlVSTCAmJiB0b3BsZXZlbC5VUkwucmV2b2tlT2JqZWN0VVJMXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9lbnZpcm9ubWVudF9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBUcmFuc3BvcnRcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBUcmFuc3BvcnRcbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZlciB3c19zZXJ2ZXIgT2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgV2ViU29ja2V0KSB7XG52YXIgVHJhbnNwb3J0LFxuICBDID0ge1xuICAgIC8vIFRyYW5zcG9ydCBzdGF0dXMgY29kZXNcbiAgICBTVEFUVVNfUkVBRFk6ICAgICAgICAwLFxuICAgIFNUQVRVU19ESVNDT05ORUNURUQ6IDEsXG4gICAgU1RBVFVTX0VSUk9SOiAgICAgICAgMlxuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzZW5kaW5nIGFub3RoZXJcbiAqIGtlZXAtYWxpdmUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb21wdXRlS2VlcEFsaXZlVGltZW91dCh1cHBlckJvdW5kKSB7XG4gIHZhciBsb3dlckJvdW5kID0gdXBwZXJCb3VuZCAqIDAuODtcbiAgcmV0dXJuIDEwMDAgKiAoTWF0aC5yYW5kb20oKSAqICh1cHBlckJvdW5kIC0gbG93ZXJCb3VuZCkgKyBsb3dlckJvdW5kKTtcbn1cblxuVHJhbnNwb3J0ID0gZnVuY3Rpb24odWEsIHNlcnZlcikge1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNwb3J0Jyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy53cyA9IG51bGw7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9IDA7XG4gIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvciA9IHt9O1xuXG4gIHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgPSB1YS5jb25maWd1cmF0aW9uLmtlZXBBbGl2ZUludGVydmFsO1xuICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBudWxsO1xuICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gbnVsbDtcblxuICB0aGlzLnVhLnRyYW5zcG9ydCA9IHRoaXM7XG5cbiAgLy8gQ29ubmVjdFxuICB0aGlzLmNvbm5lY3QoKTtcbn07XG5cblRyYW5zcG9ydC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fFN0cmluZ30gbXNnXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBtc2cudG9TdHJpbmcoKTtcblxuICAgIGlmKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3NlbmRpbmcgV2ViU29ja2V0IG1lc3NhZ2U6XFxuXFxuJyArIG1lc3NhZ2UgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLndzLnNlbmQobWVzc2FnZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigndW5hYmxlIHRvIHNlbmQgbWVzc2FnZSwgV2ViU29ja2V0IGlzIG5vdCBvcGVuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIGEga2VlcC1hbGl2ZSAoYSBkb3VibGUtQ1JMRiBzZXF1ZW5jZSkuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgc2VuZEtlZXBBbGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5rZWVwQWxpdmVUaW1lb3V0KSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy51YS5lbWl0KCdrZWVwQWxpdmVUaW1lb3V0Jyk7XG4gICAgfS5iaW5kKHRoaXMpLCAxMDAwMCk7XG5cbiAgICByZXR1cm4gdGhpcy5zZW5kKCdcXHJcXG5cXHJcXG4nKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgc2VuZGluZyBrZWVwLWFsaXZlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmtlZXBBbGl2ZUludGVydmFsICYmICF0aGlzLmtlZXBBbGl2ZVRpbWVyKSB7XG4gICAgICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbmRLZWVwQWxpdmUoKTtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnRTZW5kaW5nS2VlcEFsaXZlcygpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBjb21wdXRlS2VlcEFsaXZlVGltZW91dCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9wIHNlbmRpbmcga2VlcC1hbGl2ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdG9wU2VuZGluZ0tlZXBBbGl2ZXM6IGZ1bmN0aW9uKCkge1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlVGltZXIpO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlVGltZW91dCk7XG4gICAgdGhpcy5rZWVwQWxpdmVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgKiBEaXNjb25uZWN0IHNvY2tldC5cbiAgKi9cbiAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy53cykge1xuICAgICAgLy8gQ2xlYXIgcmVjb25uZWN0VGltZXJcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuXG4gICAgICB0aGlzLnN0b3BTZW5kaW5nS2VlcEFsaXZlcygpO1xuXG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ2Nsb3NpbmcgV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkpO1xuICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy51YS5lbWl0KCdkaXNjb25uZWN0ZWQnLCB7XG4gICAgICAgIHRyYW5zcG9ydDogdGhpcyxcbiAgICAgICAgY29kZTogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IuY29kZSxcbiAgICAgICAgcmVhc29uOiB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5yZWFzb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBDb25uZWN0IHNvY2tldC5cbiAgKi9cbiAgY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zcG9ydCA9IHRoaXM7XG5cbiAgICBpZih0aGlzLndzICYmICh0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ1dlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJyBpcyBhbHJlYWR5IGNvbm5lY3RlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMud3MpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2Nvbm5lY3RpbmcgdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkpO1xuICAgIHRoaXMudWEub25UcmFuc3BvcnRDb25uZWN0aW5nKHRoaXMsXG4gICAgICAodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPT09IDApPzE6dGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMuc2VydmVyLndzX3VyaSwgJ3NpcCcpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignZXJyb3IgY29ubmVjdGluZyB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICc6ICcgKyBlKTtcbiAgICB9XG5cbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyYW5zcG9ydC5vbk9wZW4oKTtcbiAgICB9O1xuXG4gICAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgICAgdHJhbnNwb3J0Lm9uQ2xvc2UoZSk7XG4gICAgfTtcblxuICAgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgdHJhbnNwb3J0Lm9uTWVzc2FnZShlKTtcbiAgICB9O1xuXG4gICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgdHJhbnNwb3J0Lm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgfSxcblxuICAvLyBUcmFuc3BvcnQgRXZlbnQgSGFuZGxlcnNcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgY29ubmVjdGVkJyk7XG4gICAgLy8gQ2xlYXIgcmVjb25uZWN0VGltZXIgc2luY2Ugd2UgYXJlIG5vdCBkaXNjb25uZWN0ZWRcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLy8gUmVzZXQgcmVjb25uZWN0aW9uX2F0dGVtcHRzXG4gICAgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPSAwO1xuICAgIC8vIERpc2FibGUgY2xvc2VkXG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAvLyBUcmlnZ2VyIG9uVHJhbnNwb3J0Q29ubmVjdGVkIGNhbGxiYWNrXG4gICAgdGhpcy51YS5vblRyYW5zcG9ydENvbm5lY3RlZCh0aGlzKTtcbiAgICAvLyBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzXG4gICAgdGhpcy5zdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICogQGV2ZW50XG4gICogQHBhcmFtIHtldmVudH0gZVxuICAqL1xuICBvbkNsb3NlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNvbm5lY3RlZF9iZWZvcmUgPSB0aGlzLmNvbm5lY3RlZDtcblxuICAgIHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLmNvZGUgPSBlLmNvZGU7XG4gICAgdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IucmVhc29uID0gZS5yZWFzb247XG5cbiAgICB0aGlzLnN0b3BTZW5kaW5nS2VlcEFsaXZlcygpO1xuXG4gICAgaWYgKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID4gMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCAnICsgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgKyAnIGZhaWxlZCAoY29kZTogJyArIGUuY29kZSArIChlLnJlYXNvbj8gJ3wgcmVhc29uOiAnICsgZS5yZWFzb24gOiAnJykgKycpJyk7XG4gICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkIChjb2RlOiAnICsgZS5jb2RlICsgKGUucmVhc29uPyAnfCByZWFzb246ICcgKyBlLnJlYXNvbiA6ICcnKSArJyknKTtcblxuICAgICAgaWYoZS53YXNDbGVhbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybignV2ViU29ja2V0IGFicnVwdCBkaXNjb25uZWN0aW9uJyk7XG4gICAgICB9XG4gICAgICAvLyBUcmFuc3BvcnQgd2FzIGNvbm5lY3RlZFxuICAgICAgaWYoY29ubmVjdGVkX2JlZm9yZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVhLm9uVHJhbnNwb3J0Q2xvc2VkKHRoaXMpO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIHJlcXVlc3RlZCB0byBjbG9zZS5cbiAgICAgICAgaWYoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVhLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogdGhpcyxcbiAgICAgICAgICAgIGNvZGU6IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLmNvZGUsXG4gICAgICAgICAgICByZWFzb246IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLnJlYXNvblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAgICAvL05ldHdvcmsgZXJyb3JcbiAgICAgICAgdGhpcy51YS5vblRyYW5zcG9ydEVycm9yKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uTWVzc2FnZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciBtZXNzYWdlLCB0cmFuc2FjdGlvbixcbiAgICAgIGRhdGEgPSBlLmRhdGE7XG5cbiAgICAvLyBDUkxGIEtlZXAgQWxpdmUgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuIElnbm9yZSBpdC5cbiAgICBpZihkYXRhID09PSAnXFxyXFxuJykge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVUaW1lb3V0KTtcbiAgICAgIHRoaXMua2VlcEFsaXZlVGltZW91dCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdyZWNlaXZlZCBXZWJTb2NrZXQgbWVzc2FnZSB3aXRoIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgfSBjYXRjaChldnQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybigncmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlIGZhaWxlZCB0byBiZSBjb252ZXJ0ZWQgaW50byBzdHJpbmcsIG1lc3NhZ2UgZGlzY2FyZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY2VpdmVkIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZTpcXG5cXG4nICsgZGF0YSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZWJTb2NrZXQgdGV4dCBtZXNzYWdlLlxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY2VpdmVkIFdlYlNvY2tldCB0ZXh0IG1lc3NhZ2U6XFxuXFxuJyArIGRhdGEgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IFNJUC5QYXJzZXIucGFyc2VNZXNzYWdlKGRhdGEsIHRoaXMudWEpO1xuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYodGhpcy51YS5zdGF0dXMgPT09IFNJUC5VQS5DLlNUQVRVU19VU0VSX0NMT1NFRCAmJiBtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvIHNvbWUgc2FuaXR5IGNoZWNrXG4gICAgaWYoU0lQLnNhbml0eUNoZWNrKG1lc3NhZ2UsIHRoaXMudWEsIHRoaXMpKSB7XG4gICAgICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVxdWVzdCkge1xuICAgICAgICBtZXNzYWdlLnRyYW5zcG9ydCA9IHRoaXM7XG4gICAgICAgIHRoaXMudWEucmVjZWl2ZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1Jlc3BvbnNlKSB7XG4gICAgICAgIC8qIFVuaWtlIHN0YXRlZCBpbiAxOC4xLjIsIGlmIGEgcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgKiBhbnkgdHJhbnNhY3Rpb24sIGl0IGlzIGRpc2NhcmRlZCBoZXJlIGFuZCBubyBwYXNzZWQgdG8gdGhlIGNvcmVcbiAgICAgICAgKiBpbiBvcmRlciB0byBiZSBkaXNjYXJkZWQgdGhlcmUuXG4gICAgICAgICovXG4gICAgICAgIHN3aXRjaChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLnVhLnRyYW5zYWN0aW9ucy5pY3RbbWVzc2FnZS52aWFfYnJhbmNoXTtcbiAgICAgICAgICAgIGlmKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlIDstKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy51YS50cmFuc2FjdGlvbnMubmljdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgICAgICAgaWYodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQGV2ZW50XG4gICogQHBhcmFtIHtldmVudH0gZVxuICAqL1xuICBvbkVycm9yOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignV2ViU29ja2V0IGNvbm5lY3Rpb24gZXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICogUmVjb25uZWN0aW9uIGF0dGVtcHQgbG9naWMuXG4gICogQHByaXZhdGVcbiAgKi9cbiAgcmVjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcztcblxuICAgIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzICs9IDE7XG5cbiAgICBpZih0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA+IHRoaXMudWEuY29uZmlndXJhdGlvbi53c1NlcnZlck1heFJlY29ubmVjdGlvbikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignbWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgZm9yIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpKTtcbiAgICAgIHRoaXMudWEub25UcmFuc3BvcnRFcnJvcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID09PSAxKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ0Nvbm5lY3Rpb24gdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIHNldmVyZWQsIGF0dGVtcHRpbmcgZmlyc3QgcmVjb25uZWN0Jyk7XG4gICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ3RyeWluZyB0byByZWNvbm5lY3QgdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIChyZWNvbm5lY3Rpb24gYXR0ZW1wdCAnICsgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgKyAnKScpO1xuXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgICAgICB0cmFuc3BvcnQucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgfSwgdGhpcy51YS5jb25maWd1cmF0aW9uLndzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCAqIDEwMDApO1xuICAgIH1cbiAgfVxufTtcblxuVHJhbnNwb3J0LkMgPSBDO1xucmV0dXJuIFRyYW5zcG9ydDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1RyYW5zcG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==