(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RcPhone"] = factory();
	else
		root["RcPhone"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _slicedToArray2 = __webpack_require__(45);
	
	var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _addModule = __webpack_require__(119);
	
	var _addModule2 = _interopRequireDefault(_addModule);
	
	var _ringcentral = __webpack_require__(120);
	
	var _ringcentral2 = _interopRequireDefault(_ringcentral);
	
	var _ringcentralClient = __webpack_require__(132);
	
	var _ringcentralClient2 = _interopRequireDefault(_ringcentralClient);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _settings = __webpack_require__(152);
	
	var _settings2 = _interopRequireDefault(_settings);
	
	var _brand = __webpack_require__(166);
	
	var _brand2 = _interopRequireDefault(_brand);
	
	var _auth = __webpack_require__(169);
	
	var _auth2 = _interopRequireDefault(_auth);
	
	var _subscription = __webpack_require__(192);
	
	var _subscription2 = _interopRequireDefault(_subscription);
	
	var _user = __webpack_require__(199);
	
	var _user2 = _interopRequireDefault(_user);
	
	var _webphone = __webpack_require__(203);
	
	var _webphone2 = _interopRequireDefault(_webphone);
	
	var _redux = __webpack_require__(153);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var REDUCER = (0, _symbol2.default)();
	
	function getStoreRegisterAndResolver() {
	  var handlers = new _set2.default();
	  return [function (fn) {
	    return handlers.add(fn);
	  }, function (store) {
	    return handlers.forEach(function (fn) {
	      return fn(store);
	    });
	  }];
	}
	
	var RcPhone = function (_RcModule) {
	  (0, _inherits3.default)(RcPhone, _RcModule);
	
	  function RcPhone(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var getStore = _ref.getStore;
	    var _stateMapper = _ref.stateMapper;
	    var _ref$prefix = _ref.prefix;
	    var prefix = _ref$prefix === undefined ? 'rc' : _ref$prefix;
	    var sdkSettings = _ref.sdkSettings;
	    var defaultBrand = _ref.defaultBrand;
	    (0, _classCallCheck3.default)(this, RcPhone);
	
	    var register = registerStoreHandler;
	    var resolve = void 0;
	    if (!register) {
	      var _getStoreRegisterAndR = getStoreRegisterAndResolver();
	
	      var _getStoreRegisterAndR2 = (0, _slicedToArray3.default)(_getStoreRegisterAndR, 2);
	
	      register = _getStoreRegisterAndR2[0];
	      resolve = _getStoreRegisterAndR2[1];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(RcPhone).call(this, {
	      registerStoreHandler: register,
	      stateMapper: _stateMapper
	    }));
	
	    _addModule2.default.call(_this, 'sdk', new _ringcentral2.default((0, _extends3.default)({
	
	      cachePrefix: prefix + '-'
	    }, sdkSettings)));
	
	    _addModule2.default.call(_this, 'platform', _this.sdk.platform());
	
	    _addModule2.default.call(_this, 'api', new _ringcentralClient2.default(_this.sdk));
	
	    _addModule2.default.call(_this, 'auth', new _auth2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).auth;
	      },
	      prefix: prefix,
	      platform: _this.platform
	    }));
	
	    _addModule2.default.call(_this, 'settings', new _settings2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).settings;
	      }
	    }));
	
	    _addModule2.default.call(_this, 'defaultBrand', new _brand2.default((0, _extends3.default)({
	      registerStoreHandler: register,
	      prefix: prefix + '-default',
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).defaultBrand;
	      }
	    }, defaultBrand)));
	
	    _addModule2.default.call(_this, 'subscription', new _subscription2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).subscription;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      sdk: _this.sdk,
	      auth: _this.auth
	    }));
	
	    _addModule2.default.call(_this, 'user', new _user2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).user;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    _addModule2.default.call(_this, 'webphone', new _webphone2.default({
	      registerStoreHandler: register,
	      stateMapper: function stateMapper(state) {
	        return _stateMapper(state).webphone;
	      },
	      prefix: prefix,
	      api: _this.api,
	      platform: _this.platform,
	      settings: _this.settings
	    }));
	
	    // combine reducers
	    _this[REDUCER] = (0, _redux.combineReducers)({
	      auth: _this.auth.reducer,
	      defaultBrand: _this.defaultBrand.reducer,
	      subscription: _this.subscription.reducer,
	      user: _this.user.reducer,
	      webphone: _this.webphone.reducer,
	      settings: _this.settings.reducer
	    });
	
	    if (resolve) {
	      resolve(getStore(_this.reducer));
	      // resolve(createStore(this.reducer));
	    }
	    return _this;
	  }
	
	  (0, _createClass3.default)(RcPhone, [{
	    key: 'reducer',
	    get: function get() {
	      return this[REDUCER];
	    }
	  }]);
	  return RcPhone;
	}(_rcModule2.default);
	
	exports.default = RcPhone;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(4), __esModule: true };

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	module.exports = __webpack_require__(8).Object.assign;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(6);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(21)});

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , core      = __webpack_require__(8)
	  , ctx       = __webpack_require__(9)
	  , hide      = __webpack_require__(11)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 7 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 8 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(10);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(12)
	  , createDesc = __webpack_require__(20);
	module.exports = __webpack_require__(16) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(13)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , toPrimitive    = __webpack_require__(19)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(16) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function(){
	  return Object.defineProperty(__webpack_require__(18)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(17)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , document = __webpack_require__(7).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(22)
	  , gOPS     = __webpack_require__(37)
	  , pIE      = __webpack_require__(38)
	  , toObject = __webpack_require__(39)
	  , IObject  = __webpack_require__(26)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(17)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(23)
	  , enumBugKeys = __webpack_require__(36);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(24)
	  , toIObject    = __webpack_require__(25)
	  , arrayIndexOf = __webpack_require__(29)(false)
	  , IE_PROTO     = __webpack_require__(33)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(26)
	  , defined = __webpack_require__(28);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(27);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(25)
	  , toLength  = __webpack_require__(30)
	  , toIndex   = __webpack_require__(32);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(31)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(34)('keys')
	  , uid    = __webpack_require__(35);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(7)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 37 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 38 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(28);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(41), __esModule: true };

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(42);
	module.exports = __webpack_require__(8).Object.getPrototypeOf;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(39)
	  , $getPrototypeOf = __webpack_require__(43);
	
	__webpack_require__(44)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(24)
	  , toObject    = __webpack_require__(39)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(6)
	  , core    = __webpack_require__(8)
	  , fails   = __webpack_require__(17);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _isIterable2 = __webpack_require__(46);
	
	var _isIterable3 = _interopRequireDefault(_isIterable2);
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	
	    try {
	      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	
	    return _arr;
	  }
	
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if ((0, _isIterable3.default)(Object(arr))) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(47), __esModule: true };

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(64);

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	var global        = __webpack_require__(7)
	  , hide          = __webpack_require__(11)
	  , Iterators     = __webpack_require__(52)
	  , TO_STRING_TAG = __webpack_require__(61)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(50)
	  , step             = __webpack_require__(51)
	  , Iterators        = __webpack_require__(52)
	  , toIObject        = __webpack_require__(25);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(53)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(54)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , hide           = __webpack_require__(11)
	  , has            = __webpack_require__(24)
	  , Iterators      = __webpack_require__(52)
	  , $iterCreate    = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(60)
	  , getPrototypeOf = __webpack_require__(43)
	  , ITERATOR       = __webpack_require__(61)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(57)
	  , descriptor     = __webpack_require__(20)
	  , setToStringTag = __webpack_require__(60)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(61)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(13)
	  , dPs         = __webpack_require__(58)
	  , enumBugKeys = __webpack_require__(36)
	  , IE_PROTO    = __webpack_require__(33)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(18)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(59).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(12)
	  , anObject = __webpack_require__(13)
	  , getKeys  = __webpack_require__(22);
	
	module.exports = __webpack_require__(16) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(7).document && document.documentElement;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f
	  , has = __webpack_require__(24)
	  , TAG = __webpack_require__(61)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(34)('wks')
	  , uid        = __webpack_require__(35)
	  , Symbol     = __webpack_require__(7).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(63)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(53)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(31)
	  , defined   = __webpack_require__(28);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).isIterable = function(it){
	  var O = Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || Iterators.hasOwnProperty(classof(O));
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(27)
	  , TAG = __webpack_require__(61)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(67), __esModule: true };

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(62);
	module.exports = __webpack_require__(68);

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13)
	  , get      = __webpack_require__(69);
	module.exports = __webpack_require__(8).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(65)
	  , ITERATOR  = __webpack_require__(61)('iterator')
	  , Iterators = __webpack_require__(52);
	module.exports = __webpack_require__(8).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(73), __esModule: true };

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(74);
	var $Object = __webpack_require__(8).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(16), 'Object', {defineProperty: __webpack_require__(12).f});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(77);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(78), __esModule: true };

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(48);
	module.exports = __webpack_require__(79).f('iterator');

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(61);

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(81), __esModule: true };

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(82);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	module.exports = __webpack_require__(8).Symbol;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(7)
	  , has            = __webpack_require__(24)
	  , DESCRIPTORS    = __webpack_require__(16)
	  , $export        = __webpack_require__(6)
	  , redefine       = __webpack_require__(55)
	  , META           = __webpack_require__(83).KEY
	  , $fails         = __webpack_require__(17)
	  , shared         = __webpack_require__(34)
	  , setToStringTag = __webpack_require__(60)
	  , uid            = __webpack_require__(35)
	  , wks            = __webpack_require__(61)
	  , wksExt         = __webpack_require__(79)
	  , wksDefine      = __webpack_require__(84)
	  , keyOf          = __webpack_require__(85)
	  , enumKeys       = __webpack_require__(86)
	  , isArray        = __webpack_require__(87)
	  , anObject       = __webpack_require__(13)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , createDesc     = __webpack_require__(20)
	  , _create        = __webpack_require__(57)
	  , gOPNExt        = __webpack_require__(88)
	  , $GOPD          = __webpack_require__(90)
	  , $DP            = __webpack_require__(12)
	  , $keys          = __webpack_require__(22)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(89).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(38).f  = $propertyIsEnumerable;
	  __webpack_require__(37).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(54)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(35)('meta')
	  , isObject = __webpack_require__(14)
	  , has      = __webpack_require__(24)
	  , setDesc  = __webpack_require__(12).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(17)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(7)
	  , core           = __webpack_require__(8)
	  , LIBRARY        = __webpack_require__(54)
	  , wksExt         = __webpack_require__(79)
	  , defineProperty = __webpack_require__(12).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(22)
	  , toIObject = __webpack_require__(25);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(22)
	  , gOPS    = __webpack_require__(37)
	  , pIE     = __webpack_require__(38);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(27);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(25)
	  , gOPN      = __webpack_require__(89).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(23)
	  , hiddenKeys = __webpack_require__(36).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(38)
	  , createDesc     = __webpack_require__(20)
	  , toIObject      = __webpack_require__(25)
	  , toPrimitive    = __webpack_require__(19)
	  , has            = __webpack_require__(24)
	  , IE8_DOM_DEFINE = __webpack_require__(15)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(16) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 91 */
/***/ function(module, exports) {



/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('asyncIterator');

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(84)('observable');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(95);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(99);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(96), __esModule: true };

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(97);
	module.exports = __webpack_require__(8).Object.setPrototypeOf;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(6);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(98).set});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14)
	  , anObject = __webpack_require__(13);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(9)(Function.call, __webpack_require__(90).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(101);
	var $Object = __webpack_require__(8).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(6)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(57)});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(104);
	__webpack_require__(116);
	module.exports = __webpack_require__(8).Set;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(105);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(112)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(12).f
	  , create      = __webpack_require__(57)
	  , hide        = __webpack_require__(11)
	  , redefineAll = __webpack_require__(106)
	  , ctx         = __webpack_require__(9)
	  , anInstance  = __webpack_require__(107)
	  , defined     = __webpack_require__(28)
	  , forOf       = __webpack_require__(108)
	  , $iterDefine = __webpack_require__(53)
	  , step        = __webpack_require__(51)
	  , setSpecies  = __webpack_require__(111)
	  , DESCRIPTORS = __webpack_require__(16)
	  , fastKey     = __webpack_require__(83).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(11);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(9)
	  , call        = __webpack_require__(109)
	  , isArrayIter = __webpack_require__(110)
	  , anObject    = __webpack_require__(13)
	  , toLength    = __webpack_require__(30)
	  , getIterFn   = __webpack_require__(69)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(52)
	  , ITERATOR   = __webpack_require__(61)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(7)
	  , core        = __webpack_require__(8)
	  , dP          = __webpack_require__(12)
	  , DESCRIPTORS = __webpack_require__(16)
	  , SPECIES     = __webpack_require__(61)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(7)
	  , $export        = __webpack_require__(6)
	  , meta           = __webpack_require__(83)
	  , fails          = __webpack_require__(17)
	  , hide           = __webpack_require__(11)
	  , redefineAll    = __webpack_require__(106)
	  , forOf          = __webpack_require__(108)
	  , anInstance     = __webpack_require__(107)
	  , isObject       = __webpack_require__(14)
	  , setToStringTag = __webpack_require__(60)
	  , dP             = __webpack_require__(12).f
	  , each           = __webpack_require__(113)(0)
	  , DESCRIPTORS    = __webpack_require__(16);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(9)
	  , IObject  = __webpack_require__(26)
	  , toObject = __webpack_require__(39)
	  , toLength = __webpack_require__(30)
	  , asc      = __webpack_require__(114);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(115);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14)
	  , isArray  = __webpack_require__(87)
	  , SPECIES  = __webpack_require__(61)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(6);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(117)('Set')});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(65)
	  , from    = __webpack_require__(118);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(108);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	exports.default = addModule;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function addModule(name, module) {
	  if (Object.prototype.hasOwnProperty.call(this, name)) {
	    throw new Error("module '" + name + "' already exists...");
	  }
	
	  (0, _defineProperty2.default)(this, name, {
	    get: function get() {
	      return module;
	    },
	
	    enumerable: true
	  });
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(126), __webpack_require__(130), __webpack_require__(131));
		else if(typeof define === 'function' && define.amd)
			define([, , "pubnub"], factory);
		else if(typeof exports === 'object')
			exports["SDK"] = factory(require("es6-promise"), require("node-fetch"), require("pubnub"));
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["SDK"] = factory(root[undefined], root[undefined], root[undefined]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/build/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	__webpack_require__(2);
	
	var _Utils = __webpack_require__(3);
	
	var Utils = _interopRequireWildcard(_Utils);
	
	var _Cache = __webpack_require__(8);
	
	var _Cache2 = _interopRequireDefault(_Cache);
	
	var _Externals = __webpack_require__(4);
	
	var Externals = _interopRequireWildcard(_Externals);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _ClientMock = __webpack_require__(12);
	
	var _ClientMock2 = _interopRequireDefault(_ClientMock);
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Platform = __webpack_require__(15);
	
	var _Platform2 = _interopRequireDefault(_Platform);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _PubnubFactory = __webpack_require__(17);
	
	var _PubnubFactory2 = _interopRequireDefault(_PubnubFactory);
	
	var _Subscription = __webpack_require__(19);
	
	var _Subscription2 = _interopRequireDefault(_Subscription);
	
	var _CachedSubscription = __webpack_require__(20);
	
	var _CachedSubscription2 = _interopRequireDefault(_CachedSubscription);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SDK = function () {
	
	    /**
	     * @namespace RingCentral
	     * @constructor
	     * @param {object} [options]
	     * @param {string} [options.server]
	     * @param {string} [options.cachePrefix]
	     * @param {string} [options.appSecret]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.pubnubFactory]
	     * @param {string} [options.client]
	     */
	
	    function SDK(options) {
	        _classCallCheck(this, SDK);
	
	        options = options || {};
	
	        if (!Externals.fetch) {
	            throw new Error('Native Fetch is missing, set RingCentral.SDK.core.Externals.fetch to your favorite alternative');
	        }
	
	        if (!Externals.Promise) {
	            throw new Error('Native Promise is missing, set RingCentral.SDK.core.Externals.Promise to your favorite alternative');
	        }
	
	        this._cache = new _Cache2.default(Externals.localStorage, options.cachePrefix);
	
	        this._client = options.client || new _Client2.default();
	
	        this._platform = new _Platform2.default(this._client, this._cache, options.server, options.appKey, options.appSecret, options.appName, options.appVersion, SDK.version);
	
	        this._pubnubFactory = options.pubnubFactory || Externals.PUBNUB;
	    }
	
	    /**
	     * @return {Platform}
	     */
	
	
	    SDK.prototype.platform = function platform() {
	        return this._platform;
	    };
	
	    /**
	     * @return {Subscription}
	     */
	
	
	    SDK.prototype.createSubscription = function createSubscription() {
	        return new _Subscription2.default(this._pubnubFactory, this._platform);
	    };
	
	    /**
	     * @return {CachedSubscription}
	     */
	
	
	    SDK.prototype.createCachedSubscription = function createCachedSubscription(cacheKey) {
	        return new _CachedSubscription2.default(this._pubnubFactory, this._platform, this._cache, cacheKey);
	    };
	
	    /**
	     * @return {Cache}
	     */
	
	
	    SDK.prototype.cache = function cache() {
	        return this._cache;
	    };
	
	    SDK.handleLoginRedirect = function handleLoginRedirect(origin) {
	        window.opener.postMessage({ RCAuthorizationCode: window.location.search }, origin || window.location.origin);
	    };
	
	    return SDK;
	}();
	
	SDK.version =  true ? ("3.0.0-rc1") : 'x.x.x';
	SDK.server = {
	    sandbox: 'https://platform.devtest.ringcentral.com',
	    production: 'https://platform.ringcentral.com'
	};
	SDK.core = {
	    Cache: _Cache2.default,
	    EventEmitter: _events2.default,
	    Utils: Utils,
	    Externals: Externals
	};
	SDK.http = {
	    Client: _Client2.default,
	    ApiResponse: _ApiResponse2.default
	};
	SDK.platform = {
	    Auth: _Auth2.default,
	    Platform: _Platform2.default
	};
	SDK.subscription = {
	    Subscription: _Subscription2.default
	};
	SDK.mocks = {
	    Client: _ClientMock2.default,
	    Registry: _Registry2.default,
	    Mock: _Mock2.default
	};
	SDK.pubnub = {
	    PubnubMockFactory: _PubnubFactory2.default
	};
	
	
	module.exports = SDK;
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var iteratorSymbol =
	    typeof Symbol === "function" && Symbol.iterator || "@@iterator";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    // This invoke function is written in a style that assumes some
	    // calling function (or Promise) will handle exceptions.
	    function invoke(method, arg) {
	      var result = generator[method](arg);
	      var value = result.value;
	      return value instanceof AwaitArgument
	        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
	        : Promise.resolve(value).then(function(unwrapped) {
	            // When a yielded Promise is resolved, its final value becomes
	            // the .value of the Promise<{value,done}> result for the
	            // current iteration. If the Promise is rejected, however, the
	            // result for this iteration will be rejected with the same
	            // reason. Note that rejections of yielded Promises are not
	            // thrown back into the generator function, as is the case
	            // when an awaited Promise is rejected. This difference in
	            // behavior between yield and await is important, because it
	            // allows the consumer to decide what to do with the yielded
	            // rejection (swallow it and continue, manually .throw it back
	            // into the generator, abandon iteration, whatever). With
	            // await, by contrast, there is no opportunity to examine the
	            // rejection reason outside the generator function, so the
	            // only option is to throw it from the await expression, and
	            // let the generator function handle the exception.
	            result.value = unwrapped;
	            return result;
	          });
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var invokeNext = invoke.bind(generator, "next");
	    var invokeThrow = invoke.bind(generator, "throw");
	    var invokeReturn = invoke.bind(generator, "return");
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return invoke(method, arg);
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : new Promise(function (resolve) {
	          resolve(callInvokeWithMethodAndArg());
	        });
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          context._sent = arg;
	
	          if (state === GenStateSuspendedYield) {
	            context.sent = arg;
	          } else {
	            context.sent = undefined;
	          }
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.queryStringify = queryStringify;
	exports.parseQueryString = parseQueryString;
	exports.isFunction = isFunction;
	exports.isArray = isArray;
	exports.isObject = isObject;
	exports.isObjectObject = isObjectObject;
	exports.isPlainObject = isPlainObject;
	exports.isNodeJS = isNodeJS;
	exports.isBrowser = isBrowser;
	exports.delay = delay;
	
	var _Externals = __webpack_require__(4);
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {object} parameters
	 * @returns {string}
	 */
	function queryStringify(parameters) {
	
	    var array = [];
	
	    parameters = parameters || {};
	
	    Object.keys(parameters).forEach(function (k) {
	
	        var v = parameters[k];
	
	        if (isArray(v)) {
	            v.forEach(function (vv) {
	                array.push(encodeURIComponent(k) + '=' + encodeURIComponent(vv));
	            });
	        } else {
	            array.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
	        }
	    });
	
	    return array.join('&');
	}
	
	/**
	 * TODO Replace with something better
	 * @see https://github.com/joyent/node/blob/master/lib/querystring.js
	 * @param {string} queryString
	 * @returns {object}
	 */
	function parseQueryString(queryString) {
	
	    var argsParsed = {};
	
	    queryString.split('&').forEach(function (arg) {
	
	        arg = decodeURIComponent(arg);
	
	        if (arg.indexOf('=') == -1) {
	
	            argsParsed[arg.trim()] = true;
	        } else {
	
	            var pair = arg.split('='),
	                key = pair[0].trim(),
	                value = pair[1].trim();
	
	            if (key in argsParsed) {
	                if (key in argsParsed && !isArray(argsParsed[key])) argsParsed[key] = [argsParsed[key]];
	                argsParsed[key].push(value);
	            } else {
	                argsParsed[key] = value;
	            }
	        }
	    });
	
	    return argsParsed;
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isFunction(obj) {
	    return typeof obj === "function";
	}
	
	/**
	 * @param obj
	 * @return {boolean}
	 */
	function isArray(obj) {
	    return Array.isArray ? Array.isArray(obj) : typeof obj === "array";
	}
	
	function isObject(o) {
	    return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !isArray(o);
	}
	
	function isObjectObject(o) {
	    return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
	}
	
	function isPlainObject(o) {
	    var ctor, prot;
	
	    if (isObjectObject(o) === false) return false;
	
	    // If has modified constructor
	    ctor = o.constructor;
	    if (typeof ctor !== 'function') return false;
	
	    // If has modified prototype
	    prot = ctor.prototype;
	    if (isObjectObject(prot) === false) return false;
	
	    // If constructor does not have an Object-specific method
	    if (prot.hasOwnProperty('isPrototypeOf') === false) {
	        return false;
	    }
	
	    // Most likely a plain Object
	    return true;
	}
	
	function isNodeJS() {
	    return typeof process !== 'undefined';
	}
	
	function isBrowser() {
	    return typeof window !== 'undefined';
	}
	
	function delay(timeout) {
	    return new _Externals.Promise(function (resolve, reject) {
	        setTimeout(function () {
	            resolve(null);
	        }, timeout);
	    });
	}
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	exports.__esModule = true;
	exports.localStorage = exports.PUBNUB = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.Promise = undefined;
	
	var _es6Promise = __webpack_require__(5);
	
	var _es6Promise2 = _interopRequireDefault(_es6Promise);
	
	var _nodeFetch = __webpack_require__(6);
	
	var _nodeFetch2 = _interopRequireDefault(_nodeFetch);
	
	var _pubnub = __webpack_require__(7);
	
	var _pubnub2 = _interopRequireDefault(_pubnub);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var root = typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function("return this;")();
	
	var Promise = _es6Promise2.default && _es6Promise2.default.Promise || root.Promise;
	
	var fetch = _nodeFetch2.default && typeof _nodeFetch2.default == 'function' ? _nodeFetch2.default : root.fetch;
	var Request = fetch.Request || root.Request;
	var Response = fetch.Response || root.Response;
	var Headers = fetch.Headers || root.Headers;
	
	var PUBNUB = _pubnub2.default || root.PUBNUB;
	
	var localStorage = typeof root.localStorage !== 'undefined' ? root.localStorage : {};
	
	exports.Promise = Promise;
	exports.fetch = fetch;
	exports.Request = Request;
	exports.Response = Response;
	exports.Headers = Headers;
	exports.PUBNUB = PUBNUB;
	exports.localStorage = localStorage;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
	
	/***/ },
	/* 8 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Cache = function () {
	    function Cache(storage, prefix) {
	        _classCallCheck(this, Cache);
	
	        this.setPrefix(prefix);
	        this._storage = storage;
	    }
	
	    Cache.prototype.setPrefix = function setPrefix(prefix) {
	        this._prefix = prefix || Cache.defaultPrefix;
	        return this;
	    };
	
	    Cache.prototype.setItem = function setItem(key, data) {
	        this._storage[this._prefixKey(key)] = JSON.stringify(data);
	        return this;
	    };
	
	    Cache.prototype.removeItem = function removeItem(key) {
	        delete this._storage[this._prefixKey(key)];
	        return this;
	    };
	
	    Cache.prototype.getItem = function getItem(key) {
	        var item = this._storage[this._prefixKey(key)];
	        if (!item) return null;
	        return JSON.parse(item);
	    };
	
	    Cache.prototype.clean = function clean() {
	
	        for (var key in this._storage) {
	
	            if (!this._storage.hasOwnProperty(key)) continue;
	
	            if (key.indexOf(this._prefix) === 0) {
	                delete this._storage[key];
	            }
	        }
	
	        return this;
	    };
	
	    Cache.prototype._prefixKey = function _prefixKey(key) {
	        return this._prefix + key;
	    };
	
	    return Cache;
	}();
	
	Cache.defaultPrefix = 'rc-';
	exports.default = Cache;
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	exports.findHeaderName = findHeaderName;
	
	var _Externals = __webpack_require__(4);
	
	var _Utils = __webpack_require__(3);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_EventEmitter) {
	    _inherits(Client, _EventEmitter);
	
	    function Client() {
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Client);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _EventEmitter.call.apply(_EventEmitter, [this].concat(args))), _this), _this.events = {
	            beforeRequest: 'beforeRequest',
	            requestSuccess: 'requestSuccess',
	            requestError: 'requestError'
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    /**
	     * @param {Request} request
	     * @return {Promise<ApiResponse>}
	     */
	
	    Client.prototype.sendRequest = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var apiResponse;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            apiResponse = new _ApiResponse2.default(request);
	                            _context.prev = 1;
	
	
	                            //TODO Stop request if listeners return false
	                            this.emit(this.events.beforeRequest, apiResponse);
	
	                            _context.next = 5;
	                            return this._loadResponse(request);
	
	                        case 5:
	                            apiResponse._response = _context.sent;
	                            _context.next = 8;
	                            return apiResponse._init();
	
	                        case 8:
	                            if (apiResponse.ok()) {
	                                _context.next = 10;
	                                break;
	                            }
	
	                            throw new Error('Response has unsuccessful status');
	
	                        case 10:
	
	                            this.emit(this.events.requestSuccess, apiResponse);
	
	                            return _context.abrupt("return", apiResponse);
	
	                        case 14:
	                            _context.prev = 14;
	                            _context.t0 = _context["catch"](1);
	
	
	                            if (!_context.t0.apiResponse) _context.t0 = this.makeError(_context.t0, apiResponse);
	
	                            this.emit(this.events.requestError, _context.t0);
	
	                            throw _context.t0;
	
	                        case 19:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[1, 14]]);
	        }));
	
	        function sendRequest(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @return {Promise<Response>}
	     * @private
	     */
	
	
	    Client.prototype._loadResponse = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(request) {
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return _Externals.fetch.call(null, request);
	
	                        case 2:
	                            return _context2.abrupt("return", _context2.sent);
	
	                        case 3:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this);
	        }));
	
	        function _loadResponse(_x2) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    /**
	     * Wraps the JS Error object with transaction information
	     * @param {Error|IApiError} e
	     * @param {ApiResponse} apiResponse
	     * @return {IApiError}
	     */
	
	
	    Client.prototype.makeError = function makeError(e, apiResponse) {
	
	        // Wrap only if regular error
	        if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {
	
	            e.apiResponse = apiResponse;
	            e.originalMessage = e.message;
	            e.message = apiResponse && apiResponse.error(true) || e.originalMessage;
	        }
	
	        return e;
	    };
	
	    /**
	     *
	     * @param {object} init
	     * @param {object} [init.url]
	     * @param {object} [init.body]
	     * @param {string} [init.method]
	     * @param {object} [init.query]
	     * @param {object} [init.headers]
	     * @return {Request}
	     */
	
	
	    Client.prototype.createRequest = function createRequest(init) {
	
	        init = init || {};
	        init.headers = init.headers || {};
	
	        // Sanity checks
	        if (!init.url) throw new Error('Url is not defined');
	        if (!init.method) init.method = 'GET';
	        if (init.method && Client._allowedMethods.indexOf(init.method.toUpperCase()) < 0) {
	            throw new Error('Method has wrong value: ' + init.method);
	        }
	
	        // Defaults
	        init.credentials = init.credentials || 'include';
	        init.mode = init.mode || 'cors';
	
	        // Append Query String
	        if (init.query) {
	            init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + (0, _Utils.queryStringify)(init.query);
	        }
	
	        if (!findHeaderName('Accept', init.headers)) {
	            init.headers['Accept'] = _ApiResponse2.default._jsonContentType;
	        }
	
	        // Serialize body
	        if ((0, _Utils.isPlainObject)(init.body) || !init.body) {
	
	            var contentTypeHeaderName = findHeaderName(_ApiResponse2.default._contentType, init.headers);
	
	            if (!contentTypeHeaderName) {
	                contentTypeHeaderName = _ApiResponse2.default._contentType;
	                init.headers[contentTypeHeaderName] = _ApiResponse2.default._jsonContentType;
	            }
	
	            var contentType = init.headers[contentTypeHeaderName];
	
	            // Assign a new encoded body
	            if (contentType.indexOf(_ApiResponse2.default._jsonContentType) > -1) {
	                init.body = JSON.stringify(init.body);
	            } else if (contentType.indexOf(_ApiResponse2.default._urlencodedContentType) > -1) {
	                init.body = (0, _Utils.queryStringify)(init.body);
	            }
	        }
	
	        // Create a request with encoded body
	        var req = new _Externals.Request(init.url, init);
	
	        // Keep the original body accessible directly (for mocks)
	        req.originalBody = init.body;
	
	        return req;
	    };
	
	    return Client;
	}(_events2.default);
	
	Client._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];
	exports.default = Client;
	function findHeaderName(name, headers) {
	    name = name.toLowerCase();
	    return Object.keys(headers).reduce(function (res, key) {
	        if (res) return res;
	        if (name == key.toLowerCase()) return key;
	        return res;
	    }, null);
	}
	
	/**
	 * @name IApiError
	 * @property {string} stack
	 * @property {string} originalMessage
	 * @property {ApiResponse} apiResponse
	 */
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ApiResponse = function () {
	
	    /**
	     * @param {Request} request
	     * @param {Response} response
	     * @param {string} responseText
	     */
	
	    function ApiResponse(request, response, responseText) {
	        _classCallCheck(this, ApiResponse);
	
	        /** @type {Request} */
	        this._request = request;
	
	        /** @type {Response} */
	        this._response = response;
	
	        this._text = responseText;
	        this._json = null;
	        this._multipart = [];
	    }
	
	    ApiResponse.prototype._init = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(this._isMultipart() || this._isJson())) {
	                                _context.next = 4;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.response().text();
	
	                        case 3:
	                            this._text = _context.sent;
	
	                        case 4:
	                            return _context.abrupt('return', this);
	
	                        case 5:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _init() {
	            return _ref.apply(this, arguments);
	        }
	
	        return _init;
	    }();
	
	    /**
	     * @return {Response}
	     */
	
	
	    ApiResponse.prototype.response = function response() {
	        return this._response;
	    };
	
	    /**
	     * @return {Request}
	     */
	
	
	    ApiResponse.prototype.request = function request() {
	        return this._request;
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    ApiResponse.prototype.ok = function ok() {
	        return this._response && this._response.ok;
	    };
	
	    /**
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.text = function text() {
	        if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');
	        return this._text;
	    };
	
	    /**
	     * @return {object}
	     */
	
	
	    ApiResponse.prototype.json = function json() {
	        if (!this._isJson()) throw new Error('Response is not JSON');
	        if (!this._json) {
	            this._json = this._text ? JSON.parse(this._text) : null;
	        }
	        return this._json;
	    };
	
	    /**
	     * @param [skipOKCheck]
	     * @return {string}
	     */
	
	
	    ApiResponse.prototype.error = function error(skipOKCheck) {
	
	        if (this.ok() && !skipOKCheck) return null;
	
	        var message = (this._response && this._response.status ? this._response.status + ' ' : '') + (this._response && this._response.statusText ? this._response.statusText : '');
	
	        try {
	
	            if (this.json().message) message = this.json().message;
	            if (this.json().error_description) message = this.json().error_description;
	            if (this.json().description) message = this.json().description;
	        } catch (e) {}
	
	        return message;
	    };
	
	    /**
	     * @return {ApiResponse[]}
	     */
	
	
	    ApiResponse.prototype.multipart = function multipart() {
	
	        if (!this._isMultipart()) throw new Error('Response is not multipart');
	
	        if (!this._multipart.length) {
	
	            // Step 1. Split multipart response
	
	            var text = this.text();
	
	            if (!text) throw new Error('No response body');
	
	            var boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];
	
	            if (!boundary) throw new Error('Cannot find boundary');
	
	            var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);
	
	            if (parts[0].trim() === '') parts.shift();
	            if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();
	
	            if (parts.length < 1) throw new Error('No parts in body');
	
	            // Step 2. Parse status info
	
	            var statusInfo = ApiResponse.create(parts.shift(), this._response.status, this._response.statusText).json();
	
	            // Step 3. Parse all other parts
	
	            this._multipart = parts.map(function (part, i) {
	
	                var status = statusInfo.response[i].status;
	
	                return ApiResponse.create(part, status);
	            });
	        }
	
	        return this._multipart;
	    };
	
	    ApiResponse.prototype._isContentType = function _isContentType(contentType) {
	        return this._getContentType().indexOf(contentType) > -1;
	    };
	
	    ApiResponse.prototype._getContentType = function _getContentType() {
	        return this._response.headers.get(ApiResponse._contentType) || '';
	    };
	
	    ApiResponse.prototype._isMultipart = function _isMultipart() {
	        return this._isContentType(ApiResponse._multipartContentType);
	    };
	
	    ApiResponse.prototype._isUrlEncoded = function _isUrlEncoded() {
	        return this._isContentType(ApiResponse._urlencodedContentType);
	    };
	
	    ApiResponse.prototype._isJson = function _isJson() {
	        return this._isContentType(ApiResponse._jsonContentType);
	    };
	
	    /**
	     * Method is used to create ApiResponse object from string parts of multipart/mixed response
	     * @param {string} [text]
	     * @param {number} [status]
	     * @param {string} [statusText]
	     * @return {ApiResponse}
	     */
	
	
	    ApiResponse.create = function create(text, status, statusText) {
	
	        text = text || '';
	        status = status || 200;
	        statusText = statusText || 'OK';
	
	        text = text.replace(/\r/g, '');
	
	        var headers = new _Externals.Headers(),
	            headersAndBody = text.split(ApiResponse._bodySeparator),
	            headersText = headersAndBody.length > 1 ? headersAndBody.shift() : '';
	
	        text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;
	
	        (headersText || '').split('\n').forEach(function (header) {
	
	            var split = header.trim().split(ApiResponse._headerSeparator),
	                key = split.shift().trim(),
	                value = split.join(ApiResponse._headerSeparator).trim();
	
	            if (key) headers.append(key, value);
	        });
	
	        return new ApiResponse(null, new _Externals.Response(text ? text : undefined, {
	            headers: headers,
	            status: status,
	            statusText: statusText
	        }), text);
	    };
	
	    return ApiResponse;
	}();
	
	ApiResponse._contentType = 'Content-Type';
	ApiResponse._jsonContentType = 'application/json';
	ApiResponse._multipartContentType = 'multipart/mixed';
	ApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';
	ApiResponse._headerSeparator = ':';
	ApiResponse._bodySeparator = '\n\n';
	ApiResponse._boundarySeparator = '--';
	exports.default = ApiResponse;
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Registry = __webpack_require__(13);
	
	var _Registry2 = _interopRequireDefault(_Registry);
	
	var _Client = __webpack_require__(10);
	
	var _Client2 = _interopRequireDefault(_Client);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Client = function (_HttpClient) {
	    _inherits(Client, _HttpClient);
	
	    function Client() {
	        _classCallCheck(this, Client);
	
	        var _this = _possibleConstructorReturn(this, _HttpClient.call(this));
	
	        _this._registry = new _Registry2.default();
	        return _this;
	    }
	
	    Client.prototype.registry = function registry() {
	        return this._registry;
	    };
	
	    Client.prototype._loadResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            var mock;
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            mock = this._registry.find(request);
	                            _context.next = 3;
	                            return mock.getResponse(request);
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 4:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function _loadResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return _loadResponse;
	    }();
	
	    return Client;
	}(_Client2.default);
	
	exports.default = Client;
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Mock = __webpack_require__(14);
	
	var _Mock2 = _interopRequireDefault(_Mock);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Registry = function () {
	    function Registry() {
	        _classCallCheck(this, Registry);
	
	        this._mocks = [];
	    }
	
	    Registry.prototype.add = function add(mock) {
	        this._mocks.push(mock);
	        return this;
	    };
	
	    Registry.prototype.clear = function clear() {
	        this._mocks = [];
	        return this;
	    };
	
	    Registry.prototype.find = function find(request) {
	
	        //console.log('Registry is looking for', request);
	
	        var mock = this._mocks.shift();
	
	        if (!mock) throw new Error('No mock in registry for request ' + request.method + ' ' + request.url);
	
	        if (!mock.test(request)) throw new Error('Wrong request ' + request.method + ' ' + request.url + ' for expected mock ' + mock.method() + ' ' + mock.path());
	
	        return mock;
	    };
	
	    Registry.prototype.apiCall = function apiCall(method, path, response, status, statusText, delay) {
	
	        this.add(new _Mock2.default(method, path, response, status, statusText, delay));
	
	        return this;
	    };
	
	    Registry.prototype.authentication = function authentication() {
	
	        this.apiCall('POST', '/restapi/oauth/token', {
	            'access_token': 'ACCESS_TOKEN',
	            'token_type': 'bearer',
	            'expires_in': 3600,
	            'refresh_token': 'REFRESH_TOKEN',
	            'refresh_token_expires_in': 60480,
	            'scope': 'SMS RCM Foo Boo',
	            'expireTime': new Date().getTime() + 3600000
	        });
	
	        return this;
	    };
	
	    Registry.prototype.logout = function logout() {
	
	        this.apiCall('POST', '/restapi/oauth/revoke', {});
	
	        return this;
	    };
	
	    Registry.prototype.presenceLoad = function presenceLoad(id) {
	
	        this.apiCall('GET', '/restapi/v1.0/account/~/extension/' + id + '/presence', {
	            "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id + "/presence",
	            "extension": {
	                "uri": "https://platform.ringcentral.com/restapi/v1.0/account/123/extension/" + id,
	                "id": id,
	                "extensionNumber": "101"
	            },
	            "activeCalls": [],
	            "presenceStatus": "Available",
	            "telephonyStatus": "Ringing",
	            "userStatus": "Available",
	            "dndStatus": "TakeAllCalls",
	            "extensionId": id
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeGeneric = function subscribeGeneric(expiresIn) {
	
	        expiresIn = expiresIn || 15 * 60 * 60;
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/~/presence'],
	            'expirationTime': new Date(date.getTime() + expiresIn * 1000).toISOString(),
	            'expiresIn': expiresIn,
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': false,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar'
	            },
	            'id': 'foo-bar-baz',
	            'creationTime': date.toISOString(),
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.subscribeOnPresence = function subscribeOnPresence(id, detailed) {
	
	        id = id || '1';
	
	        var date = new Date();
	
	        this.apiCall('POST', '/restapi/v1.0/subscription', {
	            'eventFilters': ['/restapi/v1.0/account/~/extension/' + id + '/presence' + (detailed ? '?detailedTelephonyState=true' : '')],
	            'expirationTime': new Date(date.getTime() + 15 * 60 * 60 * 1000).toISOString(),
	            'deliveryMode': {
	                'transportType': 'PubNub',
	                'encryption': true,
	                'address': '123_foo',
	                'subscriberKey': 'sub-c-foo',
	                'secretKey': 'sec-c-bar',
	                'encryptionAlgorithm': 'AES',
	                'encryptionKey': 'VQwb6EVNcQPBhE/JgFZ2zw=='
	            },
	            'creationTime': date.toISOString(),
	            'id': 'foo-bar-baz',
	            'status': 'Active',
	            'uri': 'https://platform.ringcentral.com/restapi/v1.0/subscription/foo-bar-baz'
	        });
	
	        return this;
	    };
	
	    Registry.prototype.tokenRefresh = function tokenRefresh(failure) {
	
	        if (!failure) {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'access_token': 'ACCESS_TOKEN_FROM_REFRESH',
	                'token_type': 'bearer',
	                'expires_in': 3600,
	                'refresh_token': 'REFRESH_TOKEN_FROM_REFRESH',
	                'refresh_token_expires_in': 60480,
	                'scope': 'SMS RCM Foo Boo'
	            });
	        } else {
	
	            this.apiCall('POST', '/restapi/oauth/token', {
	                'message': 'Wrong token',
	                'error_description': 'Wrong token',
	                'description': 'Wrong token'
	            }, 400);
	        }
	
	        return this;
	    };
	
	    return Registry;
	}();
	
	exports.default = Registry;
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _ApiResponse = __webpack_require__(11);
	
	var _ApiResponse2 = _interopRequireDefault(_ApiResponse);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Mock = function () {
	    function Mock(method, path, json, status, statusText, delay) {
	        _classCallCheck(this, Mock);
	
	        this._method = method.toUpperCase();
	        this._path = path;
	        this._json = json || {};
	        this._delay = delay || 10;
	        this._status = status || 200;
	        this._statusText = statusText || 'OK';
	    }
	
	    Mock.prototype.path = function path() {
	        return this._path;
	    };
	
	    Mock.prototype.method = function method() {
	        return this._method;
	    };
	
	    Mock.prototype.test = function test(request) {
	
	        return request.url.indexOf(this._path) > -1 && request.method.toUpperCase() == this._method;
	    };
	
	    Mock.prototype.getResponse = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(request) {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return (0, _Utils.delay)(this._delay);
	
	                        case 2:
	                            return _context.abrupt('return', this.createResponse(this._json));
	
	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function getResponse(_x) {
	            return _ref.apply(this, arguments);
	        }
	
	        return getResponse;
	    }();
	
	    Mock.prototype.createResponse = function createResponse(json, init) {
	
	        init = init || {};
	
	        init.status = init.status || this._status;
	        init.statusText = init.statusText || this._statusText;
	
	        var str = JSON.stringify(json),
	            res = new _Externals.Response(str, init);
	
	        res.headers.set(_ApiResponse2.default._contentType, _ApiResponse2.default._jsonContentType);
	
	        return res;
	    };
	
	    return Mock;
	}();
	
	exports.default = Mock;
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Externals = __webpack_require__(4);
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Auth = __webpack_require__(16);
	
	var _Auth2 = _interopRequireDefault(_Auth);
	
	var _Utils = __webpack_require__(3);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _Externals.Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _Externals.Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Platform = function (_EventEmitter) {
	    _inherits(Platform, _EventEmitter);
	
	    function Platform(client, cache, server, appKey, appSecret, appName, appVersion, sdkVersion) {
	        _classCallCheck(this, Platform);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            beforeLogin: 'beforeLogin',
	            loginSuccess: 'loginSuccess',
	            loginError: 'loginError',
	            beforeRefresh: 'beforeRefresh',
	            refreshSuccess: 'refreshSuccess',
	            refreshError: 'refreshError',
	            beforeLogout: 'beforeLogout',
	            logoutSuccess: 'logoutSuccess',
	            logoutError: 'logoutError'
	        };
	
	
	        _this._server = server;
	        _this._appKey = appKey;
	        _this._appSecret = appSecret;
	
	        /** @type {Cache} */
	        _this._cache = cache;
	
	        /** @type {Client} */
	        _this._client = client;
	
	        /** @type {Promise<ApiResponse>} */
	        _this._refreshPromise = null;
	
	        _this._auth = new _Auth2.default(_this._cache, Platform._cacheId);
	
	        _this._userAgent = (appName ? appName + (appVersion ? '/' + appVersion : '') + ' ' : '') + 'RCJSSDK/' + sdkVersion;
	
	        return _this;
	    }
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Platform.prototype.auth = function auth() {
	        return this._auth;
	    };
	
	    /**
	     * @return {Client}
	     */
	
	
	    Platform.prototype.client = function client() {
	        return this._client;
	    };
	
	    /**
	     * @param {string} path
	     * @param {object} [options]
	     * @param {boolean} [options.addServer]
	     * @param {string} [options.addMethod]
	     * @param {boolean} [options.addToken]
	     * @return {string}
	     */
	
	
	    Platform.prototype.createUrl = function createUrl(path, options) {
	
	        path = path || '';
	        options = options || {};
	
	        var builtUrl = '',
	            hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1;
	
	        if (options.addServer && !hasHttp) builtUrl += this._server;
	
	        if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp) builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;
	
	        builtUrl += path;
	
	        if (options.addMethod || options.addToken) builtUrl += path.indexOf('?') > -1 ? '&' : '?';
	
	        if (options.addMethod) builtUrl += '_method=' + options.addMethod;
	        if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();
	
	        return builtUrl;
	    };
	
	    /**
	     * @param {string} options.redirectUri
	     * @param {string} options.state
	     * @param {string} options.brandId
	     * @param {string} options.display
	     * @param {string} options.prompt
	     * @param {object} [options]
	     * @return {string}
	     */
	
	
	    Platform.prototype.loginUrl = function loginUrl(options) {
	
	        options = options || {};
	
	        return this.createUrl(Platform._authorizeEndpoint + '?' + (0, _Utils.queryStringify)({
	            'response_type': 'code',
	            'redirect_uri': options.redirectUri || '',
	            'client_id': this._appKey,
	            'state': options.state || '',
	            'brand_id': options.brandId || '',
	            'display': options.display || '',
	            'prompt': options.prompt || ''
	        }), { addServer: true });
	    };
	
	    /**
	     * @param {string} url
	     * @return {Object}
	     */
	
	
	    Platform.prototype.parseLoginRedirectUrl = function parseLoginRedirectUrl(url) {
	
	        var qs = (0, _Utils.parseQueryString)(url.split('?').reverse()[0]),
	            error = qs.error_description || qs.error;
	
	        if (error) {
	            var e = new Error(error);
	            e.error = qs.error;
	            throw e;
	        }
	
	        return qs;
	    };
	
	    /**
	     * Convenience method to handle 3-legged OAuth
	     *
	     * Attention! This is an experimental method and it's signature and behavior may change without notice.
	     *
	     * @experimental
	     * @param {number} [options.width]
	     * @param {number} [options.height]
	     * @param {object} [options.login] additional options for login()
	     * @param {string} [options.origin]
	     * @param {string} [options.property] name of window.postMessage's event data property
	     * @param {string} [options.target] target for window.open()
	     * @param {string} options.url
	     * @return {Promise}
	     */
	
	
	    Platform.prototype.loginWindow = function loginWindow(options) {
	        var _this2 = this;
	
	        return new _Externals.Promise(function (resolve, reject) {
	
	            if (!(0, _Utils.isBrowser)()) throw new Error('This method can be used only in browser');
	
	            if (!options.url) throw new Error('Missing mandatory URL parameter');
	
	            options = options || {};
	            options.url = options.url || 400;
	            options.width = options.width || 400;
	            options.height = options.height || 600;
	            options.origin = options.origin || window.location.origin;
	            options.property = options.property || 'RCAuthorizationCode';
	            options.target = options.target || '_blank';
	
	            var dualScreenLeft = window.screenLeft != undefined ? window.screenLeft : screen.left;
	            var dualScreenTop = window.screenTop != undefined ? window.screenTop : screen.top;
	
	            var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
	            var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
	
	            var left = width / 2 - options.width / 2 + dualScreenLeft;
	            var top = height / 2 - options.height / 2 + dualScreenTop;
	            var win = window.open(options.url, '_blank', options.target == '_blank' ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');
	
	            if (window.focus) win.focus();
	
	            var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';
	            var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';
	            var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';
	
	            var eventListener = function eventListener(e) {
	
	                if (e.origin != options.origin) return;
	                if (!e.data || !e.data[options.property]) return; // keep waiting
	
	                win.close();
	                window[eventRemoveMethod](messageEvent, eventListener);
	
	                try {
	
	                    var loginOptions = _this2.parseLoginRedirectUrl(e.data[options.property]);
	
	                    if (!loginOptions.code) throw new Error('No authorization code');
	
	                    resolve(loginOptions);
	                } catch (e) {
	                    reject(e);
	                }
	            };
	
	            window[eventMethod](messageEvent, eventListener, false);
	        });
	    };
	
	    /**
	     * @return {Promise<boolean>}
	     */
	
	
	    Platform.prototype.loggedIn = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.prev = 0;
	                            _context.next = 3;
	                            return this.ensureLoggedIn();
	
	                        case 3:
	                            return _context.abrupt("return", true);
	
	                        case 6:
	                            _context.prev = 6;
	                            _context.t0 = _context["catch"](0);
	                            return _context.abrupt("return", false);
	
	                        case 9:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this, [[0, 6]]);
	        }));
	
	        function loggedIn() {
	            return _ref.apply(this, arguments);
	        }
	
	        return loggedIn;
	    }();
	
	    /**
	     * @param {string} options.username
	     * @param {string} options.password
	     * @param {string} options.extension
	     * @param {string} options.code
	     * @param {string} options.redirectUri
	     * @param {string} options.endpointId
	     * @param {string} options.remember
	     * @param {string} options.accessTokenTtl
	     * @param {string} options.refreshTokenTtl
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.login = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(options) {
	            var body, apiResponse, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            options = options || {};
	
	                            this.emit(this.events.beforeLogin);
	
	                            body = {};
	
	
	                            if (!options.code) {
	
	                                body.grant_type = 'password';
	                                body.username = options.username;
	                                body.password = options.password;
	                                body.extension = options.extension || '';
	                            } else if (options.code) {
	
	                                body.grant_type = 'authorization_code';
	                                body.code = options.code;
	                                body.redirect_uri = options.redirectUri;
	                                //body.client_id = this.getCredentials().key; // not needed
	                            }
	
	                            if (options.endpointId) body.endpoint_id = options.endpointId;
	                            if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;
	                            if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;
	
	                            _context2.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, body);
	
	                        case 10:
	                            apiResponse = _context2.sent;
	                            json = apiResponse.json();
	
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.loginSuccess, apiResponse);
	
	                            return _context2.abrupt("return", apiResponse);
	
	                        case 17:
	                            _context2.prev = 17;
	                            _context2.t0 = _context2["catch"](0);
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.loginError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 22:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 17]]);
	        }));
	
	        function login(_x) {
	            return _ref2.apply(this, arguments);
	        }
	
	        return login;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     * @private
	     */
	
	
	    Platform.prototype._refresh = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var res, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this.emit(this.events.beforeRefresh);
	
	                            _context3.next = 4;
	                            return (0, _Utils.delay)(Platform._refreshDelayMs);
	
	                        case 4:
	                            if (this._auth.refreshToken()) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Refresh token is missing');
	
	                        case 6:
	                            if (this._auth.refreshTokenValid()) {
	                                _context3.next = 8;
	                                break;
	                            }
	
	                            throw new Error('Refresh token has expired');
	
	                        case 8:
	                            _context3.next = 10;
	                            return this._tokenRequest(Platform._tokenEndpoint, {
	                                "grant_type": "refresh_token",
	                                "refresh_token": this._auth.refreshToken(),
	                                "access_token_ttl": this._auth.data().expires_in + 1,
	                                "refresh_token_ttl": this._auth.data().refresh_token_expires_in + 1
	                            });
	
	                        case 10:
	                            res = _context3.sent;
	                            json = res.json();
	
	                            if (json.access_token) {
	                                _context3.next = 14;
	                                break;
	                            }
	
	                            throw this._client.makeError(new Error('Malformed OAuth response'), res);
	
	                        case 14:
	
	                            this._auth.setData(json);
	
	                            this.emit(this.events.refreshSuccess, res);
	
	                            return _context3.abrupt("return", res);
	
	                        case 19:
	                            _context3.prev = 19;
	                            _context3.t0 = _context3["catch"](0);
	
	
	                            _context3.t0 = this._client.makeError(_context3.t0);
	
	                            if (Platform._clearCacheOnRefreshError) {
	                                this._cache.clean();
	                            }
	
	                            this.emit(this.events.refreshError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 25:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 19]]);
	        }));
	
	        function _refresh() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return _refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.refresh = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var _this3 = this;
	
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (!this._refreshPromise) {
	                                _context4.next = 2;
	                                break;
	                            }
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 2:
	                            _context4.prev = 2;
	
	
	                            this._refreshPromise = this._refresh().then(function (res) {
	                                _this3._refreshPromise = null;
	                                return res;
	                            });
	
	                            return _context4.abrupt("return", this._refreshPromise);
	
	                        case 7:
	                            _context4.prev = 7;
	                            _context4.t0 = _context4["catch"](2);
	
	
	                            this._refreshPromise = null;
	                            throw _context4.t0;
	
	                        case 11:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[2, 7]]);
	        }));
	
	        function refresh() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return refresh;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.logout = function () {
	        var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	            var res;
	            return regeneratorRuntime.wrap(function _callee5$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.prev = 0;
	
	
	                            this.emit(this.events.beforeLogout);
	
	                            _context5.next = 4;
	                            return this._tokenRequest(Platform._revokeEndpoint, {
	                                token: this._auth.accessToken()
	                            });
	
	                        case 4:
	                            res = _context5.sent;
	
	
	                            this._cache.clean();
	
	                            this.emit(this.events.logoutSuccess, res);
	
	                            return _context5.abrupt("return", res);
	
	                        case 10:
	                            _context5.prev = 10;
	                            _context5.t0 = _context5["catch"](0);
	
	
	                            this.emit(this.events.logoutError, _context5.t0);
	
	                            throw _context5.t0;
	
	                        case 14:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, _callee5, this, [[0, 10]]);
	        }));
	
	        function logout() {
	            return _ref5.apply(this, arguments);
	        }
	
	        return logout;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<Request>}
	     */
	
	
	    Platform.prototype.inflateRequest = function () {
	        var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(request, options) {
	            return regeneratorRuntime.wrap(function _callee6$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	
	                            options = options || {};
	
	                            if (!options.skipAuthCheck) {
	                                _context6.next = 3;
	                                break;
	                            }
	
	                            return _context6.abrupt("return", request);
	
	                        case 3:
	                            _context6.next = 5;
	                            return this.ensureLoggedIn();
	
	                        case 5:
	
	                            request.headers.set('X-User-Agent', this._userAgent);
	                            request.headers.set('Client-Id', this._appKey);
	                            request.headers.set('Authorization', this._authHeader());
	                            //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...
	
	                            return _context6.abrupt("return", request);
	
	                        case 9:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, _callee6, this);
	        }));
	
	        function inflateRequest(_x2, _x3) {
	            return _ref6.apply(this, arguments);
	        }
	
	        return inflateRequest;
	    }();
	
	    /**
	     * @param {Request} request
	     * @param {object} [options]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.sendRequest = function () {
	        var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(request, options) {
	            return regeneratorRuntime.wrap(function _callee7$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.prev = 0;
	                            _context7.next = 3;
	                            return this.inflateRequest(request, options);
	
	                        case 3:
	                            request = _context7.sent;
	                            _context7.next = 6;
	                            return this._client.sendRequest(request);
	
	                        case 6:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 9:
	                            _context7.prev = 9;
	                            _context7.t0 = _context7["catch"](0);
	
	                            if (!(!_context7.t0.apiResponse || !_context7.t0.apiResponse.response() || _context7.t0.apiResponse.response().status != 401)) {
	                                _context7.next = 13;
	                                break;
	                            }
	
	                            throw _context7.t0;
	
	                        case 13:
	
	                            this._auth.cancelAccessToken();
	
	                            _context7.next = 16;
	                            return this.sendRequest(request, options);
	
	                        case 16:
	                            return _context7.abrupt("return", _context7.sent);
	
	                        case 17:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, _callee7, this, [[0, 9]]);
	        }));
	
	        function sendRequest(_x4, _x5) {
	            return _ref7.apply(this, arguments);
	        }
	
	        return sendRequest;
	    }();
	
	    /**
	     * General purpose function to send anything to server
	     * @param {string} options.url
	     * @param {object} [options.body]
	     * @param {string} [options.method]
	     * @param {object} [options.query]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.send = function () {
	        var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	            return regeneratorRuntime.wrap(function _callee8$(_context8) {
	                while (1) {
	                    switch (_context8.prev = _context8.next) {
	                        case 0:
	
	                            //FIXME https://github.com/bitinn/node-fetch/issues/43
	                            options.url = this.createUrl(options.url, { addServer: true });
	
	                            _context8.next = 3;
	                            return this.sendRequest(this._client.createRequest(options), options);
	
	                        case 3:
	                            return _context8.abrupt("return", _context8.sent);
	
	                        case 4:
	                        case "end":
	                            return _context8.stop();
	                    }
	                }
	            }, _callee8, this);
	        }));
	
	        function send(_x6) {
	            return _ref8.apply(this, arguments);
	        }
	
	        return send;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.get = function () {
	        var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee9$(_context9) {
	                while (1) {
	                    switch (_context9.prev = _context9.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'GET';
	                            options.url = url;
	                            options.query = query;
	                            _context9.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context9.abrupt("return", _context9.sent);
	
	                        case 7:
	                        case "end":
	                            return _context9.stop();
	                    }
	                }
	            }, _callee9, this);
	        }));
	
	        function get(_x8, _x9, _x10) {
	            return _ref9.apply(this, arguments);
	        }
	
	        return get;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} body
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.post = function () {
	        var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee10$(_context10) {
	                while (1) {
	                    switch (_context10.prev = _context10.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'POST';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context10.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context10.abrupt("return", _context10.sent);
	
	                        case 8:
	                        case "end":
	                            return _context10.stop();
	                    }
	                }
	            }, _callee10, this);
	        }));
	
	        function post(_x11, _x12, _x13, _x14) {
	            return _ref10.apply(this, arguments);
	        }
	
	        return post;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {object} [body]
	     * @param {object} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype.put = function () {
	        var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(url, body, query, options) {
	            return regeneratorRuntime.wrap(function _callee11$(_context11) {
	                while (1) {
	                    switch (_context11.prev = _context11.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'PUT';
	                            options.url = url;
	                            options.query = query;
	                            options.body = body;
	                            _context11.next = 7;
	                            return this.send(options);
	
	                        case 7:
	                            return _context11.abrupt("return", _context11.sent);
	
	                        case 8:
	                        case "end":
	                            return _context11.stop();
	                    }
	                }
	            }, _callee11, this);
	        }));
	
	        function put(_x15, _x16, _x17, _x18) {
	            return _ref11.apply(this, arguments);
	        }
	
	        return put;
	    }();
	
	    /**
	     * @param {string} url
	     * @param {string} [query]
	     * @param {object} [options]
	     * @param {object} [options.headers]
	     * @param {boolean} [options.skipAuthCheck]
	     * @return {Promise<ApiResponse>}
	     */
	
	
	    Platform.prototype['delete'] = function () {
	        var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(url, query, options) {
	            return regeneratorRuntime.wrap(function _callee12$(_context12) {
	                while (1) {
	                    switch (_context12.prev = _context12.next) {
	                        case 0:
	                            options = options || {};
	                            options.method = 'DELETE';
	                            options.url = url;
	                            options.query = query;
	                            _context12.next = 6;
	                            return this.send(options);
	
	                        case 6:
	                            return _context12.abrupt("return", _context12.sent);
	
	                        case 7:
	                        case "end":
	                            return _context12.stop();
	                    }
	                }
	            }, _callee12, this);
	        }));
	
	        function _delete(_x19, _x20, _x21) {
	            return _ref12.apply(this, arguments);
	        }
	
	        return _delete;
	    }();
	
	    Platform.prototype._tokenRequest = function () {
	        var _ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(path, body) {
	            return regeneratorRuntime.wrap(function _callee13$(_context13) {
	                while (1) {
	                    switch (_context13.prev = _context13.next) {
	                        case 0:
	                            _context13.next = 2;
	                            return this.send({
	                                url: path,
	                                skipAuthCheck: true,
	                                body: body,
	                                method: 'POST',
	                                headers: {
	                                    'Authorization': 'Basic ' + this._apiKey(),
	                                    'Content-Type': 'application/x-www-form-urlencoded'
	                                }
	                            });
	
	                        case 2:
	                            return _context13.abrupt("return", _context13.sent);
	
	                        case 3:
	                        case "end":
	                            return _context13.stop();
	                    }
	                }
	            }, _callee13, this);
	        }));
	
	        function _tokenRequest(_x22, _x23) {
	            return _ref13.apply(this, arguments);
	        }
	
	        return _tokenRequest;
	    }();
	
	    Platform.prototype.ensureLoggedIn = function () {
	        var _ref14 = _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
	            return regeneratorRuntime.wrap(function _callee14$(_context14) {
	                while (1) {
	                    switch (_context14.prev = _context14.next) {
	                        case 0:
	                            if (!this._isAccessTokenValid()) {
	                                _context14.next = 2;
	                                break;
	                            }
	
	                            return _context14.abrupt("return", null);
	
	                        case 2:
	                            _context14.next = 4;
	                            return this.refresh();
	
	                        case 4:
	                            return _context14.abrupt("return", _context14.sent);
	
	                        case 5:
	                        case "end":
	                            return _context14.stop();
	                    }
	                }
	            }, _callee14, this);
	        }));
	
	        function ensureLoggedIn() {
	            return _ref14.apply(this, arguments);
	        }
	
	        return ensureLoggedIn;
	    }();
	
	    Platform.prototype._isAccessTokenValid = function _isAccessTokenValid() {
	        return this._auth.accessTokenValid();
	    };
	
	    Platform.prototype._apiKey = function _apiKey() {
	        var apiKey = this._appKey + ':' + this._appSecret;
	        return typeof btoa == 'function' ? btoa(apiKey) : new Buffer(apiKey).toString('base64');
	    };
	
	    Platform.prototype._authHeader = function _authHeader() {
	        var token = this._auth.accessToken();
	        return this._auth.tokenType() + (token ? ' ' + token : '');
	    };
	
	    return Platform;
	}(_events2.default);
	
	Platform._urlPrefix = '/restapi';
	Platform._apiVersion = 'v1.0';
	Platform._tokenEndpoint = '/restapi/oauth/token';
	Platform._revokeEndpoint = '/restapi/oauth/revoke';
	Platform._authorizeEndpoint = '/restapi/oauth/authorize';
	Platform._refreshDelayMs = 100;
	Platform._cacheId = 'platform';
	Platform._clearCacheOnRefreshError = false;
	exports.default = Platform;
	
	/***/ },
	/* 16 */
	/***/ function(module, exports) {
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Auth = function () {
	    function Auth(cache, cacheId) {
	        _classCallCheck(this, Auth);
	
	        /** @type {Cache} */
	        this._cache = cache;
	        this._cacheId = cacheId;
	    } // 1 minute
	
	
	    Auth.prototype.accessToken = function accessToken() {
	        return this.data().access_token;
	    };
	
	    Auth.prototype.refreshToken = function refreshToken() {
	        return this.data().refresh_token;
	    };
	
	    Auth.prototype.tokenType = function tokenType() {
	        return this.data().token_type;
	    };
	
	    /**
	     * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}
	     */
	
	
	    Auth.prototype.data = function data() {
	
	        return this._cache.getItem(this._cacheId) || {
	            token_type: '',
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        };
	    };
	
	    /**
	     * @param {object} newData
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.setData = function setData(newData) {
	
	        newData = newData || {};
	
	        var data = this.data();
	
	        Object.keys(newData).forEach(function (key) {
	            data[key] = newData[key];
	        });
	
	        data.expire_time = Date.now() + data.expires_in * 1000;
	        data.refresh_token_expire_time = Date.now() + data.refresh_token_expires_in * 1000;
	
	        this._cache.setItem(this._cacheId, data);
	
	        return this;
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.accessTokenValid = function accessTokenValid() {
	
	        var authData = this.data();
	        return authData.token_type === Auth.forcedTokenType || authData.expire_time - Auth.refreshHandicapMs > Date.now();
	    };
	
	    /**
	     * Check if there is a valid (not expired) access token
	     * @return {boolean}
	     */
	
	
	    Auth.prototype.refreshTokenValid = function refreshTokenValid() {
	
	        return this.data().refresh_token_expire_time > Date.now();
	    };
	
	    /**
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.cancelAccessToken = function cancelAccessToken() {
	
	        return this.setData({
	            access_token: '',
	            expires_in: 0
	        });
	    };
	
	    /**
	     * This method sets a special authentication mode used in Service Web
	     * @return {Auth}
	     */
	
	
	    Auth.prototype.forceAuthentication = function forceAuthentication() {
	
	        this.setData({
	            token_type: Auth.forcedTokenType,
	            access_token: '',
	            expires_in: 0,
	            refresh_token: '',
	            refresh_token_expires_in: 0
	        });
	
	        return this;
	    };
	
	    return Auth;
	}();
	
	//export interface IAuthData {
	//    remember?:boolean;
	//    token_type?:string;
	//    access_token?:string;
	//    expires_in?:number; // actually it's string
	//    expire_time?:number;
	//    refresh_token?:string;
	//    refresh_token_expires_in?:number; // actually it's string
	//    refresh_token_expire_time?:number;
	//    scope?:string;
	//}
	
	
	Auth.refreshHandicapMs = 60 * 1000;
	Auth.forcedTokenType = 'forced';
	exports.default = Auth;
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _PubnubMock = __webpack_require__(18);
	
	var _PubnubMock2 = _interopRequireDefault(_PubnubMock);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PubnubMockFactory = function () {
	    function PubnubMockFactory() {
	        _classCallCheck(this, PubnubMockFactory);
	
	        this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	    }
	
	    PubnubMockFactory.prototype.init = function init(options) {
	        return new _PubnubMock2.default(options);
	    };
	
	    return PubnubMockFactory;
	}();
	
	exports.default = PubnubMockFactory;
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Externals = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PubnubMock = function (_EventEmitter) {
	    _inherits(PubnubMock, _EventEmitter);
	
	    function PubnubMock(options) {
	        _classCallCheck(this, PubnubMock);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.options = options;
	        _this.crypto_obj = _Externals.PUBNUB.crypto_obj;
	        return _this;
	    }
	
	    PubnubMock.prototype.init = function init(options) {
	        this.options = options;
	    };
	
	    PubnubMock.prototype.ready = function ready() {};
	
	    PubnubMock.prototype.subscribe = function subscribe(options) {
	        this.on('message-' + options.channel, options.message);
	    };
	
	    PubnubMock.prototype.unsubscribe = function unsubscribe(options) {
	        this.removeAllListeners('message-' + options.channel);
	    };
	
	    PubnubMock.prototype.receiveMessage = function receiveMessage(msg, channel) {
	        this.emit('message-' + channel, msg, 'env', channel);
	    };
	
	    return PubnubMock;
	}(_events2.default);
	
	exports.default = PubnubMock;
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	'use strict';
	
	exports.__esModule = true;
	
	var _events = __webpack_require__(9);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Subscription = function (_EventEmitter) {
	    _inherits(Subscription, _EventEmitter);
	
	    function Subscription(pubnubFactory, platform) {
	        _classCallCheck(this, Subscription);
	
	        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
	
	        _this.events = {
	            notification: 'notification',
	            removeSuccess: 'removeSuccess',
	            removeError: 'removeError',
	            renewSuccess: 'renewSuccess',
	            renewError: 'renewError',
	            subscribeSuccess: 'subscribeSuccess',
	            subscribeError: 'subscribeError'
	        };
	
	
	        _this._pubnubFactory = pubnubFactory;
	        _this._platform = platform;
	        _this._pubnub = null;
	        _this._pubnubLastChannel = null;
	        _this._timeout = null;
	        _this._subscription = null;
	
	        return _this;
	    }
	
	    Subscription.prototype.subscribed = function subscribed() {
	
	        var subscription = this.subscription();
	
	        return !!(subscription.id && subscription.deliveryMode && subscription.deliveryMode.subscriberKey && subscription.deliveryMode.address);
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.alive = function alive() {
	        return this.subscribed() && Date.now() < this.expirationTime();
	    };
	
	    /**
	     * @return {boolean}
	     */
	
	
	    Subscription.prototype.expired = function expired() {
	        if (!this.subscribed()) return true;
	        return !this.subscribed() || Date.now() > this.subscription().expirationTime;
	    };
	
	    Subscription.prototype.expirationTime = function expirationTime() {
	        return new Date(this.subscription().expirationTime || 0).getTime() - Subscription._renewHandicapMs;
	    };
	
	    Subscription.prototype.setSubscription = function setSubscription(subscription) {
	
	        subscription = subscription || {};
	
	        this._clearTimeout();
	        this._setSubscription(subscription);
	        this._subscribeAtPubnub();
	        this._setTimeout();
	
	        return this;
	    };
	
	    Subscription.prototype.subscription = function subscription() {
	        return this._subscription || {};
	    };
	
	    /**
	     * Creates or updates subscription if there is an active one
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.register = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	            return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!this.alive()) {
	                                _context.next = 6;
	                                break;
	                            }
	
	                            _context.next = 3;
	                            return this.renew();
	
	                        case 3:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 6:
	                            _context.next = 8;
	                            return this.subscribe();
	
	                        case 8:
	                            return _context.abrupt('return', _context.sent);
	
	                        case 9:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        function register() {
	            return _ref.apply(this, arguments);
	        }
	
	        return register;
	    }();
	
	    Subscription.prototype.eventFilters = function eventFilters() {
	        return this.subscription().eventFilters || [];
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.addEventFilters = function addEventFilters(events) {
	        this.setEventFilters(this.eventFilters().concat(events));
	        return this;
	    };
	
	    /**
	     * @param {string[]} events
	     * @return {Subscription}
	     */
	
	
	    Subscription.prototype.setEventFilters = function setEventFilters(events) {
	        var subscription = this.subscription();
	        subscription.eventFilters = events;
	        this._setSubscription(subscription);
	        return this;
	    };
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.subscribe = function () {
	        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.eventFilters().length) {
	                                _context2.next = 4;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 4:
	                            _context2.next = 6;
	                            return this._platform.post('/subscription', {
	                                eventFilters: this._getFullEventFilters(),
	                                deliveryMode: {
	                                    transportType: 'PubNub'
	                                }
	                            });
	
	                        case 6:
	                            response = _context2.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.subscribeSuccess, response);
	
	                            return _context2.abrupt('return', response);
	
	                        case 12:
	                            _context2.prev = 12;
	                            _context2.t0 = _context2['catch'](0);
	
	
	                            _context2.t0 = this._platform.client().makeError(_context2.t0);
	
	                            this.reset().emit(this.events.subscribeError, _context2.t0);
	
	                            throw _context2.t0;
	
	                        case 17:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, _callee2, this, [[0, 12]]);
	        }));
	
	        function subscribe() {
	            return _ref2.apply(this, arguments);
	        }
	
	        return subscribe;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.renew = function () {
	        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	            var response, json;
	            return regeneratorRuntime.wrap(function _callee3$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.prev = 0;
	
	
	                            this._clearTimeout();
	
	                            if (this.subscribed()) {
	                                _context3.next = 4;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 4:
	                            if (this.eventFilters().length) {
	                                _context3.next = 6;
	                                break;
	                            }
	
	                            throw new Error('Events are undefined');
	
	                        case 6:
	                            _context3.next = 8;
	                            return this._platform.put('/subscription/' + this.subscription().id, {
	                                eventFilters: this._getFullEventFilters()
	                            });
	
	                        case 8:
	                            response = _context3.sent;
	                            json = response.json();
	
	
	                            this.setSubscription(json).emit(this.events.renewSuccess, response);
	
	                            return _context3.abrupt('return', response);
	
	                        case 14:
	                            _context3.prev = 14;
	                            _context3.t0 = _context3['catch'](0);
	
	
	                            _context3.t0 = this._platform.client().makeError(_context3.t0);
	
	                            this.reset().emit(this.events.renewError, _context3.t0);
	
	                            throw _context3.t0;
	
	                        case 19:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, _callee3, this, [[0, 14]]);
	        }));
	
	        function renew() {
	            return _ref3.apply(this, arguments);
	        }
	
	        return renew;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.remove = function () {
	        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	            var response;
	            return regeneratorRuntime.wrap(function _callee4$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            _context4.prev = 0;
	
	                            if (this.subscribed()) {
	                                _context4.next = 3;
	                                break;
	                            }
	
	                            throw new Error('No subscription');
	
	                        case 3:
	                            _context4.next = 5;
	                            return this._platform.delete('/subscription/' + this.subscription().id);
	
	                        case 5:
	                            response = _context4.sent;
	
	
	                            this.reset().emit(this.events.removeSuccess, response);
	
	                            return _context4.abrupt('return', response);
	
	                        case 10:
	                            _context4.prev = 10;
	                            _context4.t0 = _context4['catch'](0);
	
	
	                            _context4.t0 = this._platform.client().makeError(_context4.t0);
	
	                            this.emit(this.events.removeError, _context4.t0);
	
	                            throw _context4.t0;
	
	                        case 15:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, _callee4, this, [[0, 10]]);
	        }));
	
	        function remove() {
	            return _ref4.apply(this, arguments);
	        }
	
	        return remove;
	    }();
	
	    /**
	     * @returns {Promise<ApiResponse>}
	     */
	
	
	    Subscription.prototype.resubscribe = function resubscribe() {
	        var filters = this.eventFilters();
	        return this.reset().setEventFilters(filters).subscribe();
	    };
	
	    /**
	     * Remove subscription and disconnect from PUBNUB
	     * This method resets subscription at client side but backend is not notified
	     */
	
	
	    Subscription.prototype.reset = function reset() {
	        this._clearTimeout();
	        if (this.subscribed() && this._pubnub) this._pubnub.unsubscribe({ channel: this.subscription().deliveryMode.address });
	        this._setSubscription(null);
	        return this;
	    };
	
	    Subscription.prototype._setSubscription = function _setSubscription(subscription) {
	        this._subscription = subscription;
	    };
	
	    Subscription.prototype._getFullEventFilters = function _getFullEventFilters() {
	        var _this2 = this;
	
	        return this.eventFilters().map(function (event) {
	            return _this2._platform.createUrl(event);
	        });
	    };
	
	    Subscription.prototype._setTimeout = function _setTimeout() {
	        var _this3 = this;
	
	        this._clearTimeout();
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        this._timeout = setInterval(function () {
	
	            if (_this3.alive()) return;
	
	            if (_this3.expired()) {
	                _this3.subscribe();
	            } else {
	                _this3.renew();
	            }
	        }, Subscription._pollInterval);
	
	        return this;
	    };
	
	    Subscription.prototype._clearTimeout = function _clearTimeout() {
	        clearInterval(this._timeout);
	        return this;
	    };
	
	    Subscription.prototype._decrypt = function _decrypt(message) {
	
	        if (!this.subscribed()) throw new Error('No subscription');
	
	        if (this.subscription().deliveryMode.encryptionKey) {
	
	            message = this._pubnubFactory.crypto_obj.decrypt(message, this.subscription().deliveryMode.encryptionKey, {
	                encryptKey: false,
	                keyEncoding: 'base64',
	                keyLength: 128,
	                mode: 'ecb'
	            });
	        }
	
	        return message;
	    };
	
	    Subscription.prototype._notify = function _notify(message) {
	        this.emit(this.events.notification, this._decrypt(message));
	        return this;
	    };
	
	    Subscription.prototype._subscribeAtPubnub = function _subscribeAtPubnub() {
	
	        if (!this.alive()) throw new Error('Subscription is not alive');
	
	        var deliveryMode = this.subscription().deliveryMode;
	
	        if (this._pubnub) {
	
	            if (this._pubnubLastChannel == deliveryMode.address) {
	                // Nothing to update, keep listening to same channel
	                return this;
	            } else if (this._pubnubLastChannel) {
	                // Need to subscribe to new channel
	                this._pubnub.unsubscribe({ channel: this._pubnubLastChannel });
	            }
	
	            // Re-init for new data
	            this._pubnub = this._pubnub.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	        } else {
	
	            // Init from scratch
	            this._pubnub = this._pubnubFactory.init({
	                ssl: true,
	                subscribe_key: deliveryMode.subscriberKey
	            });
	
	            this._pubnub.ready(); //TODO This may be not needed anymore
	        }
	
	        this._pubnubLastChannel = deliveryMode.address;
	
	        this._pubnub.subscribe({
	            channel: deliveryMode.address,
	            message: this._notify.bind(this),
	            connect: function connect() {}
	        });
	
	        return this;
	    };
	
	    return Subscription;
	}(_events2.default);
	
	//export interface ISubscription {
	//    id?:string;
	//    uri?: string;
	//    eventFilters?:string[];
	//    expirationTime?:string; // 2014-03-12T19:54:35.613Z
	//    expiresIn?:number;
	//    deliveryMode?: {
	//        transportType?:string;
	//        encryption?:boolean;
	//        address?:string;
	//        subscriberKey?:string;
	//        encryptionKey?:string;
	//        secretKey?:string;
	//    };
	//    creationTime?:string; // 2014-03-12T19:54:35.613Z
	//    status?:string; // Active
	//}
	
	
	Subscription._renewHandicapMs = 2 * 60 * 1000;
	Subscription._pollInterval = 10 * 1000;
	exports.default = Subscription;
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	"use strict";
	
	exports.__esModule = true;
	
	var _Subscription2 = __webpack_require__(19);
	
	var _Subscription3 = _interopRequireDefault(_Subscription2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CachedSubscription = function (_Subscription) {
	    _inherits(CachedSubscription, _Subscription);
	
	    function CachedSubscription(pubnubFactory, platform, cache, cacheKey) {
	        _classCallCheck(this, CachedSubscription);
	
	        /** @type {Cache} */
	
	        var _this = _possibleConstructorReturn(this, _Subscription.call(this, pubnubFactory, platform));
	
	        _this._cache = cache;
	        _this._cacheKey = cacheKey;
	
	        return _this;
	    }
	
	    CachedSubscription.prototype.subscription = function subscription() {
	        return this._cache.getItem(this._cacheKey) || {};
	    };
	
	    CachedSubscription.prototype._setSubscription = function _setSubscription(subscription) {
	        return this._cache.setItem(this._cacheKey, subscription);
	    };
	
	    /**
	     * This function checks whether there are any pre-defined eventFilters in cache and if not -- uses provided as defaults
	     * @param {string[]} events
	     * @return {CachedSubscription}
	     */
	
	
	    CachedSubscription.prototype.restore = function restore(events) {
	
	        if (!this.eventFilters().length) {
	            this.setEventFilters(events);
	        }
	
	        return this;
	    };
	
	    return CachedSubscription;
	}(_Subscription3.default);
	
	exports.default = CachedSubscription;
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), __webpack_require__(122).Buffer))

/***/ },
/* 121 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(123)
	var ieee754 = __webpack_require__(124)
	var isArray = __webpack_require__(125)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(122).Buffer, (function() { return this; }())))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 124 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(128);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(129)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121), (function() { return this; }()), __webpack_require__(127)(module)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 128 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 130 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  var support = {
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var status = (xhr.status === 1223) ? 204 : xhr.status
	        if (status < 100 || status > 599) {
	          reject(new TypeError('Network request failed'))
	          return
	        }
	        var options = {
	          status: status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*! 3.15.2 / modern */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["PUBNUB"] = factory();
		else
			root["PUBNUB"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* globals 'Modern' */
		/* eslint curly: 0, camelcase: 0, dot-notation: 0 */
	
		var packageJSON = __webpack_require__(1);
		var pubNubCore = __webpack_require__(2);
		var crypto_obj = __webpack_require__(5);
		var CryptoJS = __webpack_require__(6);
		var WS = __webpack_require__(7);
	
		/**
		 * UTIL LOCALS
		 */
		var PNSDK = 'PubNub-JS-' + 'Modern' + '/' + packageJSON.version;
	
		/**
		 * LOCAL STORAGE
		 */
		var db = (function () {
		  var ls = typeof localStorage !== 'undefined' && localStorage;
		  return {
		    get: function (key) {
		      try {
		        if (ls) return ls.getItem(key);
		        if (document.cookie.indexOf(key) === -1) return null;
		        return ((document.cookie || '').match(
		            RegExp(key + '=([^;]+)')
		          ) || [])[1] || null;
		      } catch (e) {
		        return;
		      }
		    },
		    set: function (key, value) {
		      try {
		        if (ls) return ls.setItem(key, value) && 0;
		        document.cookie = key + '=' + value +
		          '; expires=Thu, 1 Aug 2030 20:00:00 UTC; path=/';
		      } catch (e) {
		        return;
		      }
		    }
		  };
		})();
	
	
		/**
		 * CORS XHR Request
		 * ================
		 *  xdr({
		 *     url     : ['http://www.blah.com/url'],
		 *     success : function(response) {},
		 *     fail    : function() {}
		 *  });
		 */
		function xdr(setup) {
		  var xhr;
		  var timer;
		  var complete = 0;
		  var loaded = 0;
		  var async = true; /* do not allow sync operations in modern builds */
		  var xhrtme = setup.timeout || pubNubCore.DEF_TIMEOUT;
		  var data = setup.data || {};
		  var fail = setup.fail || function () {};
		  var success = setup.success || function () {};
	
		  var done = function (failed, response) {
		    if (complete) return;
		    complete = 1;
	
		    clearTimeout(timer);
	
		    if (xhr) {
		      xhr.onerror = xhr.onload = null;
		      if (xhr.abort) xhr.abort();
		      xhr = null;
		    }
	
		    if (failed) fail(response);
		  };
	
		  var finished = function () {
		    if (loaded) return;
		    var response;
		    loaded = 1;
	
		    clearTimeout(timer);
	
		    try {
		      response = JSON.parse(xhr.responseText);
		    } catch (r) {
		      return done(1);
		    }
	
		    success(response);
		  };
	
		  timer = pubNubCore.timeout(function () {
		    done(1);
		  }, xhrtme);
	
		  // Send
		  try {
		    xhr = typeof XDomainRequest !== 'undefined' &&
		      new XDomainRequest() ||
		      new XMLHttpRequest();
	
		    xhr.onerror = xhr.onabort = function () {
		      done(1, xhr.responseText || { error: 'Network Connection Error' });
		    };
		    xhr.onload = xhr.onloadend = finished;
	
		    data.pnsdk = PNSDK;
		    var url = pubNubCore.build_url(setup.url, data);
		    xhr.open('GET', url, async);
		    if (async) xhr.timeout = xhrtme;
		    xhr.send();
		  } catch (eee) {
		    done(1, { error: 'XHR Failed', stacktrace: eee });
		  }
	
		  // Return 'done'
		  return done;
		}
	
		/**
		 * BIND
		 * ====
		 * bind( 'keydown', search('a')[0], function(element) {
		 *     ...
		 * } );
		 */
		function bind(type, el, fun) {
		  pubNubCore.each(type.split(','), function (etype) {
		    var rapfun = function (e) {
		      if (!e) e = window.event;
		      if (!fun(e)) {
		        e.cancelBubble = true;
		        e.returnValue = false;
		        if (e.preventDefault) e.preventDefault();
		        if (e.stopPropagation) e.stopPropagation();
		      }
		    };
	
		    if (el.addEventListener) el.addEventListener(etype, rapfun, false);
		    else if (el.attachEvent) el.attachEvent('on' + etype, rapfun);
		    else el['on' + etype] = rapfun;
		  });
		}
	
		/**
		 * ERROR
		 * ===
		 * error('message');
		 */
		function error(message) {
		  console.error(message); // eslint-disable-line no-console
		}
	
		/**
		 * EVENTS
		 * ======
		 * PUBNUB.events.bind( 'you-stepped-on-flower', function(message) {
		 *     // Do Stuff with message
		 * } );
		 *
		 * PUBNUB.events.fire( 'you-stepped-on-flower', "message-data" );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', {message:"data"} );
		 * PUBNUB.events.fire( 'you-stepped-on-flower', [1,2,3] );
		 *
		 */
		var events = {
		  list: {},
		  unbind: function (name) {
		    events.list[name] = [];
		  },
		  bind: function (name, fun) {
		    (events.list[name] = events.list[name] || []).push(fun);
		  },
		  fire: function (name, data) {
		    pubNubCore.each(
		      events.list[name] || [],
		      function (fun) {
		        fun(data);
		      }
		    );
		  }
		};
	
		/**
		 * ATTR
		 * ====
		 * var attribute = attr( node, 'attribute' );
		 */
		function attr(node, attribute, value) {
		  if (value) node.setAttribute(attribute, value);
		  else return node && node.getAttribute && node.getAttribute(attribute);
		}
	
		/**
		 * $
		 * =
		 * var div = $('divid');
		 */
		function $(id) {
		  return document.getElementById(id);
		}
	
	
		/**
		 * SEARCH
		 * ======
		 * var elements = search('a div span');
		 */
		function search(elements, start) {
		  var list = [];
		  pubNubCore.each(elements.split(/\s+/), function (el) {
		    pubNubCore.each((start || document).getElementsByTagName(el), function (node) {
		      list.push(node);
		    });
		  });
		  return list;
		}
	
		/**
		 * CSS
		 * ===
		 * var obj = create('div');
		 */
		function css(element, styles) {
		  for (var style in styles) if (styles.hasOwnProperty(style))
		    try {
		      element.style[style] = styles[style] + (
		          '|width|height|top|left|'.indexOf(style) > 0 &&
		          typeof styles[style] === 'number'
		            ? 'px' : ''
		        );
		    } catch (e) {
		      return;
		    }
		}
	
		/**
		 * CREATE
		 * ======
		 * var obj = create('div');
		 */
		function create(element) {
		  return document.createElement(element);
		}
	
	
		function get_hmac_SHA256(data, key) {
		  var hash = CryptoJS['HmacSHA256'](data, key);
		  return hash.toString(CryptoJS['enc']['Base64']);
		}
	
		/* =-====================================================================-= */
		/* =-====================================================================-= */
		/* =-=========================     PUBNUB     ===========================-= */
		/* =-====================================================================-= */
		/* =-====================================================================-= */
	
		function CREATE_PUBNUB(setup) {
		  setup.db = db;
		  setup.xdr = xdr;
		  setup.error = setup.error || error;
		  setup.hmac_SHA256 = get_hmac_SHA256;
		  setup.crypto_obj = crypto_obj();
		  setup.WS = WS;
		  setup.params = { pnsdk: PNSDK };
	
		  var SELF = function (setup) {
		    return CREATE_PUBNUB(setup);
		  };
	
		  var PN = pubNubCore.PN_API(setup);
		  for (var prop in PN) {
		    if (PN.hasOwnProperty(prop)) {
		      SELF[prop] = PN[prop];
		    }
		  }
	
		  SELF.init = SELF;
		  SELF.$ = $;
		  SELF.attr = attr;
		  SELF.search = search;
		  SELF.bind = bind;
		  SELF.css = css;
		  SELF.create = create;
		  SELF.crypto_obj = crypto_obj();
		  SELF.WS = WS;
		  SELF.PNmessage = pubNubCore.PNmessage;
		  SELF.supplant = pubNubCore.supplant;
	
		  if (typeof(window) !== 'undefined') {
		    bind('beforeunload', window, function () {
		      SELF['each-channel'](function (ch) {
		        SELF['LEAVE'](ch.name, 1);
		      });
		      return true;
		    });
		  }
	
		  SELF.ready();
	
		  // Return without Testing
		  if (setup.notest) return SELF;
	
		  if (typeof(window) !== 'undefined') {
		    bind('offline', window, SELF['offline']);
		  }
	
		  if (typeof(document) !== 'undefined') {
		    bind('offline', document, SELF['offline']);
		  }
	
		  return SELF;
		}
	
		CREATE_PUBNUB.init = CREATE_PUBNUB;
		CREATE_PUBNUB.secure = CREATE_PUBNUB;
		CREATE_PUBNUB.crypto_obj = crypto_obj();
		CREATE_PUBNUB.WS = WS;
		CREATE_PUBNUB.db = db;
		CREATE_PUBNUB.PNmessage = pubNubCore.PNmessage;
		CREATE_PUBNUB.uuid = pubNubCore.uuid;
	
		CREATE_PUBNUB.css = css;
		CREATE_PUBNUB.$ = $;
		CREATE_PUBNUB.create = $;
		CREATE_PUBNUB.bind = bind;
		CREATE_PUBNUB.search = search;
		CREATE_PUBNUB.attr = attr;
		CREATE_PUBNUB.events = events;
	
		CREATE_PUBNUB.map = pubNubCore.map;
		CREATE_PUBNUB.each = pubNubCore.each;
		CREATE_PUBNUB.grep = pubNubCore.grep;
		CREATE_PUBNUB.supplant = pubNubCore.supplant;
		CREATE_PUBNUB.now = pubNubCore.now;
		CREATE_PUBNUB.unique = pubNubCore.unique;
		CREATE_PUBNUB.updater = pubNubCore.updater;
	
		module.exports = CREATE_PUBNUB;
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports) {
	
		module.exports = {
			"name": "pubnub",
			"preferGlobal": false,
			"version": "3.15.2",
			"author": "PubNub <support@pubnub.com>",
			"description": "Publish & Subscribe Real-time Messaging with PubNub",
			"contributors": [
				{
					"name": "Stephen Blum",
					"email": "stephen@pubnub.com"
				}
			],
			"bin": {},
			"scripts": {
				"test": "grunt test --force"
			},
			"main": "./node.js/pubnub.js",
			"browser": "./modern/dist/pubnub.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/pubnub/javascript.git"
			},
			"keywords": [
				"cloud",
				"publish",
				"subscribe",
				"websockets",
				"comet",
				"bosh",
				"xmpp",
				"real-time",
				"messaging"
			],
			"dependencies": {
				"agentkeepalive": "~0.2",
				"lodash": "^4.1.0"
			},
			"noAnalyze": false,
			"devDependencies": {
				"chai": "^3.5.0",
				"eslint": "2.4.0",
				"eslint-config-airbnb": "^6.0.2",
				"eslint-plugin-flowtype": "^2.1.0",
				"eslint-plugin-mocha": "^2.0.0",
				"eslint-plugin-react": "^4.1.0",
				"flow-bin": "^0.22.0",
				"grunt": "^0.4.5",
				"grunt-contrib-clean": "^1.0.0",
				"grunt-contrib-copy": "^0.8.2",
				"grunt-contrib-uglify": "^0.11.1",
				"grunt-env": "^0.4.4",
				"grunt-eslint": "^18.0.0",
				"grunt-flow": "^1.0.3",
				"grunt-karma": "^0.12.1",
				"grunt-mocha-istanbul": "^3.0.1",
				"grunt-text-replace": "^0.4.0",
				"grunt-webpack": "^1.0.11",
				"imports-loader": "^0.6.5",
				"isparta": "^4.0.0",
				"json-loader": "^0.5.4",
				"karma": "^0.13.21",
				"karma-chai": "^0.1.0",
				"karma-mocha": "^0.2.1",
				"karma-phantomjs-launcher": "^1.0.0",
				"karma-spec-reporter": "0.0.24",
				"load-grunt-tasks": "^3.4.0",
				"mocha": "^2.4.5",
				"nock": "^1.1.0",
				"node-uuid": "^1.4.7",
				"nodeunit": "^0.9.0",
				"phantomjs-prebuilt": "^2.1.4",
				"proxyquire": "^1.7.4",
				"sinon": "^1.17.2",
				"uglify-js": "^2.6.1",
				"underscore": "^1.7.0",
				"webpack": "^1.12.13",
				"webpack-dev-server": "^1.14.1"
			},
			"bundleDependencies": [],
			"license": "MIT",
			"engine": {
				"node": ">=0.8"
			},
			"files": [
				"core",
				"node.js",
				"modern",
				"CHANGELOG",
				"FUTURE.md",
				"LICENSE",
				"README.md"
			]
		};
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0, no-use-before-define: 0, no-unused-expressions: 0  */
		/* eslint eqeqeq: 0, one-var: 0 */
		/* eslint no-redeclare: 0 */
		/* eslint guard-for-in: 0 */
		/* eslint block-scoped-var: 0 space-return-throw-case: 0, no-unused-vars: 0 */
	
		var packageJSON = __webpack_require__(1);
		var defaultConfiguration = __webpack_require__(3);
		var utils = __webpack_require__(4);
	
		var NOW = 1;
		var READY = false;
		var READY_BUFFER = [];
		var PRESENCE_SUFFIX = '-pnpres';
		var DEF_WINDOWING = 10; // MILLISECONDS.
		var DEF_TIMEOUT = 15000; // MILLISECONDS.
		var DEF_SUB_TIMEOUT = 310; // SECONDS.
		var DEF_KEEPALIVE = 60; // SECONDS (FOR TIMESYNC).
		var SECOND = 1000; // A THOUSAND MILLISECONDS.
		var PRESENCE_HB_THRESHOLD = 5;
		var PRESENCE_HB_DEFAULT = 30;
		var SDK_VER = packageJSON.version;
	
		/**
		 * UTILITIES
		 */
		function unique() {
		  return 'x' + ++NOW + '' + (+new Date);
		}
	
		/**
		 * NEXTORIGIN
		 * ==========
		 * var next_origin = nextorigin();
		 */
		var nextorigin = (function () {
		  var max = 20;
		  var ori = Math.floor(Math.random() * max);
		  return function (origin, failover) {
		    return origin.indexOf('pubsub.') > 0
		      && origin.replace(
		        'pubsub', 'ps' + (
		          failover ? utils.generateUUID().split('-')[0] :
		            (++ori < max ? ori : ori = 1)
		        )) || origin;
		  };
		})();
	
	
		/**
		 * Generate Subscription Channel List
		 * ==================================
		 * generate_channel_list(channels_object);
		 */
		function generate_channel_list(channels, nopresence) {
		  var list = [];
		  utils.each(channels, function (channel, status) {
		    if (nopresence) {
		      if (channel.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel);
		      }
		    } else {
		      if (status.subscribed) list.push(channel);
		    }
		  });
		  return list.sort();
		}
	
		/**
		 * Generate Subscription Channel Groups List
		 * ==================================
		 * generate_channel_group_list(channels_groups object);
		 */
		function generate_channel_group_list(channel_groups, nopresence) {
		  var list = [];
		  utils.each(channel_groups, function (channel_group, status) {
		    if (nopresence) {
		      if (channel_group.search('-pnpres') < 0) {
		        if (status.subscribed) list.push(channel_group);
		      }
		    } else {
		      if (status.subscribed) list.push(channel_group);
		    }
		  });
		  return list.sort();
		}
	
		// PUBNUB READY TO CONNECT
		function ready() {
		  if (READY) return;
		  READY = 1;
		  utils.each(READY_BUFFER, function (connect) {
		    connect();
		  });
		}
	
		function PNmessage(args) {
		  var msg = args || { apns: {} };
	
		  msg['getPubnubMessage'] = function () {
		    var m = {};
	
		    if (Object.keys(msg['apns']).length) {
		      m['pn_apns'] = {
		        aps: {
		          alert: msg['apns']['alert'],
		          badge: msg['apns']['badge']
		        }
		      };
		      for (var k in msg['apns']) {
		        m['pn_apns'][k] = msg['apns'][k];
		      }
		      var exclude1 = ['badge', 'alert'];
		      for (var k in exclude1) {
		        delete m['pn_apns'][exclude1[k]];
		      }
		    }
	
		    if (msg['gcm']) {
		      m['pn_gcm'] = {
		        data: msg['gcm']
		      };
		    }
	
		    for (var k in msg) {
		      m[k] = msg[k];
		    }
		    var exclude = ['apns', 'gcm', 'publish', 'channel', 'callback', 'error'];
		    for (var k in exclude) {
		      delete m[exclude[k]];
		    }
	
		    return m;
		  };
		  msg['publish'] = function () {
		    var m = msg.getPubnubMessage();
	
		    if (msg['pubnub'] && msg['channel']) {
		      msg['pubnub'].publish({
		        message: m,
		        channel: msg['channel'],
		        callback: msg['callback'],
		        error: msg['error']
		      });
		    }
		  };
		  return msg;
		}
	
		function PN_API(setup) {
		  var SUB_WINDOWING = +setup['windowing'] || DEF_WINDOWING;
		  var SUB_TIMEOUT = (+setup['timeout'] || DEF_SUB_TIMEOUT) * SECOND;
		  var KEEPALIVE = (+setup['keepalive'] || DEF_KEEPALIVE) * SECOND;
		  var TIME_CHECK = setup['timecheck'] || 0;
		  var NOLEAVE = setup['noleave'] || 0;
		  var PUBLISH_KEY = setup['publish_key'];
		  var SUBSCRIBE_KEY = setup['subscribe_key'];
		  var AUTH_KEY = setup['auth_key'] || '';
		  var SECRET_KEY = setup['secret_key'] || '';
		  var hmac_SHA256 = setup['hmac_SHA256'];
		  var SSL = setup['ssl'] ? 's' : '';
		  var ORIGIN = 'http' + SSL + '://' + (setup['origin'] || 'pubsub.pubnub.com');
		  var STD_ORIGIN = nextorigin(ORIGIN);
		  var SUB_ORIGIN = nextorigin(ORIGIN);
		  var CONNECT = function () {
		  };
		  var PUB_QUEUE = [];
		  var CLOAK = true;
		  var TIME_DRIFT = 0;
		  var SUB_CALLBACK = 0;
		  var SUB_CHANNEL = 0;
		  var SUB_RECEIVER = 0;
		  var SUB_RESTORE = setup['restore'] || 0;
		  var SUB_BUFF_WAIT = 0;
		  var TIMETOKEN = 0;
		  var RESUMED = false;
		  var CHANNELS = {};
		  var CHANNEL_GROUPS = {};
		  var SUB_ERROR = function () {
		  };
		  var STATE = {};
		  var PRESENCE_HB_TIMEOUT = null;
		  var PRESENCE_HB = validate_presence_heartbeat(
		    setup['heartbeat'] || setup['pnexpires'] || 0, setup['error']
		  );
		  var PRESENCE_HB_INTERVAL = setup['heartbeat_interval'] || (PRESENCE_HB / 2) - 1;
		  var PRESENCE_HB_RUNNING = false;
		  var NO_WAIT_FOR_PENDING = setup['no_wait_for_pending'];
		  var COMPATIBLE_35 = setup['compatible_3.5'] || false;
		  var xdr = setup['xdr'];
		  var params = setup['params'] || {};
		  var error = setup['error'] || function () {};
		  var _is_online = setup['_is_online'] || function () { return 1;};
		  var jsonp_cb = setup['jsonp_cb'] || function () { return 0; };
		  var db = setup['db'] || { get: function () {}, set: function () {} };
		  var CIPHER_KEY = setup['cipher_key'];
		  var UUID = setup['uuid'] || (!setup['unique_uuid'] && db && db['get'](SUBSCRIBE_KEY + 'uuid') || '');
		  var USE_INSTANCEID = setup['instance_id'] || false;
		  var INSTANCEID = '';
		  var shutdown = setup['shutdown'];
		  var use_send_beacon = (typeof setup['use_send_beacon'] != 'undefined') ? setup['use_send_beacon'] : true;
		  var sendBeacon = (use_send_beacon) ? setup['sendBeacon'] : null;
		  var _poll_timer;
		  var _poll_timer2;
	
		  if (PRESENCE_HB === 2) PRESENCE_HB_INTERVAL = 1;
	
		  var crypto_obj = setup['crypto_obj'] || {
		    encrypt: function (a, key) {
		      return a;
		    },
		    decrypt: function (b, key) {
		      return b;
		    }
		  };
	
		  function _get_url_params(data) {
		    if (!data) data = {};
		    utils.each(params, function (key, value) {
		      if (!(key in data)) data[key] = value;
		    });
		    return data;
		  }
	
		  function _object_to_key_list(o) {
		    var l = [];
		    utils.each(o, function (key, value) {
		      l.push(key);
		    });
		    return l;
		  }
	
		  function _object_to_key_list_sorted(o) {
		    return _object_to_key_list(o).sort();
		  }
	
		  function _get_pam_sign_input_from_params(params) {
		    var si = '';
		    var l = _object_to_key_list_sorted(params);
	
		    for (var i in l) {
		      var k = l[i];
		      si += k + '=' + utils.pamEncode(params[k]);
		      if (i != l.length - 1) si += '&';
		    }
		    return si;
		  }
	
		  function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {
		    var err = false;
	
		    if (typeof heartbeat === 'undefined') {
		      return cur_heartbeat;
		    }
	
		    if (typeof heartbeat === 'number') {
		      if (heartbeat > PRESENCE_HB_THRESHOLD || heartbeat == 0) {
		        err = false;
		      } else {
		        err = true;
		      }
		    } else if (typeof heartbeat === 'boolean') {
		      if (!heartbeat) {
		        return 0;
		      } else {
		        return PRESENCE_HB_DEFAULT;
		      }
		    } else {
		      err = true;
		    }
	
		    if (err) {
		      error && error('Presence Heartbeat value invalid. Valid range ( x > ' + PRESENCE_HB_THRESHOLD + ' or x = 0). Current Value : ' + (cur_heartbeat || PRESENCE_HB_THRESHOLD));
		      return cur_heartbeat || PRESENCE_HB_THRESHOLD;
		    } else return heartbeat;
		  }
	
		  function encrypt(input, key) {
		    return crypto_obj['encrypt'](input, key || CIPHER_KEY) || input;
		  }
	
		  function decrypt(input, key) {
		    return crypto_obj['decrypt'](input, key || CIPHER_KEY) ||
		      crypto_obj['decrypt'](input, CIPHER_KEY) ||
		      input;
		  }
	
		  function error_common(message, callback) {
		    callback && callback({ error: message || 'error occurred' });
		    error && error(message);
		  }
	
		  function _presence_heartbeat() {
		    clearTimeout(PRESENCE_HB_TIMEOUT);
	
		    if (!PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 ||
		      PRESENCE_HB_INTERVAL < 1 ||
		      (!generate_channel_list(CHANNELS, true).length && !generate_channel_group_list(CHANNEL_GROUPS, true).length)) {
		      PRESENCE_HB_RUNNING = false;
		      return;
		    }
	
		    PRESENCE_HB_RUNNING = true;
		    SELF['presence_heartbeat']({
		      callback: function (r) {
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      },
		      error: function (e) {
		        error && error('Presence Heartbeat unable to reach Pubnub servers.' + JSON.stringify(e));
		        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, (PRESENCE_HB_INTERVAL) * SECOND);
		      }
		    });
		  }
	
		  function start_presence_heartbeat() {
		    !PRESENCE_HB_RUNNING && _presence_heartbeat();
		  }
	
		  function publish(next) {
		    if (NO_WAIT_FOR_PENDING) {
		      if (!PUB_QUEUE.length) return;
		    } else {
		      if (next) PUB_QUEUE.sending = 0;
		      if (PUB_QUEUE.sending || !PUB_QUEUE.length) return;
		      PUB_QUEUE.sending = 1;
		    }
	
		    xdr(PUB_QUEUE.shift());
		  }
	
		  function each_channel_group(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_group_list(CHANNEL_GROUPS), function (channel_group) {
		      var chang = CHANNEL_GROUPS[channel_group];
	
		      if (!chang) return;
	
		      count++;
		      (callback || function () {
		      })(chang);
		    });
	
		    return count;
		  }
	
		  function each_channel(callback) {
		    var count = 0;
	
		    utils.each(generate_channel_list(CHANNELS), function (channel) {
		      var chan = CHANNELS[channel];
	
		      if (!chan) return;
	
		      count++;
		      (callback || function () {
		      })(chan);
		    });
	
		    return count;
		  }
	
		  function _invoke_callback(response, callback, err) {
		    if (typeof response == 'object') {
		      if (response['error']) {
		        var callback_data = {};
	
		        if (response['message']) {
		          callback_data['message'] = response['message'];
		        }
	
		        if (response['payload']) {
		          callback_data['payload'] = response['payload'];
		        }
	
		        err && err(callback_data);
		        return;
		      }
		      if (response['payload']) {
		        if (response['next_page']) {
		          callback && callback(response['payload'], response['next_page']);
		        } else {
		          callback && callback(response['payload']);
		        }
		        return;
		      }
		    }
		    callback && callback(response);
		  }
	
		  function _invoke_error(response, err) {
		    if (typeof response == 'object' && response['error']) {
		      var callback_data = {};
	
		      if (response['message']) {
		        callback_data['message'] = response['message'];
		      }
	
		      if (response['payload']) {
		        callback_data['payload'] = response['payload'];
		      }
	
		      err && err(callback_data);
		      return;
		    } else {
		      err && err(response);
		    }
		  }
	
		  function CR(args, callback, url1, data) {
		    var callback = args['callback'] || callback;
		    var err = args['error'] || error;
		    var jsonp = jsonp_cb();
	
		    data = data || {};
	
		    if (!data['auth']) {
		      data['auth'] = args['auth_key'] || AUTH_KEY;
		    }
	
		    var url = [
		      STD_ORIGIN, 'v1', 'channel-registration',
		      'sub-key', SUBSCRIBE_KEY
		    ];
	
		    url.push.apply(url, url1);
	
		    if (jsonp) data['callback'] = jsonp;
	
		    xdr({
		      callback: jsonp,
		      data: _get_url_params(data),
		      success: function (response) {
		        _invoke_callback(response, callback, err);
		      },
		      fail: function (response) {
		        _invoke_error(response, err);
		      },
		      url: url
		    });
		  }
	
		  // Announce Leave Event
		  var SELF = {
		    LEAVE: function (channel, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var url;
		      var params;
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel
		      if (channel.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(channel), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    LEAVE_GROUP: function (channel_group, blocking, auth_key, callback, error) {
		      var data = { uuid: UUID, auth: auth_key || AUTH_KEY };
		      var origin = nextorigin(ORIGIN);
		      var url;
		      var params;
		      var callback = callback || function () {};
		      var err = error || function () {};
		      var jsonp = jsonp_cb();
	
		      // Prevent Leaving a Presence Channel Group
		      if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return true;
	
		      if (COMPATIBLE_35) {
		        if (!SSL) return false;
		        if (jsonp == '0') return false;
		      }
	
		      if (NOLEAVE) return false;
	
		      if (jsonp != '0') data['callback'] = jsonp;
	
		      if (channel_group && channel_group.length > 0) data['channel-group'] = channel_group;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      url = [
		        origin, 'v2', 'presence', 'sub_key',
		        SUBSCRIBE_KEY, 'channel', utils.encode(','), 'leave'
		      ];
	
		      params = _get_url_params(data);
	
		      if (sendBeacon) {
		        var url_string = utils.buildURL(url, params);
		        if (sendBeacon(url_string)) {
		          callback && callback({ status: 200, action: 'leave', message: 'OK', service: 'Presence' });
		          return true;
		        }
		      }
	
		      xdr({
		        blocking: blocking || SSL,
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		      return true;
		    },
	
		    set_resumed: function (resumed) {
		      RESUMED = resumed;
		    },
	
		    get_cipher_key: function () {
		      return CIPHER_KEY;
		    },
	
		    set_cipher_key: function (key) {
		      CIPHER_KEY = key;
		    },
	
		    raw_encrypt: function (input, key) {
		      return encrypt(input, key);
		    },
	
		    raw_decrypt: function (input, key) {
		      return decrypt(input, key);
		    },
	
		    get_heartbeat: function () {
		      return PRESENCE_HB;
		    },
	
		    set_heartbeat: function (heartbeat, heartbeat_interval) {
		      PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error);
		      PRESENCE_HB_INTERVAL = heartbeat_interval || (PRESENCE_HB / 2) - 1;
		      if (PRESENCE_HB == 2) {
		        PRESENCE_HB_INTERVAL = 1;
		      }
		      CONNECT();
		      _presence_heartbeat();
		    },
	
		    get_heartbeat_interval: function () {
		      return PRESENCE_HB_INTERVAL;
		    },
	
		    set_heartbeat_interval: function (heartbeat_interval) {
		      PRESENCE_HB_INTERVAL = heartbeat_interval;
		      _presence_heartbeat();
		    },
	
		    get_version: function () {
		      return SDK_VER;
		    },
	
		    getGcmMessageObject: function (obj) {
		      return {
		        data: obj
		      };
		    },
	
		    getApnsMessageObject: function (obj) {
		      var x = {
		        aps: { badge: 1, alert: '' }
		      };
		      for (var k in obj) {
		        k[x] = obj[k];
		      }
		      return x;
		    },
	
		    _add_param: function (key, val) {
		      params[key] = val;
		    },
	
		    channel_group: function (args, callback) {
		      var ns_ch = args['channel_group'];
		      var callback = callback || args['callback'];
		      var channels = args['channels'] || args['channel'];
		      var cloak = args['cloak'];
		      var namespace;
		      var channel_group;
		      var url = [];
		      var data = {};
		      var mode = args['mode'] || 'add';
	
	
		      if (ns_ch) {
		        var ns_ch_a = ns_ch.split(':');
	
		        if (ns_ch_a.length > 1) {
		          namespace = (ns_ch_a[0] === '*') ? null : ns_ch_a[0];
	
		          channel_group = ns_ch_a[1];
		        } else {
		          channel_group = ns_ch_a[0];
		        }
		      }
	
		      namespace && url.push('namespace') && url.push(utils.encode(namespace));
	
		      url.push('channel-group');
	
		      if (channel_group && channel_group !== '*') {
		        url.push(channel_group);
		      }
	
		      if (channels) {
		        if (utils.isArray(channels)) {
		          channels = channels.join(',');
		        }
		        data[mode] = channels;
		        data['cloak'] = (CLOAK) ? 'true' : 'false';
		      } else {
		        if (mode === 'remove') url.push('remove');
		      }
	
		      if (typeof cloak != 'undefined') data['cloak'] = (cloak) ? 'true' : 'false';
	
		      CR(args, callback, url, data);
		    },
	
		    channel_group_list_groups: function (args, callback) {
		      var namespace;
	
		      namespace = args['namespace'] || args['ns'] || args['channel_group'] || null;
		      if (namespace) {
		        args['channel_group'] = namespace + ':*';
		      }
	
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_channels: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_remove_group: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (args['channel']) return error('Use channel_group_remove_channel if you want to remove a channel from a group.');
	
		      args['mode'] = 'remove';
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_add_channel: function (args, callback) {
		      if (!args['channel_group']) return error('Missing Channel Group');
		      if (!args['channel'] && !args['channels']) return error('Missing Channel');
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_cloak: function (args, callback) {
		      if (typeof args['cloak'] == 'undefined') {
		        callback(CLOAK);
		        return;
		      }
		      CLOAK = args['cloak'];
		      SELF['channel_group'](args, callback);
		    },
	
		    channel_group_list_namespaces: function (args, callback) {
		      var url = ['namespace'];
		      CR(args, callback, url);
		    },
	
		    channel_group_remove_namespace: function (args, callback) {
		      var url = ['namespace', args['namespace'], 'remove'];
		      CR(args, callback, url);
		    },
	
		    /*
		     PUBNUB.history({
		     channel  : 'my_chat_channel',
		     limit    : 100,
		     callback : function(history) { }
		     });
		     */
		    history: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var count = args['count'] || args['limit'] || 100;
		      var reverse = args['reverse'] || 'false';
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var start = args['start'];
		      var end = args['end'];
		      var include_token = args['include_token'];
		      var string_msg_token = args['string_message_token'] || false;
		      var params = {};
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) return error('Missing Channel');
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      params['stringtoken'] = 'true';
		      params['count'] = count;
		      params['reverse'] = reverse;
		      params['auth'] = auth_key;
	
		      if (channel_group) {
		        params['channel-group'] = channel_group;
		        if (!channel) {
		          channel = ',';
		        }
		      }
		      if (jsonp) params['callback'] = jsonp;
		      if (start) params['start'] = start;
		      if (end) params['end'] = end;
		      if (include_token) params['include_token'] = 'true';
		      if (string_msg_token) params['string_message_token'] = 'true';
	
		      // Send Message
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(params),
		        success: function (response) {
		          if (typeof response == 'object' && response['error']) {
		            err({ message: response['message'], payload: response['payload'] });
		            return;
		          }
		          var messages = response[0];
		          var decrypted_messages = [];
		          for (var a = 0; a < messages.length; a++) {
		            if (include_token) {
		              var new_message = decrypt(messages[a]['message'], cipher_key);
		              var timetoken = messages[a]['timetoken'];
		              try {
		                decrypted_messages['push']({ message: JSON['parse'](new_message), timetoken: timetoken });
		              } catch (e) {
		                decrypted_messages['push'](({ message: new_message, timetoken: timetoken }));
		              }
		            } else {
		              var new_message = decrypt(messages[a], cipher_key);
		              try {
		                decrypted_messages['push'](JSON['parse'](new_message));
		              } catch (e) {
		                decrypted_messages['push']((new_message));
		              }
		            }
		          }
		          callback([decrypted_messages, response[1], response[2]]);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'history', 'sub-key',
		          SUBSCRIBE_KEY, 'channel', utils.encode(channel)
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.replay({
		     source      : 'my_channel',
		     destination : 'new_channel'
		     });
		     */
		    replay: function (args, callback) {
		      var callback = callback || args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var source = args['source'];
		      var destination = args['destination'];
		      var err = args['error'] || args['error'] || function () {};
		      var stop = args['stop'];
		      var start = args['start'];
		      var end = args['end'];
		      var reverse = args['reverse'];
		      var limit = args['limit'];
		      var jsonp = jsonp_cb();
		      var data = {};
		      var url;
	
		      // Check User Input
		      if (!source) return error('Missing Source Channel');
		      if (!destination) return error('Missing Destination Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Setup URL Params
		      if (jsonp != '0') data['callback'] = jsonp;
		      if (stop) data['stop'] = 'all';
		      if (reverse) data['reverse'] = 'true';
		      if (start) data['start'] = start;
		      if (end) data['end'] = end;
		      if (limit) data['count'] = limit;
	
		      data['auth'] = auth_key;
	
		      // Compose URL Parts
		      url = [
		        STD_ORIGIN, 'v1', 'replay',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        source, destination
		      ];
	
		      // Start (or Stop) Replay!
		      xdr({
		        callback: jsonp,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function () {
		          callback([0, 'Disconnected']);
		        },
		        url: url,
		        data: _get_url_params(data)
		      });
		    },
	
		    /*
		     PUBNUB.auth('AJFLKAJSDKLA');
		     */
		    auth: function (auth) {
		      AUTH_KEY = auth;
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.time(function(time){ });
		     */
		    time: function (callback) {
		      var jsonp = jsonp_cb();
	
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [STD_ORIGIN, 'time', jsonp],
		        success: function (response) {
		          callback(response[0]);
		        },
		        fail: function () {
		          callback(0);
		        }
		      });
		    },
	
		    /*
		     PUBNUB.publish({
		     channel : 'my_chat_channel',
		     message : 'hello!'
		     });
		     */
		    publish: function (args, callback) {
		      var msg = args['message'];
		      if (!msg) return error('Missing Message');
	
		      var callback = callback || args['callback'] || msg['callback'] || args['success'] || function () {};
		      var channel = args['channel'] || msg['channel'];
		      var meta = args['meta'] || args['metadata'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var cipher_key = args['cipher_key'];
		      var err = args['error'] || msg['error'] || function () {};
		      var post = args['post'] || false;
		      var store = ('store_in_history' in args) ? args['store_in_history'] : true;
		      var replicate = ('replicate' in args) ? args['replicate'] : true;
		      var jsonp = jsonp_cb();
		      var add_msg = 'push';
		      var params;
		      var url;
	
		      if (args['prepend']) add_msg = 'unshift';
	
		      if (!channel) return error('Missing Channel');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (msg['getPubnubMessage']) {
		        msg = msg['getPubnubMessage']();
		      }
	
		      // If trying to send Object
		      msg = JSON['stringify'](encrypt(msg, cipher_key));
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'publish',
		        PUBLISH_KEY, SUBSCRIBE_KEY,
		        0, utils.encode(channel),
		        jsonp, utils.encode(msg)
		      ];
	
		      params = { uuid: UUID, auth: auth_key };
	
		      if (meta && typeof meta === 'object') {
		        params['meta'] = JSON.stringify(meta);
		      }
	
		      if (!store) params['store'] = '0';
		      if (!replicate) params['norep'] = 'true';
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      // Queue Message Send
		      PUB_QUEUE[add_msg]({
		        callback: jsonp,
		        url: url,
		        data: _get_url_params(params),
		        fail: function (response) {
		          _invoke_error(response, err);
		          publish(1);
		        },
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		          publish(1);
		        },
		        mode: (post) ? 'POST' : 'GET'
		      });
	
		      // Send Message
		      publish();
		    },
	
		    fire: function (args, callback) {
		      args.store_in_history = false;
		      args.replicate = false;
		      SELF['publish'](args, callback);
		    },
	
		    /*
		     PUBNUB.unsubscribe({ channel : 'my_chat' });
		     */
		    unsubscribe: function (args, callback) {
		      var channelArg = args['channel'];
		      var channelGroupArg = args['channel_group'];
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var callback = callback || args['callback'] || function () {};
		      var err = args['error'] || function () {};
	
		      if (!channelArg && !channelGroupArg) return error('Missing Channel or Channel Group');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (channelArg) {
		        var channels = utils.isArray(channelArg) ? channelArg : ('' + channelArg).split(',');
		        var existingChannels = [];
		        var presenceChannels = [];
	
		        utils.each(channels, function (channel) {
		          if (CHANNELS[channel]) existingChannels.push(channel);
		        });
	
		        // if we do not have any channels to unsubscribe from, trigger a callback.
		        if (existingChannels.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannels, function (channel) {
		          presenceChannels.push(channel + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannels.concat(presenceChannels), function (channel) {
		          if (channel in CHANNELS) delete CHANNELS[channel];
		          if (channel in STATE) delete STATE[channel];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE'](existingChannels.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      if (channelGroupArg) {
		        var channelGroups = utils.isArray(channelGroupArg) ? channelGroupArg : ('' + channelGroupArg).split(',');
		        var existingChannelGroups = [];
		        var presenceChannelGroups = [];
	
		        utils.each(channelGroups, function (channelGroup) {
		          if (CHANNEL_GROUPS[channelGroup]) existingChannelGroups.push(channelGroup);
		        });
	
		        // if we do not have any channel groups to unsubscribe from, trigger a callback.
		        if (existingChannelGroups.length == 0) {
		          callback({ action: 'leave' });
		          return;
		        }
	
		        // Prepare presence channels
		        utils.each(existingChannelGroups, function (channelGroup) {
		          presenceChannelGroups.push(channelGroup + PRESENCE_SUFFIX);
		        });
	
		        utils.each(existingChannelGroups.concat(presenceChannelGroups), function (channelGroup) {
		          if (channelGroup in CHANNEL_GROUPS) delete CHANNEL_GROUPS[channelGroup];
		          if (channelGroup in STATE) delete STATE[channelGroup];
		        });
	
		        if (CHANNELS.length === 0 && CHANNEL_GROUPS.length === 0) {
		          TIMETOKEN = 0;
		        }
	
		        var CB_CALLED = true;
		        if (READY) {
		          CB_CALLED = SELF['LEAVE_GROUP'](existingChannelGroups.join(','), 0, auth_key, callback, err);
		        }
		        if (!CB_CALLED) callback({ action: 'leave' });
		      }
	
		      // Reset Connection if Count Less
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.subscribe({
		     channel  : 'my_chat'
		     callback : function(message) { }
		     });
		     */
		    subscribe: function (args, callback) {
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var callback = callback || args['callback'];
		      var callback = callback || args['message'];
		      var connect = args['connect'] || function () {};
		      var reconnect = args['reconnect'] || function () {};
		      var disconnect = args['disconnect'] || function () {};
		      var SUB_ERROR = args['error'] || SUB_ERROR || function () {};
		      var idlecb = args['idle'] || function () {};
		      var presence = args['presence'] || 0;
		      var noheresync = args['noheresync'] || 0;
		      var backfill = args['backfill'] || 0;
		      var timetoken = args['timetoken'] || 0;
		      var sub_timeout = args['timeout'] || SUB_TIMEOUT;
		      var windowing = args['windowing'] || SUB_WINDOWING;
		      var state = args['state'];
		      var heartbeat = args['heartbeat'] || args['pnexpires'];
		      var heartbeat_interval = args['heartbeat_interval'];
		      var restore = args['restore'] || SUB_RESTORE;
	
		      AUTH_KEY = args['auth_key'] || AUTH_KEY;
	
		      // Restore Enabled?
		      SUB_RESTORE = restore;
	
		      // Always Reset the TT
		      TIMETOKEN = timetoken;
	
		      // Make sure we have a Channel
		      if (!channel && !channel_group) {
		        return error('Missing Channel');
		      }
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (heartbeat || heartbeat === 0 || heartbeat_interval || heartbeat_interval === 0) {
		        SELF['set_heartbeat'](heartbeat, heartbeat_interval);
		      }
	
		      // Setup Channel(s)
		      if (channel) {
		        utils.each((channel.join ? channel.join(',') : '' + channel).split(','),
		          function (channel) {
		            var settings = CHANNELS[channel] || {};
	
		            // Store Channel State
		            CHANNELS[SUB_CHANNEL = channel] = {
		              name: channel,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            if (state) {
		              if (channel in state) {
		                STATE[channel] = state[channel];
		              } else {
		                STATE[channel] = state;
		              }
		            }
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel: channel + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel: channel,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel);
		                });
		              }
		            });
		          });
		      }
	
		      // Setup Channel Groups
		      if (channel_group) {
		        utils.each((channel_group.join ? channel_group.join(',') : '' + channel_group).split(','),
		          function (channel_group) {
		            var settings = CHANNEL_GROUPS[channel_group] || {};
	
		            CHANNEL_GROUPS[channel_group] = {
		              name: channel_group,
		              connected: settings.connected,
		              disconnected: settings.disconnected,
		              subscribed: 1,
		              callback: SUB_CALLBACK = callback,
		              cipher_key: args['cipher_key'],
		              connect: connect,
		              disconnect: disconnect,
		              reconnect: reconnect
		            };
	
		            // Presence Enabled?
		            if (!presence) return;
	
		            // Subscribe Presence Channel
		            SELF['subscribe']({
		              channel_group: channel_group + PRESENCE_SUFFIX,
		              callback: presence,
		              restore: restore,
		              auth_key: AUTH_KEY
		            });
	
		            // Presence Subscribed?
		            if (settings.subscribed) return;
	
		            // See Who's Here Now?
		            if (noheresync) return;
		            SELF['here_now']({
		              channel_group: channel_group,
		              data: _get_url_params({ uuid: UUID, auth: AUTH_KEY }),
		              callback: function (here) {
		                utils.each('uuids' in here ? here['uuids'] : [], function (uid) {
		                  presence({
		                    action: 'join',
		                    uuid: uid,
		                    timestamp: Math.floor(utils.rnow() / 1000),
		                    occupancy: here['occupancy'] || 1
		                  }, here, channel_group);
		                });
		              }
		            });
		          });
		      }
	
	
		      // Test Network Connection
		      function _test_connection(success) {
		        if (success) {
		          // Begin Next Socket Connection
		          utils.timeout(CONNECT, windowing);
		        } else {
		          // New Origin on Failed Connection
		          STD_ORIGIN = nextorigin(ORIGIN, 1);
		          SUB_ORIGIN = nextorigin(ORIGIN, 1);
	
		          // Re-test Connection
		          utils.timeout(function () {
		            SELF['time'](_test_connection);
		          }, SECOND);
		        }
	
		        // Disconnect & Reconnect
		        each_channel(function (channel) {
		          // Reconnect
		          if (success && channel.disconnected) {
		            channel.disconnected = 0;
		            return channel.reconnect(channel.name);
		          }
	
		          // Disconnect
		          if (!success && !channel.disconnected) {
		            channel.disconnected = 1;
		            channel.disconnect(channel.name);
		          }
		        });
	
		        // Disconnect & Reconnect for channel groups
		        each_channel_group(function (channel_group) {
		          // Reconnect
		          if (success && channel_group.disconnected) {
		            channel_group.disconnected = 0;
		            return channel_group.reconnect(channel_group.name);
		          }
	
		          // Disconnect
		          if (!success && !channel_group.disconnected) {
		            channel_group.disconnected = 1;
		            channel_group.disconnect(channel_group.name);
		          }
		        });
		      }
	
		      // Evented Subscribe
		      function _connect() {
		        var jsonp = jsonp_cb();
		        var channels = generate_channel_list(CHANNELS).join(',');
		        var channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(',');
	
		        // Stop Connection
		        if (!channels && !channel_groups) return;
	
		        if (!channels) channels = ',';
	
		        // Connect to PubNub Subscribe Servers
		        _reset_offline();
	
		        var data = _get_url_params({ uuid: UUID, auth: AUTH_KEY });
	
		        if (channel_groups) {
		          data['channel-group'] = channel_groups;
		        }
	
	
		        var st = JSON.stringify(STATE);
		        if (st.length > 2) data['state'] = JSON.stringify(STATE);
	
		        if (PRESENCE_HB) data['heartbeat'] = PRESENCE_HB;
	
		        if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		        start_presence_heartbeat();
		        SUB_RECEIVER = xdr({
		          timeout: sub_timeout,
		          callback: jsonp,
		          fail: function (response) {
		            if (response && response['error'] && response['service']) {
		              _invoke_error(response, SUB_ERROR);
		              _test_connection(false);
		            } else {
		              SELF['time'](function (success) {
		                !success && (_invoke_error(response, SUB_ERROR));
		                _test_connection(success);
		              });
		            }
		          },
		          data: _get_url_params(data),
		          url: [
		            SUB_ORIGIN, 'subscribe',
		            SUBSCRIBE_KEY, utils.encode(channels),
		            jsonp, TIMETOKEN
		          ],
		          success: function (messages) {
		            // Check for Errors
		            if (!messages || (typeof messages == 'object' && 'error' in messages && messages['error'])) {
		              SUB_ERROR(messages);
		              return utils.timeout(CONNECT, SECOND);
		            }
	
		            // User Idle Callback
		            idlecb(messages[1]);
	
		            // Restore Previous Connection Point if Needed
		            TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db['get'](SUBSCRIBE_KEY) || messages[1];
	
		            /*
		             // Connect
		             each_channel_registry(function(registry){
		             if (registry.connected) return;
		             registry.connected = 1;
		             registry.connect(channel.name);
		             });
		             */
	
		            // Connect
		            each_channel(function (channel) {
		              if (channel.connected) return;
		              channel.connected = 1;
		              channel.connect(channel.name);
		            });
	
		            // Connect for channel groups
		            each_channel_group(function (channel_group) {
		              if (channel_group.connected) return;
		              channel_group.connected = 1;
		              channel_group.connect(channel_group.name);
		            });
	
		            if (RESUMED && !SUB_RESTORE) {
		              TIMETOKEN = 0;
		              RESUMED = false;
		              // Update Saved Timetoken
		              db['set'](SUBSCRIBE_KEY, 0);
		              utils.timeout(_connect, windowing);
		              return;
		            }
	
		            // Invoke Memory Catchup and Receive Up to 100
		            // Previous Messages from the Queue.
		            if (backfill) {
		              TIMETOKEN = 10000;
		              backfill = 0;
		            }
	
		            // Update Saved Timetoken
		            db['set'](SUBSCRIBE_KEY, messages[1]);
	
		            // Route Channel <---> Callback for Message
		            var next_callback = (function () {
		              var channels = '';
		              var channels2 = '';
	
		              if (messages.length > 3) {
		                channels = messages[3];
		                channels2 = messages[2];
		              } else if (messages.length > 2) {
		                channels = messages[2];
		              } else {
		                channels = utils.map(
		                  generate_channel_list(CHANNELS), function (chan) {
		                    return utils.map(
		                      Array(messages[0].length)
		                        .join(',').split(','),
		                      function () {
		                        return chan;
		                      }
		                    );
		                  }).join(',');
		              }
	
		              var list = channels.split(',');
		              var list2 = (channels2) ? channels2.split(',') : [];
	
		              return function () {
		                var channel = list.shift() || SUB_CHANNEL;
		                var channel2 = list2.shift();
	
		                var chobj = {};
	
		                if (channel2) {
		                  if (channel && channel.indexOf('-pnpres') >= 0
		                    && channel2.indexOf('-pnpres') < 0) {
		                    channel2 += '-pnpres';
		                  }
		                  chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || { callback: function () {} };
		                } else {
		                  chobj = CHANNELS[channel];
		                }
	
		                var r = [
		                  chobj
		                    .callback || SUB_CALLBACK,
		                  channel.split(PRESENCE_SUFFIX)[0]
		                ];
		                channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]);
		                return r;
		              };
		            })();
	
		            var latency = detect_latency(+messages[1]);
		            utils.each(messages[0], function (msg) {
		              var next = next_callback();
		              var decrypted_msg = decrypt(msg,
		                (CHANNELS[next[1]]) ? CHANNELS[next[1]]['cipher_key'] : null);
		              next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);
		            });
	
		            utils.timeout(_connect, windowing);
		          }
		        });
		      }
	
		      CONNECT = function () {
		        _reset_offline();
		        utils.timeout(_connect, windowing);
		      };
	
		      // Reduce Status Flicker
		      if (!READY) return READY_BUFFER.push(CONNECT);
	
		      // Connect Now
		      CONNECT();
		    },
	
		    /*
		     PUBNUB.here_now({ channel : 'my_chat', callback : fun });
		     */
		    here_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var debug = args['debug'];
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var uuids = ('uuids' in args) ? args['uuids'] : true;
		      var state = args['state'];
		      var data = { uuid: UUID, auth: auth_key };
	
		      if (!uuids) data['disable_uuids'] = 1;
		      if (state) data['state'] = 1;
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      var url = [
		        STD_ORIGIN, 'v2', 'presence',
		        'sub_key', SUBSCRIBE_KEY
		      ];
	
		      channel && url.push('channel') && url.push(utils.encode(channel));
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (channel_group) {
		        data['channel-group'] = channel_group;
		        !channel && url.push('channel') && url.push(',');
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        debug: debug,
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.current_channels_by_uuid({ channel : 'my_chat', callback : fun });
		     */
		    where_now: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var uuid = args['uuid'] || UUID;
		      var data = { auth: auth_key };
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub_key', SUBSCRIBE_KEY,
		          'uuid', utils.encode(uuid)
		        ]
		      });
		    },
	
		    state: function (args, callback) {
		      var callback = args['callback'] || callback || function (r) {};
		      var err = args['error'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var jsonp = jsonp_cb();
		      var state = args['state'];
		      var uuid = args['uuid'] || UUID;
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var url;
		      var data = _get_url_params({ auth: auth_key });
	
		      // Make sure we have a Channel
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!uuid) return error('Missing UUID');
		      if (!channel && !channel_group) return error('Missing Channel');
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      if (typeof channel != 'undefined'
		        && CHANNELS[channel] && CHANNELS[channel].subscribed) {
		        if (state) STATE[channel] = state;
		      }
	
		      if (typeof channel_group != 'undefined'
		        && CHANNEL_GROUPS[channel_group]
		        && CHANNEL_GROUPS[channel_group].subscribed
		      ) {
		        if (state) STATE[channel_group] = state;
		        data['channel-group'] = channel_group;
	
		        if (!channel) {
		          channel = ',';
		        }
		      }
	
		      data['state'] = JSON.stringify(state);
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      if (state) {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', uuid, 'data'
		        ];
		      } else {
		        url = [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channel,
		          'uuid', utils.encode(uuid)
		        ];
		      }
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
	
		      });
		    },
	
		    /*
		     PUBNUB.grant({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     ttl      : 24 * 60, // Minutes
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    grant: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'] || args['channels'];
		      var channel_group = args['channel_group'];
		      var jsonp = jsonp_cb();
		      var ttl = args['ttl'];
		      var r = (args['read']) ? '1' : '0';
		      var w = (args['write']) ? '1' : '0';
		      var m = (args['manage']) ? '1' : '0';
		      var auth_key = args['auth_key'] || args['auth_keys'];
	
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'grant' + '\n';
	
		      var data = { w: w, r: r, timestamp: timestamp };
	
		      if (args['manage']) {
		        data['m'] = m;
		      }
		      if (utils.isArray(channel)) {
		        channel = channel['join'](',');
		      }
		      if (utils.isArray(auth_key)) {
		        auth_key = auth_key['join'](',');
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (ttl || ttl === 0) data['ttl'] = ttl;
	
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
	
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'grant',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.mobile_gw_provision ({
		     device_id: 'A655FBA9931AB',
		     op       : 'add' | 'remove',
		     gw_type  : 'apns' | 'gcm',
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     });
		     */
	
		    mobile_gw_provision: function (args) {
		      var callback = args['callback'] || function () {};
		      var auth_key = args['auth_key'] || AUTH_KEY;
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var channel = args['channel'];
		      var op = args['op'];
		      var gw_type = args['gw_type'];
		      var device_id = args['device_id'];
		      var params;
		      var url;
	
		      if (!device_id) return error('Missing Device ID (device_id)');
		      if (!gw_type) return error('Missing GW Type (gw_type: gcm or apns)');
		      if (!op) return error('Missing GW Operation (op: add or remove)');
		      if (!channel) return error('Missing gw destination Channel (channel)');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
	
		      // Create URL
		      url = [
		        STD_ORIGIN, 'v1/push/sub-key',
		        SUBSCRIBE_KEY, 'devices', device_id
		      ];
	
		      params = { uuid: UUID, auth: auth_key, type: gw_type };
	
		      if (op == 'add') {
		        params['add'] = channel;
		      } else if (op == 'remove') {
		        params['remove'] = channel;
		      }
	
		      if (USE_INSTANCEID) params['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: params,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: url
		      });
		    },
	
		    /*
		     PUBNUB.audit({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     read     : true,
		     write    : true,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    audit: function (args, callback) {
		      var callback = args['callback'] || callback;
		      var err = args['error'] || function () {};
		      var channel = args['channel'];
		      var channel_group = args['channel_group'];
		      var auth_key = args['auth_key'];
		      var jsonp = jsonp_cb();
	
		      // Make sure we have a Channel
		      if (!callback) return error('Missing Callback');
		      if (!SUBSCRIBE_KEY) return error('Missing Subscribe Key');
		      if (!PUBLISH_KEY) return error('Missing Publish Key');
		      if (!SECRET_KEY) return error('Missing Secret Key');
	
		      var timestamp = Math.floor(new Date().getTime() / 1000);
		      var sign_input = SUBSCRIBE_KEY + '\n' + PUBLISH_KEY + '\n' + 'audit' + '\n';
	
		      var data = { timestamp: timestamp };
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
		      if (typeof channel != 'undefined' && channel != null && channel.length > 0) data['channel'] = channel;
		      if (typeof channel_group != 'undefined' && channel_group != null && channel_group.length > 0) {
		        data['channel-group'] = channel_group;
		      }
		      if (auth_key) data['auth'] = auth_key;
	
		      data = _get_url_params(data);
	
		      if (!auth_key) delete data['auth'];
	
		      sign_input += _get_pam_sign_input_from_params(data);
	
		      var signature = hmac_SHA256(sign_input, SECRET_KEY);
	
		      signature = signature.replace(/\+/g, '-');
		      signature = signature.replace(/\//g, '_');
	
		      data['signature'] = signature;
		      xdr({
		        callback: jsonp,
		        data: data,
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        },
		        url: [
		          STD_ORIGIN, 'v1', 'auth', 'audit',
		          'sub-key', SUBSCRIBE_KEY
		        ]
		      });
		    },
	
		    /*
		     PUBNUB.revoke({
		     channel  : 'my_chat',
		     callback : fun,
		     error    : fun,
		     auth_key : '3y8uiajdklytowsj'
		     });
		     */
		    revoke: function (args, callback) {
		      args['read'] = false;
		      args['write'] = false;
		      SELF['grant'](args, callback);
		    },
	
		    set_uuid: function (uuid) {
		      UUID = uuid;
		      CONNECT();
		    },
	
		    get_uuid: function () {
		      return UUID;
		    },
	
		    isArray: function (arg) {
		      return utils.isArray(arg);
		    },
	
		    get_subscribed_channels: function () {
		      return generate_channel_list(CHANNELS, true);
		    },
	
		    presence_heartbeat: function (args) {
		      var callback = args['callback'] || function () {};
		      var err = args['error'] || function () {};
		      var jsonp = jsonp_cb();
		      var data = { uuid: UUID, auth: AUTH_KEY };
	
		      var st = JSON['stringify'](STATE);
		      if (st.length > 2) data['state'] = JSON['stringify'](STATE);
	
		      if (PRESENCE_HB > 0 && PRESENCE_HB < 320) data['heartbeat'] = PRESENCE_HB;
	
		      if (jsonp != '0') {
		        data['callback'] = jsonp;
		      }
	
		      var channels = utils.encode(generate_channel_list(CHANNELS, true)['join'](','));
		      var channel_groups = generate_channel_group_list(CHANNEL_GROUPS, true)['join'](',');
	
		      if (!channels) channels = ',';
		      if (channel_groups) data['channel-group'] = channel_groups;
	
		      if (USE_INSTANCEID) data['instanceid'] = INSTANCEID;
	
		      xdr({
		        callback: jsonp,
		        data: _get_url_params(data),
		        url: [
		          STD_ORIGIN, 'v2', 'presence',
		          'sub-key', SUBSCRIBE_KEY,
		          'channel', channels,
		          'heartbeat'
		        ],
		        success: function (response) {
		          _invoke_callback(response, callback, err);
		        },
		        fail: function (response) {
		          _invoke_error(response, err);
		        }
		      });
		    },
	
		    stop_timers: function () {
		      clearTimeout(_poll_timer);
		      clearTimeout(_poll_timer2);
		      clearTimeout(PRESENCE_HB_TIMEOUT);
		    },
	
		    shutdown: function () {
		      SELF['stop_timers']();
		      shutdown && shutdown();
		    },
	
		    // Expose PUBNUB Functions
		    xdr: xdr,
		    ready: ready,
		    db: db,
		    uuid: utils.generateUUID,
		    map: utils.map,
		    each: utils.each,
		    'each-channel': each_channel,
		    grep: utils.grep,
		    offline: function () {
		      _reset_offline(1, { message: 'Offline. Please check your network settings.' });
		    },
		    supplant: utils.supplant,
		    now: utils.rnow,
		    unique: unique,
		    updater: utils.updater
		  };
	
		  function _poll_online() {
		    _is_online() || _reset_offline(1, { error: 'Offline. Please check your network settings.' });
		    _poll_timer && clearTimeout(_poll_timer);
		    _poll_timer = utils.timeout(_poll_online, SECOND);
		  }
	
		  function _poll_online2() {
		    if (!TIME_CHECK) return;
		    SELF['time'](function (success) {
		      detect_time_detla(function () {
		      }, success);
		      success || _reset_offline(1, {
		        error: 'Heartbeat failed to connect to Pubnub Servers.' +
		        'Please check your network settings.'
		      });
		      _poll_timer2 && clearTimeout(_poll_timer2);
		      _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		    });
		  }
	
		  function _reset_offline(err, msg) {
		    SUB_RECEIVER && SUB_RECEIVER(err, msg);
		    SUB_RECEIVER = null;
	
		    clearTimeout(_poll_timer);
		    clearTimeout(_poll_timer2);
		  }
	
		  if (!UUID) UUID = SELF['uuid']();
		  if (!INSTANCEID) INSTANCEID = SELF['uuid']();
		  db['set'](SUBSCRIBE_KEY + 'uuid', UUID);
	
		  _poll_timer = utils.timeout(_poll_online, SECOND);
		  _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
		  PRESENCE_HB_TIMEOUT = utils.timeout(
		    start_presence_heartbeat,
		    (PRESENCE_HB_INTERVAL - 3) * SECOND
		  );
	
		  // Detect Age of Message
		  function detect_latency(tt) {
		    var adjusted_time = utils.rnow() - TIME_DRIFT;
		    return adjusted_time - tt / 10000;
		  }
	
		  detect_time_detla();
		  function detect_time_detla(cb, time) {
		    var stime = utils.rnow();
	
		    time && calculate(time) || SELF['time'](calculate);
	
		    function calculate(time) {
		      if (!time) return;
		      var ptime = time / 10000;
		      var latency = (utils.rnow() - stime) / 2;
		      TIME_DRIFT = utils.rnow() - (ptime + latency);
		      cb && cb(TIME_DRIFT);
		    }
		  }
	
		  return SELF;
		}
	
		module.exports = {
		  PN_API: PN_API,
		  unique: unique,
		  PNmessage: PNmessage,
		  DEF_TIMEOUT: DEF_TIMEOUT,
		  timeout: utils.timeout,
		  build_url: utils.buildURL,
		  each: utils.each,
		  uuid: utils.generateUUID,
		  URLBIT: defaultConfiguration.URLBIT,
		  grep: utils.grep,
		  supplant: utils.supplant,
		  now: utils.rnow,
		  updater: utils.updater,
		  map: utils.map
		};
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		module.exports = {
			"PARAMSBIT": "&",
			"URLBIT": "/"
		};
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint no-unused-expressions: 0, block-scoped-var: 0, no-redeclare: 0, guard-for-in: 0 */
	
		var defaultConfiguration = __webpack_require__(3);
		var REPL = /{([\w\-]+)}/g;
	
		function rnow() {
		  return +new Date;
		}
	
		function isArray(arg) {
		  return !!arg && typeof arg !== 'string' && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === 'number');
		  // return !!arg && (Array.isArray && Array.isArray(arg) || typeof(arg.length) === "number")
		}
	
		/**
		 * EACH
		 * ====
		 * each( [1,2,3], function(item) { } )
		 */
		function each(o, f) {
		  if (!o || !f) {
		    return;
		  }
	
		  if (isArray(o)) {
		    for (var i = 0, l = o.length; i < l;) {
		      f.call(o[i], o[i], i++);
		    }
		  } else {
		    for (var i in o) {
		      o.hasOwnProperty &&
		      o.hasOwnProperty(i) &&
		      f.call(o[i], i, o[i]);
		    }
		  }
		}
	
		/**
		 * ENCODE
		 * ======
		 * var encoded_data = encode('path');
		 */
		function encode(path) { return encodeURIComponent(path); }
	
		/**
		 * Build Url
		 * =======
		 *
		 */
		function buildURL(urlComponents, urlParams) {
		  var url = urlComponents.join(defaultConfiguration.URLBIT);
		  var params = [];
	
		  if (!urlParams) return url;
	
		  each(urlParams, function (key, value) {
		    var valueStr = (typeof value === 'object') ? JSON['stringify'](value) : value;
		    (typeof value !== 'undefined' &&
		      value !== null && encode(valueStr).length > 0
		    ) && params.push(key + '=' + encode(valueStr));
		  });
	
		  url += '?' + params.join(defaultConfiguration.PARAMSBIT);
		  return url;
		}
	
		/**
		 * UPDATER
		 * =======
		 * var timestamp = unique();
		 */
		function updater(fun, rate) {
		  var timeout;
		  var last = 0;
		  var runnit = function () {
		    if (last + rate > rnow()) {
		      clearTimeout(timeout);
		      timeout = setTimeout(runnit, rate);
		    } else {
		      last = rnow();
		      fun();
		    }
		  };
	
		  return runnit;
		}
	
		/**
		 * GREP
		 * ====
		 * var list = grep( [1,2,3], function(item) { return item % 2 } )
		 */
		function grep(list, fun) {
		  var fin = [];
		  each(list || [], function (l) {
		    fun(l) && fin.push(l);
		  });
		  return fin;
		}
	
		/**
		 * SUPPLANT
		 * ========
		 * var text = supplant( 'Hello {name}!', { name : 'John' } )
		 */
		function supplant(str, values) {
		  return str.replace(REPL, function (_, match) {
		    return values[match] || _;
		  });
		}
	
		/**
		 * timeout
		 * =======
		 * timeout( function(){}, 100 );
		 */
		function timeout(fun, wait) {
		  if (typeof setTimeout === 'undefined') {
		    return;
		  }
	
		  return setTimeout(fun, wait);
		}
	
		/**
		 * uuid
		 * ====
		 * var my_uuid = generateUUID();
		 */
		function generateUUID(callback) {
		  var u = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,
		    function (c) {
		      var r = Math.random() * 16 | 0;
		      var v = c === 'x' ? r : (r & 0x3 | 0x8);
		      return v.toString(16);
		    });
		  if (callback) callback(u);
		  return u;
		}
	
		/**
		 * MAP
		 * ===
		 * var list = map( [1,2,3], function(item) { return item + 1 } )
		 */
		function map(list, fun) {
		  var fin = [];
		  each(list || [], function (k, v) {
		    fin.push(fun(k, v));
		  });
		  return fin;
		}
	
	
		function pamEncode(str) {
		  return encodeURIComponent(str).replace(/[!'()*~]/g, function (c) {
		    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		  });
		}
	
	
		module.exports = {
		  buildURL: buildURL,
		  encode: encode,
		  each: each,
		  updater: updater,
		  rnow: rnow,
		  isArray: isArray,
		  map: map,
		  pamEncode: pamEncode,
		  generateUUID: generateUUID,
		  timeout: timeout,
		  supplant: supplant,
		  grep: grep
		};
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* eslint camelcase: 0 eqeqeq: 0 */
	
		var CryptoJS = __webpack_require__(6);
	
		function crypto_obj() {
		  function SHA256(s) {
		    return CryptoJS['SHA256'](s)['toString'](CryptoJS['enc']['Hex']);
		  }
	
		  var iv = '0123456789012345';
	
		  var allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];
		  var allowedKeyLengths = [128, 256];
		  var allowedModes = ['ecb', 'cbc'];
	
		  var defaultOptions = {
		    encryptKey: true,
		    keyEncoding: 'utf8',
		    keyLength: 256,
		    mode: 'cbc'
		  };
	
		  function parse_options(options) {
		    // Defaults
		    options = options || {};
		    if (!options['hasOwnProperty']('encryptKey')) options['encryptKey'] = defaultOptions['encryptKey'];
		    if (!options['hasOwnProperty']('keyEncoding')) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (!options['hasOwnProperty']('keyLength')) options['keyLength'] = defaultOptions['keyLength'];
		    if (!options['hasOwnProperty']('mode')) options['mode'] = defaultOptions['mode'];
	
		    // Validation
		    if (allowedKeyEncodings['indexOf'](options['keyEncoding']['toLowerCase']()) == -1) options['keyEncoding'] = defaultOptions['keyEncoding'];
		    if (allowedKeyLengths['indexOf'](parseInt(options['keyLength'], 10)) == -1) options['keyLength'] = defaultOptions['keyLength'];
		    if (allowedModes['indexOf'](options['mode']['toLowerCase']()) == -1) options['mode'] = defaultOptions['mode'];
	
		    return options;
		  }
	
		  function decode_key(key, options) {
		    if (options['keyEncoding'] === 'base64') {
		      return CryptoJS['enc']['Base64']['parse'](key);
		    } else if (options['keyEncoding'] === 'hex') {
		      return CryptoJS['enc']['Hex']['parse'](key);
		    } else {
		      return key;
		    }
		  }
	
		  function get_padded_key(key, options) {
		    key = decode_key(key, options);
		    if (options['encryptKey']) {
		      return CryptoJS['enc']['Utf8']['parse'](SHA256(key)['slice'](0, 32));
		    } else {
		      return key;
		    }
		  }
	
		  function get_mode(options) {
		    if (options['mode'] === 'ecb') {
		      return CryptoJS['mode']['ECB'];
		    } else {
		      return CryptoJS['mode']['CBC'];
		    }
		  }
	
		  function get_iv(options) {
		    return (options['mode'] === 'cbc') ? CryptoJS['enc']['Utf8']['parse'](iv) : null;
		  }
	
		  return {
		    encrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      var hex_message = JSON['stringify'](data);
		      var encryptedHexArray = CryptoJS['AES']['encrypt'](hex_message, cipher_key, { iv: iv, mode: mode })['ciphertext'];
		      var base_64_encrypted = encryptedHexArray['toString'](CryptoJS['enc']['Base64']);
		      return base_64_encrypted || data;
		    },
	
		    decrypt: function (data, key, options) {
		      if (!key) return data;
		      options = parse_options(options);
		      var iv = get_iv(options);
		      var mode = get_mode(options);
		      var cipher_key = get_padded_key(key, options);
		      try {
		        var binary_enc = CryptoJS['enc']['Base64']['parse'](data);
		        var json_plain = CryptoJS['AES']['decrypt']({ ciphertext: binary_enc }, cipher_key, { iv: iv, mode: mode })['toString'](CryptoJS['enc']['Utf8']);
		        var plaintext = JSON['parse'](json_plain);
		        return plaintext;
		      } catch (e) {
		        return undefined;
		      }
		    }
		  };
		}
	
		module.exports = crypto_obj;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/*
		 CryptoJS v3.1.2
		 code.google.com/p/crypto-js
		 (c) 2009-2013 by Jeff Mott. All rights reserved.
		 code.google.com/p/crypto-js/wiki/License
		 */
		var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
		    r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
		      32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,
		        2),16)<<24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
		    u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
		      a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
		    d)).finalize(c)}}});var t=f.algo={};return f}(Math);
	
		// SHA256
		(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64>n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t<=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64>p;p++){if(16>p)a[p]=
		  c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k<<25|k>>>7)^(k<<14|k>>>18)^k>>>3)+a[p-7]+((l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10)+a[p-16]}k=q+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&m^~h&n)+r[p]+a[p];l=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
		  d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
	
		// HMAC SHA256
		(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;"string"==typeof g&&(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes>m&&(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j<h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
		  this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();
	
		// Base64
		(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
		l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
	
		// BlockCipher
		(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
		  _doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
		    f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
		      m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
		      E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
		    4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
		(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
		  l)}})();
	
		// Cipher
		CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
		  finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
		  c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
		  e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
		  this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
		  1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
		  decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
		  b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
	
		// AES
		(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
		  16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
		8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
		  d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();
	
		// Mode ECB
		CryptoJS.mode.ECB = (function () {
		  var ECB = CryptoJS.lib.BlockCipherMode.extend();
	
		  ECB.Encryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.encryptBlock(words, offset);
		    }
		  });
	
		  ECB.Decryptor = ECB.extend({
		    processBlock: function (words, offset) {
		      this._cipher.decryptBlock(words, offset);
		    }
		  });
	
		  return ECB;
		}());
	
		module.exports = CryptoJS;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET INTERFACE
		// ---------------------------------------------------------------------------
		var WS = function( url, protocols ) {
		  if (!(this instanceof WS)) return new WS( url, protocols );
	
		  var self     = this
		    ,   url      = self.url      = url || ''
		    ,   protocol = self.protocol = protocols || 'Sec-WebSocket-Protocol'
		    ,   bits     = url.split('/')
		    ,   setup    = {
		    'ssl'           : bits[0] === 'wss:'
		    ,'origin'        : bits[2]
		    ,'publish_key'   : bits[3]
		    ,'subscribe_key' : bits[4]
		    ,'channel'       : bits[5]
		  };
	
		  // READY STATES
		  self['CONNECTING'] = 0; // The connection is not yet open.
		  self['OPEN']       = 1; // The connection is open and ready to communicate.
		  self['CLOSING']    = 2; // The connection is in the process of closing.
		  self['CLOSED']     = 3; // The connection is closed or couldn't be opened.
	
		  // CLOSE STATES
		  self['CLOSE_NORMAL']         = 1000; // Normal Intended Close; completed.
		  self['CLOSE_GOING_AWAY']     = 1001; // Closed Unexpecttedly.
		  self['CLOSE_PROTOCOL_ERROR'] = 1002; // Server: Not Supported.
		  self['CLOSE_UNSUPPORTED']    = 1003; // Server: Unsupported Protocol.
		  self['CLOSE_TOO_LARGE']      = 1004; // Server: Too Much Data.
		  self['CLOSE_NO_STATUS']      = 1005; // Server: No reason.
		  self['CLOSE_ABNORMAL']       = 1006; // Abnormal Disconnect.
	
		  // Events Default
		  self['onclose']   = self['onerror'] =
		    self['onmessage'] = self['onopen']  =
		      self['onsend']    =  function(){};
	
		  // Attributes
		  self['binaryType']     = '';
		  self['extensions']     = '';
		  self['bufferedAmount'] = 0;
		  self['trasnmitting']   = false;
		  self['buffer']         = [];
		  self['readyState']     = self['CONNECTING'];
	
		  // Close if no setup.
		  if (!url) {
		    self['readyState'] = self['CLOSED'];
		    self['onclose']({
		      'code'     : self['CLOSE_ABNORMAL'],
		      'reason'   : 'Missing URL',
		      'wasClean' : true
		    });
		    return self;
		  }
	
		  // PubNub WebSocket Emulation
		  self.pubnub       = PUBNUB['init'](setup);
		  self.pubnub.setup = setup;
		  self.setup        = setup;
	
		  self.pubnub['subscribe']({
		    'restore'    : false,
		    'channel'    : setup['channel'],
		    'disconnect' : self['onerror'],
		    'reconnect'  : self['onopen'],
		    'error'      : function() {
		      self['onclose']({
		        'code'     : self['CLOSE_ABNORMAL'],
		        'reason'   : 'Missing URL',
		        'wasClean' : false
		      });
		    },
		    'callback'   : function(message) {
		      self['onmessage']({ 'data' : message });
		    },
		    'connect'    : function() {
		      self['readyState'] = self['OPEN'];
		      self['onopen']();
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET SEND
		// ---------------------------------------------------------------------------
		WS.prototype.send = function(data) {
		  var self = this;
		  self.pubnub['publish']({
		    'channel'  : self.pubnub.setup['channel'],
		    'message'  : data,
		    'callback' : function(response) {
		      self['onsend']({ 'data' : response });
		    }
		  });
		};
	
		// ---------------------------------------------------------------------------
		// WEBSOCKET CLOSE
		// ---------------------------------------------------------------------------
		WS.prototype.close = function() {
		  var self = this;
		  self.pubnub['unsubscribe']({ 'channel' : self.pubnub.setup['channel'] });
		  self['readyState'] = self['CLOSED'];
		  self['onclose']({});
		};
	
		module.exports = WS;
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["Client"] = factory();
		else
			root["RingCentral"] = root["RingCentral"] || {}, root["RingCentral"]["Client"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(1);
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="./externals.d.ts" />
	"use strict";
	var accountClient = __webpack_require__(2);
	var callLogClient = __webpack_require__(40);
	var dictionaryClient = __webpack_require__(55);
	var extensionClient = __webpack_require__(70);
	var messagesClient = __webpack_require__(77);
	var notificationsClient = __webpack_require__(84);
	var presenceClient = __webpack_require__(87);
	var ringoutClient = __webpack_require__(93);
	var forwardingNumbersClient = __webpack_require__(96);
	var blockedNumbersClient = __webpack_require__(99);
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	        this._account = new accountClient.Account(sdk);
	        this._callLog = new callLogClient.CallLog(sdk);
	        this._dictionary = new dictionaryClient.Dictionary(sdk);
	        this._extension = new extensionClient.Extension(sdk);
	        this._messages = new messagesClient.Messages(sdk);
	        this._notifications = new notificationsClient.NotificationsSubscriptionAPI(sdk);
	        this._presence = new presenceClient.Presence(sdk);
	        this._ringout = new ringoutClient.RingOut(sdk);
	        this._forwardingNumbers = new forwardingNumbersClient.ForwardingNumbers(sdk);
	        this._blockedNumbers = new blockedNumbersClient.BlockedNumbers(sdk);
	    }
	    Client.prototype.account = function () { return this._account; };
	    Client.prototype.callLog = function () { return this._callLog; };
	    Client.prototype.dictionary = function () { return this._dictionary; };
	    Client.prototype.extension = function () { return this._extension; };
	    Client.prototype.messages = function () { return this._messages; };
	    Client.prototype.notifications = function () { return this._notifications; };
	    Client.prototype.presence = function () { return this._presence; };
	    Client.prototype.ringout = function () { return this._ringout; };
	    Client.prototype.forwardingNumbers = function () { return this._forwardingNumbers; };
	    Client.prototype.blockedNumbers = function () { return this._blockedNumbers; };
	    Client.version = '0.1.0';
	    return Client;
	}());
	module.exports = Client;
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountinfo = __webpack_require__(4);
	var accountbusinessaddress = __webpack_require__(28);
	var dialingplaninfo = __webpack_require__(30);
	var phonenumberinfo = __webpack_require__(34);
	var accountphonenumbers = __webpack_require__(36);
	var accountserviceinfo = __webpack_require__(37);
	var Account = (function (_super) {
	    __extends(Account, _super);
	    function Account() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Account
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Creates the account in Initial state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Accounts</td>
	     *             <td>Managing accounts: creating new accounts, viewing and updating account information, deleting existing accounts</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.createAccount = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account', options, exports.createAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccount = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}', options, exports.loadAccountOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Get Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/business-address', options, exports.loadAccountBusinessAddressOptions), accountinfo.AccountInfo);
	    };
	    /**
	     * Update Account Business Address
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.updateAccountBusinessAddress = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/business-address', options, exports.updateAccountBusinessAddressOptions), accountbusinessaddress.AccountBusinessAddress);
	    };
	    /**
	     * Get Account Dialing Plan
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns list of countries which can be selected for a dialing plan (to call short numbers and special services).</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listDialingPlans = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/dialing-plan', options, exports.listDialingPlansOptions), dialingplaninfo.DialingPlanInfo);
	    };
	    /**
	     * Provision Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.11 (Release 6.3)</p>
	     * <p>Provisions a phone number.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditAccounts</td>
	     *             <td>Viewing and updating user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Account.prototype.provisionPhoneNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.provisionPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Phone Numbers
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers assigned to the RingCentral customer account. Both company-level and extension-level numbers are returned.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Account.prototype.listAccountPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number', options, exports.listAccountPhoneNumbersOptions), accountphonenumbers.AccountPhoneNumbers);
	    };
	    /**
	     * Get Phone Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadAccountPhoneNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/phone-number/{phoneNumberId}', options, exports.loadAccountPhoneNumberOptions), phonenumberinfo.PhoneNumberInfo);
	    };
	    /**
	     * Get Account Service Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the information about service plan, available features and limitations for a particular RingCentral customer account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Account.prototype.loadServiceInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/service-info', options, exports.loadServiceInfoOptions), accountserviceinfo.AccountServiceInfo);
	    };
	    return Account;
	}(client.Client));
	exports.Account = Account;
	/**
	 * Definition of options for createAccount operation
	 */
	exports.createAccountOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createaccountrequest.CreateAccountRequest"
	    }
	];
	/**
	 * Definition of options for loadAccount operation
	 */
	exports.loadAccountOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadAccountBusinessAddress operation
	 */
	exports.loadAccountBusinessAddressOptions = [];
	/**
	 * Definition of options for updateAccountBusinessAddress operation
	 */
	exports.updateAccountBusinessAddressOptions = [
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "modifyaccountbusinessaddressrequest.ModifyAccountBusinessAddressRequest"
	    }
	];
	/**
	 * Definition of options for listDialingPlans operation
	 */
	exports.listDialingPlansOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for provisionPhoneNumber operation
	 */
	exports.provisionPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "provisionphonenumbers.ProvisionPhoneNumbers"
	    }
	];
	/**
	 * Definition of options for listAccountPhoneNumbers operation
	 */
	exports.listAccountPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "usageType",
	        "type": "IListAccountPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountPhoneNumber operation
	 */
	exports.loadAccountPhoneNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "phoneNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadServiceInfo operation
	 */
	exports.loadServiceInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	(function (IListAccountPhoneNumbersUsageType) {
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListAccountPhoneNumbersUsageType[IListAccountPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListAccountPhoneNumbersUsageType || (exports.IListAccountPhoneNumbersUsageType = {}));
	var IListAccountPhoneNumbersUsageType = exports.IListAccountPhoneNumbersUsageType;
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Client = (function () {
	    function Client(sdk) {
	        this._sdk = sdk;
	    }
	    Client.prototype.parseOptions = function (method, url, options, operationParameters) {
	        options = options || {};
	        var request = {
	            url: url,
	            method: method,
	            query: {},
	            body: undefined
	        };
	        operationParameters.forEach(function (param) {
	            if (param.required && !param.default && !options.hasOwnProperty(param.name)) {
	                throw new Error('Required parameter "' + param.name + '" not found');
	            }
	            if (param.default && !options.hasOwnProperty(param.name)) {
	                options[param.name] = param.default;
	            }
	            if (param.in == 'path') {
	                request.url = request.url.replace('{' + param.name + '}', options[param.name]);
	            }
	            if (param.in == 'query' && options.hasOwnProperty(param.name)) {
	                request.query[param.name] = options[param.name];
	            }
	            if (param.in == 'body') {
	                request.body = options[param.name];
	            }
	        });
	        return request;
	    };
	    Client.prototype.send = function (apiOptions, Class) {
	        var _this = this;
	        return this._sdk.platform()
	            .send(apiOptions)
	            .then(function (res) {
	            //TODO Support multipart
	            //TODO Think how to pass headers&stuff to outside
	            if (Class && !res._isMultipart())
	                return new Class(_this._sdk, res.json());
	            return res;
	        });
	    };
	    return Client;
	}());
	exports.Client = Client;
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var serviceinfo = __webpack_require__(22);
	var accountstatusinfo = __webpack_require__(27);
	var AccountInfo = (function (_super) {
	    __extends(AccountInfo, _super);
	    function AccountInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'mainNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'operator', Class: extensioninfo.ExtensionInfo, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceInfo', Class: serviceinfo.ServiceInfo, isArray: false, isRequired: false },
	            { property: 'setupWizardState', Class: AccountInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: AccountInfoStatus, isArray: false, isRequired: false },
	            { property: 'statusInfo', Class: accountstatusinfo.AccountStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountInfo.prototype.getClassName = function () {
	        return 'AccountInfo';
	    };
	    return AccountInfo;
	}(model.Model));
	exports.AccountInfo = AccountInfo;
	(function (AccountInfoSetupWizardState) {
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    AccountInfoSetupWizardState[AccountInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.AccountInfoSetupWizardState || (exports.AccountInfoSetupWizardState = {}));
	var AccountInfoSetupWizardState = exports.AccountInfoSetupWizardState;
	(function (AccountInfoStatus) {
	    AccountInfoStatus[AccountInfoStatus["Confirmed"] = 'Confirmed'] = "Confirmed";
	    AccountInfoStatus[AccountInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	})(exports.AccountInfoStatus || (exports.AccountInfoStatus = {}));
	var AccountInfoStatus = exports.AccountInfoStatus;
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var Model = (function () {
	    function Model(sdk, data) {
	        var _this = this;
	        this._sdk = sdk;
	        data = data || {};
	        this.getPropertyMappings().forEach(function (mapping) {
	            var Class = mapping.Class, prop = mapping.property;
	            if (!data.hasOwnProperty(prop)) {
	                if (mapping.isRequired)
	                    console.warn('Required property "' + prop + '" not defined');
	                return;
	            }
	            var processProperty = function (dataPart) {
	                if (!Class || typeof Class !== 'function') {
	                    return dataPart;
	                }
	                else {
	                    return new Class(_this._sdk, dataPart);
	                }
	            };
	            if (mapping.isArray) {
	                _this[prop] = data[prop].map(processProperty);
	            }
	            else {
	                _this[prop] = processProperty(data[prop]);
	            }
	        });
	    }
	    Model.prototype.getPropertyMappings = function () {
	        return [];
	    };
	    Model.prototype.getClassName = function () {
	        return 'Model';
	    };
	    Model.prototype.getId = function () {
	        return this['id'];
	    };
	    return Model;
	}());
	exports.Model = Model;
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactinfo = __webpack_require__(7);
	var departmentinfo = __webpack_require__(9);
	var extensionpermissions = __webpack_require__(10);
	var profileimageinfo = __webpack_require__(12);
	var referenceinfo = __webpack_require__(13);
	var regionalsettings = __webpack_require__(14);
	var extensionservicefeatureinfo = __webpack_require__(20);
	var extensionstatusinfo = __webpack_require__(21);
	var ExtensionInfo = (function (_super) {
	    __extends(ExtensionInfo, _super);
	    function ExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'contact', Class: contactinfo.ContactInfo, isArray: false, isRequired: false },
	            { property: 'departments', Class: departmentinfo.DepartmentInfo, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'permissions', Class: extensionpermissions.ExtensionPermissions, isArray: false, isRequired: false },
	            { property: 'profileImage', Class: profileimageinfo.ProfileImageInfo, isArray: false, isRequired: true },
	            { property: 'references', Class: referenceinfo.ReferenceInfo, isArray: true, isRequired: false },
	            { property: 'regionalSettings', Class: regionalsettings.RegionalSettings, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: extensionservicefeatureinfo.ExtensionServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'setupWizardState', Class: ExtensionInfoSetupWizardState, isArray: false, isRequired: false },
	            { property: 'status', Class: ExtensionInfoStatus, isArray: false, isRequired: true },
	            { property: 'statusInfo', Class: extensionstatusinfo.ExtensionStatusInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoType, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionInfo.prototype.getClassName = function () {
	        return 'ExtensionInfo';
	    };
	    return ExtensionInfo;
	}(model.Model));
	exports.ExtensionInfo = ExtensionInfo;
	(function (ExtensionInfoSetupWizardState) {
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["NotStarted"] = 'NotStarted'] = "NotStarted";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Incomplete"] = 'Incomplete'] = "Incomplete";
	    ExtensionInfoSetupWizardState[ExtensionInfoSetupWizardState["Completed"] = 'Completed'] = "Completed";
	})(exports.ExtensionInfoSetupWizardState || (exports.ExtensionInfoSetupWizardState = {}));
	var ExtensionInfoSetupWizardState = exports.ExtensionInfoSetupWizardState;
	(function (ExtensionInfoStatus) {
	    ExtensionInfoStatus[ExtensionInfoStatus["Enabled"] = 'Enabled'] = "Enabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["Disabled"] = 'Disabled'] = "Disabled";
	    ExtensionInfoStatus[ExtensionInfoStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    ExtensionInfoStatus[ExtensionInfoStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.ExtensionInfoStatus || (exports.ExtensionInfoStatus = {}));
	var ExtensionInfoStatus = exports.ExtensionInfoStatus;
	(function (ExtensionInfoType) {
	    ExtensionInfoType[ExtensionInfoType["User"] = 'User'] = "User";
	    ExtensionInfoType[ExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    ExtensionInfoType[ExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoType[ExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoType[ExtensionInfoType["Department"] = 'Department'] = "Department";
	    ExtensionInfoType[ExtensionInfoType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoType[ExtensionInfoType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoType[ExtensionInfoType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoType[ExtensionInfoType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    ExtensionInfoType[ExtensionInfoType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoType[ExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoType[ExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.ExtensionInfoType || (exports.ExtensionInfoType = {}));
	var ExtensionInfoType = exports.ExtensionInfoType;
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var contactaddressinfo = __webpack_require__(8);
	var ContactInfo = (function (_super) {
	    __extends(ContactInfo, _super);
	    function ContactInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessPhone', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: contactaddressinfo.ContactAddressInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ContactInfo.prototype.getClassName = function () {
	        return 'ContactInfo';
	    };
	    return ContactInfo;
	}(model.Model));
	exports.ContactInfo = ContactInfo;
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ContactAddressInfo = (function (_super) {
	    __extends(ContactAddressInfo, _super);
	    function ContactAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    ContactAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ContactAddressInfo.prototype.getClassName = function () {
	        return 'ContactAddressInfo';
	    };
	    return ContactAddressInfo;
	}(model.Model));
	exports.ContactAddressInfo = ContactAddressInfo;
	
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DepartmentInfo = (function (_super) {
	    __extends(DepartmentInfo, _super);
	    function DepartmentInfo() {
	        _super.apply(this, arguments);
	    }
	    DepartmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DepartmentInfo.prototype.getClassName = function () {
	        return 'DepartmentInfo';
	    };
	    return DepartmentInfo;
	}(model.Model));
	exports.DepartmentInfo = DepartmentInfo;
	
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var permissioninfo = __webpack_require__(11);
	var ExtensionPermissions = (function (_super) {
	    __extends(ExtensionPermissions, _super);
	    function ExtensionPermissions() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPermissions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'admin', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false },
	            { property: 'internationalCalling', Class: permissioninfo.PermissionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionPermissions.prototype.getClassName = function () {
	        return 'ExtensionPermissions';
	    };
	    return ExtensionPermissions;
	}(model.Model));
	exports.ExtensionPermissions = ExtensionPermissions;
	
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PermissionInfo = (function (_super) {
	    __extends(PermissionInfo, _super);
	    function PermissionInfo() {
	        _super.apply(this, arguments);
	    }
	    PermissionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    PermissionInfo.prototype.getClassName = function () {
	        return 'PermissionInfo';
	    };
	    return PermissionInfo;
	}(model.Model));
	exports.PermissionInfo = PermissionInfo;
	
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ProfileImageInfo = (function (_super) {
	    __extends(ProfileImageInfo, _super);
	    function ProfileImageInfo() {
	        _super.apply(this, arguments);
	    }
	    ProfileImageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'etag', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastModified', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'scales', Class: null /* string[] */, isArray: true, isRequired: false }
	        ];
	    };
	    ProfileImageInfo.prototype.getClassName = function () {
	        return 'ProfileImageInfo';
	    };
	    return ProfileImageInfo;
	}(model.Model));
	exports.ProfileImageInfo = ProfileImageInfo;
	
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ReferenceInfo = (function (_super) {
	    __extends(ReferenceInfo, _super);
	    function ReferenceInfo() {
	        _super.apply(this, arguments);
	    }
	    ReferenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'ref', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ReferenceInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    ReferenceInfo.prototype.getClassName = function () {
	        return 'ReferenceInfo';
	    };
	    return ReferenceInfo;
	}(model.Model));
	exports.ReferenceInfo = ReferenceInfo;
	(function (ReferenceInfoType) {
	    ReferenceInfoType[ReferenceInfoType["PartnerId"] = 'PartnerId'] = "PartnerId";
	    ReferenceInfoType[ReferenceInfoType["CustomerDirectoryId"] = 'CustomerDirectoryId'] = "CustomerDirectoryId";
	})(exports.ReferenceInfoType || (exports.ReferenceInfoType = {}));
	var ReferenceInfoType = exports.ReferenceInfoType;
	
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var timezoneinfo = __webpack_require__(16);
	var languageinfo = __webpack_require__(17);
	var greetinglanguageinfo = __webpack_require__(18);
	var formattinglocaleinfo = __webpack_require__(19);
	var RegionalSettings = (function (_super) {
	    __extends(RegionalSettings, _super);
	    function RegionalSettings() {
	        _super.apply(this, arguments);
	    }
	    RegionalSettings.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'timezone', Class: timezoneinfo.TimezoneInfo, isArray: false, isRequired: false },
	            { property: 'language', Class: languageinfo.LanguageInfo, isArray: false, isRequired: false },
	            { property: 'greetingLanguage', Class: greetinglanguageinfo.GreetingLanguageInfo, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: formattinglocaleinfo.FormattingLocaleInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RegionalSettings.prototype.getClassName = function () {
	        return 'RegionalSettings';
	    };
	    return RegionalSettings;
	}(model.Model));
	exports.RegionalSettings = RegionalSettings;
	
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CountryInfo = (function (_super) {
	    __extends(CountryInfo, _super);
	    function CountryInfo() {
	        _super.apply(this, arguments);
	    }
	    CountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CountryInfo.prototype.getClassName = function () {
	        return 'CountryInfo';
	    };
	    return CountryInfo;
	}(model.Model));
	exports.CountryInfo = CountryInfo;
	
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TimezoneInfo = (function (_super) {
	    __extends(TimezoneInfo, _super);
	    function TimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    TimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TimezoneInfo.prototype.getClassName = function () {
	        return 'TimezoneInfo';
	    };
	    return TimezoneInfo;
	}(model.Model));
	exports.TimezoneInfo = TimezoneInfo;
	
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LanguageInfo = (function (_super) {
	    __extends(LanguageInfo, _super);
	    function LanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    LanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'greeting', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'formattingLocale', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'ui', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    LanguageInfo.prototype.getClassName = function () {
	        return 'LanguageInfo';
	    };
	    return LanguageInfo;
	}(model.Model));
	exports.LanguageInfo = LanguageInfo;
	
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var GreetingLanguageInfo = (function (_super) {
	    __extends(GreetingLanguageInfo, _super);
	    function GreetingLanguageInfo() {
	        _super.apply(this, arguments);
	    }
	    GreetingLanguageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    GreetingLanguageInfo.prototype.getClassName = function () {
	        return 'GreetingLanguageInfo';
	    };
	    return GreetingLanguageInfo;
	}(model.Model));
	exports.GreetingLanguageInfo = GreetingLanguageInfo;
	
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var FormattingLocaleInfo = (function (_super) {
	    __extends(FormattingLocaleInfo, _super);
	    function FormattingLocaleInfo() {
	        _super.apply(this, arguments);
	    }
	    FormattingLocaleInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'localeCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    FormattingLocaleInfo.prototype.getClassName = function () {
	        return 'FormattingLocaleInfo';
	    };
	    return FormattingLocaleInfo;
	}(model.Model));
	exports.FormattingLocaleInfo = FormattingLocaleInfo;
	
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionServiceFeatureInfo = (function (_super) {
	    __extends(ExtensionServiceFeatureInfo, _super);
	    function ExtensionServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'enabled', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ExtensionServiceFeatureInfo';
	    };
	    return ExtensionServiceFeatureInfo;
	}(model.Model));
	exports.ExtensionServiceFeatureInfo = ExtensionServiceFeatureInfo;
	
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionStatusInfo = (function (_super) {
	    __extends(ExtensionStatusInfo, _super);
	    function ExtensionStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    ExtensionStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: ExtensionStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionStatusInfo.prototype.getClassName = function () {
	        return 'ExtensionStatusInfo';
	    };
	    return ExtensionStatusInfo;
	}(model.Model));
	exports.ExtensionStatusInfo = ExtensionStatusInfo;
	(function (ExtensionStatusInfoReason) {
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    ExtensionStatusInfoReason[ExtensionStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.ExtensionStatusInfoReason || (exports.ExtensionStatusInfoReason = {}));
	var ExtensionStatusInfoReason = exports.ExtensionStatusInfoReason;
	
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var billingplaninfo = __webpack_require__(23);
	var brandinfo = __webpack_require__(24);
	var serviceplaninfo = __webpack_require__(25);
	var targetserviceplaninfo = __webpack_require__(26);
	var ServiceInfo = (function (_super) {
	    __extends(ServiceInfo, _super);
	    function ServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'billingPlan', Class: billingplaninfo.BillingPlanInfo, isArray: false, isRequired: false },
	            { property: 'brand', Class: brandinfo.BrandInfo, isArray: false, isRequired: false },
	            { property: 'servicePlan', Class: serviceplaninfo.ServicePlanInfo, isArray: false, isRequired: false },
	            { property: 'targetServicePlan', Class: targetserviceplaninfo.TargetServicePlanInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceInfo.prototype.getClassName = function () {
	        return 'ServiceInfo';
	    };
	    return ServiceInfo;
	}(model.Model));
	exports.ServiceInfo = ServiceInfo;
	
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BillingPlanInfo = (function (_super) {
	    __extends(BillingPlanInfo, _super);
	    function BillingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    BillingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'durationUnit', Class: BillingPlanInfoDurationUnit, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: BillingPlanInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    BillingPlanInfo.prototype.getClassName = function () {
	        return 'BillingPlanInfo';
	    };
	    return BillingPlanInfo;
	}(model.Model));
	exports.BillingPlanInfo = BillingPlanInfo;
	(function (BillingPlanInfoDurationUnit) {
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Month"] = 'Month'] = "Month";
	    BillingPlanInfoDurationUnit[BillingPlanInfoDurationUnit["Day"] = 'Day'] = "Day";
	})(exports.BillingPlanInfoDurationUnit || (exports.BillingPlanInfoDurationUnit = {}));
	var BillingPlanInfoDurationUnit = exports.BillingPlanInfoDurationUnit;
	(function (BillingPlanInfoType) {
	    BillingPlanInfoType[BillingPlanInfoType["Initial"] = 'Initial'] = "Initial";
	    BillingPlanInfoType[BillingPlanInfoType["Regular"] = 'Regular'] = "Regular";
	    BillingPlanInfoType[BillingPlanInfoType["Suspended"] = 'Suspended'] = "Suspended";
	    BillingPlanInfoType[BillingPlanInfoType["Trial"] = 'Trial'] = "Trial";
	    BillingPlanInfoType[BillingPlanInfoType["TrialNoCC"] = 'TrialNoCC'] = "TrialNoCC";
	    BillingPlanInfoType[BillingPlanInfoType["Free"] = 'Free'] = "Free";
	})(exports.BillingPlanInfoType || (exports.BillingPlanInfoType = {}));
	var BillingPlanInfoType = exports.BillingPlanInfoType;
	
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var BrandInfo = (function (_super) {
	    __extends(BrandInfo, _super);
	    function BrandInfo() {
	        _super.apply(this, arguments);
	    }
	    BrandInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'homeCountry', Class: countryinfo.CountryInfo, isArray: false, isRequired: false }
	        ];
	    };
	    BrandInfo.prototype.getClassName = function () {
	        return 'BrandInfo';
	    };
	    return BrandInfo;
	}(model.Model));
	exports.BrandInfo = BrandInfo;
	
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServicePlanInfo = (function (_super) {
	    __extends(ServicePlanInfo, _super);
	    function ServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    ServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'edition', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ServicePlanInfo.prototype.getClassName = function () {
	        return 'ServicePlanInfo';
	    };
	    return ServicePlanInfo;
	}(model.Model));
	exports.ServicePlanInfo = ServicePlanInfo;
	
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var TargetServicePlanInfo = (function (_super) {
	    __extends(TargetServicePlanInfo, _super);
	    function TargetServicePlanInfo() {
	        _super.apply(this, arguments);
	    }
	    TargetServicePlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    TargetServicePlanInfo.prototype.getClassName = function () {
	        return 'TargetServicePlanInfo';
	    };
	    return TargetServicePlanInfo;
	}(model.Model));
	exports.TargetServicePlanInfo = TargetServicePlanInfo;
	
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountStatusInfo = (function (_super) {
	    __extends(AccountStatusInfo, _super);
	    function AccountStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'comment', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'reason', Class: AccountStatusInfoReason, isArray: false, isRequired: false }
	        ];
	    };
	    AccountStatusInfo.prototype.getClassName = function () {
	        return 'AccountStatusInfo';
	    };
	    return AccountStatusInfo;
	}(model.Model));
	exports.AccountStatusInfo = AccountStatusInfo;
	(function (AccountStatusInfoReason) {
	    AccountStatusInfoReason[AccountStatusInfoReason["Voluntarily"] = 'Voluntarily'] = "Voluntarily";
	    AccountStatusInfoReason[AccountStatusInfoReason["Involuntarily"] = 'Involuntarily'] = "Involuntarily";
	})(exports.AccountStatusInfoReason || (exports.AccountStatusInfoReason = {}));
	var AccountStatusInfoReason = exports.AccountStatusInfoReason;
	
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var businessaddressinfo = __webpack_require__(29);
	var AccountBusinessAddress = (function (_super) {
	    __extends(AccountBusinessAddress, _super);
	    function AccountBusinessAddress() {
	        _super.apply(this, arguments);
	    }
	    AccountBusinessAddress.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'company', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'email', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'businessAddress', Class: businessaddressinfo.BusinessAddressInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountBusinessAddress.prototype.getClassName = function () {
	        return 'AccountBusinessAddress';
	    };
	    return AccountBusinessAddress;
	}(model.Model));
	exports.AccountBusinessAddress = AccountBusinessAddress;
	
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BusinessAddressInfo = (function (_super) {
	    __extends(BusinessAddressInfo, _super);
	    function BusinessAddressInfo() {
	        _super.apply(this, arguments);
	    }
	    BusinessAddressInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'country', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'street', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'zip', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BusinessAddressInfo.prototype.getClassName = function () {
	        return 'BusinessAddressInfo';
	    };
	    return BusinessAddressInfo;
	}(model.Model));
	exports.BusinessAddressInfo = BusinessAddressInfo;
	
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dialingplancountryinfo = __webpack_require__(31);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var DialingPlanInfo = (function (_super) {
	    __extends(DialingPlanInfo, _super);
	    function DialingPlanInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dialingplancountryinfo.DialingPlanCountryInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DialingPlanInfo.prototype.getClassName = function () {
	        return 'DialingPlanInfo';
	    };
	    return DialingPlanInfo;
	}(model.Model));
	exports.DialingPlanInfo = DialingPlanInfo;
	
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DialingPlanCountryInfo = (function (_super) {
	    __extends(DialingPlanCountryInfo, _super);
	    function DialingPlanCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DialingPlanCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DialingPlanCountryInfo.prototype.getClassName = function () {
	        return 'DialingPlanCountryInfo';
	    };
	    return DialingPlanCountryInfo;
	}(model.Model));
	exports.DialingPlanCountryInfo = DialingPlanCountryInfo;
	
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PagingInfo = (function (_super) {
	    __extends(PagingInfo, _super);
	    function PagingInfo() {
	        _super.apply(this, arguments);
	    }
	    PagingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'page', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'perPage', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageStart', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'pageEnd', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalPages', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'totalElements', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    PagingInfo.prototype.getClassName = function () {
	        return 'PagingInfo';
	    };
	    return PagingInfo;
	}(model.Model));
	exports.PagingInfo = PagingInfo;
	
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NavigationInfo = (function (_super) {
	    __extends(NavigationInfo, _super);
	    function NavigationInfo() {
	        _super.apply(this, arguments);
	    }
	    NavigationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'firstPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nextPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'previousPage', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'lastPage', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NavigationInfo.prototype.getClassName = function () {
	        return 'NavigationInfo';
	    };
	    return NavigationInfo;
	}(model.Model));
	exports.NavigationInfo = NavigationInfo;
	
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var countryinfo = __webpack_require__(15);
	var phonenumbersextensioninfo = __webpack_require__(35);
	var PhoneNumberInfo = (function (_super) {
	    __extends(PhoneNumberInfo, _super);
	    function PhoneNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'country', Class: countryinfo.CountryInfo, isArray: false, isRequired: false },
	            { property: 'extension', Class: phonenumbersextensioninfo.PhoneNumbersExtensionInfo, isArray: false, isRequired: false },
	            { property: 'features', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'paymentType', Class: PhoneNumberInfoPaymentType, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: PhoneNumberInfoType, isArray: false, isRequired: false },
	            { property: 'usageType', Class: PhoneNumberInfoUsageType, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumberInfo.prototype.getClassName = function () {
	        return 'PhoneNumberInfo';
	    };
	    return PhoneNumberInfo;
	}(model.Model));
	exports.PhoneNumberInfo = PhoneNumberInfo;
	(function (PhoneNumberInfoPaymentType) {
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["External"] = 'External'] = "External";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["TollFree"] = 'TollFree'] = "TollFree";
	    PhoneNumberInfoPaymentType[PhoneNumberInfoPaymentType["Local"] = 'Local'] = "Local";
	})(exports.PhoneNumberInfoPaymentType || (exports.PhoneNumberInfoPaymentType = {}));
	var PhoneNumberInfoPaymentType = exports.PhoneNumberInfoPaymentType;
	(function (PhoneNumberInfoType) {
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceFax"] = 'VoiceFax'] = "VoiceFax";
	    PhoneNumberInfoType[PhoneNumberInfoType["FaxOnly"] = 'FaxOnly'] = "FaxOnly";
	    PhoneNumberInfoType[PhoneNumberInfoType["VoiceOnly"] = 'VoiceOnly'] = "VoiceOnly";
	})(exports.PhoneNumberInfoType || (exports.PhoneNumberInfoType = {}));
	var PhoneNumberInfoType = exports.PhoneNumberInfoType;
	(function (PhoneNumberInfoUsageType) {
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    PhoneNumberInfoUsageType[PhoneNumberInfoUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.PhoneNumberInfoUsageType || (exports.PhoneNumberInfoUsageType = {}));
	var PhoneNumberInfoUsageType = exports.PhoneNumberInfoUsageType;
	
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PhoneNumbersExtensionInfo = (function (_super) {
	    __extends(PhoneNumbersExtensionInfo, _super);
	    function PhoneNumbersExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PhoneNumbersExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'partnerId', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PhoneNumbersExtensionInfo.prototype.getClassName = function () {
	        return 'PhoneNumbersExtensionInfo';
	    };
	    return PhoneNumbersExtensionInfo;
	}(model.Model));
	exports.PhoneNumbersExtensionInfo = PhoneNumbersExtensionInfo;
	
	
	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var paginginfo = __webpack_require__(32);
	var navigationinfo = __webpack_require__(33);
	var AccountPhoneNumbers = (function (_super) {
	    __extends(AccountPhoneNumbers, _super);
	    function AccountPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    AccountPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountPhoneNumbers.prototype.getClassName = function () {
	        return 'AccountPhoneNumbers';
	    };
	    return AccountPhoneNumbers;
	}(model.Model));
	exports.AccountPhoneNumbers = AccountPhoneNumbers;
	
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var servicefeatureinfo = __webpack_require__(38);
	var accountlimits = __webpack_require__(39);
	var AccountServiceInfo = (function (_super) {
	    __extends(AccountServiceInfo, _super);
	    function AccountServiceInfo() {
	        _super.apply(this, arguments);
	    }
	    AccountServiceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'servicePlanName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'serviceFeatures', Class: servicefeatureinfo.ServiceFeatureInfo, isArray: true, isRequired: false },
	            { property: 'limits', Class: accountlimits.AccountLimits, isArray: true, isRequired: false }
	        ];
	    };
	    AccountServiceInfo.prototype.getClassName = function () {
	        return 'AccountServiceInfo';
	    };
	    return AccountServiceInfo;
	}(model.Model));
	exports.AccountServiceInfo = AccountServiceInfo;
	
	
	/***/ },
	/* 38 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ServiceFeatureInfo = (function (_super) {
	    __extends(ServiceFeatureInfo, _super);
	    function ServiceFeatureInfo() {
	        _super.apply(this, arguments);
	    }
	    ServiceFeatureInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'featureName', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'enabled', Class: ServiceFeatureInfoEnabled, isArray: false, isRequired: false }
	        ];
	    };
	    ServiceFeatureInfo.prototype.getClassName = function () {
	        return 'ServiceFeatureInfo';
	    };
	    return ServiceFeatureInfo;
	}(model.Model));
	exports.ServiceFeatureInfo = ServiceFeatureInfo;
	(function (ServiceFeatureInfoEnabled) {
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["True"] = 'True'] = "True";
	    ServiceFeatureInfoEnabled[ServiceFeatureInfoEnabled["False"] = 'False'] = "False";
	})(exports.ServiceFeatureInfoEnabled || (exports.ServiceFeatureInfoEnabled = {}));
	var ServiceFeatureInfoEnabled = exports.ServiceFeatureInfoEnabled;
	
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var AccountLimits = (function (_super) {
	    __extends(AccountLimits, _super);
	    function AccountLimits() {
	        _super.apply(this, arguments);
	    }
	    AccountLimits.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'freeSoftPhoneLinesPerExtension', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'meetingSize', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'maxMonitoredExtensionsPerUser', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    AccountLimits.prototype.getClassName = function () {
	        return 'AccountLimits';
	    };
	    return AccountLimits;
	}(model.Model));
	exports.AccountLimits = AccountLimits;
	
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var accountactivecalls = __webpack_require__(41);
	var accountcalllog = __webpack_require__(47);
	var accountcalllogrecord = __webpack_require__(48);
	var extensionactivecalls = __webpack_require__(49);
	var extensioncalllog = __webpack_require__(50);
	var extensioncalllogrecord = __webpack_require__(51);
	var calllogsync = __webpack_require__(52);
	var callrecording = __webpack_require__(54);
	var CallLog = (function (_super) {
	    __extends(CallLog, _super);
	    function CallLog() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Account Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listAccountActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/active-calls', options, exports.listAccountActiveCallsOptions), accountactivecalls.AccountActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log', options, exports.loadAccountCallLogOptions), accountcalllog.AccountCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteAccountCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/call-log', options, exports.deleteAccountCallLogOptions), null);
	    };
	    /**
	     * Get Account Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns individual call log record(s) by ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadAccountCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/call-log/{callRecordId}', options, exports.loadAccountCallLogRecordOptions), accountcalllogrecord.AccountCallLogRecord);
	    };
	    /**
	     * Get Active Calls
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns records of all extension calls that are in progress, ordered by start time in descending order.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.listExtensionActiveCalls = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/active-calls', options, exports.listExtensionActiveCallsOptions), extensionactivecalls.ExtensionActiveCalls);
	    };
	    /**
	     * Get Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log records filtered by the specified parameters.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.loadExtensionCallLogOptions), extensioncalllog.ExtensionCallLog);
	    };
	    /**
	     * Delete Call Log Records by Filter
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditCallLog</td>
	     *             <td>Viewing and updating user call logs</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.deleteExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log', options, exports.deleteExtensionCallLogOptions), null);
	    };
	    /**
	     * Get Extension Call Log Record(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.3 (Release 5.11)</p>
	     * <p>Returns call log record(s) by their ID(s). Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadExtensionCallLogRecord = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log/{callRecordId}', options, exports.loadExtensionCallLogRecordOptions), extensioncalllogrecord.ExtensionCallLogRecord);
	    };
	    /**
	     * Call Log Synchronization
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.syncExtensionCallLog = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log-sync', options, exports.syncExtensionCallLogOptions), calllogsync.CallLogSync);
	    };
	    /**
	     * Get Call Recording
	     *
	     * <p style='font-style:italic;'>Since 1.0.18</p>
	     * <p>Returns call recording metadata.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadCallLog</td>
	     *             <td>Viewing user call logs</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingMetadata = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}', options, exports.loadCallRecordingMetadataOptions), callrecording.CallRecording);
	    };
	    /**
	     * Get Call Recording Data
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadCallRecording</td>
	     *             <td>Downloading call recording content</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    CallLog.prototype.loadCallRecordingContent = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/recording/{recordingId}/content', options, exports.loadCallRecordingContentOptions), null);
	    };
	    return CallLog;
	}(client.Client));
	exports.CallLog = CallLog;
	/**
	 * Definition of options for listAccountActiveCalls operation
	 */
	exports.listAccountActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListAccountActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListAccountActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLog operation
	 */
	exports.loadAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadAccountCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadAccountCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadAccountCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteAccountCallLog operation
	 */
	exports.deleteAccountCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadAccountCallLogRecord operation
	 */
	exports.loadAccountCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listExtensionActiveCalls operation
	 */
	exports.listExtensionActiveCallsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "direction",
	        "type": "IListExtensionActiveCallsDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionActiveCallsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLog operation
	 */
	exports.loadExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ILoadExtensionCallLogDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "ILoadExtensionCallLogType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Voice",
	            "Fax"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "view",
	        "type": "ILoadExtensionCallLogView",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Simple",
	            "Detailed"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withRecording",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for deleteExtensionCallLog operation
	 */
	exports.deleteExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionCallLogRecord operation
	 */
	exports.loadExtensionCallLogRecordOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "callRecordId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncExtensionCallLog operation
	 */
	exports.syncExtensionCallLogOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncExtensionCallLogSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "statusGroup",
	        "type": "ISyncExtensionCallLogStatusGroup",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Missed",
	            "All"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCallRecordingMetadata operation
	 */
	exports.loadCallRecordingMetadataOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for loadCallRecordingContent operation
	 */
	exports.loadCallRecordingContentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "recordingId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	(function (IListAccountActiveCallsDirection) {
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListAccountActiveCallsDirection[IListAccountActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListAccountActiveCallsDirection || (exports.IListAccountActiveCallsDirection = {}));
	var IListAccountActiveCallsDirection = exports.IListAccountActiveCallsDirection;
	(function (IListAccountActiveCallsType) {
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListAccountActiveCallsType[IListAccountActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListAccountActiveCallsType || (exports.IListAccountActiveCallsType = {}));
	var IListAccountActiveCallsType = exports.IListAccountActiveCallsType;
	(function (ILoadAccountCallLogDirection) {
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadAccountCallLogDirection[ILoadAccountCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadAccountCallLogDirection || (exports.ILoadAccountCallLogDirection = {}));
	var ILoadAccountCallLogDirection = exports.ILoadAccountCallLogDirection;
	(function (ILoadAccountCallLogType) {
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadAccountCallLogType[ILoadAccountCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadAccountCallLogType || (exports.ILoadAccountCallLogType = {}));
	var ILoadAccountCallLogType = exports.ILoadAccountCallLogType;
	(function (ILoadAccountCallLogView) {
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadAccountCallLogView[ILoadAccountCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadAccountCallLogView || (exports.ILoadAccountCallLogView = {}));
	var ILoadAccountCallLogView = exports.ILoadAccountCallLogView;
	(function (IListExtensionActiveCallsDirection) {
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListExtensionActiveCallsDirection[IListExtensionActiveCallsDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListExtensionActiveCallsDirection || (exports.IListExtensionActiveCallsDirection = {}));
	var IListExtensionActiveCallsDirection = exports.IListExtensionActiveCallsDirection;
	(function (IListExtensionActiveCallsType) {
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Voice"] = 'Voice'] = "Voice";
	    IListExtensionActiveCallsType[IListExtensionActiveCallsType["Fax"] = 'Fax'] = "Fax";
	})(exports.IListExtensionActiveCallsType || (exports.IListExtensionActiveCallsType = {}));
	var IListExtensionActiveCallsType = exports.IListExtensionActiveCallsType;
	(function (ILoadExtensionCallLogDirection) {
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ILoadExtensionCallLogDirection[ILoadExtensionCallLogDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ILoadExtensionCallLogDirection || (exports.ILoadExtensionCallLogDirection = {}));
	var ILoadExtensionCallLogDirection = exports.ILoadExtensionCallLogDirection;
	(function (ILoadExtensionCallLogType) {
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Voice"] = 'Voice'] = "Voice";
	    ILoadExtensionCallLogType[ILoadExtensionCallLogType["Fax"] = 'Fax'] = "Fax";
	})(exports.ILoadExtensionCallLogType || (exports.ILoadExtensionCallLogType = {}));
	var ILoadExtensionCallLogType = exports.ILoadExtensionCallLogType;
	(function (ILoadExtensionCallLogView) {
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Simple"] = 'Simple'] = "Simple";
	    ILoadExtensionCallLogView[ILoadExtensionCallLogView["Detailed"] = 'Detailed'] = "Detailed";
	})(exports.ILoadExtensionCallLogView || (exports.ILoadExtensionCallLogView = {}));
	var ILoadExtensionCallLogView = exports.ILoadExtensionCallLogView;
	(function (ISyncExtensionCallLogSyncType) {
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncExtensionCallLogSyncType[ISyncExtensionCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncExtensionCallLogSyncType || (exports.ISyncExtensionCallLogSyncType = {}));
	var ISyncExtensionCallLogSyncType = exports.ISyncExtensionCallLogSyncType;
	(function (ISyncExtensionCallLogStatusGroup) {
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["Missed"] = 'Missed'] = "Missed";
	    ISyncExtensionCallLogStatusGroup[ISyncExtensionCallLogStatusGroup["All"] = 'All'] = "All";
	})(exports.ISyncExtensionCallLogStatusGroup || (exports.ISyncExtensionCallLogStatusGroup = {}));
	var ISyncExtensionCallLogStatusGroup = exports.ISyncExtensionCallLogStatusGroup;
	
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountActiveCalls = (function (_super) {
	    __extends(AccountActiveCalls, _super);
	    function AccountActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    AccountActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountActiveCalls.prototype.getClassName = function () {
	        return 'AccountActiveCalls';
	    };
	    return AccountActiveCalls;
	}(model.Model));
	exports.AccountActiveCalls = AccountActiveCalls;
	
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var calllogrecordleginfo = __webpack_require__(45);
	var CallLogRecord = (function (_super) {
	    __extends(CallLogRecord, _super);
	    function CallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: CallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordTransport, isArray: false, isRequired: false },
	            { property: 'legs', Class: calllogrecordleginfo.CallLogRecordLegInfo, isArray: true, isRequired: true }
	        ];
	    };
	    CallLogRecord.prototype.getClassName = function () {
	        return 'CallLogRecord';
	    };
	    return CallLogRecord;
	}(model.Model));
	exports.CallLogRecord = CallLogRecord;
	(function (CallLogRecordType) {
	    CallLogRecordType[CallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordType[CallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordType || (exports.CallLogRecordType = {}));
	var CallLogRecordType = exports.CallLogRecordType;
	(function (CallLogRecordDirection) {
	    CallLogRecordDirection[CallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordDirection[CallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordDirection || (exports.CallLogRecordDirection = {}));
	var CallLogRecordDirection = exports.CallLogRecordDirection;
	(function (CallLogRecordAction) {
	    CallLogRecordAction[CallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordAction[CallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordAction[CallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordAction[CallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordAction[CallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordAction[CallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordAction[CallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordAction[CallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordAction[CallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordAction[CallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordAction[CallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordAction[CallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordAction[CallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordAction[CallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordAction[CallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordAction[CallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordAction[CallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordAction[CallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordAction[CallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordAction[CallLogRecordAction["Support"] = 'Support'] = "Support";
	    CallLogRecordAction[CallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordAction || (exports.CallLogRecordAction = {}));
	var CallLogRecordAction = exports.CallLogRecordAction;
	(function (CallLogRecordResult) {
	    CallLogRecordResult[CallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordResult[CallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordResult[CallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordResult[CallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordResult[CallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordResult[CallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordResult[CallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordResult[CallLogRecordResult["Received"] = 'Received'] = "Received";
	    CallLogRecordResult[CallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordResult[CallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordResult[CallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordResult[CallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordResult[CallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordResult[CallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordResult[CallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordResult[CallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordResult[CallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordResult[CallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordResult[CallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordResult[CallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordResult[CallLogRecordResult["Account"] = 'Account'] = "Account";
	    CallLogRecordResult[CallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordResult[CallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordResult[CallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordResult[CallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordResult[CallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordResult[CallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordResult[CallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordResult[CallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordResult[CallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordResult[CallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordResult[CallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordResult[CallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordResult[CallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordResult[CallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordResult[CallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordResult[CallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordResult || (exports.CallLogRecordResult = {}));
	var CallLogRecordResult = exports.CallLogRecordResult;
	(function (CallLogRecordTransport) {
	    CallLogRecordTransport[CallLogRecordTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordTransport[CallLogRecordTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordTransport || (exports.CallLogRecordTransport = {}));
	var CallLogRecordTransport = exports.CallLogRecordTransport;
	
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallLogCallerInfo = (function (_super) {
	    __extends(CallLogCallerInfo, _super);
	    function CallLogCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogCallerInfo.prototype.getClassName = function () {
	        return 'CallLogCallerInfo';
	    };
	    return CallLogCallerInfo;
	}(model.Model));
	exports.CallLogCallerInfo = CallLogCallerInfo;
	
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RecordingInfo = (function (_super) {
	    __extends(RecordingInfo, _super);
	    function RecordingInfo() {
	        _super.apply(this, arguments);
	    }
	    RecordingInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: RecordingInfoType, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    RecordingInfo.prototype.getClassName = function () {
	        return 'RecordingInfo';
	    };
	    return RecordingInfo;
	}(model.Model));
	exports.RecordingInfo = RecordingInfo;
	(function (RecordingInfoType) {
	    RecordingInfoType[RecordingInfoType["Automatic"] = 'Automatic'] = "Automatic";
	    RecordingInfoType[RecordingInfoType["OnDemand"] = 'OnDemand'] = "OnDemand";
	})(exports.RecordingInfoType || (exports.RecordingInfoType = {}));
	var RecordingInfoType = exports.RecordingInfoType;
	
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfocalllog = __webpack_require__(46);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var CallLogRecordLegInfo = (function (_super) {
	    __extends(CallLogRecordLegInfo, _super);
	    function CallLogRecordLegInfo() {
	        _super.apply(this, arguments);
	    }
	    CallLogRecordLegInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'action', Class: CallLogRecordLegInfoAction, isArray: false, isRequired: false },
	            { property: 'direction', Class: CallLogRecordLegInfoDirection, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfocalllog.ExtensionInfoCallLog, isArray: false, isRequired: false },
	            { property: 'legType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: CallLogRecordLegInfoType, isArray: false, isRequired: false },
	            { property: 'result', Class: CallLogRecordLegInfoResult, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'transport', Class: CallLogRecordLegInfoTransport, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogRecordLegInfo.prototype.getClassName = function () {
	        return 'CallLogRecordLegInfo';
	    };
	    return CallLogRecordLegInfo;
	}(model.Model));
	exports.CallLogRecordLegInfo = CallLogRecordLegInfo;
	(function (CallLogRecordLegInfoAction) {
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FindMe"] = 'FindMe'] = "FindMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingMe"] = 'RingMe'] = "RingMe";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Transfer"] = 'Transfer'] = "Transfer";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['411Info'] = '411 Info'] = '411Info';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Emergency"] = 'Emergency'] = "Emergency";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["Support"] = 'Support'] = "Support";
	    CallLogRecordLegInfoAction[CallLogRecordLegInfoAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.CallLogRecordLegInfoAction || (exports.CallLogRecordLegInfoAction = {}));
	var CallLogRecordLegInfoAction = exports.CallLogRecordLegInfoAction;
	(function (CallLogRecordLegInfoDirection) {
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    CallLogRecordLegInfoDirection[CallLogRecordLegInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.CallLogRecordLegInfoDirection || (exports.CallLogRecordLegInfoDirection = {}));
	var CallLogRecordLegInfoDirection = exports.CallLogRecordLegInfoDirection;
	(function (CallLogRecordLegInfoType) {
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Voice"] = 'Voice'] = "Voice";
	    CallLogRecordLegInfoType[CallLogRecordLegInfoType["Fax"] = 'Fax'] = "Fax";
	})(exports.CallLogRecordLegInfoType || (exports.CallLogRecordLegInfoType = {}));
	var CallLogRecordLegInfoType = exports.CallLogRecordLegInfoType;
	(function (CallLogRecordLegInfoResult) {
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Unknown"] = 'Unknown'] = "Unknown";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Missed"] = 'Missed'] = "Missed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Rejected"] = 'Rejected'] = "Rejected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Reply"] = 'Reply'] = "Reply";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Received"] = 'Received'] = "Received";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Blocked"] = 'Blocked'] = "Blocked";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Busy"] = 'Busy'] = "Busy";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["SendError"] = 'Send Error'] = "SendError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Sent"] = 'Sent'] = "Sent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Account"] = 'Account'] = "Account";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Suspended"] = 'Suspended'] = "Suspended";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternalError"] = 'Internal Error'] = "InternalError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Stopped"] = 'Stopped'] = "Stopped";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Hangup"] = 'Hang up'] = "Hangup";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["Declined"] = 'Declined'] = "Declined";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    CallLogRecordLegInfoResult[CallLogRecordLegInfoResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.CallLogRecordLegInfoResult || (exports.CallLogRecordLegInfoResult = {}));
	var CallLogRecordLegInfoResult = exports.CallLogRecordLegInfoResult;
	(function (CallLogRecordLegInfoTransport) {
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["PSTN"] = 'PSTN'] = "PSTN";
	    CallLogRecordLegInfoTransport[CallLogRecordLegInfoTransport["VoIP"] = 'VoIP'] = "VoIP";
	})(exports.CallLogRecordLegInfoTransport || (exports.CallLogRecordLegInfoTransport = {}));
	var CallLogRecordLegInfoTransport = exports.CallLogRecordLegInfoTransport;
	
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoCallLog = (function (_super) {
	    __extends(ExtensionInfoCallLog, _super);
	    function ExtensionInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoCallLog.prototype.getClassName = function () {
	        return 'ExtensionInfoCallLog';
	    };
	    return ExtensionInfoCallLog;
	}(model.Model));
	exports.ExtensionInfoCallLog = ExtensionInfoCallLog;
	
	
	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var AccountCallLog = (function (_super) {
	    __extends(AccountCallLog, _super);
	    function AccountCallLog() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    AccountCallLog.prototype.getClassName = function () {
	        return 'AccountCallLog';
	    };
	    return AccountCallLog;
	}(model.Model));
	exports.AccountCallLog = AccountCallLog;
	
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var AccountCallLogRecord = (function (_super) {
	    __extends(AccountCallLogRecord, _super);
	    function AccountCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    AccountCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: AccountCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: AccountCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: AccountCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: AccountCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    AccountCallLogRecord.prototype.getClassName = function () {
	        return 'AccountCallLogRecord';
	    };
	    return AccountCallLogRecord;
	}(model.Model));
	exports.AccountCallLogRecord = AccountCallLogRecord;
	(function (AccountCallLogRecordType) {
	    AccountCallLogRecordType[AccountCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    AccountCallLogRecordType[AccountCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.AccountCallLogRecordType || (exports.AccountCallLogRecordType = {}));
	var AccountCallLogRecordType = exports.AccountCallLogRecordType;
	(function (AccountCallLogRecordDirection) {
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    AccountCallLogRecordDirection[AccountCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.AccountCallLogRecordDirection || (exports.AccountCallLogRecordDirection = {}));
	var AccountCallLogRecordDirection = exports.AccountCallLogRecordDirection;
	(function (AccountCallLogRecordAction) {
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    AccountCallLogRecordAction[AccountCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    AccountCallLogRecordAction[AccountCallLogRecordAction["Support"] = 'Support'] = "Support";
	    AccountCallLogRecordAction[AccountCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.AccountCallLogRecordAction || (exports.AccountCallLogRecordAction = {}));
	var AccountCallLogRecordAction = exports.AccountCallLogRecordAction;
	(function (AccountCallLogRecordResult) {
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Received"] = 'Received'] = "Received";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Account"] = 'Account'] = "Account";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    AccountCallLogRecordResult[AccountCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.AccountCallLogRecordResult || (exports.AccountCallLogRecordResult = {}));
	var AccountCallLogRecordResult = exports.AccountCallLogRecordResult;
	
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionActiveCalls = (function (_super) {
	    __extends(ExtensionActiveCalls, _super);
	    function ExtensionActiveCalls() {
	        _super.apply(this, arguments);
	    }
	    ExtensionActiveCalls.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionActiveCalls.prototype.getClassName = function () {
	        return 'ExtensionActiveCalls';
	    };
	    return ExtensionActiveCalls;
	}(model.Model));
	exports.ExtensionActiveCalls = ExtensionActiveCalls;
	
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionCallLog = (function (_super) {
	    __extends(ExtensionCallLog, _super);
	    function ExtensionCallLog() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionCallLog.prototype.getClassName = function () {
	        return 'ExtensionCallLog';
	    };
	    return ExtensionCallLog;
	}(model.Model));
	exports.ExtensionCallLog = ExtensionCallLog;
	
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogcallerinfo = __webpack_require__(43);
	var recordinginfo = __webpack_require__(44);
	var ExtensionCallLogRecord = (function (_super) {
	    __extends(ExtensionCallLogRecord, _super);
	    function ExtensionCallLogRecord() {
	        _super.apply(this, arguments);
	    }
	    ExtensionCallLogRecord.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'sessionId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'from', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'to', Class: calllogcallerinfo.CallLogCallerInfo, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionCallLogRecordType, isArray: false, isRequired: false },
	            { property: 'direction', Class: ExtensionCallLogRecordDirection, isArray: false, isRequired: false },
	            { property: 'action', Class: ExtensionCallLogRecordAction, isArray: false, isRequired: false },
	            { property: 'result', Class: ExtensionCallLogRecordResult, isArray: false, isRequired: false },
	            { property: 'startTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'recording', Class: recordinginfo.RecordingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionCallLogRecord.prototype.getClassName = function () {
	        return 'ExtensionCallLogRecord';
	    };
	    return ExtensionCallLogRecord;
	}(model.Model));
	exports.ExtensionCallLogRecord = ExtensionCallLogRecord;
	(function (ExtensionCallLogRecordType) {
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Voice"] = 'Voice'] = "Voice";
	    ExtensionCallLogRecordType[ExtensionCallLogRecordType["Fax"] = 'Fax'] = "Fax";
	})(exports.ExtensionCallLogRecordType || (exports.ExtensionCallLogRecordType = {}));
	var ExtensionCallLogRecordType = exports.ExtensionCallLogRecordType;
	(function (ExtensionCallLogRecordDirection) {
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ExtensionCallLogRecordDirection[ExtensionCallLogRecordDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ExtensionCallLogRecordDirection || (exports.ExtensionCallLogRecordDirection = {}));
	var ExtensionCallLogRecordDirection = exports.ExtensionCallLogRecordDirection;
	(function (ExtensionCallLogRecordAction) {
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneCall"] = 'Phone Call'] = "PhoneCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["PhoneLogin"] = 'Phone Login'] = "PhoneLogin";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["IncomingFax"] = 'Incoming Fax'] = "IncomingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["AcceptCall"] = 'Accept Call'] = "AcceptCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FindMe"] = 'FindMe'] = "FindMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["FollowMe"] = 'FollowMe'] = "FollowMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["OutgoingFax"] = 'Outgoing Fax'] = "OutgoingFax";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallReturn"] = 'Call Return'] = "CallReturn";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["CallingCard"] = 'Calling Card'] = "CallingCard";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingDirectly"] = 'Ring Directly'] = "RingDirectly";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutWeb"] = 'RingOut Web'] = "RingOutWeb";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["VoIPCall"] = 'VoIP Call'] = "VoIPCall";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutPC"] = 'RingOut PC'] = "RingOutPC";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingMe"] = 'RingMe'] = "RingMe";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Transfer"] = 'Transfer'] = "Transfer";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['411Info'] = '411 Info'] = '411Info';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Emergency"] = 'Emergency'] = "Emergency";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction['E911Update'] = 'E911 Update'] = 'E911Update';
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["Support"] = 'Support'] = "Support";
	    ExtensionCallLogRecordAction[ExtensionCallLogRecordAction["RingOutMobile"] = 'RingOut Mobile'] = "RingOutMobile";
	})(exports.ExtensionCallLogRecordAction || (exports.ExtensionCallLogRecordAction = {}));
	var ExtensionCallLogRecordAction = exports.ExtensionCallLogRecordAction;
	(function (ExtensionCallLogRecordResult) {
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Unknown"] = 'Unknown'] = "Unknown";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultInProgress"] = 'ResultInProgress'] = "ResultInProgress";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Missed"] = 'Missed'] = "Missed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callaccepted"] = 'Call accepted'] = "Callaccepted";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Rejected"] = 'Rejected'] = "Rejected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Reply"] = 'Reply'] = "Reply";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Received"] = 'Received'] = "Received";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ReceiveError"] = 'Receive Error'] = "ReceiveError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxonDemand"] = 'Fax on Demand'] = "FaxonDemand";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartialReceive"] = 'Partial Receive'] = "PartialReceive";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Blocked"] = 'Blocked'] = "Blocked";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Callconnected"] = 'Call connected'] = "Callconnected";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["NoAnswer"] = 'No Answer'] = "NoAnswer";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalDisabled"] = 'International Disabled'] = "InternationalDisabled";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Busy"] = 'Busy'] = "Busy";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["SendError"] = 'Send Error'] = "SendError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Sent"] = 'Sent'] = "Sent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Nofaxmachine"] = 'No fax machine'] = "Nofaxmachine";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["ResultEmpty"] = 'ResultEmpty'] = "ResultEmpty";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Account"] = 'Account'] = "Account";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Suspended"] = 'Suspended'] = "Suspended";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailed"] = 'Call Failed'] = "CallFailed";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["CallFailure"] = 'Call Failure'] = "CallFailure";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternalError"] = 'Internal Error'] = "InternalError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["IPPhoneoffline"] = 'IP Phone offline'] = "IPPhoneoffline";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["RestrictedNumber"] = 'Restricted Number'] = "RestrictedNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["WrongNumber"] = 'Wrong Number'] = "WrongNumber";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Stopped"] = 'Stopped'] = "Stopped";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Hangup"] = 'Hang up'] = "Hangup";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PoorLineQuality"] = 'Poor Line Quality'] = "PoorLineQuality";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["PartiallySent"] = 'Partially Sent'] = "PartiallySent";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["InternationalRestriction"] = 'International Restriction'] = "InternationalRestriction";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Abandoned"] = 'Abandoned'] = "Abandoned";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["Declined"] = 'Declined'] = "Declined";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxReceiptError"] = 'Fax Receipt Error'] = "FaxReceiptError";
	    ExtensionCallLogRecordResult[ExtensionCallLogRecordResult["FaxSendError"] = 'Fax Send Error'] = "FaxSendError";
	})(exports.ExtensionCallLogRecordResult || (exports.ExtensionCallLogRecordResult = {}));
	var ExtensionCallLogRecordResult = exports.ExtensionCallLogRecordResult;
	
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var calllogrecord = __webpack_require__(42);
	var syncinfocalllog = __webpack_require__(53);
	var CallLogSync = (function (_super) {
	    __extends(CallLogSync, _super);
	    function CallLogSync() {
	        _super.apply(this, arguments);
	    }
	    CallLogSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: calllogrecord.CallLogRecord, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: syncinfocalllog.SyncInfoCallLog, isArray: false, isRequired: false }
	        ];
	    };
	    CallLogSync.prototype.getClassName = function () {
	        return 'CallLogSync';
	    };
	    return CallLogSync;
	}(model.Model));
	exports.CallLogSync = CallLogSync;
	
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SyncInfoCallLog = (function (_super) {
	    __extends(SyncInfoCallLog, _super);
	    function SyncInfoCallLog() {
	        _super.apply(this, arguments);
	    }
	    SyncInfoCallLog.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: SyncInfoCallLogSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    SyncInfoCallLog.prototype.getClassName = function () {
	        return 'SyncInfoCallLog';
	    };
	    return SyncInfoCallLog;
	}(model.Model));
	exports.SyncInfoCallLog = SyncInfoCallLog;
	(function (SyncInfoCallLogSyncType) {
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["FSync"] = 'FSync'] = "FSync";
	    SyncInfoCallLogSyncType[SyncInfoCallLogSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.SyncInfoCallLogSyncType || (exports.SyncInfoCallLogSyncType = {}));
	var SyncInfoCallLogSyncType = exports.SyncInfoCallLogSyncType;
	
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var CallRecording = (function (_super) {
	    __extends(CallRecording, _super);
	    function CallRecording() {
	        _super.apply(this, arguments);
	    }
	    CallRecording.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentUri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'duration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    CallRecording.prototype.getClassName = function () {
	        return 'CallRecording';
	    };
	    return CallRecording;
	}(model.Model));
	exports.CallRecording = CallRecording;
	
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var countrylist = __webpack_require__(56);
	var dictionarycountryinfo = __webpack_require__(57);
	var languagelist = __webpack_require__(58);
	var languageinfo = __webpack_require__(17);
	var dictionarylocationlist = __webpack_require__(59);
	var dictionarysecretquestionlist = __webpack_require__(61);
	var secretquestioninfo = __webpack_require__(62);
	var dictionaryshippingoptions = __webpack_require__(63);
	var dictionarystatelist = __webpack_require__(65);
	var dictionarystateinfo = __webpack_require__(66);
	var dictionarytimezonelist = __webpack_require__(68);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var Dictionary = (function (_super) {
	    __extends(Dictionary, _super);
	    function Dictionary() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Country List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the countries available for calling.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listCountries = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country', options, exports.listCountriesOptions), countrylist.CountryList);
	    };
	    /**
	     * Get Country
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadCountry = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/country/{countryId}', options, exports.loadCountryOptions), dictionarycountryinfo.DictionaryCountryInfo);
	    };
	    /**
	     * Get Language List
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns the information about supported languages.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLanguages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language', options, exports.listLanguagesOptions), languagelist.LanguageList);
	    };
	    /**
	     * Get Language
	     *
	     * <p style='font-style:italic;'>Since 1.0.14 (Release 6.6)</p>
	     * <p>Returns language by its respective ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadLanguage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/language/{languageId}', options, exports.loadLanguageOptions), languageinfo.LanguageInfo);
	    };
	    /**
	     * Get Location List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the available locations for the certain state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listLocations = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/location', options, exports.listLocationsOptions), dictionarylocationlist.DictionaryLocationList);
	    };
	    /**
	     * Get Secret Question List
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns the list of secret questions for a specific language.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listSecretQuestions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question', options, exports.listSecretQuestionsOptions), dictionarysecretquestionlist.DictionarySecretQuestionList);
	    };
	    /**
	     * Get Secret Question
	     *
	     * <p style='font-style:italic;'>Since 1.0.20 (Release 7.4)</p>
	     * <p>Returns a particular secret question in specific language by question ID.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadSecretQuestion = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/secret-question/questionId', options, exports.loadSecretQuestionOptions), secretquestioninfo.SecretQuestionInfo);
	    };
	    /**
	     * Get Shipping Options
	     *
	     * <p style='font-style:italic;'>Since 1.0.16 (Release 7.1)</p>
	     * <p>Returns the list of device shipping options with their prices, according to brand, tier, number of ordered devices.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listShippingOptions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/shipping-options', options, exports.listShippingOptionsOptions), dictionaryshippingoptions.DictionaryShippingOptions);
	    };
	    /**
	     * Get State List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all the states for a certain country.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadlistStates = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state', options, exports.loadlistStatesOptions), dictionarystatelist.DictionaryStateList);
	    };
	    /**
	     * Get State
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on the required state.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadState = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/state/{stateId}', options, exports.loadStateOptions), dictionarystateinfo.DictionaryStateInfo);
	    };
	    /**
	     * Get Timezone List
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns all available timezones.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.listTimezones = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone', options, exports.listTimezonesOptions), dictionarytimezonelist.DictionaryTimezoneList);
	    };
	    /**
	     * Get Timezone
	     *
	     * <p style='font-style:italic;'>Since 1.0.10 (Release 6.2)</p>
	     * <p>Returns the information on a certain timezone.</p>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Dictionary.prototype.loadTimezone = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/dictionary/timezone/{timezoneId}', options, exports.loadTimezoneOptions), dictionarytimezoneinfo.DictionaryTimezoneInfo);
	    };
	    return Dictionary;
	}(client.Client));
	exports.Dictionary = Dictionary;
	/**
	 * Definition of options for listCountries operation
	 */
	exports.listCountriesOptions = [
	    {
	        "name": "loginAllowed",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "numberSelling",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadCountry operation
	 */
	exports.loadCountryOptions = [
	    {
	        "name": "countryId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLanguages operation
	 */
	exports.listLanguagesOptions = [];
	/**
	 * Definition of options for loadLanguage operation
	 */
	exports.loadLanguageOptions = [
	    {
	        "name": "languageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listLocations operation
	 */
	exports.listLocationsOptions = [
	    {
	        "name": "orderBy",
	        "type": "IListLocationsOrderBy",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Npa",
	            "City"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withNxx",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listSecretQuestions operation
	 */
	exports.listSecretQuestionsOptions = [];
	/**
	 * Definition of options for loadSecretQuestion operation
	 */
	exports.loadSecretQuestionOptions = [
	    {
	        "name": "questionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listShippingOptions operation
	 */
	exports.listShippingOptionsOptions = [];
	/**
	 * Definition of options for loadlistStates operation
	 */
	exports.loadlistStatesOptions = [
	    {
	        "name": "countryId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "withPhoneNumbers",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadState operation
	 */
	exports.loadStateOptions = [
	    {
	        "name": "stateId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listTimezones operation
	 */
	exports.listTimezonesOptions = [
	    {
	        "name": "page",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadTimezone operation
	 */
	exports.loadTimezoneOptions = [
	    {
	        "name": "timezoneId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListLocationsOrderBy) {
	    IListLocationsOrderBy[IListLocationsOrderBy["Npa"] = 'Npa'] = "Npa";
	    IListLocationsOrderBy[IListLocationsOrderBy["City"] = 'City'] = "City";
	})(exports.IListLocationsOrderBy || (exports.IListLocationsOrderBy = {}));
	var IListLocationsOrderBy = exports.IListLocationsOrderBy;
	
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarycountryinfo = __webpack_require__(57);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var CountryList = (function (_super) {
	    __extends(CountryList, _super);
	    function CountryList() {
	        _super.apply(this, arguments);
	    }
	    CountryList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarycountryinfo.DictionaryCountryInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    CountryList.prototype.getClassName = function () {
	        return 'CountryList';
	    };
	    return CountryList;
	}(model.Model));
	exports.CountryList = CountryList;
	
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryCountryInfo = (function (_super) {
	    __extends(DictionaryCountryInfo, _super);
	    function DictionaryCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'callingCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'emergencyCalling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'numberSelling', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'loginAllowed', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryCountryInfo.prototype.getClassName = function () {
	        return 'DictionaryCountryInfo';
	    };
	    return DictionaryCountryInfo;
	}(model.Model));
	exports.DictionaryCountryInfo = DictionaryCountryInfo;
	
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var languageinfo = __webpack_require__(17);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var LanguageList = (function (_super) {
	    __extends(LanguageList, _super);
	    function LanguageList() {
	        _super.apply(this, arguments);
	    }
	    LanguageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'records', Class: languageinfo.LanguageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    LanguageList.prototype.getClassName = function () {
	        return 'LanguageList';
	    };
	    return LanguageList;
	}(model.Model));
	exports.LanguageList = LanguageList;
	
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var locationinfo = __webpack_require__(60);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryLocationList = (function (_super) {
	    __extends(DictionaryLocationList, _super);
	    function DictionaryLocationList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryLocationList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: locationinfo.LocationInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryLocationList.prototype.getClassName = function () {
	        return 'DictionaryLocationList';
	    };
	    return DictionaryLocationList;
	}(model.Model));
	exports.DictionaryLocationList = DictionaryLocationList;
	
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var LocationInfo = (function (_super) {
	    __extends(LocationInfo, _super);
	    function LocationInfo() {
	        _super.apply(this, arguments);
	    }
	    LocationInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'areaCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'city', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'npa', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'nxx', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'state', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    LocationInfo.prototype.getClassName = function () {
	        return 'LocationInfo';
	    };
	    return LocationInfo;
	}(model.Model));
	exports.LocationInfo = LocationInfo;
	
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var secretquestioninfo = __webpack_require__(62);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionarySecretQuestionList = (function (_super) {
	    __extends(DictionarySecretQuestionList, _super);
	    function DictionarySecretQuestionList() {
	        _super.apply(this, arguments);
	    }
	    DictionarySecretQuestionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: secretquestioninfo.SecretQuestionInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    DictionarySecretQuestionList.prototype.getClassName = function () {
	        return 'DictionarySecretQuestionList';
	    };
	    return DictionarySecretQuestionList;
	}(model.Model));
	exports.DictionarySecretQuestionList = DictionarySecretQuestionList;
	
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var SecretQuestionInfo = (function (_super) {
	    __extends(SecretQuestionInfo, _super);
	    function SecretQuestionInfo() {
	        _super.apply(this, arguments);
	    }
	    SecretQuestionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionType', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'languageId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'questionText', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'showInSignUp', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    SecretQuestionInfo.prototype.getClassName = function () {
	        return 'SecretQuestionInfo';
	    };
	    return SecretQuestionInfo;
	}(model.Model));
	exports.SecretQuestionInfo = SecretQuestionInfo;
	
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var shippingmethodinfo = __webpack_require__(64);
	var DictionaryShippingOptions = (function (_super) {
	    __extends(DictionaryShippingOptions, _super);
	    function DictionaryShippingOptions() {
	        _super.apply(this, arguments);
	    }
	    DictionaryShippingOptions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'quantity', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'price', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'method', Class: shippingmethodinfo.ShippingMethodInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryShippingOptions.prototype.getClassName = function () {
	        return 'DictionaryShippingOptions';
	    };
	    return DictionaryShippingOptions;
	}(model.Model));
	exports.DictionaryShippingOptions = DictionaryShippingOptions;
	
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ShippingMethodInfo = (function (_super) {
	    __extends(ShippingMethodInfo, _super);
	    function ShippingMethodInfo() {
	        _super.apply(this, arguments);
	    }
	    ShippingMethodInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    ShippingMethodInfo.prototype.getClassName = function () {
	        return 'ShippingMethodInfo';
	    };
	    return ShippingMethodInfo;
	}(model.Model));
	exports.ShippingMethodInfo = ShippingMethodInfo;
	
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarystateinfo = __webpack_require__(66);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryStateList = (function (_super) {
	    __extends(DictionaryStateList, _super);
	    function DictionaryStateList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarystateinfo.DictionaryStateInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryStateList.prototype.getClassName = function () {
	        return 'DictionaryStateList';
	    };
	    return DictionaryStateList;
	}(model.Model));
	exports.DictionaryStateList = DictionaryStateList;
	
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var statecountryinfo = __webpack_require__(67);
	var DictionaryStateInfo = (function (_super) {
	    __extends(DictionaryStateInfo, _super);
	    function DictionaryStateInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryStateInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'country', Class: statecountryinfo.StateCountryInfo, isArray: false, isRequired: false },
	            { property: 'isoCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryStateInfo.prototype.getClassName = function () {
	        return 'DictionaryStateInfo';
	    };
	    return DictionaryStateInfo;
	}(model.Model));
	exports.DictionaryStateInfo = DictionaryStateInfo;
	
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var StateCountryInfo = (function (_super) {
	    __extends(StateCountryInfo, _super);
	    function StateCountryInfo() {
	        _super.apply(this, arguments);
	    }
	    StateCountryInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    StateCountryInfo.prototype.getClassName = function () {
	        return 'StateCountryInfo';
	    };
	    return StateCountryInfo;
	}(model.Model));
	exports.StateCountryInfo = StateCountryInfo;
	
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var dictionarytimezoneinfo = __webpack_require__(69);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DictionaryTimezoneList = (function (_super) {
	    __extends(DictionaryTimezoneList, _super);
	    function DictionaryTimezoneList() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: dictionarytimezoneinfo.DictionaryTimezoneInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DictionaryTimezoneList.prototype.getClassName = function () {
	        return 'DictionaryTimezoneList';
	    };
	    return DictionaryTimezoneList;
	}(model.Model));
	exports.DictionaryTimezoneList = DictionaryTimezoneList;
	
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var DictionaryTimezoneInfo = (function (_super) {
	    __extends(DictionaryTimezoneInfo, _super);
	    function DictionaryTimezoneInfo() {
	        _super.apply(this, arguments);
	    }
	    DictionaryTimezoneInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'description', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    DictionaryTimezoneInfo.prototype.getClassName = function () {
	        return 'DictionaryTimezoneInfo';
	    };
	    return DictionaryTimezoneInfo;
	}(model.Model));
	exports.DictionaryTimezoneInfo = DictionaryTimezoneInfo;
	
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionlist = __webpack_require__(71);
	var extensioninfo = __webpack_require__(6);
	var extensionphonenumbers = __webpack_require__(72);
	var extensiongrantlist = __webpack_require__(73);
	var departmentmembers = __webpack_require__(76);
	var Extension = (function (_super) {
	    __extends(Extension, _super);
	    function Extension() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension List
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns the list of extensions created for a particular account. All types of extensions are included in this list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.listExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension', options, exports.listExtensionsOptions), extensionlist.ExtensionList);
	    };
	    /**
	     * Get Extension Info
	     *
	     * <p style='font-style:italic;'>Since 1.0.0</p>
	     * <p>Returns basic information about a particular extension of an account.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.loadExtensionInfo = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}', options, exports.loadExtensionInfoOptions), extensioninfo.ExtensionInfo);
	    };
	    /**
	     * Get Extension Phone Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers that are used by a particular extension, and can be filtered by the phone number type. The returned list contains all numbers which are directly mapped to a given extension plus the features and also company-level numbers
	     *     which may be used when performing different operations on behalf of this extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionPhoneNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/phone-number', options, exports.listExtensionPhoneNumbersOptions), extensionphonenumbers.ExtensionPhoneNumbers);
	    };
	    /**
	     * Get Extension Grant List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the list of extension grants.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listExtensionGrants = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/grant', options, exports.listExtensionGrantsOptions), extensiongrantlist.ExtensionGrantList);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.loadExtensionProfileImageOptions), null);
	    };
	    /**
	     * Create Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.createExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.createExtensionProfileImageOptions), null);
	    };
	    /**
	     * Update Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Updates the extension profile image.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>High</p>
	     */
	    Extension.prototype.updateExtensionProfileImage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image', options, exports.updateExtensionProfileImageOptions), null);
	    };
	    /**
	     * Get Extension Profile Image
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Returns the scaled profile image of an extension.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Extension.prototype.loadExtensionScaledProfileImage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/profile-image/{scaleSize}', options, exports.loadExtensionScaledProfileImageOptions), null);
	    };
	    /**
	     * Get Department Member List
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Extension.prototype.listDepartmentMembers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/department/{departmentId}/members', options, exports.listDepartmentMembersOptions), departmentmembers.DepartmentMembers);
	    };
	    return Extension;
	}(client.Client));
	exports.Extension = Extension;
	/**
	 * Definition of options for listExtensions operation
	 */
	exports.listExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "status",
	        "type": "IListExtensionsStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Enabled",
	            "Disabled",
	            "NotActivated",
	            "Unassigned"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "type",
	        "type": "IListExtensionsType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "User",
	            "FaxUser",
	            "VirtualUser",
	            "DigitalUser",
	            "Department",
	            "Announcement",
	            "Voicemail",
	            "SharedLinesGroup",
	            "PagingOnlyGroup",
	            "IvrMenu",
	            "ApplicationExtension",
	            "ParkLocation"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionInfo operation
	 */
	exports.loadExtensionInfoOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listExtensionPhoneNumbers operation
	 */
	exports.listExtensionPhoneNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "usageType",
	        "type": "IListExtensionPhoneNumbersUsageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "MainCompanyNumber",
	            "AdditionalCompanyNumber",
	            "CompanyNumber",
	            "DirectNumber",
	            "CompanyFaxNumber",
	            "ForwardedNumber"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for listExtensionGrants operation
	 */
	exports.listExtensionGrantsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadExtensionProfileImage operation
	 */
	exports.loadExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for createExtensionProfileImage operation
	 */
	exports.createExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for updateExtensionProfileImage operation
	 */
	exports.updateExtensionProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadExtensionScaledProfileImage operation
	 */
	exports.loadExtensionScaledProfileImageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "scaleSize",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for listDepartmentMembers operation
	 */
	exports.listDepartmentMembersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "departmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListExtensionsStatus) {
	    IListExtensionsStatus[IListExtensionsStatus["Enabled"] = 'Enabled'] = "Enabled";
	    IListExtensionsStatus[IListExtensionsStatus["Disabled"] = 'Disabled'] = "Disabled";
	    IListExtensionsStatus[IListExtensionsStatus["NotActivated"] = 'NotActivated'] = "NotActivated";
	    IListExtensionsStatus[IListExtensionsStatus["Unassigned"] = 'Unassigned'] = "Unassigned";
	})(exports.IListExtensionsStatus || (exports.IListExtensionsStatus = {}));
	var IListExtensionsStatus = exports.IListExtensionsStatus;
	(function (IListExtensionsType) {
	    IListExtensionsType[IListExtensionsType["User"] = 'User'] = "User";
	    IListExtensionsType[IListExtensionsType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    IListExtensionsType[IListExtensionsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    IListExtensionsType[IListExtensionsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    IListExtensionsType[IListExtensionsType["Department"] = 'Department'] = "Department";
	    IListExtensionsType[IListExtensionsType["Announcement"] = 'Announcement'] = "Announcement";
	    IListExtensionsType[IListExtensionsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    IListExtensionsType[IListExtensionsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    IListExtensionsType[IListExtensionsType["PagingOnlyGroup"] = 'PagingOnlyGroup'] = "PagingOnlyGroup";
	    IListExtensionsType[IListExtensionsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    IListExtensionsType[IListExtensionsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    IListExtensionsType[IListExtensionsType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.IListExtensionsType || (exports.IListExtensionsType = {}));
	var IListExtensionsType = exports.IListExtensionsType;
	(function (IListExtensionPhoneNumbersUsageType) {
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["MainCompanyNumber"] = 'MainCompanyNumber'] = "MainCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["AdditionalCompanyNumber"] = 'AdditionalCompanyNumber'] = "AdditionalCompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyNumber"] = 'CompanyNumber'] = "CompanyNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["DirectNumber"] = 'DirectNumber'] = "DirectNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["CompanyFaxNumber"] = 'CompanyFaxNumber'] = "CompanyFaxNumber";
	    IListExtensionPhoneNumbersUsageType[IListExtensionPhoneNumbersUsageType["ForwardedNumber"] = 'ForwardedNumber'] = "ForwardedNumber";
	})(exports.IListExtensionPhoneNumbersUsageType || (exports.IListExtensionPhoneNumbersUsageType = {}));
	var IListExtensionPhoneNumbersUsageType = exports.IListExtensionPhoneNumbersUsageType;
	
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionList = (function (_super) {
	    __extends(ExtensionList, _super);
	    function ExtensionList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionList.prototype.getClassName = function () {
	        return 'ExtensionList';
	    };
	    return ExtensionList;
	}(model.Model));
	exports.ExtensionList = ExtensionList;
	
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var phonenumberinfo = __webpack_require__(34);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionPhoneNumbers = (function (_super) {
	    __extends(ExtensionPhoneNumbers, _super);
	    function ExtensionPhoneNumbers() {
	        _super.apply(this, arguments);
	    }
	    ExtensionPhoneNumbers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: phonenumberinfo.PhoneNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionPhoneNumbers.prototype.getClassName = function () {
	        return 'ExtensionPhoneNumbers';
	    };
	    return ExtensionPhoneNumbers;
	}(model.Model));
	exports.ExtensionPhoneNumbers = ExtensionPhoneNumbers;
	
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var grantinfo = __webpack_require__(74);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionGrantList = (function (_super) {
	    __extends(ExtensionGrantList, _super);
	    function ExtensionGrantList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionGrantList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: grantinfo.GrantInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    ExtensionGrantList.prototype.getClassName = function () {
	        return 'ExtensionGrantList';
	    };
	    return ExtensionGrantList;
	}(model.Model));
	exports.ExtensionGrantList = ExtensionGrantList;
	
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfogrants = __webpack_require__(75);
	var GrantInfo = (function (_super) {
	    __extends(GrantInfo, _super);
	    function GrantInfo() {
	        _super.apply(this, arguments);
	    }
	    GrantInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: extensioninfogrants.ExtensionInfoGrants, isArray: false, isRequired: false },
	            { property: 'callPickup', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'callMonitoring', Class: null /* boolean */, isArray: false, isRequired: false }
	        ];
	    };
	    GrantInfo.prototype.getClassName = function () {
	        return 'GrantInfo';
	    };
	    return GrantInfo;
	}(model.Model));
	exports.GrantInfo = GrantInfo;
	
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ExtensionInfoGrants = (function (_super) {
	    __extends(ExtensionInfoGrants, _super);
	    function ExtensionInfoGrants() {
	        _super.apply(this, arguments);
	    }
	    ExtensionInfoGrants.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: ExtensionInfoGrantsType, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionInfoGrants.prototype.getClassName = function () {
	        return 'ExtensionInfoGrants';
	    };
	    return ExtensionInfoGrants;
	}(model.Model));
	exports.ExtensionInfoGrants = ExtensionInfoGrants;
	(function (ExtensionInfoGrantsType) {
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["User"] = 'User'] = "User";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["FaxUser"] = 'Fax User'] = "FaxUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Department"] = 'Department'] = "Department";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Announcement"] = 'Announcement'] = "Announcement";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["Voicemail"] = 'Voicemail'] = "Voicemail";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["SharedLinesGroup"] = 'SharedLinesGroup'] = "SharedLinesGroup";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["PagingOnly"] = 'PagingOnly'] = "PagingOnly";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["IvrMenu"] = 'IvrMenu'] = "IvrMenu";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    ExtensionInfoGrantsType[ExtensionInfoGrantsType["ParkLocation"] = 'Park Location'] = "ParkLocation";
	})(exports.ExtensionInfoGrantsType || (exports.ExtensionInfoGrantsType = {}));
	var ExtensionInfoGrantsType = exports.ExtensionInfoGrantsType;
	
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var extensioninfo = __webpack_require__(6);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var DepartmentMembers = (function (_super) {
	    __extends(DepartmentMembers, _super);
	    function DepartmentMembers() {
	        _super.apply(this, arguments);
	    }
	    DepartmentMembers.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: extensioninfo.ExtensionInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    DepartmentMembers.prototype.getClassName = function () {
	        return 'DepartmentMembers';
	    };
	    return DepartmentMembers;
	}(model.Model));
	exports.DepartmentMembers = DepartmentMembers;
	
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var messageinfo = __webpack_require__(78);
	var messagelist = __webpack_require__(81);
	var messagesync = __webpack_require__(82);
	var Messages = (function (_super) {
	    __extends(Messages, _super);
	    function Messages() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Pager Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends a pager message.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>InternalMessages</td>
	     *             <td>Sending and receiving intra-company text messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendInternalMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/company-pager', options, exports.sendInternalMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create Fax Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends/resends new fax message. Resend can be done if sending failed.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>Faxes</td>
	     *             <td>Sending and receiving faxes</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    Messages.prototype.sendFaxMessage = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/fax', options, exports.sendFaxMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Create SMS Message
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Creates and sends new SMS message. Sending SMS messages simultaneously to different recipients is limited up to 50 requests per minute; relevant for all client applications.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>SMS</td>
	     *             <td>Sending and receiving SMS (text) messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.sendSMS = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/sms', options, exports.sendSMSOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Get Message List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of messages from an extension mailbox.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.listMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store', options, exports.listMessagesOptions), messagelist.MessageList);
	    };
	    /**
	     * Get Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns individual message record(s) by the given message ID(s). The length of inbound messages is unlimited. Batch request is supported, see Batch Requests for details.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.loadMessage = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.loadMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Update Message(s) by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Updates message(s) by ID(s). Batch request is supported, see Batch Requests for details. Currently, only the message read status updating is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.updateMessage = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.updateMessageOptions), messageinfo.MessageInfo);
	    };
	    /**
	     * Delete Message(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Deletes message(s) by the given message ID(s). The first call of this method transfers the message to the 'Delete' status. The second call transfers the deleted message to the 'Purged' status. If it is required to make the message 'Purged' immediately
	     *     (from the first call), then set the query parameter purge to 'True'. Batch request is supported.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditMessages</td>
	     *             <td>Viewing and updating user messages</td>
	     *         </tr>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.deleteMessage = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}', options, exports.deleteMessageOptions), null);
	    };
	    /**
	     * Get Message Attachment
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Returns particular message attachment data as a media stream.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    Messages.prototype.loadMessageAttachment = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-store/{messageId}/content/{attachmentId}', options, exports.loadMessageAttachmentOptions), null);
	    };
	    /**
	     * Get Message Sync
	     *
	     * <p style='font-style:italic;'>Since 1.0.4 (Release 5.13)</p>
	     * <p>Provides facilities to synchronize mailbox content stored externally with server state.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadMessages</td>
	     *             <td>Viewing user messages</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Messages.prototype.syncMessages = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/message-sync', options, exports.syncMessagesOptions), messagesync.MessageSync);
	    };
	    return Messages;
	}(client.Client));
	exports.Messages = Messages;
	/**
	 * Definition of options for sendInternalMessage operation
	 */
	exports.sendInternalMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createpagermessagerequest.CreatePagerMessageRequest"
	    }
	];
	/**
	 * Definition of options for sendFaxMessage operation
	 */
	exports.sendFaxMessageOptions = [
	    {
	        "name": "accountId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "extensionId",
	        "in": "path",
	        "notes": "",
	        "paramType": "path",
	        "defaultValue": "~",
	        "required": true,
	        "allowMultiple": false,
	        "type": "string"
	    },
	    {
	        "name": "Content-Type",
	        "in": "header",
	        "default": "multipart/mixed; boundary=Boundary_1_14413901_1361871080888",
	        "type": "string"
	    },
	    {
	        "name": "Content-Length",
	        "in": "header",
	        "default": "",
	        "type": "string"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "consumes": [
	            "multipart/mixed; boundary=Boundary_1_14413901_1361871080888"
	        ],
	        "default": "--Boundary_1_14413901_1361871080888\nContent-Type: application/json\n\n{\n  \"to\":[{\"phoneNumber\":\"18005630003\"}],\n  \"faxResolution\":\"High\",\n  \"sendTime\":\"2013-02-26T09:31:20.882Z\"\n}\n\n--Boundary_1_14413901_1361871080888\nContent-Type: text/plain\n\nHello, World!\n\n--Boundary_1_14413901_1361871080888--",
	        "type": "string"
	    }
	];
	/**
	 * Definition of options for sendSMS operation
	 */
	exports.sendSMSOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createsmsmessage.CreateSMSMessage"
	    }
	];
	/**
	 * Definition of options for listMessages operation
	 */
	exports.listMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "availability",
	        "type": "IListMessagesAvailability",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Alive",
	            "Deleted",
	            "Purged"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "IListMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "IListMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "readStatus",
	        "type": "IListMessagesReadStatus",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Read",
	            "Unread"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "phoneNumber",
	        "type": "string",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessage operation
	 */
	exports.loadMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "number",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateMessage operation
	 */
	exports.updateMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updatemessagerequest.UpdateMessageRequest"
	    }
	];
	/**
	 * Definition of options for deleteMessage operation
	 */
	exports.deleteMessageOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "purge",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for loadMessageAttachment operation
	 */
	exports.loadMessageAttachmentOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "attachmentId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "messageId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for syncMessages operation
	 */
	exports.syncMessagesOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "conversationId",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateFrom",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "dateTo",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "direction",
	        "type": "ISyncMessagesDirection",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Inbound",
	            "Outbound"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "distinctConversations",
	        "type": "boolean",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "messageType",
	        "type": "ISyncMessagesMessageType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "Fax",
	            "SMS",
	            "VoiceMail",
	            "Pager",
	            "Text"
	        ],
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "recordCount",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncToken",
	        "type": "string",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "syncType",
	        "type": "ISyncMessagesSyncType",
	        "items": {
	            "type": "string"
	        },
	        "collectionFormat": "multi",
	        "allowEmptyValue": true,
	        "enum": [
	            "FSync",
	            "ISync"
	        ],
	        "in": "query",
	        "required": false
	    }
	];
	(function (IListMessagesAvailability) {
	    IListMessagesAvailability[IListMessagesAvailability["Alive"] = 'Alive'] = "Alive";
	    IListMessagesAvailability[IListMessagesAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    IListMessagesAvailability[IListMessagesAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.IListMessagesAvailability || (exports.IListMessagesAvailability = {}));
	var IListMessagesAvailability = exports.IListMessagesAvailability;
	(function (IListMessagesDirection) {
	    IListMessagesDirection[IListMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    IListMessagesDirection[IListMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.IListMessagesDirection || (exports.IListMessagesDirection = {}));
	var IListMessagesDirection = exports.IListMessagesDirection;
	(function (IListMessagesMessageType) {
	    IListMessagesMessageType[IListMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    IListMessagesMessageType[IListMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    IListMessagesMessageType[IListMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    IListMessagesMessageType[IListMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    IListMessagesMessageType[IListMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.IListMessagesMessageType || (exports.IListMessagesMessageType = {}));
	var IListMessagesMessageType = exports.IListMessagesMessageType;
	(function (IListMessagesReadStatus) {
	    IListMessagesReadStatus[IListMessagesReadStatus["Read"] = 'Read'] = "Read";
	    IListMessagesReadStatus[IListMessagesReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.IListMessagesReadStatus || (exports.IListMessagesReadStatus = {}));
	var IListMessagesReadStatus = exports.IListMessagesReadStatus;
	(function (ISyncMessagesDirection) {
	    ISyncMessagesDirection[ISyncMessagesDirection["Inbound"] = 'Inbound'] = "Inbound";
	    ISyncMessagesDirection[ISyncMessagesDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.ISyncMessagesDirection || (exports.ISyncMessagesDirection = {}));
	var ISyncMessagesDirection = exports.ISyncMessagesDirection;
	(function (ISyncMessagesMessageType) {
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Fax"] = 'Fax'] = "Fax";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["SMS"] = 'SMS'] = "SMS";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Pager"] = 'Pager'] = "Pager";
	    ISyncMessagesMessageType[ISyncMessagesMessageType["Text"] = 'Text'] = "Text";
	})(exports.ISyncMessagesMessageType || (exports.ISyncMessagesMessageType = {}));
	var ISyncMessagesMessageType = exports.ISyncMessagesMessageType;
	(function (ISyncMessagesSyncType) {
	    ISyncMessagesSyncType[ISyncMessagesSyncType["FSync"] = 'FSync'] = "FSync";
	    ISyncMessagesSyncType[ISyncMessagesSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.ISyncMessagesSyncType || (exports.ISyncMessagesSyncType = {}));
	var ISyncMessagesSyncType = exports.ISyncMessagesSyncType;
	
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageattachmentinfo = __webpack_require__(79);
	var messagestorecallerinfo = __webpack_require__(80);
	var MessageInfo = (function (_super) {
	    __extends(MessageInfo, _super);
	    function MessageInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'attachments', Class: messageattachmentinfo.MessageAttachmentInfo, isArray: true, isRequired: false },
	            { property: 'availability', Class: MessageInfoAvailability, isArray: false, isRequired: false },
	            { property: 'conversationId', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryErrorCode', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'direction', Class: MessageInfoDirection, isArray: false, isRequired: false },
	            { property: 'faxPageCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'faxResolution', Class: MessageInfoFaxResolution, isArray: false, isRequired: false },
	            { property: 'from', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: false, isRequired: false },
	            { property: 'lastModifiedTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'pgToDepartment', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'priority', Class: MessageInfoPriority, isArray: false, isRequired: false },
	            { property: 'readStatus', Class: MessageInfoReadStatus, isArray: false, isRequired: false },
	            { property: 'smsDeliveryTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'smsSendingAttemptsCount', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'subject', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'to', Class: messagestorecallerinfo.MessageStoreCallerInfo, isArray: true, isRequired: false },
	            { property: 'type', Class: MessageInfoType, isArray: false, isRequired: false },
	            { property: 'vmTranscriptionStatus', Class: MessageInfoVmTranscriptionStatus, isArray: false, isRequired: false }
	        ];
	    };
	    MessageInfo.prototype.getClassName = function () {
	        return 'MessageInfo';
	    };
	    return MessageInfo;
	}(model.Model));
	exports.MessageInfo = MessageInfo;
	(function (MessageInfoAvailability) {
	    MessageInfoAvailability[MessageInfoAvailability["Alive"] = 'Alive'] = "Alive";
	    MessageInfoAvailability[MessageInfoAvailability["Deleted"] = 'Deleted'] = "Deleted";
	    MessageInfoAvailability[MessageInfoAvailability["Purged"] = 'Purged'] = "Purged";
	})(exports.MessageInfoAvailability || (exports.MessageInfoAvailability = {}));
	var MessageInfoAvailability = exports.MessageInfoAvailability;
	(function (MessageInfoDirection) {
	    MessageInfoDirection[MessageInfoDirection["Inbound"] = 'Inbound'] = "Inbound";
	    MessageInfoDirection[MessageInfoDirection["Outbound"] = 'Outbound'] = "Outbound";
	})(exports.MessageInfoDirection || (exports.MessageInfoDirection = {}));
	var MessageInfoDirection = exports.MessageInfoDirection;
	(function (MessageInfoFaxResolution) {
	    MessageInfoFaxResolution[MessageInfoFaxResolution["High"] = 'High'] = "High";
	    MessageInfoFaxResolution[MessageInfoFaxResolution["Low"] = 'Low'] = "Low";
	})(exports.MessageInfoFaxResolution || (exports.MessageInfoFaxResolution = {}));
	var MessageInfoFaxResolution = exports.MessageInfoFaxResolution;
	(function (MessageInfoMessageStatus) {
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageInfoMessageStatus[MessageInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageInfoMessageStatus || (exports.MessageInfoMessageStatus = {}));
	var MessageInfoMessageStatus = exports.MessageInfoMessageStatus;
	(function (MessageInfoPriority) {
	    MessageInfoPriority[MessageInfoPriority["Normal"] = 'Normal'] = "Normal";
	    MessageInfoPriority[MessageInfoPriority["High"] = 'High'] = "High";
	})(exports.MessageInfoPriority || (exports.MessageInfoPriority = {}));
	var MessageInfoPriority = exports.MessageInfoPriority;
	(function (MessageInfoReadStatus) {
	    MessageInfoReadStatus[MessageInfoReadStatus["Read"] = 'Read'] = "Read";
	    MessageInfoReadStatus[MessageInfoReadStatus["Unread"] = 'Unread'] = "Unread";
	})(exports.MessageInfoReadStatus || (exports.MessageInfoReadStatus = {}));
	var MessageInfoReadStatus = exports.MessageInfoReadStatus;
	(function (MessageInfoType) {
	    MessageInfoType[MessageInfoType["Fax"] = 'Fax'] = "Fax";
	    MessageInfoType[MessageInfoType["SMS"] = 'SMS'] = "SMS";
	    MessageInfoType[MessageInfoType["VoiceMail"] = 'VoiceMail'] = "VoiceMail";
	    MessageInfoType[MessageInfoType["Pager"] = 'Pager'] = "Pager";
	    MessageInfoType[MessageInfoType["Text"] = 'Text'] = "Text";
	})(exports.MessageInfoType || (exports.MessageInfoType = {}));
	var MessageInfoType = exports.MessageInfoType;
	(function (MessageInfoVmTranscriptionStatus) {
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["NotAvailable"] = 'NotAvailable'] = "NotAvailable";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["InProgress"] = 'InProgress'] = "InProgress";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["TimedOut"] = 'TimedOut'] = "TimedOut";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Completed"] = 'Completed'] = "Completed";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["CompletedPartially"] = 'CompletedPartially'] = "CompletedPartially";
	    MessageInfoVmTranscriptionStatus[MessageInfoVmTranscriptionStatus["Failed"] = 'Failed'] = "Failed";
	})(exports.MessageInfoVmTranscriptionStatus || (exports.MessageInfoVmTranscriptionStatus = {}));
	var MessageInfoVmTranscriptionStatus = exports.MessageInfoVmTranscriptionStatus;
	
	
	/***/ },
	/* 79 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageAttachmentInfo = (function (_super) {
	    __extends(MessageAttachmentInfo, _super);
	    function MessageAttachmentInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageAttachmentInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MessageAttachmentInfoType, isArray: false, isRequired: false },
	            { property: 'contentType', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'vmDuration', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageAttachmentInfo.prototype.getClassName = function () {
	        return 'MessageAttachmentInfo';
	    };
	    return MessageAttachmentInfo;
	}(model.Model));
	exports.MessageAttachmentInfo = MessageAttachmentInfo;
	(function (MessageAttachmentInfoType) {
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioRecording"] = 'AudioRecording'] = "AudioRecording";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["AudioTranscription"] = 'AudioTranscription'] = "AudioTranscription";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["Text"] = 'Text'] = "Text";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["SourceDocument"] = 'SourceDocument'] = "SourceDocument";
	    MessageAttachmentInfoType[MessageAttachmentInfoType["RenderedDocument"] = 'RenderedDocument'] = "RenderedDocument";
	})(exports.MessageAttachmentInfoType || (exports.MessageAttachmentInfoType = {}));
	var MessageAttachmentInfoType = exports.MessageAttachmentInfoType;
	
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessageStoreCallerInfo = (function (_super) {
	    __extends(MessageStoreCallerInfo, _super);
	    function MessageStoreCallerInfo() {
	        _super.apply(this, arguments);
	    }
	    MessageStoreCallerInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'location', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'messageStatus', Class: MessageStoreCallerInfoMessageStatus, isArray: false, isRequired: false },
	            { property: 'faxErrorCode', Class: MessageStoreCallerInfoFaxErrorCode, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessageStoreCallerInfo.prototype.getClassName = function () {
	        return 'MessageStoreCallerInfo';
	    };
	    return MessageStoreCallerInfo;
	}(model.Model));
	exports.MessageStoreCallerInfo = MessageStoreCallerInfo;
	(function (MessageStoreCallerInfoMessageStatus) {
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Queued"] = 'Queued'] = "Queued";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Sent"] = 'Sent'] = "Sent";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Delivered"] = 'Delivered'] = "Delivered";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["DeliveryFailed"] = 'DeliveryFailed'] = "DeliveryFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["SendingFailed"] = 'SendingFailed'] = "SendingFailed";
	    MessageStoreCallerInfoMessageStatus[MessageStoreCallerInfoMessageStatus["Received"] = 'Received'] = "Received";
	})(exports.MessageStoreCallerInfoMessageStatus || (exports.MessageStoreCallerInfoMessageStatus = {}));
	var MessageStoreCallerInfoMessageStatus = exports.MessageStoreCallerInfoMessageStatus;
	(function (MessageStoreCallerInfoFaxErrorCode) {
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["Undefined"] = 'Undefined'] = "Undefined";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxSendPermission"] = 'NoFaxSendPermission'] = "NoFaxSendPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoInternationalPermission"] = 'NoInternationalPermission'] = "NoInternationalPermission";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoFaxMachine"] = 'NoFaxMachine'] = "NoFaxMachine";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["OutgoingCallError"] = 'OutgoingCallError'] = "OutgoingCallError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["RenderingFailed"] = 'RenderingFailed'] = "RenderingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["TooManyPages"] = 'TooManyPages'] = "TooManyPages";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ReturnToDBQueue"] = 'ReturnToDBQueue'] = "ReturnToDBQueue";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["NoCallTime"] = 'NoCallTime'] = "NoCallTime";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["WrongNumber"] = 'WrongNumber'] = "WrongNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedNumber"] = 'ProhibitedNumber'] = "ProhibitedNumber";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternalError"] = 'InternalError'] = "InternalError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["FaxSendingProhibited"] = 'FaxSendingProhibited'] = "FaxSendingProhibited";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ThePhoneIsBlacklisted"] = 'ThePhoneIsBlacklisted'] = "ThePhoneIsBlacklisted";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["UserNotFound"] = 'UserNotFound'] = "UserNotFound";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ConvertError"] = 'ConvertError'] = "ConvertError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["DBGeneralError"] = 'DBGeneralError'] = "DBGeneralError";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["SkypeBillingFailed"] = 'SkypeBillingFailed'] = "SkypeBillingFailed";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["AccountSuspended"] = 'AccountSuspended'] = "AccountSuspended";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["ProhibitedDestination"] = 'ProhibitedDestination'] = "ProhibitedDestination";
	    MessageStoreCallerInfoFaxErrorCode[MessageStoreCallerInfoFaxErrorCode["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	})(exports.MessageStoreCallerInfoFaxErrorCode || (exports.MessageStoreCallerInfoFaxErrorCode = {}));
	var MessageStoreCallerInfoFaxErrorCode = exports.MessageStoreCallerInfoFaxErrorCode;
	
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MessageList = (function (_super) {
	    __extends(MessageList, _super);
	    function MessageList() {
	        _super.apply(this, arguments);
	    }
	    MessageList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageList.prototype.getClassName = function () {
	        return 'MessageList';
	    };
	    return MessageList;
	}(model.Model));
	exports.MessageList = MessageList;
	
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var messageinfo = __webpack_require__(78);
	var messagessyncinfo = __webpack_require__(83);
	var MessageSync = (function (_super) {
	    __extends(MessageSync, _super);
	    function MessageSync() {
	        _super.apply(this, arguments);
	    }
	    MessageSync.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: messageinfo.MessageInfo, isArray: true, isRequired: true },
	            { property: 'syncInfo', Class: messagessyncinfo.MessagesSyncInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MessageSync.prototype.getClassName = function () {
	        return 'MessageSync';
	    };
	    return MessageSync;
	}(model.Model));
	exports.MessageSync = MessageSync;
	
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MessagesSyncInfo = (function (_super) {
	    __extends(MessagesSyncInfo, _super);
	    function MessagesSyncInfo() {
	        _super.apply(this, arguments);
	    }
	    MessagesSyncInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'syncType', Class: MessagesSyncInfoSyncType, isArray: false, isRequired: false },
	            { property: 'syncToken', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'syncTime', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    MessagesSyncInfo.prototype.getClassName = function () {
	        return 'MessagesSyncInfo';
	    };
	    return MessagesSyncInfo;
	}(model.Model));
	exports.MessagesSyncInfo = MessagesSyncInfo;
	(function (MessagesSyncInfoSyncType) {
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["FSync"] = 'FSync'] = "FSync";
	    MessagesSyncInfoSyncType[MessagesSyncInfoSyncType["ISync"] = 'ISync'] = "ISync";
	})(exports.MessagesSyncInfoSyncType || (exports.MessagesSyncInfoSyncType = {}));
	var MessagesSyncInfoSyncType = exports.MessagesSyncInfoSyncType;
	
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var getsubscriptioninforesponse = __webpack_require__(85);
	var NotificationsSubscriptionAPI = (function (_super) {
	    __extends(NotificationsSubscriptionAPI, _super);
	    function NotificationsSubscriptionAPI() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Create Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Creates a new subscription. To call this method with APNS transport type you have to specify endpoint_id attribute in get token request at authorization.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.create = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/subscription', options, exports.createOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Get Subscription
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>Returns the requested subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Light</p>
	     */
	    NotificationsSubscriptionAPI.prototype.load = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.loadOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Renew Subscription / Modify Event Filters
	     *
	     * <p style='font-style:italic;'>Since 1.0.6 (Release 5.15)</p>
	     * <p>With empty request body - renews the existent subscription. If event filters specified - modifies the event filters for the existing subscription. The client application can extend or narrow the events for which it receives notifications in the frame
	     *     of one subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.update = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.updateOptions), getsubscriptioninforesponse.GetSubscriptionInfoResponse);
	    };
	    /**
	     * Cancel Subscription
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the existent subscription.</p>
	     * <h4>Usage Plan Group</h4>
	     * <p>Medium</p>
	     */
	    NotificationsSubscriptionAPI.prototype.remove = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/subscription/{subscriptionId}', options, exports.removeOptions), null);
	    };
	    return NotificationsSubscriptionAPI;
	}(client.Client));
	exports.NotificationsSubscriptionAPI = NotificationsSubscriptionAPI;
	/**
	 * Definition of options for create operation
	 */
	exports.createOptions = [
	    {
	        "name": "body",
	        "type": "createsubscriptionrequest.CreateSubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for load operation
	 */
	exports.loadOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for update operation
	 */
	exports.updateOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "type": "modifysubscriptionrequest.ModifySubscriptionRequest",
	        "in": "body",
	        "required": true
	    }
	];
	/**
	 * Definition of options for remove operation
	 */
	exports.removeOptions = [
	    {
	        "name": "subscriptionId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var notificationdeliverymode = __webpack_require__(86);
	var GetSubscriptionInfoResponse = (function (_super) {
	    __extends(GetSubscriptionInfoResponse, _super);
	    function GetSubscriptionInfoResponse() {
	        _super.apply(this, arguments);
	    }
	    GetSubscriptionInfoResponse.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'eventFilters', Class: null /* string[] */, isArray: true, isRequired: false },
	            { property: 'expirationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'expiresIn', Class: null /* number */, isArray: false, isRequired: false },
	            { property: 'status', Class: GetSubscriptionInfoResponseStatus, isArray: false, isRequired: false },
	            { property: 'creationTime', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'deliveryMode', Class: notificationdeliverymode.NotificationDeliveryMode, isArray: false, isRequired: true }
	        ];
	    };
	    GetSubscriptionInfoResponse.prototype.getClassName = function () {
	        return 'GetSubscriptionInfoResponse';
	    };
	    return GetSubscriptionInfoResponse;
	}(model.Model));
	exports.GetSubscriptionInfoResponse = GetSubscriptionInfoResponse;
	(function (GetSubscriptionInfoResponseStatus) {
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Active"] = 'Active'] = "Active";
	    GetSubscriptionInfoResponseStatus[GetSubscriptionInfoResponseStatus["Suspended"] = 'Suspended'] = "Suspended";
	})(exports.GetSubscriptionInfoResponseStatus || (exports.GetSubscriptionInfoResponseStatus = {}));
	var GetSubscriptionInfoResponseStatus = exports.GetSubscriptionInfoResponseStatus;
	
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var NotificationDeliveryMode = (function (_super) {
	    __extends(NotificationDeliveryMode, _super);
	    function NotificationDeliveryMode() {
	        _super.apply(this, arguments);
	    }
	    NotificationDeliveryMode.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'transportType', Class: NotificationDeliveryModeTransportType, isArray: false, isRequired: true },
	            { property: 'encryption', Class: null /* boolean */, isArray: false, isRequired: true },
	            { property: 'address', Class: null /* string */, isArray: false, isRequired: true },
	            { property: 'subscriberKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionAlgorithm', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'encryptionKey', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'registrationId', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'certificateName', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    NotificationDeliveryMode.prototype.getClassName = function () {
	        return 'NotificationDeliveryMode';
	    };
	    return NotificationDeliveryMode;
	}(model.Model));
	exports.NotificationDeliveryMode = NotificationDeliveryMode;
	(function (NotificationDeliveryModeTransportType) {
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["PubNub"] = 'PubNub'] = "PubNub";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["APNS"] = 'APNS'] = "APNS";
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType['PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP'] = 'PubNub/APNS/VoIP';
	    NotificationDeliveryModeTransportType[NotificationDeliveryModeTransportType["WebHook"] = 'WebHook'] = "WebHook";
	})(exports.NotificationDeliveryModeTransportType || (exports.NotificationDeliveryModeTransportType = {}));
	var NotificationDeliveryModeTransportType = exports.NotificationDeliveryModeTransportType;
	
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var presenceinfo = __webpack_require__(88);
	var monitoredextensions = __webpack_require__(90);
	var Presence = (function (_super) {
	    __extends(Presence, _super);
	    function Presence() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension(s) Presence Status by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns presence status of an extension or several extensions by their ID(s). Batch request is supported, see Batch Requests for details.The presenceStatus is returned as Offline (the parameters telephonyStatus, message, userStatus and dndStatus are not
	     *     returned at all) for the following extension types: Department/Announcement Only/Take Messages Only (Voicemail)/Fax User/Paging Only Group/Shared Lines Group/IVR Menu/Application Extension/Park Location.If the user requests his/her own presence status,
	     *     the response contains actual presence status even if the status publication is turned off.Batch request is supported. For batch requests the number of extensions in one request is limited to 30. If more extensions are included in the request, the
	     *     error code 400 Bad Request is returned with the logical error code InvalidMultipartRequest and the corresponding message 'Extension Presence Info multipart request is limited to 30 extensions'.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.getPresenceStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence', options, exports.getPresenceStatusOptions), presenceinfo.PresenceInfo);
	    };
	    /**
	     * Get Monitored Extensions
	     *
	     * <p style='font-style:italic;'>Since 1.0.13 (Release 6.5)</p>
	     * <p>Returns list of lines - extensions which presence status can be indicated and monitored on BLF-enabled (Busy Lamp Field) devices.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadPresence</td>
	     *             <td>Getting user presence information</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    Presence.prototype.listMonitoredExtensions = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/presence/line', options, exports.listMonitoredExtensionsOptions), monitoredextensions.MonitoredExtensions);
	    };
	    return Presence;
	}(client.Client));
	exports.Presence = Presence;
	/**
	 * Definition of options for getPresenceStatus operation
	 */
	exports.getPresenceStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listMonitoredExtensions operation
	 */
	exports.listMonitoredExtensionsOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var presenceextensioninfo = __webpack_require__(89);
	var PresenceInfo = (function (_super) {
	    __extends(PresenceInfo, _super);
	    function PresenceInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'allowSeeMyPresence', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'dndStatus', Class: PresenceInfoDndStatus, isArray: false, isRequired: false },
	            { property: 'extension', Class: presenceextensioninfo.PresenceExtensionInfo, isArray: false, isRequired: false },
	            { property: 'message', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'pickUpCallsOnHold', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'presenceStatus', Class: PresenceInfoPresenceStatus, isArray: false, isRequired: false },
	            { property: 'ringOnMonitoredCall', Class: null /* boolean */, isArray: false, isRequired: false },
	            { property: 'telephonyStatus', Class: PresenceInfoTelephonyStatus, isArray: false, isRequired: false },
	            { property: 'userStatus', Class: PresenceInfoUserStatus, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceInfo.prototype.getClassName = function () {
	        return 'PresenceInfo';
	    };
	    return PresenceInfo;
	}(model.Model));
	exports.PresenceInfo = PresenceInfo;
	(function (PresenceInfoDndStatus) {
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeAllCalls"] = 'TakeAllCalls'] = "TakeAllCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptAnyCalls"] = 'DoNotAcceptAnyCalls'] = "DoNotAcceptAnyCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["DoNotAcceptDepartmentCalls"] = 'DoNotAcceptDepartmentCalls'] = "DoNotAcceptDepartmentCalls";
	    PresenceInfoDndStatus[PresenceInfoDndStatus["TakeDepartmentCallsOnly"] = 'TakeDepartmentCallsOnly'] = "TakeDepartmentCallsOnly";
	})(exports.PresenceInfoDndStatus || (exports.PresenceInfoDndStatus = {}));
	var PresenceInfoDndStatus = exports.PresenceInfoDndStatus;
	(function (PresenceInfoPresenceStatus) {
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoPresenceStatus[PresenceInfoPresenceStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoPresenceStatus || (exports.PresenceInfoPresenceStatus = {}));
	var PresenceInfoPresenceStatus = exports.PresenceInfoPresenceStatus;
	(function (PresenceInfoTelephonyStatus) {
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["NoCall"] = 'NoCall'] = "NoCall";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["CallConnected"] = 'CallConnected'] = "CallConnected";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["Ringing"] = 'Ringing'] = "Ringing";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["OnHold"] = 'OnHold'] = "OnHold";
	    PresenceInfoTelephonyStatus[PresenceInfoTelephonyStatus["ParkedCall"] = 'ParkedCall'] = "ParkedCall";
	})(exports.PresenceInfoTelephonyStatus || (exports.PresenceInfoTelephonyStatus = {}));
	var PresenceInfoTelephonyStatus = exports.PresenceInfoTelephonyStatus;
	(function (PresenceInfoUserStatus) {
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Offline"] = 'Offline'] = "Offline";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Busy"] = 'Busy'] = "Busy";
	    PresenceInfoUserStatus[PresenceInfoUserStatus["Available"] = 'Available'] = "Available";
	})(exports.PresenceInfoUserStatus || (exports.PresenceInfoUserStatus = {}));
	var PresenceInfoUserStatus = exports.PresenceInfoUserStatus;
	
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var PresenceExtensionInfo = (function (_super) {
	    __extends(PresenceExtensionInfo, _super);
	    function PresenceExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    PresenceExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    PresenceExtensionInfo.prototype.getClassName = function () {
	        return 'PresenceExtensionInfo';
	    };
	    return PresenceExtensionInfo;
	}(model.Model));
	exports.PresenceExtensionInfo = PresenceExtensionInfo;
	
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var lineinfo = __webpack_require__(91);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var MonitoredExtensions = (function (_super) {
	    __extends(MonitoredExtensions, _super);
	    function MonitoredExtensions() {
	        _super.apply(this, arguments);
	    }
	    MonitoredExtensions.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'records', Class: lineinfo.LineInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    MonitoredExtensions.prototype.getClassName = function () {
	        return 'MonitoredExtensions';
	    };
	    return MonitoredExtensions;
	}(model.Model));
	exports.MonitoredExtensions = MonitoredExtensions;
	
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var monitoredlinesextensioninfo = __webpack_require__(92);
	var LineInfo = (function (_super) {
	    __extends(LineInfo, _super);
	    function LineInfo() {
	        _super.apply(this, arguments);
	    }
	    LineInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extension', Class: monitoredlinesextensioninfo.MonitoredLinesExtensionInfo, isArray: false, isRequired: false }
	        ];
	    };
	    LineInfo.prototype.getClassName = function () {
	        return 'LineInfo';
	    };
	    return LineInfo;
	}(model.Model));
	exports.LineInfo = LineInfo;
	
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var MonitoredLinesExtensionInfo = (function (_super) {
	    __extends(MonitoredLinesExtensionInfo, _super);
	    function MonitoredLinesExtensionInfo() {
	        _super.apply(this, arguments);
	    }
	    MonitoredLinesExtensionInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'extensionNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'type', Class: MonitoredLinesExtensionInfoType, isArray: false, isRequired: false }
	        ];
	    };
	    MonitoredLinesExtensionInfo.prototype.getClassName = function () {
	        return 'MonitoredLinesExtensionInfo';
	    };
	    return MonitoredLinesExtensionInfo;
	}(model.Model));
	exports.MonitoredLinesExtensionInfo = MonitoredLinesExtensionInfo;
	(function (MonitoredLinesExtensionInfoType) {
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["User"] = 'User'] = "User";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["FaxUser"] = 'FaxUser'] = "FaxUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["VirtualUser"] = 'VirtualUser'] = "VirtualUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["DigitalUser"] = 'DigitalUser'] = "DigitalUser";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["Department"] = 'Department'] = "Department";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ApplicationExtension"] = 'ApplicationExtension'] = "ApplicationExtension";
	    MonitoredLinesExtensionInfoType[MonitoredLinesExtensionInfoType["ParkLocation"] = 'ParkLocation'] = "ParkLocation";
	})(exports.MonitoredLinesExtensionInfoType || (exports.MonitoredLinesExtensionInfoType = {}));
	var MonitoredLinesExtensionInfoType = exports.MonitoredLinesExtensionInfoType;
	
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var ringoutstatus = __webpack_require__(94);
	var RingOut = (function (_super) {
	    __extends(RingOut, _super);
	    function RingOut() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Make RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Makes a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.makeRingOutCall = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout', options, exports.makeRingOutCallOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Get Status of RingOut Call
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the status of a 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    RingOut.prototype.getRingOutCallStatus = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.getRingOutCallStatusOptions), ringoutstatus.RingOutStatus);
	    };
	    /**
	     * Cancel RingOut Call
	     *
	     * <p style='font-style:italic;'></p>
	     * <p>Cancels the 2-leg RingOut call.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>RingOut</td>
	     *             <td>Performing two-legged ring-out phone calls</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Heavy</p>
	     */
	    RingOut.prototype.cancelRingOutCall = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/ringout/{ringoutId}', options, exports.cancelRingOutCallOptions), null);
	    };
	    return RingOut;
	}(client.Client));
	exports.RingOut = RingOut;
	/**
	 * Definition of options for makeRingOutCall operation
	 */
	exports.makeRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "makeringoutrequest.MakeRingOutRequest"
	    }
	];
	/**
	 * Definition of options for getRingOutCallStatus operation
	 */
	exports.getRingOutCallStatusOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for cancelRingOutCall operation
	 */
	exports.cancelRingOutCallOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "ringoutId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ringoutstatusinfo = __webpack_require__(95);
	var RingOutStatus = (function (_super) {
	    __extends(RingOutStatus, _super);
	    function RingOutStatus() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatus.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'status', Class: ringoutstatusinfo.RingOutStatusInfo, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatus.prototype.getClassName = function () {
	        return 'RingOutStatus';
	    };
	    return RingOutStatus;
	}(model.Model));
	exports.RingOutStatus = RingOutStatus;
	
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var RingOutStatusInfo = (function (_super) {
	    __extends(RingOutStatusInfo, _super);
	    function RingOutStatusInfo() {
	        _super.apply(this, arguments);
	    }
	    RingOutStatusInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'callStatus', Class: RingOutStatusInfoCallStatus, isArray: false, isRequired: false },
	            { property: 'callerStatus', Class: RingOutStatusInfoCallerStatus, isArray: false, isRequired: false },
	            { property: 'calleeStatus', Class: RingOutStatusInfoCalleeStatus, isArray: false, isRequired: false }
	        ];
	    };
	    RingOutStatusInfo.prototype.getClassName = function () {
	        return 'RingOutStatusInfo';
	    };
	    return RingOutStatusInfo;
	}(model.Model));
	exports.RingOutStatusInfo = RingOutStatusInfo;
	(function (RingOutStatusInfoCallStatus) {
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallStatus[RingOutStatusInfoCallStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallStatus || (exports.RingOutStatusInfoCallStatus = {}));
	var RingOutStatusInfoCallStatus = exports.RingOutStatusInfoCallStatus;
	(function (RingOutStatusInfoCallerStatus) {
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCallerStatus[RingOutStatusInfoCallerStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCallerStatus || (exports.RingOutStatusInfoCallerStatus = {}));
	var RingOutStatusInfoCallerStatus = exports.RingOutStatusInfoCallerStatus;
	(function (RingOutStatusInfoCalleeStatus) {
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Invalid"] = 'Invalid'] = "Invalid";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Success"] = 'Success'] = "Success";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InProgress"] = 'InProgress'] = "InProgress";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Busy"] = 'Busy'] = "Busy";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoAnswer"] = 'NoAnswer'] = "NoAnswer";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Rejected"] = 'Rejected'] = "Rejected";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["GenericError"] = 'GenericError'] = "GenericError";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["Finished"] = 'Finished'] = "Finished";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["InternationalDisabled"] = 'InternationalDisabled'] = "InternationalDisabled";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["DestinationBlocked"] = 'DestinationBlocked'] = "DestinationBlocked";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NotEnoughFunds"] = 'NotEnoughFunds'] = "NotEnoughFunds";
	    RingOutStatusInfoCalleeStatus[RingOutStatusInfoCalleeStatus["NoSuchUser"] = 'NoSuchUser'] = "NoSuchUser";
	})(exports.RingOutStatusInfoCalleeStatus || (exports.RingOutStatusInfoCalleeStatus = {}));
	var RingOutStatusInfoCalleeStatus = exports.RingOutStatusInfoCalleeStatus;
	
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var extensionforwardingnumberlist = __webpack_require__(97);
	var forwardingnumberinfo = __webpack_require__(98);
	var ForwardingNumbers = (function (_super) {
	    __extends(ForwardingNumbers, _super);
	    function ForwardingNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get Extension Forwarding Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.7 (Release 5.16)</p>
	     * <p>Returns the list of extension phone numbers used for call forwarding and call flip. The returned list contains all the extension phone numbers that are used for call forwarding and call flip.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    ForwardingNumbers.prototype.listExtensionForwardingNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.listExtensionForwardingNumbersOptions), extensionforwardingnumberlist.ExtensionForwardingNumberList);
	    };
	    /**
	     * Create Forwarding Number
	     *
	     * <p style='font-style:italic;'>Since 1.0.12 (Release 6.4)</p>
	     * <p>Adds a new forwarding number to the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.createExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number', options, exports.createExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Update Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Updates an existent forwarding number from the forwarding number list.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.updateExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.updateExtensionForwardingNumberOptions), forwardingnumberinfo.ForwardingNumberInfo);
	    };
	    /**
	     * Delete Forwarding Number by ID
	     *
	     * <p style='font-style:italic;'>Since 1.0.24 (Release 8.0)</p>
	     * <p>Deletes a forwarding number from the forwarding number list by its ID.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating user extension info (includes extension name, number, email and phone number, assigned phone numbers, devices and other extension settings)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    ForwardingNumbers.prototype.deleteExtensionForwardingNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/forwarding-number/{forwardingNumberId}', options, exports.deleteExtensionForwardingNumberOptions), null);
	    };
	    return ForwardingNumbers;
	}(client.Client));
	exports.ForwardingNumbers = ForwardingNumbers;
	/**
	 * Definition of options for listExtensionForwardingNumbers operation
	 */
	exports.listExtensionForwardingNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "page",
	        "type": "number",
	        "in": "query",
	        "required": false
	    },
	    {
	        "name": "perPage",
	        "type": "number",
	        "in": "query",
	        "required": false
	    }
	];
	/**
	 * Definition of options for createExtensionForwardingNumber operation
	 */
	exports.createExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "createforwardingnumberrequest.CreateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for updateExtensionForwardingNumber operation
	 */
	exports.updateExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    },
	    {
	        "name": "body",
	        "in": "body",
	        "required": true,
	        "type": "updateforwardingnumberrequest.UpdateForwardingNumberRequest"
	    }
	];
	/**
	 * Definition of options for deleteExtensionForwardingNumber operation
	 */
	exports.deleteExtensionForwardingNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "forwardingNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var forwardingnumberinfo = __webpack_require__(98);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var ExtensionForwardingNumberList = (function (_super) {
	    __extends(ExtensionForwardingNumberList, _super);
	    function ExtensionForwardingNumberList() {
	        _super.apply(this, arguments);
	    }
	    ExtensionForwardingNumberList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: forwardingnumberinfo.ForwardingNumberInfo, isArray: true, isRequired: false },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: false },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: false }
	        ];
	    };
	    ExtensionForwardingNumberList.prototype.getClassName = function () {
	        return 'ExtensionForwardingNumberList';
	    };
	    return ExtensionForwardingNumberList;
	}(model.Model));
	exports.ExtensionForwardingNumberList = ExtensionForwardingNumberList;
	
	
	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var ForwardingNumberInfo = (function (_super) {
	    __extends(ForwardingNumberInfo, _super);
	    function ForwardingNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    ForwardingNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'label', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'features', Class: ForwardingNumberInfoFeatures, isArray: false, isRequired: false },
	            { property: 'flipNumber', Class: null /* number */, isArray: false, isRequired: false }
	        ];
	    };
	    ForwardingNumberInfo.prototype.getClassName = function () {
	        return 'ForwardingNumberInfo';
	    };
	    return ForwardingNumberInfo;
	}(model.Model));
	exports.ForwardingNumberInfo = ForwardingNumberInfo;
	(function (ForwardingNumberInfoFeatures) {
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallFlip"] = 'CallFlip'] = "CallFlip";
	    ForwardingNumberInfoFeatures[ForwardingNumberInfoFeatures["CallForwarding"] = 'CallForwarding'] = "CallForwarding";
	})(exports.ForwardingNumberInfoFeatures || (exports.ForwardingNumberInfoFeatures = {}));
	var ForwardingNumberInfoFeatures = exports.ForwardingNumberInfoFeatures;
	
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var client = __webpack_require__(3);
	var blockednumberinfo = __webpack_require__(100);
	var blockednumberslist = __webpack_require__(101);
	var BlockedNumbers = (function (_super) {
	    __extends(BlockedNumbers, _super);
	    function BlockedNumbers() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Add Blocked Number
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.blockNumber = function (options) {
	        return this.send(this.parseOptions('POST', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.blockNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Get Blocked Number List
	     *
	     * <p style='font-style:italic;'>Since 1.0.2</p>
	     * <p>Returns the list of phone numbers which are specified by the user to block inbound calls and SMS messages.</p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.listBlockedNumbers = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number', options, exports.listBlockedNumbersOptions), blockednumberslist.BlockedNumbersList);
	    };
	    /**
	     * Get Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>ReadAccounts</td>
	     *             <td>Viewing user account info (including name, business name, address and phone number/account number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Light</p>
	     */
	    BlockedNumbers.prototype.loadBlockedNumber = function (options) {
	        return this.send(this.parseOptions('GET', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.loadBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Update Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.updateBlockedNumber = function (options) {
	        return this.send(this.parseOptions('PUT', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.updateBlockedNumberOptions), blockednumberinfo.BlockedNumberInfo);
	    };
	    /**
	     * Delete Blocked Number(s) by ID
	     *
	     * <p style='font-style:italic;'></p>
	     * <p></p>
	     * <h4>Required Permissions</h4>
	     * <table class='fullwidth'>
	     *     <thead>
	     *         <tr>
	     *             <th>Permission</th>
	     *             <th>Description</th>
	     *         </tr>
	     *     </thead>
	     *     <tbody>
	     *         <tr>
	     *             <td class='code'>EditExtensions</td>
	     *             <td>Viewing and updating my extension info (includes extension name, number, email and phone number)</td>
	     *         </tr>
	     *     </tbody>
	     * </table>
	     * <h4>API Group</h4>
	     * <p>Medium</p>
	     */
	    BlockedNumbers.prototype.unblockNumber = function (options) {
	        return this.send(this.parseOptions('DELETE', '/restapi/v1.0/account/{accountId}/extension/{extensionId}/blocked-number/{blockedNumberId}', options, exports.unblockNumberOptions), null);
	    };
	    return BlockedNumbers;
	}(client.Client));
	exports.BlockedNumbers = BlockedNumbers;
	/**
	 * Definition of options for blockNumber operation
	 */
	exports.blockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for listBlockedNumbers operation
	 */
	exports.listBlockedNumbersOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    }
	];
	/**
	 * Definition of options for loadBlockedNumber operation
	 */
	exports.loadBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for updateBlockedNumber operation
	 */
	exports.updateBlockedNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	/**
	 * Definition of options for unblockNumber operation
	 */
	exports.unblockNumberOptions = [
	    {
	        "name": "accountId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "extensionId",
	        "type": "string",
	        "in": "path",
	        "required": true,
	        "default": "~"
	    },
	    {
	        "name": "blockedNumberId",
	        "type": "string",
	        "in": "path",
	        "required": true
	    }
	];
	
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var BlockedNumberInfo = (function (_super) {
	    __extends(BlockedNumberInfo, _super);
	    function BlockedNumberInfo() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumberInfo.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'uri', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'id', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'name', Class: null /* string */, isArray: false, isRequired: false },
	            { property: 'phoneNumber', Class: null /* string */, isArray: false, isRequired: false }
	        ];
	    };
	    BlockedNumberInfo.prototype.getClassName = function () {
	        return 'BlockedNumberInfo';
	    };
	    return BlockedNumberInfo;
	}(model.Model));
	exports.BlockedNumberInfo = BlockedNumberInfo;
	
	
	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {
	
	/// <reference path="../externals.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var model = __webpack_require__(5);
	var blockednumberinfo = __webpack_require__(100);
	var navigationinfo = __webpack_require__(33);
	var paginginfo = __webpack_require__(32);
	var BlockedNumbersList = (function (_super) {
	    __extends(BlockedNumbersList, _super);
	    function BlockedNumbersList() {
	        _super.apply(this, arguments);
	    }
	    BlockedNumbersList.prototype.getPropertyMappings = function () {
	        return [
	            { property: 'records', Class: blockednumberinfo.BlockedNumberInfo, isArray: true, isRequired: true },
	            { property: 'navigation', Class: navigationinfo.NavigationInfo, isArray: false, isRequired: true },
	            { property: 'paging', Class: paginginfo.PagingInfo, isArray: false, isRequired: true }
	        ];
	    };
	    BlockedNumbersList.prototype.getClassName = function () {
	        return 'BlockedNumbersList';
	    };
	    return BlockedNumbersList;
	}(model.Model));
	exports.BlockedNumbersList = BlockedNumbersList;
	
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=ringcentral-client.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['store', 'mapper', 'prefix', 'actions', 'emitter']);
	
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default reducer if module does not has its own reducer.
	 */
	function defaultReducer(state) {
	  if (typeof state === 'undefined') return {};
	  return state;
	}
	/**
	 * @function
	 * @param {Object} state
	 * @return {Object}
	 * @description Default parent state to module state mapper.
	 */
	function defaultMapper(state) {
	  return state;
	}
	
	/**
	 * @class
	 * @default
	 * @description Base module class.
	 */
	
	var RcModule = function () {
	  /**
	   * @constructor
	   */
	
	  function RcModule(_ref) {
	    var _this = this;
	
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? defaultMapper : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var actions = _ref.actions;
	    (0, _classCallCheck3.default)(this, RcModule);
	
	    // Extending EventEmitter breaks some mechanic, so we wire emitter up like this instead.
	    this[symbols.emitter] = new _eventEmitter2.default();
	    this[symbols.mapper] = stateMapper;
	    this[symbols.prefix] = prefix;
	    this[symbols.actions] = actions && (0, _reduxHelper.prefixActions)(actions, prefix);
	    registerStoreHandler(function (store) {
	      _this[symbols.store] = store;
	    });
	  }
	
	  /**
	   * @function
	   * @param {String} event
	   * @param {Function} handler
	   * @return {Function} Unregister function.
	   */
	
	
	  (0, _createClass3.default)(RcModule, [{
	    key: 'on',
	    value: function on(event, handler) {
	      var _this2 = this;
	
	      this[symbols.emitter].on(event, handler);
	      return function () {
	        _this2[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function)} handler
	     * @return {Function} Unregister function.
	     */
	
	  }, {
	    key: 'once',
	    value: function once(event, handler) {
	      var _this3 = this;
	
	      this[symbols.emitter].once(event, handler);
	      return function () {
	        _this3[symbols.emitter].off(event, handler);
	      };
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {...args} args
	     */
	
	  }, {
	    key: 'emit',
	    value: function emit(event) {
	      var _symbols$emitter;
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      (_symbols$emitter = this[symbols.emitter]).emit.apply(_symbols$emitter, [event].concat(args));
	    }
	    /**
	     * @function
	     * @param {String} event
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'off',
	    value: function off(event, handler) {
	      this[symbols.emitter].off(event, handler);
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this[symbols.mapper](this[symbols.store].getState());
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return defaultReducer;
	    }
	  }, {
	    key: 'store',
	    get: function get() {
	      return this[symbols.store];
	    }
	  }, {
	    key: 'prefix',
	    get: function get() {
	      return this[symbols.prefix];
	    }
	  }, {
	    key: 'actions',
	    get: function get() {
	      return this[symbols.actions];
	    }
	  }]);
	  return RcModule;
	}();
	
	exports.default = RcModule;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class
	 * @description Helper class for creating a symbol mapping
	 */
	
	var SymbolMap = function (_Enum) {
	  (0, _inherits3.default)(SymbolMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} keys
	   */
	
	  function SymbolMap(keys) {
	    (0, _classCallCheck3.default)(this, SymbolMap);
	
	    var definition = {};
	    keys.forEach(function (key) {
	      definition[key] = (0, _symbol2.default)();
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(SymbolMap).call(this, definition));
	  }
	
	  return SymbolMap;
	}(_enum2.default);
	
	exports.default = SymbolMap;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty = __webpack_require__(72);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _symbol = __webpack_require__(80);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = {}.hasOwnProperty;
	var DEFINITION = (0, _symbol2.default)();
	var VALUES = (0, _symbol2.default)();
	
	var Enum = function () {
	  function Enum(definition) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, Enum);
	
	    this[DEFINITION] = (0, _assign2.default)({}, definition);
	    this[VALUES] = new _set2.default();
	
	    var _loop = function _loop(key) {
	      if (hasOwnProperty.call(definition, key)) {
	        (0, _defineProperty2.default)(_this, key, {
	          get: function get() {
	            return this[DEFINITION][key];
	          },
	
	          enumerable: true
	        });
	        _this[VALUES].add(_this[DEFINITION][key]);
	      }
	    };
	
	    for (var key in definition) {
	      _loop(key);
	    }
	  }
	
	  (0, _createClass3.default)(Enum, null, [{
	    key: "hasValue",
	    value: function hasValue(value) {
	      return this[VALUES].has(value);
	    }
	  }]);
	  return Enum;
	}();
	
	/*
	 * //with Proxy support
	 *const enumHandler = {
	 *  get(target, key) {
	 *    return target[key];
	 *  },
	 *  set() {
	 *    return;
	 *  }
	 *};
	 *Enum = class Enum extends Proxy {
	 *  constructor(definition) {
	 *    super(Object.assign({}, definition), enumHandler);
	 *  }
	 *}
	 */
	
	
	exports.default = Enum;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionMap = undefined;
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	exports.prefixActions = prefixActions;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	/**
	 * @class
	 * @description helper class for creating redux action definition maps
	 */
	
	var ActionMap = exports.ActionMap = function (_Enum) {
	  (0, _inherits3.default)(ActionMap, _Enum);
	
	  /**
	   * @constructor
	   * @param {String[]} actions - list of action strings
	   * @extends Enum
	   */
	
	  function ActionMap() {
	    var actions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	    (0, _classCallCheck3.default)(this, ActionMap);
	
	    var definition = {};
	    actions.forEach(function (action) {
	      definition[action] = prefix !== '' ? prefix + '-' + action : action;
	    });
	    return (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(ActionMap).call(this, definition));
	  }
	
	  return ActionMap;
	}(_enum2.default);
	
	/**
	 * @function
	 * @description helper function to return a prefixed action definition maps
	 */
	
	
	function prefixActions(actions, prefix) {
	  if (!prefix || prefix === '') return actions;
	  var definition = {};
	  for (var action in actions) {
	    if (hasOwnProperty.call(actions, action)) {
	      definition[action] = prefix + '-' + action;
	    }
	  }
	  return new _enum2.default(definition);
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var d        = __webpack_require__(138)
	  , callable = __webpack_require__(151)
	
	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }
	
	  , on, once, off, emit, methods, descriptors, base;
	
	on = function (type, listener) {
		var data;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];
	
		return this;
	};
	
	once = function (type, listener) {
		var once, self;
	
		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});
	
		once.__eeOnceListener__ = listener;
		return this;
	};
	
	off = function (type, listener) {
		var data, listeners, candidate, i;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];
	
		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}
	
		return this;
	};
	
	emit = function (type) {
		var i, l, listener, listeners, args;
	
		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;
	
		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
	
			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};
	
	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};
	
	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};
	
	base = defineProperties({}, descriptors);
	
	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign        = __webpack_require__(139)
	  , normalizeOpts = __webpack_require__(146)
	  , isCallable    = __webpack_require__(147)
	  , contains      = __webpack_require__(148)
	
	  , d;
	
	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}
	
		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};
	
	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}
	
		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(140)()
		? Object.assign
		: __webpack_require__(141);


/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys  = __webpack_require__(142)
	  , value = __webpack_require__(145)
	
	  , max = Math.max;
	
	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(143)()
		? Object.keys
		: __webpack_require__(144);


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	'use strict';
	
	var keys = Object.keys;
	
	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};
	
	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 147 */
/***/ function(module, exports) {

	// Deprecated
	
	'use strict';
	
	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(149)()
		? String.prototype.contains
		: __webpack_require__(150);


/***/ },
/* 149 */
/***/ function(module, exports) {

	'use strict';
	
	var str = 'razdwatrzy';
	
	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	var indexOf = String.prototype.indexOf;
	
	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _reduxHelper = __webpack_require__(136);
	
	var _redux = __webpack_require__(153);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['reducer']);
	
	function getSettingsReducer(prefix) {
	  return function (state, action) {
	    if (typeof state === 'undefined') return {};
	
	    return state;
	  };
	}
	
	var Settings = function (_RcModule) {
	  (0, _inherits3.default)(Settings, _RcModule);
	
	  function Settings(options) {
	    (0, _classCallCheck3.default)(this, Settings);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Settings).call(this, (0, _extends3.default)({}, options)));
	
	    _this[symbols.reducer] = {
	      base: getSettingsReducer(_this.prefix)
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'registerReducer',
	    value: function registerReducer(name, reducer) {
	      this[symbols.reducer][name] = reducer;
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _redux.combineReducers)(this[symbols.reducer]);
	    }
	  }]);
	  return Settings;
	}(_rcModule2.default);
	
	exports.default = Settings;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(154);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(161);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(163);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(164);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(159);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(156),
	    isHostObject = __webpack_require__(157),
	    isObjectLike = __webpack_require__(158);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(160)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(154);
	
	var _isPlainObject = __webpack_require__(155);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(162);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(165);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _brandReducer = __webpack_require__(168);
	
	var _brandReducer2 = _interopRequireDefault(_brandReducer);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['initialState']);
	
	var Brand = function (_RcModule) {
	  (0, _inherits3.default)(Brand, _RcModule);
	
	  function Brand(_ref) {
	    var registerStoreHandler = _ref.registerStoreHandler;
	    var _ref$stateMapper = _ref.stateMapper;
	    var stateMapper = _ref$stateMapper === undefined ? function (state) {
	      return state.brand;
	    } : _ref$stateMapper;
	    var prefix = _ref.prefix;
	    var id = _ref.id;
	    var name = _ref.name;
	    (0, _classCallCheck3.default)(this, Brand);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Brand).call(this, {
	      registerStoreHandler: registerStoreHandler,
	      stateMapper: stateMapper,
	      prefix: prefix,
	      actions: _brandActions2.default
	    }));
	
	    _this[symbols.initialState] = {
	      id: id,
	      name: name
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(Brand, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _brandReducer2.default)(this[symbols.initialState], this.prefix);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return this.state.id;
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return this.state.name;
	    }
	  }]);
	  return Brand;
	}(_rcModule2.default);
	
	exports.default = Brand;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['setBrand']);

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _brandActions = __webpack_require__(167);
	
	var _brandActions2 = _interopRequireDefault(_brandActions);
	
	var _reduxHelper = __webpack_require__(136);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getReducer(initialState, prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_brandActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	
	    if (!action) return state;
	    switch (action.type) {
	      case actions.setBrand:
	        return (0, _assign2.default)({}, state, {
	          name: action.payload.name,
	          id: action.payload.id
	        });
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getIterator2 = __webpack_require__(66);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _toConsumableArray2 = __webpack_require__(170);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _set = __webpack_require__(102);
	
	var _set2 = _interopRequireDefault(_set);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _authReducer = __webpack_require__(189);
	
	var _authReducer2 = _interopRequireDefault(_authReducer);
	
	var _authEvents = __webpack_require__(190);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['platform', 'emitter', 'beforeLogoutHandlers']);
	
	var ENUMS = new _enum2.default({
	  loginStatus: _loginStatus2.default
	});
	
	/**
	 * @class
	 * @description Authentication module
	 */
	
	var Auth = function (_RcModule) {
	  (0, _inherits3.default)(Auth, _RcModule);
	
	  /**
	   * @function
	   */
	
	  function Auth(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Auth);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Auth).call(this, (0, _extends3.default)({}, options, {
	      actions: _authActions2.default
	    })));
	
	    var platform = options.platform;
	
	
	    _this[symbols.platform] = platform;
	    _this[symbols.beforeLogoutHandlers] = new _set2.default();
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.loginSuccess
	      });
	      _utils.emit.call(_this, _authEvents.authEventTypes.loginStatusChanged, _this.state.status);
	    });
	    // loginError
	    platform.on(platform.events.loginError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.loginError,
	        error: error
	      });
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this.store.dispatch({
	        type: _this.actions.logoutSuccess
	      });
	      // this.emit(authEvents.userInfoCleared);
	    });
	
	    platform.on(platform.events.logoutError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.logoutError,
	        error: error
	      });
	    });
	
	    platform.on(platform.events.refreshError, function (error) {
	      _this.store.dispatch({
	        type: _this.actions.refreshError,
	        error: error
	      });
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      var loggedIn;
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              loggedIn = _context.sent;
	
	              _this.store.dispatch({
	                type: _this.actions.init,
	                status: loggedIn ? _loginStatus2.default.loggedIn : _loginStatus2.default.notLoggedIn
	              });
	              _this.emit(_authEvents.authEventTypes.authEventTypes, _this.state.status);
	
	            case 5:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this2);
	    }))();
	    return _this;
	  }
	
	  (0, _createClass3.default)(Auth, [{
	    key: 'login',
	
	    /**
	     * @function
	     * @async
	     * @description Login function using username and password
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(_ref) {
	        var username = _ref.username;
	        var password = _ref.password;
	        var extension = _ref.extension;
	        var remember = _ref.remember;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    username: username,
	                    password: password,
	                    extension: extension,
	                    remember: remember
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context2.next = 4;
	                return this[symbols.platform].login({
	                  username: username,
	                  password: password,
	                  extension: extension,
	                  remember: remember
	                });
	
	              case 4:
	                return _context2.abrupt('return', _context2.sent);
	
	              case 5:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	
	      function login(_x) {
	        return ref.apply(this, arguments);
	      }
	
	      return login;
	    }()
	
	    /**
	     * @function
	     * @description get OAuth page url
	     */
	
	  }, {
	    key: 'loginUrl',
	    value: function loginUrl(_ref2) {
	      var redirectUri = _ref2.redirectUri;
	      var state = _ref2.state;
	      var brandId = _ref2.brandId;
	      var display = _ref2.display;
	      var prompt = _ref2.prompt;
	
	      return this[symbols.platform].loginUrl({
	        redirectUri: redirectUri,
	        state: state,
	        brandId: brandId,
	        display: display,
	        prompt: prompt
	      });
	    }
	
	    /**
	     * @function
	     * @param {string} url
	     * @return {Object}
	     */
	
	  }, {
	    key: 'parseLoginUrl',
	    value: function parseLoginUrl(url) {
	      return this[symbols.platform].parseLoginRedirectUrl(url);
	    }
	
	    /**
	     * @function
	     * @async
	     * @description Authorize using OAauth code
	     */
	
	  }, {
	    key: 'authorize',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(_ref3) {
	        var code = _ref3.code;
	        var redirectUri = _ref3.redirectUri;
	        return _regenerator2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                this.store.dispatch({
	                  type: this.actions.login,
	                  payload: {
	                    code: code,
	                    redirectUri: redirectUri
	                  }
	                });
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingIn);
	                _context3.next = 4;
	                return this[symbols.platform].login({
	                  code: code,
	                  redirectUri: redirectUri
	                });
	
	              case 4:
	                return _context3.abrupt('return', _context3.sent);
	
	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	
	      function authorize(_x2) {
	        return ref.apply(this, arguments);
	      }
	
	      return authorize;
	    }()
	
	    /**
	     * @function
	     * @async
	     * @description Log the user out
	     */
	
	  }, {
	    key: 'logout',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	        var _this3 = this;
	
	        var handlers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;
	
	        return _regenerator2.default.wrap(function _callee5$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                // deal with removing subscriptions
	
	                _utils.emit.call(this, _authEvents.authEventTypes.loginStatusChanged, _authEvents.authEvents.loggingOut);
	                handlers = [].concat((0, _toConsumableArray3.default)(this[symbols.beforeLogoutHandlers]));
	                _iteratorNormalCompletion = true;
	                _didIteratorError = false;
	                _iteratorError = undefined;
	                _context6.prev = 5;
	                _loop = _regenerator2.default.mark(function _loop() {
	                  var handler;
	                  return _regenerator2.default.wrap(function _loop$(_context5) {
	                    while (1) {
	                      switch (_context5.prev = _context5.next) {
	                        case 0:
	                          handler = _step.value;
	                          _context5.prev = 1;
	                          _context5.next = 4;
	                          return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	                            return _regenerator2.default.wrap(function _callee4$(_context4) {
	                              while (1) {
	                                switch (_context4.prev = _context4.next) {
	                                  case 0:
	                                    return _context4.abrupt('return', handler());
	
	                                  case 1:
	                                  case 'end':
	                                    return _context4.stop();
	                                }
	                              }
	                            }, _callee4, _this3);
	                          }))();
	
	                        case 4:
	                          _context5.next = 8;
	                          break;
	
	                        case 6:
	                          _context5.prev = 6;
	                          _context5.t0 = _context5['catch'](1);
	
	                        case 8:
	                        case 'end':
	                          return _context5.stop();
	                      }
	                    }
	                  }, _loop, _this3, [[1, 6]]);
	                });
	                _iterator = (0, _getIterator3.default)(handlers);
	
	              case 8:
	                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                  _context6.next = 13;
	                  break;
	                }
	
	                return _context6.delegateYield(_loop(), 't0', 10);
	
	              case 10:
	                _iteratorNormalCompletion = true;
	                _context6.next = 8;
	                break;
	
	              case 13:
	                _context6.next = 19;
	                break;
	
	              case 15:
	                _context6.prev = 15;
	                _context6.t1 = _context6['catch'](5);
	                _didIteratorError = true;
	                _iteratorError = _context6.t1;
	
	              case 19:
	                _context6.prev = 19;
	                _context6.prev = 20;
	
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	
	              case 22:
	                _context6.prev = 22;
	
	                if (!_didIteratorError) {
	                  _context6.next = 25;
	                  break;
	                }
	
	                throw _iteratorError;
	
	              case 25:
	                return _context6.finish(22);
	
	              case 26:
	                return _context6.finish(19);
	
	              case 27:
	                _context6.next = 29;
	                return this[symbols.platform].logout();
	
	              case 29:
	                return _context6.abrupt('return', _context6.sent);
	
	              case 30:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee5, this, [[5, 15, 19, 27], [20,, 22, 26]]);
	      }));
	
	      function logout() {
	        return ref.apply(this, arguments);
	      }
	
	      return logout;
	    }()
	    /**
	     * @function
	     * @param {Function} handler
	     * @returns {Function}
	     */
	
	  }, {
	    key: 'addBeforeLogoutHandler',
	    value: function addBeforeLogoutHandler(handler) {
	      var _this4 = this;
	
	      this[symbols.beforeLogoutHandlers].add(handler);
	      return function () {
	        _this4[symbols.beforeLogoutHandlers].remove(handler);
	      };
	    }
	    /**
	     * @function
	     * @param {Function} handler
	     */
	
	  }, {
	    key: 'removeBeforeLogoutHandler',
	    value: function removeBeforeLogoutHandler(handler) {
	      this[symbols.beforeLogoutHandlers].remove(handler);
	    }
	  }, {
	    key: 'isLoggedIn',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	        return _regenerator2.default.wrap(function _callee6$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                _context7.next = 2;
	                return this[symbols.platform].loggedIn();
	
	              case 2:
	                return _context7.abrupt('return', _context7.sent);
	
	              case 3:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee6, this);
	      }));
	
	      function isLoggedIn() {
	        return ref.apply(this, arguments);
	      }
	
	      return isLoggedIn;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _authReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _authEvents.authEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _authEvents.authEventTypes;
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Auth;
	}(_rcModule2.default);
	
	exports.default = Auth;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(171);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(172), __esModule: true };

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(62);
	__webpack_require__(173);
	module.exports = __webpack_require__(8).Array.from;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(9)
	  , $export        = __webpack_require__(6)
	  , toObject       = __webpack_require__(39)
	  , call           = __webpack_require__(109)
	  , isArrayIter    = __webpack_require__(110)
	  , toLength       = __webpack_require__(30)
	  , createProperty = __webpack_require__(174)
	  , getIterFn      = __webpack_require__(69);
	
	$export($export.S + $export.F * !__webpack_require__(175)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12)
	  , createDesc      = __webpack_require__(20);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(61)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(177);


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(178);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }
	
	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            return step("next", value);
	          }, function (err) {
	            return step("throw", err);
	          });
	        }
	      }
	
	      return step("next");
	    });
	  };
	};

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(181), __esModule: true };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(91);
	__webpack_require__(62);
	__webpack_require__(48);
	__webpack_require__(182);
	module.exports = __webpack_require__(8).Promise;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(54)
	  , global             = __webpack_require__(7)
	  , ctx                = __webpack_require__(9)
	  , classof            = __webpack_require__(65)
	  , $export            = __webpack_require__(6)
	  , isObject           = __webpack_require__(14)
	  , anObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(10)
	  , anInstance         = __webpack_require__(107)
	  , forOf              = __webpack_require__(108)
	  , setProto           = __webpack_require__(98).set
	  , speciesConstructor = __webpack_require__(183)
	  , task               = __webpack_require__(184).set
	  , microtask          = __webpack_require__(186)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(61)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(106)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(60)($Promise, PROMISE);
	__webpack_require__(111)(PROMISE);
	Wrapper = __webpack_require__(8)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(175)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(13)
	  , aFunction = __webpack_require__(10)
	  , SPECIES   = __webpack_require__(61)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(9)
	  , invoke             = __webpack_require__(185)
	  , html               = __webpack_require__(59)
	  , cel                = __webpack_require__(18)
	  , global             = __webpack_require__(7)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(27)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(7)
	  , macrotask = __webpack_require__(184).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(27)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING', // after init, before status from platform is determined
	  notLoggedIn: 'NOT_LOGGED_IN',
	  loggingIn: 'LOGGING_IN',
	  loggedIn: 'LOGGED_IN',
	  loggingOut: 'LOGGING_OUT'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['login', 'loginSuccess', 'loginError', 'logout', 'logoutSuccess', 'logoutError', 'refresh', 'refreshSuccess', 'refreshError', 'init'], 'auth');

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getAuthReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _authActions = __webpack_require__(188);
	
	var _authActions2 = _interopRequireDefault(_authActions);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _loginStatus2.default.pending,
	  authError: null
	};
	
	function getAuthReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_authActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.init:
	        return (0, _assign2.default)({}, state, { status: action.status });
	
	      case actions.login:
	        return {
	          status: _loginStatus2.default.loggingIn,
	          authError: null
	        };
	
	      case actions.loginSuccess:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: null
	        };
	
	      case actions.logoutSuccess:
	        return {
	          status: _loginStatus2.default.notLoggedIn,
	          authError: null
	        };
	
	      case actions.loginError:
	        return {
	          state: _loginStatus2.default.notLoggedIn,
	          authError: action.error
	        };
	
	      case actions.logoutError:
	        return {
	          status: _loginStatus2.default.loggedIn,
	          authError: action.error
	        };
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.authEventTypes = exports.authEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _loginStatus = __webpack_require__(187);
	
	var _loginStatus2 = _interopRequireDefault(_loginStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = (0, _extends3.default)({}, _loginStatus2.default);
	
	var authEvents = exports.authEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  loginStatusChanged: 'LOGIN_STATUS_CHANGED'
	};
	
	var authEventTypes = exports.authEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sleep = exports.fetchList = undefined;
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _typeof2 = __webpack_require__(76);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var fetchList = exports.fetchList = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(fn) {
	    var fetchedPages, totalPages, list, data;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            fetchedPages = 0;
	            totalPages = 1;
	            list = [];
	
	          case 3:
	            if (!(fetchedPages < totalPages)) {
	              _context.next = 12;
	              break;
	            }
	
	            fetchedPages++;
	            _context.next = 7;
	            return fn({
	              page: fetchedPages
	            });
	
	          case 7:
	            data = _context.sent;
	
	            totalPages = data.paging.totalPages;
	            list = list.concat(data.records);
	            _context.next = 3;
	            break;
	
	          case 12:
	            return _context.abrupt('return', list);
	
	          case 13:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function fetchList(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @param {String} eventType
	 * @param {String} event
	 * @description Helper function to emit eventTyped events and the event itself
	 */
	
	
	/**
	 * @function
	 * @param {Number} t
	 */
	
	var sleep = exports.sleep = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(t) {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            return _context2.abrupt('return', new _promise2.default(function (resolve) {
	              setTimeout(resolve, t);
	            }));
	
	          case 1:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function sleep(_x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	exports.extractData = extractData;
	exports.emit = emit;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function extractData(model) {
	  if (Array.isArray(model)) {
	    return model.map(function (item) {
	      return extractData(item);
	    });
	  } else if ((typeof model === 'undefined' ? 'undefined' : (0, _typeof3.default)(model)) === 'object') {
	    var data = {};
	    for (var key in model) {
	      if (key[0] !== '_' && model.hasOwnProperty(key)) {
	        data[key] = extractData(model[key]);
	      }
	    }
	    return data;
	  }
	  return model;
	}
	
	function emit(eventType, event) {
	  for (var _len = arguments.length, payloads = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    payloads[_key - 2] = arguments[_key];
	  }
	
	  this.emit.apply(this, [event].concat(payloads));
	  this.emit.apply(this, [eventType, event].concat(payloads));
	}

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _stringify = __webpack_require__(193);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionReducer = __webpack_require__(196);
	
	var _subscriptionReducer2 = _interopRequireDefault(_subscriptionReducer);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _utils = __webpack_require__(191);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['auth', 'sdk', 'platform', 'subscription', 'filterCache']);
	
	var filterRegex = {
	  message: /message-store$/,
	  presence: /presence(\?detailedTelephonyState=true)?$/,
	  telephony: /presence\?detailedTelephonyState=true$/,
	  line: /presence\/line$/,
	  linePresence: /presence\/line\/presence(\?detailedTelephonyState=true)?$/,
	  lineTelephony: /presence\/line\/presence\?detailedTelephonyState=true$/
	};
	
	/**
	 * @function
	 * @param {Object} message
	 * @description Handles messages delivered by the subscripton
	 */
	function messageHandler(message) {
	  var _this = this;
	
	  // determine which events the message falls under
	  var events = [];
	  if (filterRegex.message.test(message.event)) {
	    events.push('message');
	  } else if (filterRegex.line.test(message.event)) {
	    events.push('line');
	  } else if (filterRegex.linePresence.test(message.event)) {
	    events.push('linePresence');
	    if (filterRegex.lineTelephony.test(message.event)) events.push('lineTelephony');
	  } else if (filterRegex.presence.test(message.event)) {
	    events.push('presence');
	    if (filterRegex.telephony.test(message.event)) events.push('telephony');
	  }
	  // dispatch the message in redux manner
	  this.store.dispatch({
	    type: this.actions.notification,
	    eventTypes: events,
	    payload: message
	  });
	  // emit the messages as events
	  events.forEach(function (event) {
	    _utils.emit.call(_this, _subscriptionEvents.subscriptionEventTypes.notification, _subscriptionEvents.subscriptionEvents[event], message);
	  });
	}
	function init() {
	  var _this2 = this;
	
	  var platform = this[symbols.platform];
	  this[symbols.subscription] = this[symbols.sdk].createSubscription();
	  var ownerId = platform.auth().data().owner_id;
	  var cacheKey = null;
	  if (typeof localStorage !== 'undefined') {
	    cacheKey = this.prefix + '-sub-' + ownerId;
	    var cachedSubscription = localStorage.getItem(cacheKey);
	    if (cachedSubscription) {
	      try {
	        this.base.setSubscription(JSON.parse(cachedSubscription));
	      } catch (e) {
	        /* do nothing */
	      }
	    }
	  }
	
	  this.base.setEventFilters(this.filters);
	
	  this.base.on(this.base.events.notification, function (message) {
	    messageHandler.call(_this2, message);
	  });
	  this.base.on(this.base.events.removeSuccess, function () {
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.removeError, function () {
	    // TODO
	  });
	  this.base.on(this.base.events.renewSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    var oldStatus = _this2.status;
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    if (oldStatus !== _this2.status) {
	      _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    }
	  });
	  this.base.on(this.base.events.renewError, function (error) {
	    // TODO handle 429
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.notSubscribed,
	      subscription: null
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	    _this2.base.reset().setEventFilters(_this2.filters).register().catch(function (e) {});
	  });
	  this.base.on(this.base.events.subscribeSuccess, function () {
	    if (cacheKey) {
	      localStorage.setItem(cacheKey, (0, _stringify2.default)(_this2.base.subscription()));
	    }
	    _this2.store.dispatch({
	      type: _this2.actions.updateStatus,
	      status: _subscriptionStatus2.default.subscribed,
	      subscription: _this2.base.subscription()
	    });
	    _utils.emit.call(_this2, _subscriptionEvents.subscriptionEventTypes.statusChanged, _this2.status);
	  });
	  this.base.on(this.base.events.subscribeError, function (error) {
	    // TODO
	    // handle 429
	    // handle subscription limit
	  });
	
	  if (this.filters.length) {
	    this.base.register().catch(function () {/* do nothing */});
	  }
	}
	
	var Subscription = function (_RcModule) {
	  (0, _inherits3.default)(Subscription, _RcModule);
	
	  function Subscription(options) {
	    var _this4 = this;
	
	    (0, _classCallCheck3.default)(this, Subscription);
	
	    var _this3 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Subscription).call(this, (0, _extends3.default)({}, options, {
	      registerStoreHandler: function registerStoreHandler(handler) {
	        options.registerStoreHandler(function (store) {
	          // set store to self first
	          handler(store);
	
	          // update store with cachedFilters
	          _this3.store.dispatch({
	            type: _this3.actions.updateFilters,
	            filters: _this3.filters
	          });
	
	          _this3[symbols.filterCache] = null;
	        });
	      },
	      actions: _subscriptionActions2.default
	    })));
	
	    var auth = options.auth;
	    var platform = options.platform;
	    var sdk = options.sdk;
	
	    _this3[symbols.auth] = auth;
	    _this3[symbols.platform] = platform;
	    _this3[symbols.sdk] = sdk;
	    _this3[symbols.subscription] = null;
	
	    // caches filters before redux store is created
	    _this3[symbols.filterCache] = [];
	
	    auth.on(auth.events.loggedIn, function () {
	      init.call(_this3);
	    });
	
	    auth.on(auth.events.loggedOut, function () {
	      if (_this3.base) {
	        _this3.reset();
	      }
	    });
	
	    // platform.on(platform.events.loginSuccess, () => {
	    //   this::init();
	    // });
	    // platform.on(platform.events.logoutSuccess, async () => {
	    //   if (this.base) {
	    //     await this.reset();
	    //   }
	    //   this[symbols.subscription] = null;
	    // });
	
	    auth.addBeforeLogoutHandler((0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	      return _regenerator2.default.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return _this3.reset();
	
	            case 2:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this4);
	    })));
	
	    // (async () => {
	    //   if (await platform.loggedIn()) {
	    //     this::init();
	    //   }
	    // })();
	    return _this3;
	  }
	
	  (0, _createClass3.default)(Subscription, [{
	    key: 'subscribe',
	    value: function subscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	
	      if (this.filters.indexOf(event) === -1) {
	        var newFilters = this.filters.slice();
	        newFilters.push(event);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          this.base.register().catch(function () {/* do nothing */});
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'unsubscribe',
	    value: function unsubscribe(event) {
	      // TODO normalized error
	      if (!_enum2.default.hasValue.call(_subscriptionEvents.subscriptionEvents, event)) {
	        throw new Error('event is not recognized');
	      }
	      var idx = this.filters.indexOf(event);
	      if (this.filters.indexOf(event) > -1) {
	        var newFilters = this.filters.slice();
	        newFilters.splice(idx, 1);
	        if (this.base) {
	          this.base.setEventFilters(newFilters);
	          this.store.dispatch({
	            type: this.actions.updateFilters,
	            filters: newFilters
	          });
	          if (newFilters.length) {
	            this.base.register().catch(function () {/* do nothing */});
	          } else {
	            this.base.remove();
	          }
	        } else {
	          this[symbols.filterCache] = newFilters;
	        }
	      }
	    }
	  }, {
	    key: 'reset',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	        var oldStatus;
	        return _regenerator2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	
	                if (!this.base) {
	                  _context2.next = 9;
	                  break;
	                }
	
	                if (!(this.status === _subscriptionStatus2.default.subscribed)) {
	                  _context2.next = 7;
	                  break;
	                }
	
	                _context2.next = 5;
	                return this.base.remove();
	
	              case 5:
	                _context2.next = 9;
	                break;
	
	              case 7:
	                _context2.next = 9;
	                return this.base.reset();
	
	              case 9:
	                _context2.next = 13;
	                break;
	
	              case 11:
	                _context2.prev = 11;
	                _context2.t0 = _context2['catch'](0);
	
	              case 13:
	                this[symbols.subscription] = null;
	                oldStatus = this.status;
	
	                this.store.dispatch({
	                  type: this.actions.updateStatus,
	                  status: _subscriptionStatus2.default.notSubscribed,
	                  subscription: null
	                });
	                if (oldStatus !== this.status) {
	                  _utils.emit.call(this, _subscriptionEvents.subscriptionEventTypes.statusChanged, this.status);
	                }
	
	              case 17:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[0, 11]]);
	      }));
	
	      function reset() {
	        return ref.apply(this, arguments);
	      }
	
	      return reset;
	    }()
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _subscriptionReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'status',
	    get: function get() {
	      return this.state.status;
	    }
	  }, {
	    key: 'filters',
	    get: function get() {
	      return this[symbols.filterCache] || this.state.filters;
	    }
	  }, {
	    key: 'base',
	    get: function get() {
	      return this[symbols.subscription];
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _subscriptionEvents.subscriptionEventTypes;
	    }
	  }]);
	  return Subscription;
	}(_rcModule2.default);
	
	exports.default = Subscription;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(8)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['updateFilters', 'notification', 'updateStatus'], 'subscription');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getSubscriptionReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _subscriptionActions = __webpack_require__(195);
	
	var _subscriptionActions2 = _interopRequireDefault(_subscriptionActions);
	
	var _subscriptionEvents = __webpack_require__(197);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  cacheKey: null,
	  filters: [],
	  status: _subscriptionEvents.subscriptionEvents.pending
	};
	
	function getSubscriptionReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_subscriptionActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	      case actions.updateStatus:
	        return (0, _assign2.default)({}, state, {
	          status: action.status,
	          subscription: actions.subscription
	        });
	
	      case actions.updateFilters:
	        return (0, _assign2.default)({}, state, {
	          filters: action.filters.slice()
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.subscriptionEventTypes = exports.subscriptionEvents = undefined;
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _subscriptionStatus = __webpack_require__(198);
	
	var _subscriptionStatus2 = _interopRequireDefault(_subscriptionStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinition = (0, _extends3.default)({
	  message: '/restapi/v1.0/account/~/extension/~/message-store',
	  presence: '/restapi/v1.0/account/~/extension/~/presence',
	  telephony: '/restapi/v1.0/account/~/extension/~/presence?detailedTelephonyState=true',
	  line: '/restapi/v1.0/account/~/extension/~/presence/line',
	  linePresence: '/restapi/v1.0/account/~/extension/~/presence/line/presence',
	  lineTelephony: '/restapi/v1.0/account/~/extension/~/presence/line/presence?detailedTelephonyState=true'
	}, _subscriptionStatus2.default);
	
	var subscriptionEvents = exports.subscriptionEvents = new _enum2.default(eventDefinition);
	
	var eventTypeDefinition = {
	  notification: 'NOTIFICATION',
	  statusChanged: 'STATUS_CHANGED'
	};
	
	var subscriptionEventTypes = exports.subscriptionEventTypes = new _enum2.default(eventTypeDefinition);

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  pending: 'PENDING',
	  subscribed: 'SUBSCRIBED',
	  notSubscribed: 'NOT_SUBSCRIBED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(180);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	// const initialState = {
	//   test: true,
	// };
	
	// function getUserSettingsReducer(prefix) {
	//   return (state, action) => {
	//     if (typeof state === 'undefined') return Object.assign({}, initialState);
	//     if (!action) return state;
	//     switch (action.type) {
	//       default:
	//         return state;
	//     }
	//   };
	// }
	
	/**
	 * @function
	 * @param {String} dataType
	 * @param {function} loadFunction - async loader function returning a promise
	 * @return {Promise}
	 * @description Generic data loading logic with events
	 */
	
	var loadData = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(dataType, loadFunction) {
	    var payload;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            this.store.dispatch({
	              type: this.actions['load' + dataType]
	            });
	            this.emit(_userEvents.userEvents['load' + dataType]);
	            _context.prev = 2;
	            _context.next = 5;
	            return loadFunction.call(this);
	
	          case 5:
	            payload = _context.sent;
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Success'],
	              payload: payload
	            });
	            _utils.emit.call(this, _userEvents.userEventTypes.userInfoChanged, _userEvents.userEvents['load' + dataType + 'Success']);
	            _context.next = 15;
	            break;
	
	          case 10:
	            _context.prev = 10;
	            _context.t0 = _context['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions['load' + dataType + 'Failed']
	            });
	            this.emit(_userEvents.userEvents['load' + dataType + 'Failed']);
	            throw _context.t0;
	
	          case 15:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[2, 10]]);
	  }));
	  return function loadData(_x, _x2) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise<Object>}
	 * @description Fetch account info and extract the data
	 */
	
	
	var extractAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return this[symbols.api].account().loadAccount();
	
	          case 2:
	            _context2.t0 = _context2.sent;
	            return _context2.abrupt('return', (0, _utils.extractData)(_context2.t0));
	
	          case 4:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function extractAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadAccountInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return loadData.call(this, 'AccountInfo', extractAccountInfo);
	
	          case 2:
	            return _context3.abrupt('return', _context3.sent);
	
	          case 3:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function loadAccountInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return this[symbols.api].extension().loadExtensionInfo();
	
	          case 2:
	            _context4.t0 = _context4.sent;
	            return _context4.abrupt('return', (0, _utils.extractData)(_context4.t0));
	
	          case 4:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function extractExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadExtensionInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return loadData.call(this, 'ExtensionInfo', extractExtensionInfo);
	
	          case 2:
	            return _context5.abrupt('return', _context5.sent);
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function loadExtensionInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
	    var _this = this;
	
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this[symbols.api].account().listDialingPlans(options);
	            });
	
	          case 2:
	            _context6.t0 = _context6.sent;
	            return _context6.abrupt('return', (0, _utils.extractData)(_context6.t0));
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function extractDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadDialingPlans = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            _context7.next = 2;
	            return loadData.call(this, 'DialingPlans', extractDialingPlans);
	
	          case 2:
	            return _context7.abrupt('return', _context7.sent);
	
	          case 3:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function loadDialingPlans() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
	    var _this2 = this;
	
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            _context8.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this2[symbols.api].extension().listExtensionPhoneNumbers(options);
	            });
	
	          case 2:
	            _context8.t0 = _context8.sent;
	            return _context8.abrupt('return', (0, _utils.extractData)(_context8.t0));
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function extractPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadPhoneNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9() {
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            _context9.next = 2;
	            return loadData.call(this, 'PhoneNumbers', extractPhoneNumbers);
	
	          case 2:
	            return _context9.abrupt('return', _context9.sent);
	
	          case 3:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this);
	  }));
	  return function loadPhoneNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	    var _this3 = this;
	
	    return _regenerator2.default.wrap(function _callee10$(_context10) {
	      while (1) {
	        switch (_context10.prev = _context10.next) {
	          case 0:
	            _context10.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this3[symbols.api].forwardingNumbers().listExtensionForwardingNumbers(options);
	            });
	
	          case 2:
	            _context10.t0 = _context10.sent;
	            return _context10.abrupt('return', (0, _utils.extractData)(_context10.t0));
	
	          case 4:
	          case 'end':
	            return _context10.stop();
	        }
	      }
	    }, _callee10, this);
	  }));
	  return function extractForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadForwardingNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11() {
	    return _regenerator2.default.wrap(function _callee11$(_context11) {
	      while (1) {
	        switch (_context11.prev = _context11.next) {
	          case 0:
	            _context11.next = 2;
	            return loadData.call(this, 'ForwardingNumbers', extractForwardingNumbers);
	
	          case 2:
	            return _context11.abrupt('return', _context11.sent);
	
	          case 3:
	          case 'end':
	            return _context11.stop();
	        }
	      }
	    }, _callee11, this);
	  }));
	  return function loadForwardingNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var extractBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
	    var _this4 = this;
	
	    return _regenerator2.default.wrap(function _callee12$(_context12) {
	      while (1) {
	        switch (_context12.prev = _context12.next) {
	          case 0:
	            _context12.next = 2;
	            return _utils.fetchList.call(this, function (options) {
	              return _this4[symbols.api].blockedNumbers().listBlockedNumbers(options);
	            });
	
	          case 2:
	            _context12.t0 = _context12.sent;
	            return _context12.abrupt('return', (0, _utils.extractData)(_context12.t0));
	
	          case 4:
	          case 'end':
	            return _context12.stop();
	        }
	      }
	    }, _callee12, this);
	  }));
	  return function extractBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var loadBlockedNumbers = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	    return _regenerator2.default.wrap(function _callee13$(_context13) {
	      while (1) {
	        switch (_context13.prev = _context13.next) {
	          case 0:
	            _context13.next = 2;
	            return loadData.call(this, 'BlockedNumbers', extractBlockedNumbers);
	
	          case 2:
	            return _context13.abrupt('return', _context13.sent);
	
	          case 3:
	          case 'end':
	            return _context13.stop();
	        }
	      }
	    }, _callee13, this);
	  }));
	  return function loadBlockedNumbers() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @function
	 * @return {Promise}
	 */
	
	
	var loadInfo = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14() {
	    return _regenerator2.default.wrap(function _callee14$(_context14) {
	      while (1) {
	        switch (_context14.prev = _context14.next) {
	          case 0:
	            _context14.prev = 0;
	            _context14.next = 3;
	            return _promise2.default.all([loadAccountInfo.call(this), loadExtensionInfo.call(this), loadDialingPlans.call(this), loadPhoneNumbers.call(this), loadForwardingNumbers.call(this), loadBlockedNumbers.call(this)]);
	
	          case 3:
	            _context14.next = 8;
	            break;
	
	          case 5:
	            _context14.prev = 5;
	            _context14.t0 = _context14['catch'](0);
	
	            // TODO send error out
	            console.log(_context14.t0);
	
	          case 8:
	          case 'end':
	            return _context14.stop();
	        }
	      }
	    }, _callee14, this, [[0, 5]]);
	  }));
	  return function loadInfo() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	/**
	 * @class User
	 * @extends RcModule
	 * @default
	 * @export
	 */
	
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _utils = __webpack_require__(191);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	var _userReducer = __webpack_require__(201);
	
	var _userReducer2 = _interopRequireDefault(_userReducer);
	
	var _userEvents = __webpack_require__(202);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'settings']);
	var User = function (_RcModule) {
	  (0, _inherits3.default)(User, _RcModule);
	
	  /**
	   * @function
	   * @param {Object} options
	   */
	
	  function User(options) {
	    var _this6 = this;
	
	    (0, _classCallCheck3.default)(this, User);
	
	    var _this5 = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(User).call(this, (0, _extends3.default)({}, options, {
	      actions: _userActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this5[symbols.api] = api;
	    _this5[symbols.platform] = platform;
	    _this5[symbols.settings] = settings;
	
	    // settings.registerReducer('user', getUserSettingsReducer());
	
	    // load info on login
	    platform.on(platform.events.loginSuccess, function () {
	      loadInfo.call(_this5);
	    });
	    // unload info on logout
	    platform.on(platform.events.logoutSuccess, function () {
	      _this5.store.dispatch({
	        type: _this5.actions.clearUserInfo
	      });
	      // this.emit(userEvents.userInfoCleared);
	    });
	
	    // load info if already logged in
	    (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15() {
	      return _regenerator2.default.wrap(function _callee15$(_context15) {
	        while (1) {
	          switch (_context15.prev = _context15.next) {
	            case 0:
	              _context15.next = 2;
	              return platform.loggedIn();
	
	            case 2:
	              if (!_context15.sent) {
	                _context15.next = 5;
	                break;
	              }
	
	              _context15.next = 5;
	              return loadInfo.call(_this5);
	
	            case 5:
	            case 'end':
	              return _context15.stop();
	          }
	        }
	      }, _callee15, _this6);
	    }))();
	
	    /**
	     * TODO:
	     *   1. Dialing Plan Checking
	     */
	    return _this5;
	  }
	
	  (0, _createClass3.default)(User, [{
	    key: 'reducer',
	    get: function get() {
	      return (0, _userReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'events',
	    get: function get() {
	      return _userEvents.userEvents;
	    }
	  }, {
	    key: 'eventTypes',
	    get: function get() {
	      return _userEvents.userEventTypes;
	    }
	  }, {
	    key: 'directNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.usageType === 'DirectNumber';
	      });
	    }
	  }, {
	    key: 'mainCompanyNumber',
	    get: function get() {
	      return this.state.phoneNumbers.find(function (n) {
	        return n.usageType === 'MainCompanyNumber';
	      });
	    }
	  }, {
	    key: 'dialingPlans',
	    get: function get() {
	      return this.state.dialingPlans;
	    }
	  }, {
	    key: 'extensionNumber',
	    get: function get() {
	      return this.state.extensionInfo.extensionNumber;
	    }
	  }, {
	    key: 'smsNumbers',
	    get: function get() {
	      return this.state.phoneNumbers.filter(function (n) {
	        return n.features.indexOf('SmsSender') > -1;
	      });
	    }
	  }]);
	  return User;
	}(_rcModule2.default);
	
	exports.default = User;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['clearUserInfo', 'loadAccountInfo', 'loadAccountInfoSuccess', 'loadAccountInfoFailed', 'loadExtensionInfo', 'loadExtensionInfoSuccess', 'loadExtensionInfoFailed', 'loadDialingPlans', 'loadDialingPlansSuccess', 'loadDialingPlansFailed', 'loadPhoneNumbers', 'loadPhoneNumbersSuccess', 'loadPhoneNumbersFailed', 'loadForwardingNumbers', 'loadForwardingNumbersSuccess', 'loadForwardingNumbersFailed', 'loadBlockedNumbers', 'loadBlockedNumbersSuccess', 'loadBlockedNumbersFailed'], 'user');

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getUserReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _userActions = __webpack_require__(200);
	
	var _userActions2 = _interopRequireDefault(_userActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  accountInfo: null,
	  accountInfoLoading: false,
	  accountInfoError: null,
	
	  extensionInfo: null,
	  extensionInfoLoading: false,
	  extensionInfoError: null,
	
	  dialingPlans: [],
	  dialingPlansLoading: false,
	  dialingPlansError: null,
	
	  phoneNumbers: [],
	  phoneNumbersLoading: false,
	  phoneNumbersError: null,
	
	  forwardingNumbers: [],
	  forwardingNumbersLoading: false,
	  forwardingNumbersError: null,
	
	  blockedNumbers: [],
	  blockedNumbersLoading: false,
	  blockedNumbersError: null
	};
	
	function getUserReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_userActions2.default, prefix);
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      // account info
	      case actions.loadAccountInfo:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: true
	        });
	      case actions.loadAccountInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          accountInfo: action.payload,
	          accountInfoLoading: false,
	          accountInfoError: null
	        });
	      case actions.loadAccountInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          accountInfoLoading: false,
	          accountInfoError: action.error
	        });
	
	      // extension info
	      case actions.loadExtensionInfo:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: true
	        });
	      case actions.loadExtensionInfoSuccess:
	        return (0, _assign2.default)({}, state, {
	          extensionInfo: action.payload,
	          extensionInfoLoading: false,
	          extensionInfoError: null
	        });
	      case actions.loadExtensionInfoFailed:
	        return (0, _assign2.default)({}, state, {
	          extensionInfoLoading: false,
	          extensionInfoError: action.error
	        });
	
	      // dialing plans
	      case actions.loadDialingPlans:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: true
	        });
	      case actions.loadDialingPlansSuccess:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlans: action.payload
	        });
	      case action.loadDialingPlansFailed:
	        return (0, _assign2.default)({}, state, {
	          dialingPlansLoading: false,
	          dialingPlansError: action.error
	        });
	
	      // phone numbers
	      case actions.loadPhoneNumbers:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: true
	        });
	      case actions.loadPhoneNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbers: action.payload
	        });
	      case action.loadPhoneNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          phoneNumbersLoading: false,
	          phoneNumbersError: action.error
	        });
	
	      // forwarding numbers
	      case actions.loadForwardingNumbers:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: true
	        });
	      case actions.loadForwardingNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbers: action.payload
	        });
	      case action.loadForwardingNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          forwardingNumbersLoading: false,
	          forwardingNumbersError: action.error
	        });
	
	      // blocked numbers
	      case actions.loadBlockedNumbers:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: true
	        });
	      case actions.loadBlockedNumbersSuccess:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbers: action.payload
	        });
	      case action.loadBlockedNumbersFailed:
	        return (0, _assign2.default)({}, state, {
	          blockedNumbersLoading: false,
	          blockedNumbersError: action.error
	        });
	
	      case action.clearUserInfo:
	        return (0, _assign2.default)({}, initialState);
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.userEventTypes = exports.userEvents = undefined;
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var eventDefinitions = {
	  userInfoLoaded: 'USER_INFO_LOADED',
	  userInfoCleared: 'USER_INFO_CLEARED',
	
	  loadAccountInfo: 'LOAD_ACCOUNT_INFO',
	  loadAccountInfoSuccess: 'LOAD_ACCOUNT_INFO_SUCCESS',
	  loadAccountInfoFailed: 'LOAD_ACCOUNT_INFO_FAILED',
	
	  loadExtensionInfo: 'LOAD_EXTENSION_INFO',
	  loadExtensionInfoSuccess: 'LOAD_EXTENSION_INFO_SUCCESS',
	  loadExtensionInfoFailed: 'LOAD_EXTENSION_INFO_FAILED',
	
	  loadDialingPlans: 'LOAD_DIALING_PLANS',
	  loadDialingPlansSuccess: 'LOAD_DIALING_PLANS_SUCCESS',
	  loadDialingPlansFailed: 'LOAD_DIALING_PLANS_FAILED',
	
	  loadPhoneNumbers: 'LOAD_PHONE_NUMBERS',
	  loadPhoneNumbersSuccess: 'LOAD_PHONE_NUMBERS_SUCCESS',
	  loadPhoneNumbersFailed: 'LOAD_PHONE_NUMBERS_FAILED',
	
	  loadForwardingNumbers: 'LOAD_FORWARDING_NUMBERS',
	  loadForwardingNumbersSuccess: 'LOAD_FORWARDING_NUMBERS_SUCCESS',
	  loadForwardingNumbersFailed: 'LOAD_FORWARDING_NUMBERS_FAILED',
	
	  loadBlockedNumbers: 'LOAD_BLOCKED_NUMBERS',
	  loadBlockedNumbersSuccess: 'LOAD_BLOCKED_NUMBERS_SUCCESS',
	  loadBlockedNumbersFailed: 'LOAD_BLOCKED_NUMBERS_FAILED'
	};
	
	var userEvents = exports.userEvents = new _enum2.default(eventDefinitions);
	
	var eventTypeDefinitions = {
	  userInfoChanged: 'USER_INFO_CHANGED'
	};
	
	var userEventTypes = exports.userEventTypes = new _enum2.default(eventTypeDefinitions);

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(2);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _getPrototypeOf = __webpack_require__(40);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(70);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(71);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(75);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(94);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _regenerator = __webpack_require__(176);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _asyncToGenerator2 = __webpack_require__(179);
	
	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
	
	var initPhoneInstance = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
	    var info;
	    return _regenerator2.default.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return this[symbols.platform].post('/client-info/sip-provision', {
	              sipInfo: [{ transport: 'WSS' }]
	            }).then(function (res) {
	              return res.json();
	            });
	
	          case 2:
	            info = _context.sent;
	            return _context.abrupt('return', new _ringcentralWebPhone2.default(info, {
	              logLevel: 0,
	              audioHelper: {
	                enabled: true
	              }
	            }));
	
	          case 4:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	  return function initPhoneInstance() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var record = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (flag) {
	              _context2.next = 6;
	              break;
	            }
	
	            _context2.next = 3;
	            return this.currentSession.stopRecord();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.stopRecord
	              }
	            });
	            _context2.next = 9;
	            break;
	
	          case 6:
	            _context2.next = 8;
	            return this.currentSession.startRecord();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.record
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	  return function record(_x) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var mute = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if (flag) {
	              _context3.next = 6;
	              break;
	            }
	
	            _context3.next = 3;
	            return this.currentSession.unmute();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unmute
	              }
	            });
	            _context3.next = 9;
	            break;
	
	          case 6:
	            _context3.next = 8;
	            return this.currentSession.mute();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.mute
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	  return function mute(_x3) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var hold = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
	    var flag = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	    return _regenerator2.default.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            if (flag) {
	              _context4.next = 6;
	              break;
	            }
	
	            _context4.next = 3;
	            return this.currentSession.unhold();
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.unhold
	              }
	            });
	            _context4.next = 9;
	            break;
	
	          case 6:
	            _context4.next = 8;
	            return this.currentSession.hold();
	
	          case 8:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.hold
	              }
	            });
	
	          case 9:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this);
	  }));
	  return function hold(_x5) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var park = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
	    return _regenerator2.default.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return this.currentSession.park();
	
	          case 2:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.park
	              }
	            });
	
	          case 3:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	  return function park() {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var transfer = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(number) {
	    return _regenerator2.default.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            this.checkSession();
	            _context6.next = 3;
	            return this.currentSession.transfer(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.transfer,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	  return function transfer(_x7) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var flip = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(number) {
	    return _regenerator2.default.wrap(function _callee7$(_context7) {
	      while (1) {
	        switch (_context7.prev = _context7.next) {
	          case 0:
	            this.checkSession();
	            _context7.next = 3;
	            return this.currentSession.flip(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.flip,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context7.stop();
	        }
	      }
	    }, _callee7, this);
	  }));
	  return function flip(_x8) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var dtmf = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(number) {
	    return _regenerator2.default.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            this.checkSession();
	            _context8.next = 3;
	            return this.currentSession.dtmf(number);
	
	          case 3:
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.dtmf,
	                payload: {
	                  number: number
	                }
	              }
	            });
	
	          case 4:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	  return function dtmf(_x9) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var operations = function () {
	  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(name) {
	    var actions,
	        _actions$name,
	        _len,
	        args,
	        _key,
	        _args9 = arguments;
	
	    return _regenerator2.default.wrap(function _callee9$(_context9) {
	      while (1) {
	        switch (_context9.prev = _context9.next) {
	          case 0:
	            actions = { record: record, mute: mute, hold: hold, park: park, transfer: transfer, flip: flip, dtmf: dtmf };
	
	            this.checkSession();
	            _context9.prev = 2;
	
	            for (_len = _args9.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	              args[_key - 1] = _args9[_key];
	            }
	
	            _context9.next = 6;
	            return (_actions$name = actions[name]).call.apply(_actions$name, [this].concat(args));
	
	          case 6:
	            _context9.next = 12;
	            break;
	
	          case 8:
	            _context9.prev = 8;
	            _context9.t0 = _context9['catch'](2);
	
	            this.store.dispatch({
	              type: this.actions.callOperation,
	              operation: {
	                type: _callActions2.default.error,
	                error: _context9.t0
	              }
	            });
	            // TODO: needed?
	            throw _context9.t0;
	
	          case 12:
	          case 'end':
	            return _context9.stop();
	        }
	      }
	    }, _callee9, this, [[2, 8]]);
	  }));
	  return function operations(_x10, _x11) {
	    return ref.apply(this, arguments);
	  };
	}();
	
	var _rcModule = __webpack_require__(133);
	
	var _rcModule2 = _interopRequireDefault(_rcModule);
	
	var _symbolMap = __webpack_require__(134);
	
	var _symbolMap2 = _interopRequireDefault(_symbolMap);
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _webphoneReducer = __webpack_require__(206);
	
	var _webphoneReducer2 = _interopRequireDefault(_webphoneReducer);
	
	var _eventEmitter = __webpack_require__(137);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _ringcentralWebPhone = __webpack_require__(210);
	
	var _ringcentralWebPhone2 = _interopRequireDefault(_ringcentralWebPhone);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var symbols = new _symbolMap2.default(['api', 'platform', 'emitter', 'settings', 'phoneInstance']);
	
	var ENUMS = new _enum2.default({
	  webphoneStatus: _webphoneStatus2.default,
	  callStatus: _callStatus2.default
	});
	
	var Webphone = function (_RcModule) {
	  (0, _inherits3.default)(Webphone, _RcModule);
	
	  function Webphone(options) {
	    var _this2 = this;
	
	    (0, _classCallCheck3.default)(this, Webphone);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (0, _getPrototypeOf2.default)(Webphone).call(this, (0, _extends3.default)({}, options, {
	      actions: _webphoneActions2.default
	    })));
	
	    var api = options.api;
	    var platform = options.platform;
	    var settings = options.settings;
	
	    _this[symbols.api] = api;
	    _this[symbols.platform] = platform;
	    _this[symbols.emitter] = new _eventEmitter2.default();
	    _this[symbols.settings] = settings;
	
	    _this.currentSession = null;
	    _this.isRegistered = false;
	
	    // TODO: commented out until setting module completed
	    // settings.registerReducer('webphone', getWebphoneReducer())
	
	    platform.on(platform.events.loginSuccess, (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10() {
	      return _regenerator2.default.wrap(function _callee10$(_context10) {
	        while (1) {
	          switch (_context10.prev = _context10.next) {
	            case 0:
	              _context10.next = 2;
	              return initPhoneInstance.call(_this);
	
	            case 2:
	              _this[symbols.phoneInstance] = _context10.sent;
	
	              _this[symbols.phoneInstance].userAgent.on('registered', function () {
	                // sip will fire multiple registered events, only dispatch one register action to state.
	                // TODO: is this isRegistered state needed to be store as instance variable
	                //       or just check store state
	                if (!_this.isRegistered) {
	                  _this.store.dispatch({
	                    type: _this.actions.registerSuccess
	                  });
	                }
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	              });
	              _this[symbols.phoneInstance].userAgent.on('unregistered', function () {
	                _this.isRegistered = _this[symbols.phoneInstance].userAgent.isRegistered();
	                _this.store.dispatch({
	                  type: _this.actions.unregister,
	                  operation: {
	                    type: _callActions2.default.clear
	                  }
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('registrationFailed', function (error) {
	                _this.store.dispatch({
	                  type: _this.actions.registerError,
	                  error: error
	                });
	              });
	              _this[symbols.phoneInstance].userAgent.on('invite', function (session) {
	                _this.currentSession = session;
	                _this.listenSessionEvents();
	                console.log(session);
	                _this.store.dispatch({
	                  type: _this.actions.callIncoming,
	                  payload: {
	                    remoteIdentity: session.remoteIdentity,
	                    localIdentity: session.localIdentity
	                  }
	                });
	              });
	
	            case 7:
	            case 'end':
	              return _context10.stop();
	          }
	        }
	      }, _callee10, _this2);
	    })));
	    return _this;
	  }
	
	  (0, _createClass3.default)(Webphone, [{
	    key: 'call',
	
	
	    /**
	     * Make a phone call, this method should be called in registerSuccess state
	     * @param {string} toNumber
	     * @param {string} [fromNumber]
	     * @return {Session}
	     */
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(_ref) {
	        var toNumber = _ref.toNumber;
	        var fromNumber = _ref.fromNumber;
	        var media = _ref.media;
	        return _regenerator2.default.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                if (this[symbols.phoneInstance]) {
	                  _context11.next = 2;
	                  break;
	                }
	
	                throw Error('not registered');
	
	              case 2:
	                this.store.dispatch({
	                  type: this.actions.call,
	                  payload: {
	                    toNumber: toNumber,
	                    fromNumber: fromNumber
	                  }
	                });
	                this.currentSession = this[symbols.phoneInstance].userAgent.invite(toNumber, {
	                  media: {
	                    render: media
	                  }
	                });
	                this.listenSessionEvents();
	                _context11.prev = 5;
	                _context11.next = 8;
	                return this.currentSession;
	
	              case 8:
	                _context11.next = 14;
	                break;
	
	              case 10:
	                _context11.prev = 10;
	                _context11.t0 = _context11['catch'](5);
	
	                console.error(_context11.t0);
	                this.store.dispatch({
	                  type: this.actions.callError,
	                  error: _context11.t0
	                });
	
	              case 14:
	                return _context11.abrupt('return', this.currentSession);
	
	              case 15:
	              case 'end':
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this, [[5, 10]]);
	      }));
	
	      function call(_x12) {
	        return ref.apply(this, arguments);
	      }
	
	      return call;
	    }()
	
	    /**
	     * Accept a phone call, this method should be called when call is incoming
	     * @param {Object} media, see https://github.com/ringcentral/ringcentral-web-phone#accepting-incoming-call
	     * @return {Promise}
	     */
	
	  }, {
	    key: 'accept',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12(media) {
	        return _regenerator2.default.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                this.checkSession();
	                _context12.prev = 1;
	                _context12.next = 4;
	                return this.currentSession.accept(media);
	
	              case 4:
	                _context12.next = 9;
	                break;
	
	              case 6:
	                _context12.prev = 6;
	                _context12.t0 = _context12['catch'](1);
	
	                // TODO
	                console.error(_context12.t0);
	
	              case 9:
	              case 'end':
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this, [[1, 6]]);
	      }));
	
	      function accept(_x13) {
	        return ref.apply(this, arguments);
	      }
	
	      return accept;
	    }()
	  }, {
	    key: 'bye',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
	        return _regenerator2.default.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                this.checkSession();
	                _context13.prev = 1;
	                _context13.next = 4;
	                return this.currentSession.terminate();
	
	              case 4:
	                _context13.next = 9;
	                break;
	
	              case 6:
	                _context13.prev = 6;
	                _context13.t0 = _context13['catch'](1);
	
	                // TODO
	                console.error(_context13.t0);
	
	              case 9:
	              case 'end':
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this, [[1, 6]]);
	      }));
	
	      function bye() {
	        return ref.apply(this, arguments);
	      }
	
	      return bye;
	    }()
	  }, {
	    key: 'record',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14(flag) {
	        return _regenerator2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                operations.call(this, 'record', flag);
	
	              case 1:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));
	
	      function record(_x14) {
	        return ref.apply(this, arguments);
	      }
	
	      return record;
	    }()
	  }, {
	    key: 'mute',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15(flag) {
	        return _regenerator2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                operations.call(this, 'mute', flag);
	
	              case 1:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));
	
	      function mute(_x15) {
	        return ref.apply(this, arguments);
	      }
	
	      return mute;
	    }()
	  }, {
	    key: 'hold',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16(flag) {
	        return _regenerator2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                operations.call(this, 'hold', flag);
	
	              case 1:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));
	
	      function hold(_x16) {
	        return ref.apply(this, arguments);
	      }
	
	      return hold;
	    }()
	  }, {
	    key: 'park',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17(flag) {
	        return _regenerator2.default.wrap(function _callee17$(_context17) {
	          while (1) {
	            switch (_context17.prev = _context17.next) {
	              case 0:
	                operations.call(this, 'park', flag);
	
	              case 1:
	              case 'end':
	                return _context17.stop();
	            }
	          }
	        }, _callee17, this);
	      }));
	
	      function park(_x17) {
	        return ref.apply(this, arguments);
	      }
	
	      return park;
	    }()
	  }, {
	    key: 'transfer',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18(number) {
	        return _regenerator2.default.wrap(function _callee18$(_context18) {
	          while (1) {
	            switch (_context18.prev = _context18.next) {
	              case 0:
	                operations.call(this, 'transfer', number);
	
	              case 1:
	              case 'end':
	                return _context18.stop();
	            }
	          }
	        }, _callee18, this);
	      }));
	
	      function transfer(_x18) {
	        return ref.apply(this, arguments);
	      }
	
	      return transfer;
	    }()
	  }, {
	    key: 'flip',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19(number) {
	        return _regenerator2.default.wrap(function _callee19$(_context19) {
	          while (1) {
	            switch (_context19.prev = _context19.next) {
	              case 0:
	                operations.call(this, 'flip', number);
	
	              case 1:
	              case 'end':
	                return _context19.stop();
	            }
	          }
	        }, _callee19, this);
	      }));
	
	      function flip(_x19) {
	        return ref.apply(this, arguments);
	      }
	
	      return flip;
	    }()
	  }, {
	    key: 'dtmf',
	    value: function () {
	      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20(number) {
	        return _regenerator2.default.wrap(function _callee20$(_context20) {
	          while (1) {
	            switch (_context20.prev = _context20.next) {
	              case 0:
	                operations.call(this, 'dtmf', number);
	
	              case 1:
	              case 'end':
	                return _context20.stop();
	            }
	          }
	        }, _callee20, this);
	      }));
	
	      function dtmf(_x20) {
	        return ref.apply(this, arguments);
	      }
	
	      return dtmf;
	    }()
	  }, {
	    key: 'loadRingAudio',
	    value: function loadRingAudio(_ref2) {
	      var incoming = _ref2.incoming;
	      var outgoing = _ref2.outgoing;
	
	      this[symbols.phoneInstance].userAgent.audioHelper.loadAudio({
	        incoming: incoming,
	        outgoing: outgoing
	      });
	    }
	  }, {
	    key: 'checkSession',
	    value: function checkSession() {
	      if (!this.currentSession) {
	        this.store.dispatch({
	          type: this.actions.sessionError
	        });
	        throw Error('No active session');
	      }
	    }
	
	    /**
	     * Internal method for listen session events
	     */
	
	  }, {
	    key: 'listenSessionEvents',
	    value: function listenSessionEvents() {
	      var _this3 = this;
	
	      this.currentSession.on('accepted', function (response) {
	        console.log(response);
	        // accepted event for outbound call will returne a incomingResponse
	        if (response.data) {
	          _this3.store.dispatch({
	            type: _this3.actions.callConnect,
	            payload: {
	              remoteIdentity: response.to,
	              localIdentity: response.from
	            }
	          });
	          // accepted event for inbound call will only contain a row sip data
	        } else {
	          _this3.store.dispatch({
	            type: _this3.actions.callAccept
	          });
	        }
	      });
	      // all situation about call terminated except 'call cancel'
	      this.currentSession.on('terminated', function (response, cause) {
	        console.log(response);
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // when we call out and cancel the phone call
	      this.currentSession.on('cancel', function (response, cause) {
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd,
	          error: cause
	        });
	        _this3.currentSession = null;
	      });
	      // should not need
	      this.currentSession.on('bye', function (response) {
	        console.log(response);
	        _this3.store.dispatch({
	          type: _this3.actions.callEnd
	        });
	        _this3.currentSession = null;
	      });
	    }
	  }, {
	    key: 'reducer',
	    get: function get() {
	      return (0, _webphoneReducer2.default)(this.prefix);
	    }
	  }, {
	    key: 'enums',
	    get: function get() {
	      return ENUMS;
	    }
	  }]);
	  return Webphone;
	}(_rcModule2.default);
	
	exports.default = Webphone;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap(['register', 'registerSuccess', 'registerError', 'unregister',
	
	// outbound call
	'call', 'callConnect',
	// inbound call
	'callAccept', 'callIncoming', 'callEnd', 'callError', 'callOperation',
	// no active session
	'sessionError']);

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _reduxHelper = __webpack_require__(136);
	
	exports.default = new _reduxHelper.ActionMap([
	// operational error
	'error',
	// unregister, clear operational state
	'clear',
	// operation
	'flip', 'record', 'stopRecord', 'hold', 'unhold', 'mute', 'unmute', 'park', 'transfer', 'forward', 'dtmf']);

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = getReducer;
	
	var _reduxHelper = __webpack_require__(136);
	
	var _webphoneActions = __webpack_require__(204);
	
	var _webphoneActions2 = _interopRequireDefault(_webphoneActions);
	
	var _webphoneStatus = __webpack_require__(207);
	
	var _webphoneStatus2 = _interopRequireDefault(_webphoneStatus);
	
	var _callReducer = __webpack_require__(208);
	
	var _callReducer2 = _interopRequireDefault(_callReducer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  status: _webphoneStatus2.default.preRegister,
	  // assign from UI
	  toNumber: '',
	  fromNumber: '',
	  // sip info return from sip server
	  remoteIdentity: null,
	  localIdentity: null,
	  operation: (0, _callReducer2.default)(),
	  error: null
	};
	
	function getReducer(prefix) {
	  var actions = (0, _reduxHelper.prefixActions)(_webphoneActions2.default, prefix);
	
	  return function (state, action) {
	    if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	    if (!action) return state;
	    switch (action.type) {
	
	      case actions.registerSuccess:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerSuccessed
	        });
	      case actions.registerError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.registerFailed,
	          error: action.error
	        });
	      case actions.unregister:
	        return initialState;
	      case actions.call:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnecting,
	          toNumber: action.payload.toNumber,
	          fromNumber: action.payload.fromNumber
	        });
	      case actions.callIncoming:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callIncoming,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      // TODO: update fromNumber, toNumber
	      case actions.callConnect:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected,
	          remoteIdentity: action.payload.remoteIdentity,
	          localIdentity: action.payload.localIdentity
	        });
	      case actions.callAccept:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callConnected
	        });
	      case actions.callEnd:
	        return (0, _assign2.default)({}, initialState, {
	          status: _webphoneStatus2.default.registerSuccessed,
	          error: action.error
	        });
	      case actions.callError:
	        return (0, _assign2.default)({}, state, {
	          status: _webphoneStatus2.default.callFailed,
	          error: action.error
	        });
	      case actions.callOperation:
	        return (0, _assign2.default)({}, state, {
	          operation: (0, _callReducer2.default)(state.operation, action.operation)
	        });
	      case actions.sessionError:
	        return (0, _assign2.default)({}, initialState, {
	          error: action.error
	        });
	
	      default:
	        return state;
	    }
	  };
	}

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  // For registering
	  preRegister: 'PRE_REGISTER',
	  registerSuccessed: 'REGISTER_SUCCESSED',
	  registerFailed: 'REGISTER_FAILED',
	  // For callout and active call
	  callConnecting: 'CALL_CONNECTING',
	  callConnected: 'CALL_CONNECTED',
	  callFailed: 'CALL_FAILED',
	  // For incoming call
	  callIncoming: 'CALL_INCOMING'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assign = __webpack_require__(3);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	exports.default = function (state, action) {
	  if (typeof state === 'undefined') return (0, _assign2.default)({}, initialState);
	  if (!action) return state;
	  switch (action.type) {
	
	    case _callActions2.default.error:
	      return (0, _assign2.default)({}, state, {
	        error: action.error
	      });
	    case _callActions2.default.clear:
	      return (0, _assign2.default)({}, initialState);
	    case _callActions2.default.record:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.recording) ? state.status : state.status.concat(_callStatus2.default.recording)
	      });
	    case _callActions2.default.stopRecord:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.recording)
	      });
	    case _callActions2.default.mute:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.muted) ? state.status : state.status.concat(_callStatus2.default.muted)
	      });
	    case _callActions2.default.unmute:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.muted)
	      });
	    case _callActions2.default.hold:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.holding) ? state.status : state.status.concat(_callStatus2.default.holding),
	        disabled: ['park', 'record']
	      });
	    case _callActions2.default.unhold:
	      return (0, _assign2.default)({}, state, {
	        status: remove(state.status, _callStatus2.default.holding),
	        disabled: []
	      });
	    case _callActions2.default.park:
	      // https://en.wikipedia.org/wiki/Call_parking
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.parker) ? state.status : state.status.concat(_callStatus2.default.parker)
	      });
	    case _callActions2.default.transfer:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.transfered) ? state.status : state.status.concat(_callStatus2.default.transfered),
	        transferTaget: action.payload.number
	      });
	    case _callActions2.default.flip:
	      return (0, _assign2.default)({}, state, {
	        status: contain(state.status, _callStatus2.default.flip) ? state.status : state.status.concat(_callStatus2.default.flip),
	        flipTarget: action.payload.number
	      });
	    case _callActions2.default.dtmf:
	      // TODO: clarify park action
	      return (0, _assign2.default)({}, state, {
	        status: state.status.concat(_callStatus2.default.parked),
	        dtmfNumber: action.payload.number
	      });
	
	    default:
	      return state;
	  }
	};
	
	var _callActions = __webpack_require__(205);
	
	var _callActions2 = _interopRequireDefault(_callActions);
	
	var _callStatus = __webpack_require__(209);
	
	var _callStatus2 = _interopRequireDefault(_callStatus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function contain(arr, ele) {
	  return arr.indexOf(ele) > -1;
	}
	
	function remove(arr, ele) {
	  if (contain(arr, ele)) {
	    arr.splice(arr.indexOf(ele), 1);
	  }
	  return arr;
	}
	
	var initialState = {
	  // operations which is enable
	  status: [],
	  // some operations will disable another, such as 'hold'
	  disabled: [],
	  // some operations have infomation need to be stored
	  transferTaget: null,
	  flipTarget: null,
	  dtmfNumber: null,
	  // operation error
	  error: null
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _enum = __webpack_require__(135);
	
	var _enum2 = _interopRequireDefault(_enum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var definition = {
	  flip: 'FLIPED',
	  recording: 'RECORDING',
	  holding: 'HOLDING',
	  muted: 'MUTED',
	  parked: 'PARKED',
	  transfered: 'TRANSFERED',
	  forwarded: 'FOWARDED'
	};
	
	exports.default = new _enum2.default(definition);

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(211)], __WEBPACK_AMD_DEFINE_RESULT__ = function(SIP) {
	            return factory(SIP);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object') {
	        module.exports = factory(require('sip.js'));
	        module.exports.default = module.exports; //ES6
	    } else {
	        root.RingCentral = root.RingCentral || {};
	        root.RingCentral.WebPhone = factory(root.SIP);
	    }
	}(this, function(SIP) {
	
	    var messages = {
	        park: {reqid: 1, command: 'callpark'},
	        startRecord: {reqid: 2, command: 'startcallrecord'},
	        stopRecord: {reqid: 3, command: 'stopcallrecord'},
	        flip: {reqid: 3, command: 'callflip', target: ''},
	        monitor: {reqid: 4, command: 'monitor'},
	        barge: {reqid: 5, command: 'barge'},
	        whisper: {reqid: 6, command: 'whisper'},
	        takeover: {reqid: 7, command: 'takeover'}
	    };
	
	    var responseTimeout = 10000;
	
	    function uuid() {
	        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
	            return v.toString(16);
	        });
	    }
	
	    function delay(ms) {
	        return new Promise(function(resolve, reject) {
	            setTimeout(resolve, ms);
	        });
	    }
	
	    function extend(dst, src) {
	        src = src || {};
	        dst = dst || {};
	        Object.keys(src).forEach(function(k) {
	            dst[k] = src[k];
	        });
	        return dst;
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param options
	     * @constructor
	     */
	    function AudioHelper(options) {
	
	        options = options || {};
	
	        this._enabled = !!options.enabled;
	        this.loadAudio(options);
	
	    }
	
	    AudioHelper.prototype._playSound = function(url, val, volume) {
	
	        if (!this._enabled || !url) return this;
	
	        if (!this._audio[url]) {
	            if (val) {
	                this._audio[url] = new Audio();
	                this._audio[url].src = url;
	                this._audio[url].loop = true;
	                this._audio[url].volume = volume;
	                this._audio[url].play();
	            }
	        } else {
	            if (val) {
	                this._audio[url].currentTime = 0;
	                this._audio[url].play();
	            } else {
	                this._audio[url].pause();
	            }
	        }
	
	        return this;
	
	    };
	
	    AudioHelper.prototype.loadAudio = function(options) {
	        this._incoming = options.incoming;
	        this._outgoing = options.outgoing;
	        this._audio = {};
	    }
	
	    AudioHelper.prototype.setVolume = function(volume) {
	        if (volume < 0) { volume = 0; }
	        if (volume > 1) { volume = 1; }
	        this.volume = volume;
	        for (var url in this._audio) {
	            if (this._audio.hasOwnProperty(url)) {
	                this._audio[url].volume = volume;
	            }
	        }
	    }
	
	    AudioHelper.prototype.playIncoming = function(val) {
	        return this._playSound(this._incoming, val, (this.volume || 0.5));
	    };
	
	    AudioHelper.prototype.playOutgoing = function(val) {
	        return this._playSound(this._outgoing, val, (this.volume || 1));
	    };
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @param {object} regData
	     * @param {object} [options]
	     * @param {string} [options.uuid]
	     * @param {string} [options.appKey]
	     * @param {string} [options.appName]
	     * @param {string} [options.appVersion]
	     * @param {string} [options.audioHelper]
	     * @param {string} [options.onSession] fired each time UserAgent starts working with session
	     * @constructor
	     */
	    function WebPhone(regData, options) {
	
	        regData = regData || {};
	        options = options || {};
	
	        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;
	        this.sipFlags = regData.sipFlags;
	
	        var id = options.uuid || localStorage.getItem('rc-webPhone-uuid') || uuid(); //TODO Make configurable
	        localStorage.setItem('rc-webPhone-uuid', id);
	
	        this.endpointHeader = 'P-rc-endpoint-id: ' + id;
	
	        var configuration = {
	            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,
	            wsServers: this.sipInfo.outboundProxy && this.sipInfo.transport
	                ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy
	                : this.sipInfo.wsServers,
	            authorizationUser: this.sipInfo.authorizationId,
	            password: this.sipInfo.password,
	            traceSip: true,
	            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?
	            turnServers: [],
	            log: {
	                level: options.logLevel || 1 //FIXME LOG LEVEL 3
	            },
	            domain: this.sipInfo.domain,
	            autostart: true,
	            register: true,
	            iceGatheringTimeout: this.sipInfo.iceGatheringTimeout || 3000
	        };
	
	        this.appKey = options.appKey;
	        this.appName = options.appName;
	        this.appVersion = options.appVersion;
	        this.userAgentHeader = 'RC-User-Agent: ' +
	                               (options.appName ? (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' : '') +
	                               'RCWEBPHONE/' + WebPhone.version;
	
	        this.clientIdHeader = 'Client-id:' + options.appKey;
	
	        this.userAgent = new SIP.UA(configuration).register({
	            extraHeaders: [
	                this.endpointHeader,
	                this.userAgentHeader,
	                this.clientIdHeader
	            ]
	        });
	
	        this.userAgent.endpointHeader = this.endpointHeader;
	        this.userAgent.userAgentHeader = this.userAgentHeader;
	        this.userAgent.clientIdHeader = this.clientIdHeader;
	        this.userAgent.sipInfo = this.sipInfo;
	
	        this.userAgent.__invite = this.userAgent.invite;
	        this.userAgent.invite = invite;
	
	        this.userAgent.on('invite', function(session) {
	            this.userAgent.audioHelper.playIncoming(true);
	            patchSession(session);
	        }.bind(this));
	
	        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);
	
	        this.userAgent.onSession = options.onSession || null;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    WebPhone.version = '0.3.1';
	    WebPhone.uuid = uuid;
	    WebPhone.delay = delay;
	    WebPhone.extend = extend;
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function patchSession(session) {
	
	        if (session.__patched) return session;
	
	        session.__patched = true;
	
	        session.__sendRequest = session.sendRequest;
	        session.__receiveRequest = session.receiveRequest;
	        session.__receiveInviteResponse = session.receiveInviteResponse;
	        session.__receiveResponse = session.receiveResponse;
	        session.__accept = session.accept;
	        session.__hold = session.hold;
	        session.__unhold = session.unhold;
	        session.__dtmf = session.dtmf;
	
	        session.sendRequest = sendRequest;
	        session.receiveRequest = receiveRequest;
	        session.receiveInviteResponse = receiveInviteResponse;
	        session.receiveResponse = receiveResponse;
	        session.accept = accept;
	        session.hold = hold;
	        session.unhold = unhold;
	        session.dtmf = dtmf;
	
	        session.blindTransfer = blindTransfer;
	        session.transfer = transfer;
	        session.park = park;
	        session.forward = forward;
	        session.startRecord = startRecord;
	        session.stopRecord = stopRecord;
	        session.flip = flip;
	
	        session.on('replaced', patchSession);
	        // session.on('connecting', onConnecting);
	
	        // Audio
	        session.on('accepted', stopPlaying);
	        session.on('rejected', stopPlaying);
	        session.on('bye', stopPlaying);
	        session.on('terminated', stopPlaying);
	        session.on('cancel', stopPlaying);
	        session.on('failed', stopPlaying);
	        session.on('replaced', stopPlaying);
	        session.mediaHandler.on('iceConnectionCompleted', stopPlaying);
	        session.mediaHandler.on('iceConnectionFailed', stopPlaying);
	
	        function stopPlaying() {
	            session.ua.audioHelper.playOutgoing(false);
	            session.ua.audioHelper.playIncoming(false);
	            session.removeListener('accepted', stopPlaying);
	            session.removeListener('rejected', stopPlaying);
	            session.removeListener('bye', stopPlaying);
	            session.removeListener('terminated', stopPlaying);
	            session.removeListener('cancel', stopPlaying);
	            session.removeListener('failed', stopPlaying);
	            session.removeListener('replaced', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionCompleted', stopPlaying);
	            session.mediaHandler.removeListener('iceConnectionFailed', stopPlaying);
	        }
	
	        if (session.ua.onSession) session.ua.onSession(session);
	
	        return session;
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {object} command
	     * @param {object} [options]
	     * @return {Promise}
	     */
	    function sendReceive(session, command, options) {
	
	        options = options || {};
	
	        extend(command, options);
	
	        var cseq = null;
	
	        return new Promise(function(resolve, reject) {
	
	            session.sendRequest(SIP.C.INFO, {
	                body: JSON.stringify({
	                    request: command
	                }),
	                extraHeaders: [
	                    "Content-Type: application/json;charset=utf-8",
	                    session.ua.userAgentHeader,
	                    session.ua.endpointHeader,
	                    session.ua.clientIdHeader
	                ],
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 200) {
	                        cseq = response.cseq;
	                        var onInfo = function(request) {
	                            if (response.cseq === cseq) {
	
	                                var body = request && request.body || '{}';
	                                var obj;
	
	                                try {
	                                    obj = JSON.parse(body);
	                                } catch (e) {
	                                    obj = {};
	                                }
	
	                                if (obj.response && obj.response.command === command.command) {
	                                    if (obj.response.result) {
	                                        if (obj.response.result.code == 0) {
	                                            return resolve(obj.response.result);
	                                        } else {
	                                            return reject(obj.response.result);
	                                        }
	                                    }
	                                }
	                                timeout && clearTimeout(timeout);
	                                session.removeListener('RC_SIP_INFO', onInfo);
	                                resolve(null); //FIXME What to resolve
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_INFO', onInfo);
	                        }, responseTimeout);
	                        session.on('RC_SIP_INFO', onInfo);
	                    }
	                    else {
	                        reject(new Error('The INFO response status code is: ' + response.status_code + ' (waiting for 200)'));
	                    }
	                }
	            });
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    function sendRequest(type, config) {
	        if (type == SIP.C.PRACK) {
	            type = SIP.C.ACK;
	        }
	        return this.__sendRequest(type, config);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * Fired each time a provisional (100-199) response is received.
	     * Early media is supported by SIP.js library
	     * But in case it is sent without 100rel support we play it manually
	     * STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	     *
	     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1072388
	     * @param {SIP.Session} session
	     * @param response
	     * @param {funciton} cb
	     */
	    function patch100rel(session, response, cb) {
	
	        //Early media is supported by SIP.js library
	        //But in case it is sent without 100rel support we play it manually
	        //STATUS_EARLY_MEDIA === 11, it will be set by SIP.js if 100rel is supported
	        if (session.status !== SIP.Session.C.STATUS_EARLY_MEDIA && response.status_code === 183 && typeof(response.body) === 'string' && response.body.indexOf('\n') !== -1) {
	            if (!response.hasHeader('require')) response.setHeader('require', '100rel');
	        }
	
	        return cb.call(session, response);
	
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveInviteResponse(response) {
	        return patch100rel(this, response, this.__receiveInviteResponse);
	    }
	
	    /**
	     * @this {SIP.Session}
	     * @param response
	     * @return {*}
	     */
	    function receiveResponse(response) {
	        return patch100rel(this, response, this.__receiveResponse);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setRecord(session, flag) {
	
	        var message = !!flag
	            ? messages.startRecord
	            : messages.stopRecord;
	
	        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {
	            return sendReceive(session, message)
	                .then(function(data) {
	                    session.__onRecord = !!flag;
	                    return data;
	                });
	        }
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @private
	     * @param {SIP.Session} session
	     * @param {boolean} flag
	     * @return {Promise}
	     */
	    function setHold(session, flag) {
	        return new Promise(function(resolve, reject) {
	
	            var options = {
	                eventHandlers: {
	                    succeeded: resolve,
	                    failed: reject
	                }
	            };
	
	            if (flag) {
	                session.__hold(options);
	            } else {
	                session.__unhold(options);
	            }
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.UA}
	     * @param number
	     * @param options
	     * @return {SIP.Session}
	     */
	    function invite(number, options) {
	
	        var ua = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(ua.userAgentHeader);
	        options.extraHeaders.push(ua.endpointHeader);
	        options.extraHeaders.push(ua.clientIdHeader);
	
	        options.extraHeaders.push('P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain); //FIXME Phone Number
	
	        //FIXME Backend should know it already
	        if (options.homeCountryId) { options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId); }
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        ua.audioHelper.playOutgoing(true);
	
	        return patchSession(ua.__invite(number, options));
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param request
	     * @return {*}
	     */
	    function receiveRequest(request) {
	        var session = this;
	        switch (request.method) {
	            case SIP.C.INFO:
	                session.emit('RC_SIP_INFO', request);
	                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED || session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	                    var contentType = request.getHeader('content-type');
	                    if (contentType.match(/^application\/json/i)) {
	                        request.reply(200);
	                        return session;
	                    }
	                }
	                break;
	            //Refresh invite should not be rejected with 488
	            case SIP.C.INVITE:
	                if (session.status === SIP.Session.C.STATUS_CONFIRMED) {
	                    if (request.call_id && session.dialog && session.dialog.id && request.call_id == session.dialog.id.call_id) {
	                        //TODO: check that SDP did not change
	                        session.logger.log('re-INVITE received');
	                        var localSDP = session.mediaHandler.peerConnection.localDescription.sdp;
	                        request.reply(200, null, ['Contact: ' + session.contact], localSDP, function() {
	                            session.status = SIP.Session.C.STATUS_WAITING_FOR_ACK;
	                            session.setInvite2xxTimer(request, localSDP);
	                            session.setACKTimer();
	                        });
	                        return session;
	                    }
	                    //else will be rejected with 488 by SIP.js
	                }
	                break;
	            //We need to analize NOTIFY messages sometimes, so we fire an event
	            case SIP.C.NOTIFY:
	                session.emit('RC_SIP_NOTIFY', request);
	                break;
	        }
	        return session.__receiveRequest.apply(session, arguments);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {object} options
	     * @return {Promise}
	     */
	    function accept(options) {
	
	        var session = this;
	
	        options = options || {};
	        options.extraHeaders = options.extraHeaders || [];
	
	        options.extraHeaders.push(session.ua.userAgentHeader);
	        options.extraHeaders.push(session.ua.endpointHeader);
	        options.extraHeaders.push(session.ua.clientIdHeader);
	
	        options.media = options.media || {};
	        options.media.constraints = options.media.constraints || {audio: true, video: false};
	
	        options.RTCConstraints = options.RTCConstraints || {optional: [{DtlsSrtpKeyAgreement: 'true'}]};
	
	        return new Promise(function(resolve, reject) {
	
	            function onAnswered() {
	                resolve(session);
	                session.removeListener('failed', onFail);
	            }
	
	            function onFail(e) {
	                reject(e);
	                session.removeListener('accepted', onAnswered);
	            }
	
	            //TODO More events?
	            session.once('accepted', onAnswered);
	            session.once('failed', onFail);
	
	            session.__accept(options);
	
	        });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} dtmf
	     * @param {number} duration
	     * @return {Promise}
	     */
	    function dtmf(dtmf, duration) {
	        var session = this;
	        duration = parseInt(duration) || 1000;
	        var peer = session.mediaHandler.peerConnection;
	        var stream = session.getLocalStreams()[0];
	        var dtmfSender = peer.createDTMFSender(stream.getAudioTracks()[0]);
	        if (dtmfSender !== undefined && dtmfSender.canInsertDTMF) {
	            return dtmfSender.insertDTMF(dtmf, duration);
	        }
	        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : (!dtmfSender.canInsertDTMF ? 'can\'t insert DTMF' : 'Unknown')));
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function hold() {
	        return setHold(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @return {Promise}
	     */
	    function unhold() {
	        return setHold(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session} session
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function blindTransfer(target, options) {
	
	        options = options || {};
	
	        var session = this;
	        var extraHeaders = options.extraHeaders || [];
	        var originalTarget = target;
	
	        return new Promise(function(resolve, reject) {
	            //Blind Transfer is taken from SIP.js source
	
	            // Check Session Status
	            if (session.status !== SIP.Session.C.STATUS_CONFIRMED) {
	                throw new SIP.Exceptions.InvalidStateError(session.status);
	            }
	
	            // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	            // so try to make one ahead of time
	            try {
	                target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	            } catch (e) {
	                session.logger.debug(".refer() cannot parse Refer_To from", target);
	                session.logger.debug("...falling through to normalizeTarget()");
	            }
	
	            // Check target validity
	            target = session.ua.normalizeTarget(target);
	            if (!target) {
	                throw new TypeError('Invalid target: ' + originalTarget);
	            }
	
	            extraHeaders.push('Contact: ' + session.contact);
	            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	            extraHeaders.push('Refer-To: ' + target);
	            extraHeaders.push(session.ua.userAgentHeader);
	            extraHeaders.push(session.ua.endpointHeader);
	            extraHeaders.push(session.ua.clientIdHeader);
	
	            // Send the request
	            session.sendRequest(SIP.C.REFER, {
	                extraHeaders: extraHeaders,
	                body: options.body,
	                receiveResponse: function(response) {
	                    var timeout = null;
	                    if (response.status_code === 202) {
	                        var callId = response.call_id;
	
	                        var onNotify = function(request) {
	                            if (request.call_id === callId) {
	                                var body = request && request.body || '';
	                                switch (true) {
	                                    case /1[0-9]{2}/.test(body):
	                                        request.reply(200);
	                                        break;
	                                    case /2[0-9]{2}/.test(body):
	                                        session.terminate();
	                                        clearTimeout(timeout);
	                                        session.removeListener('RC_SIP_NOTIFY', onNotify);
	                                        resolve();
	                                        break;
	                                    default:
	                                        reject(body);
	                                        break;
	                                }
	                            }
	                        };
	
	                        timeout = setTimeout(function() {
	                            reject(new Error('Timeout: no reply'));
	                            session.removeListener('RC_SIP_NOTIFY', onNotify);
	                        }, responseTimeout);
	                        session.on('RC_SIP_NOTIFY', onNotify);
	                    }
	                    else {
	                        reject(new Error('The response status code is: ' + response.status_code + ' (waiting for 202)'));
	                    }
	                }
	            });
	
	        });
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} options
	     * @return {Promise}
	     */
	    function transfer(target, options) {
	
	        var session = this;
	
	        return (session.isOnHold() ? Promise.resolve(null) : session.hold())
	            .then(function() { return delay(300); })
	            .then(function() {
	                return session.blindTransfer(target, options);
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param {string} target
	     * @param {object} acceptOptions
	     * @param {object} [transferOptions]
	     * @return {Promise}
	     */
	    function forward(target, acceptOptions, transferOptions) {
	
	        var interval = null,
	            session = this;
	
	        return session.accept(acceptOptions)
	            .then(function() {
	
	                return new Promise(function(resolve, reject) {
	                    interval = setInterval(function() {
	                        if (session.status === 12) {
	                            clearInterval(interval);
	                            session.mute();
	                            setTimeout(function() {
	                                resolve(session.transfer(target, transferOptions));
	                            }, 700);
	                        }
	                    }, 50);
	                });
	
	            });
	
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function startRecord() {
	        return setRecord(this, true);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function stopRecord() {
	        return setRecord(this, false);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @param target
	     * @return {Promise}
	     */
	    function flip(target) {
	        return sendReceive(this, messages.flip, {target: target});
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    /**
	     * @this {SIP.Session}
	     * @return {Promise}
	     */
	    function park() {
	        return sendReceive(this, messages.park);
	    }
	
	    /*--------------------------------------------------------------------------------------------------------------------*/
	
	    return WebPhone;
	
	}));

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = __webpack_require__(212)(__webpack_require__(245));


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @name SIP
	 * @namespace
	 */
	"use strict";
	
	module.exports = function (environment) {
	
	var pkg = __webpack_require__(213);
	
	var SIP = Object.defineProperties({}, {
	  version: {
	    get: function(){ return pkg.version; }
	  },
	  name: {
	    get: function(){ return pkg.title; }
	  }
	});
	
	__webpack_require__(214)(SIP, environment);
	SIP.LoggerFactory = __webpack_require__(215)(environment.console);
	SIP.EventEmitter = __webpack_require__(216)(environment.console);
	SIP.C = __webpack_require__(218)(SIP.name, SIP.version);
	SIP.Exceptions = __webpack_require__(219);
	SIP.Timers = __webpack_require__(220)(environment.timers);
	SIP.Transport = environment.Transport(SIP, environment.WebSocket);
	__webpack_require__(221)(SIP);
	__webpack_require__(222)(SIP);
	__webpack_require__(223)(SIP);
	__webpack_require__(224)(SIP);
	__webpack_require__(225)(SIP);
	__webpack_require__(226)(SIP);
	__webpack_require__(228)(SIP);
	__webpack_require__(229)(SIP);
	SIP.MediaHandler = __webpack_require__(230)(SIP.EventEmitter);
	__webpack_require__(231)(SIP);
	__webpack_require__(232)(SIP);
	__webpack_require__(233)(SIP, environment);
	__webpack_require__(235)(SIP);
	SIP.WebRTC = __webpack_require__(236)(SIP, environment);
	__webpack_require__(239)(SIP, environment);
	SIP.Hacks = __webpack_require__(240)(SIP);
	__webpack_require__(241)(SIP);
	SIP.DigestAuthentication = __webpack_require__(242)(SIP.Utils);
	SIP.Grammar = __webpack_require__(243)(SIP);
	
	return SIP;
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"sip.js@0.7.5",
				"/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone"
			]
		],
		"_from": "sip.js@0.7.5",
		"_id": "sip.js@0.7.5",
		"_inCache": true,
		"_installable": true,
		"_location": "/sip.js",
		"_nodeVersion": "4.4.3",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/sip.js-0.7.5.tgz_1461594418690_0.5839933124370873"
		},
		"_npmUser": {
			"email": "1212jtraceur@gmail.com",
			"name": "josephfrazier"
		},
		"_npmVersion": "2.15.1",
		"_phantomChildren": {},
		"_requested": {
			"name": "sip.js",
			"raw": "sip.js@0.7.5",
			"rawSpec": "0.7.5",
			"scope": null,
			"spec": "0.7.5",
			"type": "version"
		},
		"_requiredBy": [
			"/ringcentral-web-phone"
		],
		"_resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz",
		"_shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
		"_shrinkwrap": null,
		"_spec": "sip.js@0.7.5",
		"_where": "/Users/howard.zhang/Sites/ringcentral-js-integration-commons/node_modules/ringcentral-web-phone",
		"author": {
			"email": "developer@onsip.com",
			"name": "OnSIP",
			"url": "http://sipjs.com/authors/"
		},
		"browser": {
			"./src/environment.js": "./src/environment_browser.js"
		},
		"bugs": {
			"url": "https://github.com/onsip/SIP.js/issues"
		},
		"contributors": [
			{
				"url": "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
			}
		],
		"dependencies": {
			"promiscuous": "^0.6.0",
			"ws": "^0.6.4"
		},
		"description": "A simple, intuitive, and powerful JavaScript signaling library",
		"devDependencies": {
			"beefy": "^2.1.5",
			"browserify": "^4.1.8",
			"grunt": "~0.4.0",
			"grunt-browserify": "^4.0.1",
			"grunt-cli": "~0.1.6",
			"grunt-contrib-copy": "^0.5.0",
			"grunt-contrib-jasmine": "^0.9.2",
			"grunt-contrib-jshint": ">0.5.0",
			"grunt-contrib-uglify": "~0.2.0",
			"grunt-peg": "~1.3.1",
			"grunt-trimtrailingspaces": "^0.4.0",
			"pegjs": "^0.8.0"
		},
		"directories": {},
		"dist": {
			"shasum": "86ace7051594f91b4551bdb8120a16c44962d3a2",
			"tarball": "https://registry.npmjs.org/sip.js/-/sip.js-0.7.5.tgz"
		},
		"engines": {
			"node": ">=0.8"
		},
		"gitHead": "bae44bd0359f4d70ded309a32361f04a04e78d6e",
		"homepage": "http://sipjs.com",
		"keywords": [
			"sip",
			"websocket",
			"webrtc",
			"library",
			"javascript"
		],
		"license": "MIT",
		"main": "src/index.js",
		"maintainers": [
			{
				"email": "eric.green@onsip.com",
				"name": "egreen_onsip"
			},
			{
				"email": "james@onsip.com",
				"name": "james-criscuolo"
			},
			{
				"email": "1212jtraceur@gmail.com",
				"name": "josephfrazier"
			}
		],
		"name": "sip.js",
		"optionalDependencies": {
			"promiscuous": "^0.6.0"
		},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/onsip/SIP.js.git"
		},
		"scripts": {
			"build": "grunt build",
			"prepublish": "cd src/Grammar && mkdir -p dist && pegjs --extra-options-file peg.json src/Grammar.pegjs dist/Grammar.js",
			"repl": "beefy test/repl.js --open",
			"test": "grunt travis --verbose"
		},
		"title": "SIP.js",
		"version": "0.7.5"
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Utils
	 */
	
	module.exports = function (SIP, environment) {
	var Utils;
	
	Utils= {
	
	  Promise: environment.Promise,
	
	  defer: function defer () {
	    var deferred = {};
	    deferred.promise = new Utils.Promise(function (resolve, reject) {
	      deferred.resolve = resolve;
	      deferred.reject = reject;
	    });
	    return deferred;
	  },
	
	  promisify: function promisify (object, methodName, callbacksFirst) {
	    var oldMethod = object[methodName];
	    return function promisifiedMethod (arg, onSuccess, onFailure) {
	      return new Utils.Promise(function (resolve, reject) {
	        var oldArgs = [arg, resolve, reject];
	        if (callbacksFirst) {
	          oldArgs = [resolve, reject, arg];
	        }
	        oldMethod.apply(object, oldArgs);
	      }).then(onSuccess, onFailure);
	    };
	  },
	
	  augment: function (object, constructor, args, override) {
	    var idx, proto;
	
	    // Add public properties from constructor's prototype onto object
	    proto = constructor.prototype;
	    for (idx in proto) {
	      if (override || object[idx] === undefined) {
	        object[idx] = proto[idx];
	      }
	    }
	
	    // Construct the object as though it were just created by constructor
	    constructor.apply(object, args);
	  },
	
	  optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {
	    if (isDeprecated && options[loser]) {
	      logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');
	    }
	
	    if (options[winner] && options[loser]) {
	      logger.warn(winner + ' overriding ' + loser);
	    }
	
	    options[winner] = options[winner] || options[loser] || defaultValue;
	  },
	
	  str_utf8_length: function(string) {
	    return encodeURIComponent(string).replace(/%[A-F\d]{2}/g, 'U').length;
	  },
	
	  generateFakeSDP: function(body) {
	    if (!body) {
	      return;
	    }
	
	    var start = body.indexOf('o=');
	    var end = body.indexOf('\r\n', start);
	
	    return 'v=0\r\n' + body.slice(start, end) + '\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0';
	  },
	
	  isFunction: function(fn) {
	    if (fn !== undefined) {
	      return Object.prototype.toString.call(fn) === '[object Function]';
	    } else {
	      return false;
	    }
	  },
	
	  isDecimal: function (num) {
	    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
	  },
	
	  createRandomToken: function(size, base) {
	    var i, r,
	      token = '';
	
	    base = base || 32;
	
	    for( i=0; i < size; i++ ) {
	      r = Math.random() * base|0;
	      token += r.toString(base);
	    }
	
	    return token;
	  },
	
	  newTag: function() {
	    return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);
	  },
	
	  // http://stackoverflow.com/users/109538/broofa
	  newUUID: function() {
	    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
	      return v.toString(16);
	    });
	
	    return UUID;
	  },
	
	  hostType: function(host) {
	    if (!host) {
	      return;
	    } else {
	      host = SIP.Grammar.parse(host,'host');
	      if (host !== -1) {
	        return host.host_type;
	      }
	    }
	  },
	
	  /**
	  * Normalize SIP URI.
	  * NOTE: It does not allow a SIP URI without username.
	  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
	  * Detects the domain part (if given) and properly hex-escapes the user portion.
	  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
	  * @private
	  * @param {String} target
	  * @param {String} [domain]
	  */
	  normalizeTarget: function(target, domain) {
	    var uri, target_array, target_user, target_domain;
	
	    // If no target is given then raise an error.
	    if (!target) {
	      return;
	    // If a SIP.URI instance is given then return it.
	    } else if (target instanceof SIP.URI) {
	      return target;
	
	    // If a string is given split it by '@':
	    // - Last fragment is the desired domain.
	    // - Otherwise append the given domain argument.
	    } else if (typeof target === 'string') {
	      target_array = target.split('@');
	
	      switch(target_array.length) {
	        case 1:
	          if (!domain) {
	            return;
	          }
	          target_user = target;
	          target_domain = domain;
	          break;
	        case 2:
	          target_user = target_array[0];
	          target_domain = target_array[1];
	          break;
	        default:
	          target_user = target_array.slice(0, target_array.length-1).join('@');
	          target_domain = target_array[target_array.length-1];
	      }
	
	      // Remove the URI scheme (if present).
	      target_user = target_user.replace(/^(sips?|tel):/i, '');
	
	      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
	      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
	        target_user = target_user.replace(/[\-\.\(\)]/g, '');
	      }
	
	      // Build the complete SIP URI.
	      target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;
	
	      // Finally parse the resulting URI.
	      if (uri = SIP.URI.parse(target)) {
	        return uri;
	      } else {
	        return;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	  * Hex-escape a SIP URI user.
	  * @private
	  * @param {String} user
	  */
	  escapeUser: function(user) {
	    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	    return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
	  },
	
	  headerize: function(string) {
	    var exceptions = {
	      'Call-Id': 'Call-ID',
	      'Cseq': 'CSeq',
	      'Min-Se': 'Min-SE',
	      'Rack': 'RAck',
	      'Rseq': 'RSeq',
	      'Www-Authenticate': 'WWW-Authenticate'
	      },
	      name = string.toLowerCase().replace(/_/g,'-').split('-'),
	      hname = '',
	      parts = name.length, part;
	
	    for (part = 0; part < parts; part++) {
	      if (part !== 0) {
	        hname +='-';
	      }
	      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
	    }
	    if (exceptions[hname]) {
	      hname = exceptions[hname];
	    }
	    return hname;
	  },
	
	  sipErrorCause: function(status_code) {
	    var cause;
	
	    for (cause in SIP.C.SIP_ERROR_CAUSES) {
	      if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
	        return SIP.C.causes[cause];
	      }
	    }
	
	    return SIP.C.causes.SIP_FAILURE_CODE;
	  },
	
	  getReasonPhrase: function getReasonPhrase (code, specific) {
	    return specific || SIP.C.REASON_PHRASE[code] || '';
	  },
	
	  getReasonHeaderValue: function getReasonHeaderValue (code, reason) {
	    reason = SIP.Utils.getReasonPhrase(code, reason);
	    return 'SIP ;cause=' + code + ' ;text="' + reason + '"';
	  },
	
	  getCancelReason: function getCancelReason (code, reason) {
	    if (code && code < 200 || code > 699) {
	      throw new TypeError('Invalid status_code: ' + code);
	    } else if (code) {
	      return SIP.Utils.getReasonHeaderValue(code, reason);
	    }
	  },
	
	  buildStatusLine: function buildStatusLine (code, reason) {
	    code = code || null;
	    reason = reason || null;
	
	    // Validate code and reason values
	    if (!code || (code < 100 || code > 699)) {
	      throw new TypeError('Invalid status_code: '+ code);
	    } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
	      throw new TypeError('Invalid reason_phrase: '+ reason);
	    }
	
	    reason = Utils.getReasonPhrase(code, reason);
	
	    return 'SIP/2.0 ' + code + ' ' + reason + '\r\n';
	  },
	
	  /**
	  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
	  * @private
	  */
	  getRandomTestNetIP: function() {
	    function getOctet(from,to) {
	      return Math.floor(Math.random()*(to-from+1)+from);
	    }
	    return '192.0.2.' + getOctet(1, 254);
	  },
	
	  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
	  calculateMD5: function(string) {
	    function RotateLeft(lValue, iShiftBits) {
	      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
	    }
	
	    function AddUnsigned(lX,lY) {
	      var lX4,lY4,lX8,lY8,lResult;
	      lX8 = (lX & 0x80000000);
	      lY8 = (lY & 0x80000000);
	      lX4 = (lX & 0x40000000);
	      lY4 = (lY & 0x40000000);
	      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
	      if (lX4 & lY4) {
	        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
	      }
	      if (lX4 | lY4) {
	        if (lResult & 0x40000000) {
	          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
	        } else {
	          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
	        }
	      } else {
	        return (lResult ^ lX8 ^ lY8);
	      }
	    }
	
	    function F(x,y,z) {
	      return (x & y) | ((~x) & z);
	    }
	
	    function G(x,y,z) {
	      return (x & z) | (y & (~z));
	    }
	
	    function H(x,y,z) {
	      return (x ^ y ^ z);
	    }
	
	    function I(x,y,z) {
	      return (y ^ (x | (~z)));
	    }
	
	    function FF(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function GG(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function HH(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function II(a,b,c,d,x,s,ac) {
	      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
	      return AddUnsigned(RotateLeft(a, s), b);
	    }
	
	    function ConvertToWordArray(string) {
	      var lWordCount;
	      var lMessageLength = string.length;
	      var lNumberOfWords_temp1=lMessageLength + 8;
	      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
	      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
	      var lWordArray=Array(lNumberOfWords-1);
	      var lBytePosition = 0;
	      var lByteCount = 0;
	      while ( lByteCount < lMessageLength ) {
	        lWordCount = (lByteCount-(lByteCount % 4))/4;
	        lBytePosition = (lByteCount % 4)*8;
	        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
	        lByteCount++;
	      }
	      lWordCount = (lByteCount-(lByteCount % 4))/4;
	      lBytePosition = (lByteCount % 4)*8;
	      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
	      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
	      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
	      return lWordArray;
	    }
	
	    function WordToHex(lValue) {
	      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
	      for (lCount = 0;lCount<=3;lCount++) {
	        lByte = (lValue>>>(lCount*8)) & 255;
	        WordToHexValue_temp = "0" + lByte.toString(16);
	        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
	      }
	      return WordToHexValue;
	    }
	
	    function Utf8Encode(string) {
	      string = string.replace(/\r\n/g,"\n");
	      var utftext = "";
	
	      for (var n = 0; n < string.length; n++) {
	        var c = string.charCodeAt(n);
	
	        if (c < 128) {
	          utftext += String.fromCharCode(c);
	        }
	        else if((c > 127) && (c < 2048)) {
	          utftext += String.fromCharCode((c >> 6) | 192);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	        else {
	          utftext += String.fromCharCode((c >> 12) | 224);
	          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	          utftext += String.fromCharCode((c & 63) | 128);
	        }
	      }
	      return utftext;
	    }
	
	    var x=[];
	    var k,AA,BB,CC,DD,a,b,c,d;
	    var S11=7, S12=12, S13=17, S14=22;
	    var S21=5, S22=9 , S23=14, S24=20;
	    var S31=4, S32=11, S33=16, S34=23;
	    var S41=6, S42=10, S43=15, S44=21;
	
	    string = Utf8Encode(string);
	
	    x = ConvertToWordArray(string);
	
	    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
	
	    for (k=0;k<x.length;k+=16) {
	      AA=a; BB=b; CC=c; DD=d;
	      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
	      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
	      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
	      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
	      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
	      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
	      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
	      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
	      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
	      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
	      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
	      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
	      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
	      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
	      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
	      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
	      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
	      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
	      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
	      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
	      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
	      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
	      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
	      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
	      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
	      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
	      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
	      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
	      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
	      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
	      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
	      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
	      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
	      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
	      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
	      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
	      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
	      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
	      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
	      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
	      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
	      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
	      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
	      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
	      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
	      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
	      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
	      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
	      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
	      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
	      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
	      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
	      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
	      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
	      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
	      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
	      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
	      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
	      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
	      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
	      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
	      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
	      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
	      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
	      a=AddUnsigned(a,AA);
	      b=AddUnsigned(b,BB);
	      c=AddUnsigned(c,CC);
	      d=AddUnsigned(d,DD);
	    }
	
	    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);
	
	    return temp.toLowerCase();
	  }
	};
	
	SIP.Utils = Utils;
	};


/***/ },
/* 215 */
/***/ function(module, exports) {

	"use strict";
	var levels = {
	  'error': 0,
	  'warn': 1,
	  'log': 2,
	  'debug': 3
	};
	
	module.exports = function (console) {
	
	var LoggerFactory = function () {
	  var logger,
	    level = 2,
	    builtinEnabled = true,
	    connector = null;
	
	    this.loggers = {};
	
	    logger = this.getLogger('sip.loggerfactory');
	
	
	  Object.defineProperties(this, {
	    builtinEnabled: {
	      get: function(){ return builtinEnabled; },
	      set: function(value){
	        if (typeof value === 'boolean') {
	          builtinEnabled = value;
	        } else {
	          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    level: {
	      get: function() {return level; },
	      set: function(value) {
	        if (value >= 0 && value <=3) {
	          level = value;
	        } else if (value > 3) {
	          level = 3;
	        } else if (levels.hasOwnProperty(value)) {
	          level = levels[value];
	        } else {
	          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    },
	
	    connector: {
	      get: function() {return connector; },
	      set: function(value){
	        if(value === null || value === "" || value === undefined) {
	          connector = null;
	        } else if (typeof value === 'function') {
	          connector = value;
	        } else {
	          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
	        }
	      }
	    }
	  });
	};
	
	LoggerFactory.prototype.print = function(target, category, label, content) {
	  if (typeof content === 'string') {
	    var prefix = [new Date(), category];
	    if (label) {
	      prefix.push(label);
	    }
	    content = prefix.concat(content).join(' | ');
	  }
	  target.call(console, content);
	};
	
	function Logger (logger, category, label) {
	  this.logger = logger;
	  this.category = category;
	  this.label = label;
	}
	
	Object.keys(levels).forEach(function (targetName) {
	  Logger.prototype[targetName] = function (content) {
	    this.logger[targetName](this.category, this.label, content);
	  };
	
	  LoggerFactory.prototype[targetName] = function (category, label, content) {
	    if (this.level >= levels[targetName]) {
	      if (this.builtinEnabled) {
	        this.print(console[targetName], category, label, content);
	      }
	
	      if (this.connector) {
	        this.connector(targetName, category, label, content);
	      }
	    }
	  };
	});
	
	LoggerFactory.prototype.getLogger = function(category, label) {
	  var logger;
	
	  if (label && this.level === 3) {
	    return new Logger(this, category, label);
	  } else if (this.loggers[category]) {
	    return this.loggers[category];
	  } else {
	    logger = new Logger(this, category);
	    this.loggers[category] = logger;
	    return logger;
	  }
	};
	
	return LoggerFactory;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NodeEventEmitter = __webpack_require__(217).EventEmitter;
	
	module.exports = function (console) {
	
	// Don't use `new SIP.EventEmitter()` for inheriting.
	// Use Object.create(SIP.EventEmitter.prototoype);
	function EventEmitter () {
	  NodeEventEmitter.call(this);
	}
	
	EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {
	  constructor: {
	    value: EventEmitter,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	EventEmitter.prototype.off = function off (eventName, listener) {
	  var warning = '';
	  warning += 'SIP.EventEmitter#off is deprecated and may be removed in future SIP.js versions.\n';
	  warning += 'Please use removeListener or removeAllListeners instead.\n';
	  warning += 'See here for more details:\n';
	  warning += 'http://nodejs.org/api/events.html#events_emitter_removelistener_event_listener';
	  console.warn(warning);
	
	  if (arguments.length < 2) {
	    return this.removeAllListeners.apply(this, arguments);
	  } else {
	    return this.removeListener(eventName, listener);
	  }
	};
	
	return EventEmitter;
	
	};


/***/ },
/* 217 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 218 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Constants
	 */
	
	/**
	 * SIP Constants.
	 * @augments SIP
	 */
	
	module.exports = function (name, version) {
	return {
	  USER_AGENT: name +'/'+ version,
	
	  // SIP scheme
	  SIP:  'sip',
	  SIPS: 'sips',
	
	  // End and Failure causes
	  causes: {
	    // Generic error causes
	    CONNECTION_ERROR:         'Connection Error',
	    REQUEST_TIMEOUT:          'Request Timeout',
	    SIP_FAILURE_CODE:         'SIP Failure Code',
	    INTERNAL_ERROR:           'Internal Error',
	
	    // SIP error causes
	    BUSY:                     'Busy',
	    REJECTED:                 'Rejected',
	    REDIRECTED:               'Redirected',
	    UNAVAILABLE:              'Unavailable',
	    NOT_FOUND:                'Not Found',
	    ADDRESS_INCOMPLETE:       'Address Incomplete',
	    INCOMPATIBLE_SDP:         'Incompatible SDP',
	    AUTHENTICATION_ERROR:     'Authentication Error',
	    DIALOG_ERROR:             'Dialog Error',
	
	    // Session error causes
	    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
	    WEBRTC_ERROR:             'WebRTC Error',
	    CANCELED:                 'Canceled',
	    NO_ANSWER:                'No Answer',
	    EXPIRES:                  'Expires',
	    NO_ACK:                   'No ACK',
	    NO_PRACK:                 'No PRACK',
	    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
	    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
	    RTP_TIMEOUT:              'RTP Timeout'
	  },
	
	  supported: {
	    UNSUPPORTED:        'none',
	    SUPPORTED:          'supported',
	    REQUIRED:           'required'
	  },
	
	  SIP_ERROR_CAUSES: {
	    REDIRECTED: [300,301,302,305,380],
	    BUSY: [486,600],
	    REJECTED: [403,603],
	    NOT_FOUND: [404,604],
	    UNAVAILABLE: [480,410,408,430],
	    ADDRESS_INCOMPLETE: [484],
	    INCOMPATIBLE_SDP: [488,606],
	    AUTHENTICATION_ERROR:[401,407]
	  },
	
	  // SIP Methods
	  ACK:        'ACK',
	  BYE:        'BYE',
	  CANCEL:     'CANCEL',
	  INFO:       'INFO',
	  INVITE:     'INVITE',
	  MESSAGE:    'MESSAGE',
	  NOTIFY:     'NOTIFY',
	  OPTIONS:    'OPTIONS',
	  REGISTER:   'REGISTER',
	  UPDATE:     'UPDATE',
	  SUBSCRIBE:  'SUBSCRIBE',
	  REFER:      'REFER',
	  PRACK:      'PRACK',
	
	  /* SIP Response Reasons
	   * DOC: http://www.iana.org/assignments/sip-parameters
	   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
	   */
	  REASON_PHRASE: {
	    100: 'Trying',
	    180: 'Ringing',
	    181: 'Call Is Being Forwarded',
	    182: 'Queued',
	    183: 'Session Progress',
	    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
	    200: 'OK',
	    202: 'Accepted',  // RFC 3265
	    204: 'No Notification',  //RFC 5839
	    300: 'Multiple Choices',
	    301: 'Moved Permanently',
	    302: 'Moved Temporarily',
	    305: 'Use Proxy',
	    380: 'Alternative Service',
	    400: 'Bad Request',
	    401: 'Unauthorized',
	    402: 'Payment Required',
	    403: 'Forbidden',
	    404: 'Not Found',
	    405: 'Method Not Allowed',
	    406: 'Not Acceptable',
	    407: 'Proxy Authentication Required',
	    408: 'Request Timeout',
	    410: 'Gone',
	    412: 'Conditional Request Failed',  // RFC 3903
	    413: 'Request Entity Too Large',
	    414: 'Request-URI Too Long',
	    415: 'Unsupported Media Type',
	    416: 'Unsupported URI Scheme',
	    417: 'Unknown Resource-Priority',  // RFC 4412
	    420: 'Bad Extension',
	    421: 'Extension Required',
	    422: 'Session Interval Too Small',  // RFC 4028
	    423: 'Interval Too Brief',
	    428: 'Use Identity Header',  // RFC 4474
	    429: 'Provide Referrer Identity',  // RFC 3892
	    430: 'Flow Failed',  // RFC 5626
	    433: 'Anonymity Disallowed',  // RFC 5079
	    436: 'Bad Identity-Info',  // RFC 4474
	    437: 'Unsupported Certificate',  // RFC 4744
	    438: 'Invalid Identity Header',  // RFC 4744
	    439: 'First Hop Lacks Outbound Support',  // RFC 5626
	    440: 'Max-Breadth Exceeded',  // RFC 5393
	    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
	    470: 'Consent Needed',  // RFC 5360
	    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
	    480: 'Temporarily Unavailable',
	    481: 'Call/Transaction Does Not Exist',
	    482: 'Loop Detected',
	    483: 'Too Many Hops',
	    484: 'Address Incomplete',
	    485: 'Ambiguous',
	    486: 'Busy Here',
	    487: 'Request Terminated',
	    488: 'Not Acceptable Here',
	    489: 'Bad Event',  // RFC 3265
	    491: 'Request Pending',
	    493: 'Undecipherable',
	    494: 'Security Agreement Required',  // RFC 3329
	    500: 'Internal Server Error',
	    501: 'Not Implemented',
	    502: 'Bad Gateway',
	    503: 'Service Unavailable',
	    504: 'Server Time-out',
	    505: 'Version Not Supported',
	    513: 'Message Too Large',
	    580: 'Precondition Failure',  // RFC 3312
	    600: 'Busy Everywhere',
	    603: 'Decline',
	    604: 'Does Not Exist Anywhere',
	    606: 'Not Acceptable'
	  },
	
	  /* SIP Option Tags
	   * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
	   */
	  OPTION_TAGS: {
	    '100rel':                   true,  // RFC 3262
	    199:                        true,  // RFC 6228
	    answermode:                 true,  // RFC 5373
	    'early-session':            true,  // RFC 3959
	    eventlist:                  true,  // RFC 4662
	    explicitsub:                true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    'from-change':              true,  // RFC 4916
	    'geolocation-http':         true,  // RFC 6442
	    'geolocation-sip':          true,  // RFC 6442
	    gin:                        true,  // RFC 6140
	    gruu:                       true,  // RFC 5627
	    histinfo:                   true,  // RFC 7044
	    ice:                        true,  // RFC 5768
	    join:                       true,  // RFC 3911
	    'multiple-refer':           true,  // RFC 5368
	    norefersub:                 true,  // RFC 4488
	    nosub:                      true,  // RFC-ietf-sipcore-refer-explicit-subscription-03
	    outbound:                   true,  // RFC 5626
	    path:                       true,  // RFC 3327
	    policy:                     true,  // RFC 6794
	    precondition:               true,  // RFC 3312
	    pref:                       true,  // RFC 3840
	    privacy:                    true,  // RFC 3323
	    'recipient-list-invite':    true,  // RFC 5366
	    'recipient-list-message':   true,  // RFC 5365
	    'recipient-list-subscribe': true,  // RFC 5367
	    replaces:                   true,  // RFC 3891
	    'resource-priority':        true,  // RFC 4412
	    'sdp-anat':                 true,  // RFC 4092
	    'sec-agree':                true,  // RFC 3329
	    tdialog:                    true,  // RFC 4538
	    timer:                      true,  // RFC 4028
	    uui:                        true   // RFC 7433
	  }
	};
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Exceptions
	 */
	
	/**
	 * SIP Exceptions.
	 * @augments SIP
	 */
	module.exports = {
	  ConfigurationError: (function(){
	    var exception = function(parameter, value) {
	      this.code = 1;
	      this.name = 'CONFIGURATION_ERROR';
	      this.parameter = parameter;
	      this.value = value;
	      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  InvalidStateError: (function(){
	    var exception = function(status) {
	      this.code = 2;
	      this.name = 'INVALID_STATE_ERROR';
	      this.status = status;
	      this.message = 'Invalid status: ' + status;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  NotSupportedError: (function(){
	    var exception = function(message) {
	      this.code = 3;
	      this.name = 'NOT_SUPPORTED_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }()),
	
	  GetDescriptionError: (function(){
	    var exception = function(message) {
	      this.code = 4;
	      this.name = 'GET_DESCRIPTION_ERROR';
	      this.message = message;
	    };
	    exception.prototype = new Error();
	    return exception;
	  }())
	};


/***/ },
/* 220 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP TIMERS
	 */
	
	/**
	 * @augments SIP
	 */
	var
	  T1 = 500,
	  T2 = 4000,
	  T4 = 5000;
	module.exports = function (timers) {
	  var Timers = {
	    T1: T1,
	    T2: T2,
	    T4: T4,
	    TIMER_B: 64 * T1,
	    TIMER_D: 0  * T1,
	    TIMER_F: 64 * T1,
	    TIMER_H: 64 * T1,
	    TIMER_I: 0  * T1,
	    TIMER_J: 0  * T1,
	    TIMER_K: 0  * T4,
	    TIMER_L: 64 * T1,
	    TIMER_M: 64 * T1,
	    TIMER_N: 64 * T1,
	    PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
	  };
	
	  ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']
	  .forEach(function (name) {
	    // can't just use timers[name].bind(timers) since it bypasses jasmine's
	    // clock-mocking
	    Timers[name] = function () {
	      return timers[name].apply(timers, arguments);
	    };
	  });
	
	  return Timers;
	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message Parser
	 */
	
	/**
	 * Extract and parse every header of a SIP message.
	 * @augments SIP
	 * @namespace
	 */
	module.exports = function (SIP) {
	var Parser;
	
	function getHeader(data, headerStart) {
	  var
	    // 'start' position of the header.
	    start = headerStart,
	    // 'end' position of the header.
	    end = 0,
	    // 'partial end' position of the header.
	    partialEnd = 0;
	
	  //End of message.
	  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
	    return -2;
	  }
	
	  while(end === 0) {
	    // Partial End of Header.
	    partialEnd = data.indexOf('\r\n', start);
	
	    // 'indexOf' returns -1 if the value to be found never occurs.
	    if (partialEnd === -1) {
	      return partialEnd;
	    }
	
	    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
	      // Not the end of the message. Continue from the next position.
	      start = partialEnd + 2;
	    } else {
	      end = partialEnd;
	    }
	  }
	
	  return end;
	}
	
	function parseHeader(message, data, headerStart, headerEnd) {
	  var header, idx, length, parsed,
	    hcolonIndex = data.indexOf(':', headerStart),
	    headerName = data.substring(headerStart, hcolonIndex).trim(),
	    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
	
	  // If header-field is well-known, parse it.
	  switch(headerName.toLowerCase()) {
	    case 'via':
	    case 'v':
	      message.addHeader('via', headerValue);
	      if(message.getHeaders('via').length === 1) {
	        parsed = message.parseHeader('Via');
	        if(parsed) {
	          message.via = parsed;
	          message.via_branch = parsed.branch;
	        }
	      } else {
	        parsed = 0;
	      }
	      break;
	    case 'from':
	    case 'f':
	      message.setHeader('from', headerValue);
	      parsed = message.parseHeader('from');
	      if(parsed) {
	        message.from = parsed;
	        message.from_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'to':
	    case 't':
	      message.setHeader('to', headerValue);
	      parsed = message.parseHeader('to');
	      if(parsed) {
	        message.to = parsed;
	        message.to_tag = parsed.getParam('tag');
	      }
	      break;
	    case 'record-route':
	      parsed = SIP.Grammar.parse(headerValue, 'Record_Route');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('record-route', headerValue.substring(header.position, header.offset));
	        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'call-id':
	    case 'i':
	      message.setHeader('call-id', headerValue);
	      parsed = message.parseHeader('call-id');
	      if(parsed) {
	        message.call_id = headerValue;
	      }
	      break;
	    case 'contact':
	    case 'm':
	      parsed = SIP.Grammar.parse(headerValue, 'Contact');
	
	      if (parsed === -1) {
	        parsed = undefined;
	        break;
	      }
	
	      length = parsed.length;
	      for (idx = 0; idx < length; idx++) {
	        header = parsed[idx];
	        message.addHeader('contact', headerValue.substring(header.position, header.offset));
	        message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;
	      }
	      break;
	    case 'content-length':
	    case 'l':
	      message.setHeader('content-length', headerValue);
	      parsed = message.parseHeader('content-length');
	      break;
	    case 'content-type':
	    case 'c':
	      message.setHeader('content-type', headerValue);
	      parsed = message.parseHeader('content-type');
	      break;
	    case 'cseq':
	      message.setHeader('cseq', headerValue);
	      parsed = message.parseHeader('cseq');
	      if(parsed) {
	        message.cseq = parsed.value;
	      }
	      if(message instanceof SIP.IncomingResponse) {
	        message.method = parsed.method;
	      }
	      break;
	    case 'max-forwards':
	      message.setHeader('max-forwards', headerValue);
	      parsed = message.parseHeader('max-forwards');
	      break;
	    case 'www-authenticate':
	      message.setHeader('www-authenticate', headerValue);
	      parsed = message.parseHeader('www-authenticate');
	      break;
	    case 'proxy-authenticate':
	      message.setHeader('proxy-authenticate', headerValue);
	      parsed = message.parseHeader('proxy-authenticate');
	      break;
	    case 'refer-to':
	    case 'r':
	      message.setHeader('refer-to', headerValue);
	      parsed = message.parseHeader('refer-to');
	      if (parsed) {
	        message.refer_to = parsed;
	      }
	      break;
	    default:
	      // Do not parse this header.
	      message.setHeader(headerName, headerValue);
	      parsed = 0;
	  }
	
	  if (parsed === undefined) {
	    return {
	      error: 'error parsing header "'+ headerName +'"'
	    };
	  } else {
	    return true;
	  }
	}
	
	/** Parse SIP Message
	 * @function
	 * @param {String} message SIP message.
	 * @param {Object} logger object.
	 * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
	 */
	Parser = {};
	Parser.parseMessage = function(data, ua) {
	  var message, firstLine, contentLength, bodyStart, parsed,
	    headerStart = 0,
	    headerEnd = data.indexOf('\r\n'),
	    logger = ua.getLogger('sip.parser');
	
	  if(headerEnd === -1) {
	    logger.warn('no CRLF found, not a SIP message, discarded');
	    return;
	  }
	
	  // Parse first line. Check if it is a Request or a Reply.
	  firstLine = data.substring(0, headerEnd);
	  parsed = SIP.Grammar.parse(firstLine, 'Request_Response');
	
	  if(parsed === -1) {
	    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
	    return;
	  } else if(!parsed.status_code) {
	    message = new SIP.IncomingRequest(ua);
	    message.method = parsed.method;
	    message.ruri = parsed.uri;
	  } else {
	    message = new SIP.IncomingResponse(ua);
	    message.status_code = parsed.status_code;
	    message.reason_phrase = parsed.reason_phrase;
	  }
	
	  message.data = data;
	  headerStart = headerEnd + 2;
	
	  /* Loop over every line in data. Detect the end of each header and parse
	  * it or simply add to the headers collection.
	  */
	  while(true) {
	    headerEnd = getHeader(data, headerStart);
	
	    // The SIP message has normally finished.
	    if(headerEnd === -2) {
	      bodyStart = headerStart + 2;
	      break;
	    }
	    // data.indexOf returned -1 due to a malformed message.
	    else if(headerEnd === -1) {
	      logger.error('malformed message');
	      return;
	    }
	
	    parsed = parseHeader(message, data, headerStart, headerEnd);
	
	    if(parsed !== true) {
	      logger.error(parsed.error);
	      return;
	    }
	
	    headerStart = headerEnd + 2;
	  }
	
	  /* RFC3261 18.3.
	   * If there are additional bytes in the transport packet
	   * beyond the end of the body, they MUST be discarded.
	   */
	  if(message.hasHeader('content-length')) {
	    contentLength = message.getHeader('content-length');
	    message.body = data.substr(bodyStart, contentLength);
	  } else {
	    message.body = data.substring(bodyStart);
	  }
	
	  return message;
	};
	
	SIP.Parser = Parser;
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Message
	 */
	
	module.exports = function (SIP) {
	var
	  OutgoingRequest,
	  IncomingMessage,
	  IncomingRequest,
	  IncomingResponse;
	
	function getSupportedHeader (request) {
	  var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;
	  var optionTags = [];
	  var optionTagSet = {};
	
	  if (request.method === SIP.C.REGISTER) {
	    optionTags.push('path', 'gruu');
	  } else if (request.method === SIP.C.INVITE &&
	             (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {
	    optionTags.push('gruu');
	  }
	
	  if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {
	    optionTags.push('100rel');
	  }
	  if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {
	    optionTags.push('replaces');
	  }
	
	  optionTags.push('outbound');
	
	  optionTags = optionTags.concat(request.ua.configuration.extraSupported);
	
	  optionTags = optionTags.filter(function(optionTag) {
	    var registered = SIP.C.OPTION_TAGS[optionTag];
	    var unique = !optionTagSet[optionTag];
	    optionTagSet[optionTag] = true;
	    return (registered || allowUnregistered) && unique;
	  });
	
	  return 'Supported: ' + optionTags.join(', ') + '\r\n';
	}
	
	/**
	 * @augments SIP
	 * @class Class for outgoing SIP request.
	 * @param {String} method request method
	 * @param {String} ruri request uri
	 * @param {SIP.UA} ua
	 * @param {Object} params parameters that will have priority over ua.configuration parameters:
	 * <br>
	 *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set
	 * @param {Object} [headers] extra headers
	 * @param {String} [body]
	 */
	OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
	  var
	    to,
	    from,
	    call_id,
	    cseq,
	    to_uri,
	    from_uri;
	
	  params = params || {};
	
	  // Mandatory parameters check
	  if(!method || !ruri || !ua) {
	    return null;
	  }
	
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.method = method;
	  this.ruri = ruri;
	  this.body = body;
	  this.extraHeaders = (extraHeaders || []).slice();
	  this.statusCode = params.status_code;
	  this.reasonPhrase = params.reason_phrase;
	
	  // Fill the Common SIP Request Headers
	
	  // Route
	  if (params.route_set) {
	    this.setHeader('route', params.route_set);
	  } else if (ua.configuration.usePreloadedRoute){
	    this.setHeader('route', ua.transport.server.sip_uri);
	  }
	
	  // Via
	  // Empty Via header. Will be filled by the client transaction.
	  this.setHeader('via', '');
	
	  // Max-Forwards
	  this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);
	
	  // To
	  to_uri = params.to_uri || ruri;
	  to = (params.to_displayName || params.to_displayName === 0) ? '"' + params.to_displayName + '" ' : '';
	  to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';
	  to += params.to_tag ? ';tag=' + params.to_tag : '';
	  this.to = new SIP.NameAddrHeader.parse(to);
	  this.setHeader('to', to);
	
	  // From
	  from_uri = params.from_uri || ua.configuration.uri;
	  if (params.from_displayName || params.from_displayName === 0) {
	    from = '"' + params.from_displayName + '" ';
	  } else if (ua.configuration.displayName) {
	    from = '"' + ua.configuration.displayName + '" ';
	  } else {
	    from = '';
	  }
	  from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';
	  from += params.from_tag || SIP.Utils.newTag();
	  this.from = new SIP.NameAddrHeader.parse(from);
	  this.setHeader('from', from);
	
	  // Call-ID
	  call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));
	  this.call_id = call_id;
	  this.setHeader('call-id', call_id);
	
	  // CSeq
	  cseq = params.cseq || Math.floor(Math.random() * 10000);
	  this.cseq = cseq;
	  this.setHeader('cseq', cseq + ' ' + method);
	};
	
	OutgoingRequest.prototype = {
	  /**
	   * Replace the the given header by the given value.
	   * @param {String} name header name
	   * @param {String | Array} value header value
	   */
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length,
	      header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0];
	      }
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          return header.substring(header.indexOf(':')+1).trim();
	        }
	      }
	    }
	
	    return;
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length, regexp,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(header) {
	      length = header.length;
	      for (idx = 0; idx < length; idx++) {
	        result.push(header[idx]);
	      }
	      return result;
	    } else {
	      length = this.extraHeaders.length;
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        header = this.extraHeaders[idx];
	        if (regexp.test(header)) {
	          result.push(header.substring(header.indexOf(':')+1).trim());
	        }
	      }
	      return result;
	    }
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    var regexp, idx,
	      length = this.extraHeaders.length;
	
	    if (this.headers[SIP.Utils.headerize(name)]) {
	      return true;
	    } else {
	      regexp = new RegExp('^\\s*' + name + '\\s*:','i');
	      for (idx = 0; idx < length; idx++) {
	        if (regexp.test(this.extraHeaders[idx])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  },
	
	  toString: function() {
	    var msg = '', header, length, idx;
	
	    msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\r\n';
	
	    for (header in this.headers) {
	      length = this.headers[header].length;
	      for (idx = 0; idx < length; idx++) {
	        msg += header + ': ' + this.headers[header][idx] + '\r\n';
	      }
	    }
	
	    length = this.extraHeaders.length;
	    for (idx = 0; idx < length; idx++) {
	      msg += this.extraHeaders[idx].trim() +'\r\n';
	    }
	
	    msg += getSupportedHeader(this);
	    msg += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	    if(this.body) {
	      length = SIP.Utils.str_utf8_length(this.body);
	      msg += 'Content-Length: ' + length + '\r\n\r\n';
	      msg += this.body;
	    } else {
	      msg += 'Content-Length: 0\r\n\r\n';
	    }
	
	    return msg;
	  }
	};
	
	/**
	 * @augments SIP
	 * @class Class for incoming SIP message.
	 */
	IncomingMessage = function(){
	  this.data = null;
	  this.headers = null;
	  this.method =  null;
	  this.via = null;
	  this.via_branch = null;
	  this.call_id = null;
	  this.cseq = null;
	  this.from = null;
	  this.from_tag = null;
	  this.to = null;
	  this.to_tag = null;
	  this.body = null;
	};
	
	IncomingMessage.prototype = {
	  /**
	  * Insert a header of the given name and value into the last position of the
	  * header array.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  addHeader: function(name, value) {
	    var header = { raw: value };
	
	    name = SIP.Utils.headerize(name);
	
	    if(this.headers[name]) {
	      this.headers[name].push(header);
	    } else {
	      this.headers[name] = [header];
	    }
	  },
	
	  /**
	   * Get the value of the given header name at the given position.
	   * @param {String} name header name
	   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
	   */
	  getHeader: function(name) {
	    var header = this.headers[SIP.Utils.headerize(name)];
	
	    if(header) {
	      if(header[0]) {
	        return header[0].raw;
	      }
	    } else {
	      return;
	    }
	  },
	
	  /**
	   * Get the header/s of the given name.
	   * @param {String} name header name
	   * @returns {Array} Array with all the headers of the specified name.
	   */
	  getHeaders: function(name) {
	    var idx, length,
	      header = this.headers[SIP.Utils.headerize(name)],
	      result = [];
	
	    if(!header) {
	      return [];
	    }
	
	    length = header.length;
	    for (idx = 0; idx < length; idx++) {
	      result.push(header[idx].raw);
	    }
	
	    return result;
	  },
	
	  /**
	   * Verify the existence of the given header.
	   * @param {String} name header name
	   * @returns {boolean} true if header with given name exists, false otherwise
	   */
	  hasHeader: function(name) {
	    return(this.headers[SIP.Utils.headerize(name)]) ? true : false;
	  },
	
	  /**
	  * Parse the given header on the given index.
	  * @param {String} name header name
	  * @param {Number} [idx=0] header index
	  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	  */
	  parseHeader: function(name, idx) {
	    var header, value, parsed;
	
	    name = SIP.Utils.headerize(name);
	
	    idx = idx || 0;
	
	    if(!this.headers[name]) {
	      this.logger.log('header "' + name + '" not present');
	      return;
	    } else if(idx >= this.headers[name].length) {
	      this.logger.log('not so many "' + name + '" headers present');
	      return;
	    }
	
	    header = this.headers[name][idx];
	    value = header.raw;
	
	    if(header.parsed) {
	      return header.parsed;
	    }
	
	    //substitute '-' by '_' for grammar rule matching.
	    parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));
	
	    if(parsed === -1) {
	      this.headers[name].splice(idx, 1); //delete from headers
	      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
	      return;
	    } else {
	      header.parsed = parsed;
	      return parsed;
	    }
	  },
	
	  /**
	   * Message Header attribute selector. Alias of parseHeader.
	   * @param {String} name header name
	   * @param {Number} [idx=0] header index
	   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
	   *
	   * @example
	   * message.s('via',3).port
	   */
	  s: function(name, idx) {
	    return this.parseHeader(name, idx);
	  },
	
	  /**
	  * Replace the value of the given header by the value.
	  * @param {String} name header name
	  * @param {String} value header value
	  */
	  setHeader: function(name, value) {
	    var header = { raw: value };
	    this.headers[SIP.Utils.headerize(name)] = [header];
	  },
	
	  toString: function() {
	    return this.data;
	  }
	};
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP request.
	 */
	IncomingRequest = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.ua = ua;
	  this.headers = {};
	  this.ruri = null;
	  this.transport = null;
	  this.server_transaction = null;
	};
	IncomingRequest.prototype = new IncomingMessage();
	
	/**
	* Stateful reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	* @param {Object} headers extra headers
	* @param {String} body body
	* @param {Function} [onSuccess] onSuccess callback
	* @param {Function} [onFailure] onFailure callback
	*/
	IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
	  var rr, vias, length, idx, response,
	    to = this.getHeader('To'),
	    r = 0,
	    v = 0;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	  extraHeaders = (extraHeaders || []).slice();
	
	  if(this.method === SIP.C.INVITE && code > 100 && code <= 200) {
	    rr = this.getHeaders('record-route');
	    length = rr.length;
	
	    for(r; r < length; r++) {
	      response += 'Record-Route: ' + rr[r] + '\r\n';
	    }
	  }
	
	  vias = this.getHeaders('via');
	  length = vias.length;
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	
	  length = extraHeaders.length;
	  for (idx = 0; idx < length; idx++) {
	    response += extraHeaders[idx].trim() +'\r\n';
	  }
	
	  response += getSupportedHeader(this);
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	
	  if(body) {
	    length = SIP.Utils.str_utf8_length(body);
	    response += 'Content-Type: application/sdp\r\n';
	    response += 'Content-Length: ' + length + '\r\n\r\n';
	    response += body;
	  } else {
	    response += 'Content-Length: ' + 0 + '\r\n\r\n';
	  }
	
	  this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);
	
	  return response;
	};
	
	/**
	* Stateless reply.
	* @param {Number} code status code
	* @param {String} reason reason phrase
	*/
	IncomingRequest.prototype.reply_sl = function(code, reason) {
	  var to, response,
	    v = 0,
	    vias = this.getHeaders('via'),
	    length = vias.length;
	
	  response = SIP.Utils.buildStatusLine(code, reason);
	
	  for(v; v < length; v++) {
	    response += 'Via: ' + vias[v] + '\r\n';
	  }
	
	  to = this.getHeader('To');
	
	  if(!this.to_tag && code > 100) {
	    to += ';tag=' + SIP.Utils.newTag();
	  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
	    to += ';tag=' + this.to_tag;
	  }
	
	  response += 'To: ' + to + '\r\n';
	  response += 'From: ' + this.getHeader('From') + '\r\n';
	  response += 'Call-ID: ' + this.call_id + '\r\n';
	  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
	  response += 'User-Agent: ' + this.ua.configuration.userAgentString +'\r\n';
	  response += 'Content-Length: ' + 0 + '\r\n\r\n';
	
	  this.transport.send(response);
	};
	
	
	/**
	 * @augments IncomingMessage
	 * @class Class for incoming SIP response.
	 */
	IncomingResponse = function(ua) {
	  this.logger = ua.getLogger('sip.sipmessage');
	  this.headers = {};
	  this.status_code = null;
	  this.reason_phrase = null;
	};
	IncomingResponse.prototype = new IncomingMessage();
	
	SIP.OutgoingRequest = OutgoingRequest;
	SIP.IncomingRequest = IncomingRequest;
	SIP.IncomingResponse = IncomingResponse;
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP URI
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP URI.
	 *
	 * @param {String} [scheme]
	 * @param {String} [user]
	 * @param {String} host
	 * @param {String} [port]
	 * @param {Object} [parameters]
	 * @param {Object} [headers]
	 *
	 */
	module.exports = function (SIP) {
	var URI;
	
	URI = function(scheme, user, host, port, parameters, headers) {
	  var param, header, raw, normal;
	
	  // Checks
	  if(!host) {
	    throw new TypeError('missing or invalid "host" parameter');
	  }
	
	  // Initialize parameters
	  scheme = scheme || SIP.C.SIP;
	  this.parameters = {};
	  this.headers = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  for (header in headers) {
	    this.setHeader(header, headers[header]);
	  }
	
	  // Raw URI
	  raw = {
	    scheme: scheme,
	    user: user,
	    host: host,
	    port: port
	  };
	
	  // Normalized URI
	  normal = {
	    scheme: scheme.toLowerCase(),
	    user: user,
	    host: host.toLowerCase(),
	    port: port
	  };
	
	  Object.defineProperties(this, {
	    _normal: {
	      get: function() { return normal; }
	    },
	
	    _raw: {
	      get: function() { return raw; }
	    },
	
	    scheme: {
	      get: function() { return normal.scheme; },
	      set: function(value) {
	        raw.scheme = value;
	        normal.scheme = value.toLowerCase();
	      }
	    },
	
	    user: {
	      get: function() { return normal.user; },
	      set: function(value) {
	        normal.user = raw.user = value;
	      }
	    },
	
	    host: {
	      get: function() { return normal.host; },
	      set: function(value) {
	        raw.host = value;
	        normal.host = value.toLowerCase();
	      }
	    },
	
	    aor: {
	      get: function() { return normal.user + '@' + normal.host; }
	    },
	
	    port: {
	      get: function() { return normal.port; },
	      set: function(value) {
	        normal.port = raw.port = value === 0 ? value : (parseInt(value,10) || null);
	      }
	    }
	  });
	};
	
	URI.prototype = {
	  setParam: function(key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
	    }
	  },
	
	  getParam: function(key) {
	    if(key) {
	      return this.parameters[key.toLowerCase()];
	    }
	  },
	
	  hasParam: function(key) {
	    if(key) {
	      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
	    }
	  },
	
	  deleteParam: function(parameter) {
	    var value;
	    parameter = parameter.toLowerCase();
	    if (this.parameters.hasOwnProperty(parameter)) {
	      value = this.parameters[parameter];
	      delete this.parameters[parameter];
	      return value;
	    }
	  },
	
	  clearParams: function() {
	    this.parameters = {};
	  },
	
	  setHeader: function(name, value) {
	    this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	  },
	
	  getHeader: function(name) {
	    if(name) {
	      return this.headers[SIP.Utils.headerize(name)];
	    }
	  },
	
	  hasHeader: function(name) {
	    if(name) {
	      return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;
	    }
	  },
	
	  deleteHeader: function(header) {
	    var value;
	    header = SIP.Utils.headerize(header);
	    if(this.headers.hasOwnProperty(header)) {
	      value = this.headers[header];
	      delete this.headers[header];
	      return value;
	    }
	  },
	
	  clearHeaders: function() {
	    this.headers = {};
	  },
	
	  clone: function() {
	    return new URI(
	      this._raw.scheme,
	      this._raw.user,
	      this._raw.host,
	      this._raw.port,
	      JSON.parse(JSON.stringify(this.parameters)),
	      JSON.parse(JSON.stringify(this.headers)));
	  },
	
	  toRaw: function() {
	    return this._toString(this._raw);
	  },
	
	  toString: function() {
	    return this._toString(this._normal);
	  },
	
	  _toString: function(uri) {
	    var header, parameter, idx, uriString, headers = [];
	
	    uriString  = uri.scheme + ':';
	    // add slashes if it's not a sip(s) URI
	    if (!uri.scheme.toLowerCase().match("^sips?$")) {
	      uriString += "//";
	    }
	    if (uri.user) {
	      uriString += SIP.Utils.escapeUser(uri.user) + '@';
	    }
	    uriString += uri.host;
	    if (uri.port || uri.port === 0) {
	      uriString += ':' + uri.port;
	    }
	
	    for (parameter in this.parameters) {
	      uriString += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        uriString += '='+ this.parameters[parameter];
	      }
	    }
	
	    for(header in this.headers) {
	      for(idx in this.headers[header]) {
	        headers.push(header + '=' + this.headers[header][idx]);
	      }
	    }
	
	    if (headers.length > 0) {
	      uriString += '?' + headers.join('&');
	    }
	
	    return uriString;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.URI instance or undefined if
	  * it is an invalid URI.
	  * @public
	  * @param {String} uri
	  */
	URI.parse = function(uri) {
	  uri = SIP.Grammar.parse(uri,'SIP_URI');
	
	  if (uri !== -1) {
	    return uri;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.URI = URI;
	};


/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP NameAddrHeader
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a Name Address SIP header.
	 *
	 * @param {SIP.URI} uri
	 * @param {String} [displayName]
	 * @param {Object} [parameters]
	 *
	 */
	module.exports = function (SIP) {
	var NameAddrHeader;
	
	NameAddrHeader = function(uri, displayName, parameters) {
	  var param;
	
	  // Checks
	  if(!uri || !(uri instanceof SIP.URI)) {
	    throw new TypeError('missing or invalid "uri" parameter');
	  }
	
	  // Initialize parameters
	  this.uri = uri;
	  this.parameters = {};
	
	  for (param in parameters) {
	    this.setParam(param, parameters[param]);
	  }
	
	  Object.defineProperties(this, {
	    friendlyName: {
	      get: function() { return this.displayName || uri.aor; }
	    },
	
	    displayName: {
	      get: function() { return displayName; },
	      set: function(value) {
	        displayName = (value === 0) ? '0' : value;
	      }
	    }
	  });
	};
	NameAddrHeader.prototype = {
	  setParam: function (key, value) {
	    if(key) {
	      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
	    }
	  },
	  getParam: SIP.URI.prototype.getParam,
	  hasParam: SIP.URI.prototype.hasParam,
	  deleteParam: SIP.URI.prototype.deleteParam,
	  clearParams: SIP.URI.prototype.clearParams,
	
	  clone: function() {
	    return new NameAddrHeader(
	      this.uri.clone(),
	      this.displayName,
	      JSON.parse(JSON.stringify(this.parameters)));
	  },
	
	  toString: function() {
	    var body, parameter;
	
	    body  = (this.displayName || this.displayName === 0) ? '"' + this.displayName + '" ' : '';
	    body += '<' + this.uri.toString() + '>';
	
	    for (parameter in this.parameters) {
	      body += ';' + parameter;
	
	      if (this.parameters[parameter] !== null) {
	        body += '='+ this.parameters[parameter];
	      }
	    }
	
	    return body;
	  }
	};
	
	
	/**
	  * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
	  * it is an invalid NameAddrHeader.
	  * @public
	  * @param {String} name_addr_header
	  */
	NameAddrHeader.parse = function(name_addr_header) {
	  name_addr_header = SIP.Grammar.parse(name_addr_header,'Name_Addr_Header');
	
	  if (name_addr_header !== -1) {
	    return name_addr_header;
	  } else {
	    return undefined;
	  }
	};
	
	SIP.NameAddrHeader = NameAddrHeader;
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview SIP Transactions
	 */
	
	/**
	 * SIP Transactions module.
	 * @augments SIP
	 */
	module.exports = function (SIP) {
	var
	  C = {
	    // Transaction states
	    STATUS_TRYING:     1,
	    STATUS_PROCEEDING: 2,
	    STATUS_CALLING:    3,
	    STATUS_ACCEPTED:   4,
	    STATUS_COMPLETED:  5,
	    STATUS_TERMINATED: 6,
	    STATUS_CONFIRMED:  7,
	
	    // Transaction types
	    NON_INVITE_CLIENT: 'nict',
	    NON_INVITE_SERVER: 'nist',
	    INVITE_CLIENT: 'ict',
	    INVITE_SERVER: 'ist'
	  };
	
	function buildViaHeader (request_sender, transport, id) {
	  var via;
	  via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);
	  via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;
	  if (request_sender.ua.configuration.forceRport) {
	    via += ';rport';
	  }
	  return via;
	}
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var NonInviteClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.type = C.NON_INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	};
	NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteClientTransaction.prototype.send = function() {
	  var tr = this;
	
	  this.stateChanged(C.STATUS_TRYING);
	  this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	NonInviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.F);
	  SIP.Timers.clearTimeout(this.K);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onTransportError();
	};
	
	NonInviteClientTransaction.prototype.timer_F = function() {
	  this.logger.log('Timer F expired for non-INVITE client transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	  this.request_sender.onRequestTimeout();
	};
	
	NonInviteClientTransaction.prototype.timer_K = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	NonInviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	    tr = this,
	    status_code = response.status_code;
	
	  if(status_code < 200) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        SIP.Timers.clearTimeout(this.F);
	
	        if(status_code === 408) {
	          this.request_sender.onRequestTimeout();
	        } else {
	          this.request_sender.receiveResponse(response);
	        }
	
	        this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	};
	
	
	
	/**
	* @augments SIP.Transactions
	* @class Invite Client Transaction
	* @param {SIP.RequestSender} request_sender
	* @param {SIP.OutgoingRequest} request
	* @param {SIP.Transport} transport
	*/
	var InviteClientTransaction = function(request_sender, request, transport) {
	  var via,
	    tr = this;
	
	  this.type = C.INVITE_CLIENT;
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	
	  this.request_sender.ua.newTransaction(this);
	
	  // Add the cancel property to the request.
	  //Will be called from the request instance, not the transaction itself.
	  this.request.cancel = function(reason) {
	    tr.cancel_request(tr, reason);
	  };
	};
	InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteClientTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteClientTransaction.prototype.send = function() {
	  var tr = this;
	  this.stateChanged(C.STATUS_CALLING);
	  this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);
	
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	InviteClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  SIP.Timers.clearTimeout(this.D);
	  SIP.Timers.clearTimeout(this.M);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	
	  if (this.state !== C.STATUS_ACCEPTED) {
	    this.request_sender.onTransportError();
	  }
	};
	
	// RFC 6026 7.2
	InviteClientTransaction.prototype.timer_M = function() {
	  this.logger.log('Timer M expired for INVITE client transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    SIP.Timers.clearTimeout(this.B);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	  }
	};
	
	// RFC 3261 17.1.1
	InviteClientTransaction.prototype.timer_B = function() {
	  this.logger.log('Timer B expired for INVITE client transaction ' + this.id);
	  if(this.state === C.STATUS_CALLING) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.request_sender.ua.destroyTransaction(this);
	    this.request_sender.onRequestTimeout();
	  }
	};
	
	InviteClientTransaction.prototype.timer_D = function() {
	  this.logger.log('Timer D expired for INVITE client transaction ' + this.id);
	  SIP.Timers.clearTimeout(this.B);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.request_sender.ua.destroyTransaction(this);
	};
	
	InviteClientTransaction.prototype.sendACK = function(response) {
	  var tr = this;
	
	  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
	  this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
	  this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
	  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
	  this.ack += 'Content-Length: 0\r\n';
	  this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
	  this.ack += ' ACK\r\n\r\n';
	
	  this.D = SIP.Timers.setTimeout(tr.timer_D.bind(tr), SIP.Timers.TIMER_D);
	
	  this.transport.send(this.ack);
	};
	
	InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
	  var request = tr.request;
	
	  this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
	  this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';
	
	  if(this.request.headers['Route']) {
	    this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
	  }
	
	  this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
	  this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
	  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
	  this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
	  ' CANCEL\r\n';
	
	  if(reason) {
	    this.cancel += 'Reason: ' + reason + '\r\n';
	  }
	
	  this.cancel += 'Content-Length: 0\r\n\r\n';
	
	  // Send only if a provisional response (>100) has been received.
	  if(this.state === C.STATUS_PROCEEDING) {
	    this.transport.send(this.cancel);
	  }
	};
	
	InviteClientTransaction.prototype.receiveResponse = function(response) {
	  var
	  tr = this,
	  status_code = response.status_code;
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        this.request_sender.receiveResponse(response);
	        if(this.cancel) {
	          this.transport.send(this.cancel);
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_ACCEPTED:
	        this.request_sender.receiveResponse(response);
	        break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_CALLING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.sendACK(response);
	        this.request_sender.receiveResponse(response);
	        break;
	      case C.STATUS_COMPLETED:
	        this.sendACK(response);
	        break;
	    }
	  }
	};
	
	
	/**
	 * @augments SIP.Transactions
	 * @class ACK Client Transaction
	 * @param {SIP.RequestSender} request_sender
	 * @param {SIP.OutgoingRequest} request
	 * @param {SIP.Transport} transport
	 */
	var AckClientTransaction = function(request_sender, request, transport) {
	  var via;
	
	  this.transport = transport;
	  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
	  this.request_sender = request_sender;
	  this.request = request;
	
	  this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);
	
	  via = buildViaHeader(request_sender, transport, this.id);
	  this.request.setHeader('via', via);
	};
	AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	AckClientTransaction.prototype.send = function() {
	  if(!this.transport.send(this.request)) {
	    this.onTransportError();
	  }
	};
	
	AckClientTransaction.prototype.onTransportError = function() {
	  this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);
	  this.request_sender.onTransportError();
	};
	
	
	/**
	* @augments SIP.Transactions
	* @class Non Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var NonInviteServerTransaction = function(request, ua) {
	  this.type = C.NON_INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.nist', this.id);
	
	  this.state = C.STATUS_TRYING;
	
	  ua.newTransaction(this);
	};
	NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	NonInviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	NonInviteServerTransaction.prototype.timer_J = function() {
	  this.logger.log('Timer J expired for non-INVITE server transaction ' + this.id);
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	NonInviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);
	
	    SIP.Timers.clearTimeout(this.J);
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code === 100) {
	    /* RFC 4320 4.1
	     * 'A SIP element MUST NOT
	     * send any provisional response with a
	     * Status-Code other than 100 to a non-INVITE request.'
	     */
	    switch(this.state) {
	      case C.STATUS_TRYING:
	        this.stateChanged(C.STATUS_PROCEEDING);
	        if(!this.transport.send(response))  {
	          this.onTransportError();
	        }
	        break;
	      case C.STATUS_PROCEEDING:
	        this.last_response = response;
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	    }
	  } else if(status_code >= 200 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_TRYING:
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_COMPLETED);
	        this.last_response = response;
	        this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          deferred.resolve();
	        }
	        break;
	      case C.STATUS_COMPLETED:
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	* @augments SIP.Transactions
	* @class Invite Server Transaction
	* @param {SIP.IncomingRequest} request
	* @param {SIP.UA} ua
	*/
	var InviteServerTransaction = function(request, ua) {
	  this.type = C.INVITE_SERVER;
	  this.id = request.via_branch;
	  this.request = request;
	  this.transport = request.transport;
	  this.ua = ua;
	  this.last_response = '';
	  request.server_transaction = this;
	
	  this.logger = ua.getLogger('sip.transaction.ist', this.id);
	
	  this.state = C.STATUS_PROCEEDING;
	
	  ua.newTransaction(this);
	
	  this.resendProvisionalTimer = null;
	
	  request.reply(100);
	};
	InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);
	
	InviteServerTransaction.prototype.stateChanged = function(state) {
	  this.state = state;
	  this.emit('stateChanged');
	};
	
	InviteServerTransaction.prototype.timer_H = function() {
	  this.logger.log('Timer H expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_COMPLETED) {
	    this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
	  }
	
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	InviteServerTransaction.prototype.timer_I = function() {
	  this.stateChanged(C.STATUS_TERMINATED);
	  this.ua.destroyTransaction(this);
	};
	
	// RFC 6026 7.1
	InviteServerTransaction.prototype.timer_L = function() {
	  this.logger.log('Timer L expired for INVITE server transaction ' + this.id);
	
	  if(this.state === C.STATUS_ACCEPTED) {
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.onTransportError = function() {
	  if (!this.transportError) {
	    this.transportError = true;
	
	    this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);
	
	    if (this.resendProvisionalTimer !== null) {
	      SIP.Timers.clearInterval(this.resendProvisionalTimer);
	      this.resendProvisionalTimer = null;
	    }
	
	    SIP.Timers.clearTimeout(this.L);
	    SIP.Timers.clearTimeout(this.H);
	    SIP.Timers.clearTimeout(this.I);
	
	    this.stateChanged(C.STATUS_TERMINATED);
	    this.ua.destroyTransaction(this);
	  }
	};
	
	InviteServerTransaction.prototype.resend_provisional = function() {
	  if(!this.transport.send(this.last_response)) {
	    this.onTransportError();
	  }
	};
	
	// INVITE Server Transaction RFC 3261 17.2.1
	InviteServerTransaction.prototype.receiveResponse = function(status_code, response) {
	  var tr = this;
	  var deferred = SIP.Utils.defer();
	
	  if(status_code >= 100 && status_code <= 199) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	        }
	        this.last_response = response;
	        break;
	    }
	  }
	
	  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
	    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
	    if(this.resendProvisionalTimer === null) {
	      this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr),
	        SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);
	    }
	  } else if(status_code >= 200 && status_code <= 299) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        this.stateChanged(C.STATUS_ACCEPTED);
	        this.last_response = response;
	        this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);
	
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	        /* falls through */
	        case C.STATUS_ACCEPTED:
	          // Note that this point will be reached for proceeding tr.state also.
	          if(!this.transport.send(response)) {
	            this.onTransportError();
	            deferred.reject();
	          } else {
	            deferred.resolve();
	          }
	          break;
	    }
	  } else if(status_code >= 300 && status_code <= 699) {
	    switch(this.state) {
	      case C.STATUS_PROCEEDING:
	        if (this.resendProvisionalTimer !== null) {
	          SIP.Timers.clearInterval(this.resendProvisionalTimer);
	          this.resendProvisionalTimer = null;
	        }
	
	        if(!this.transport.send(response)) {
	          this.onTransportError();
	          deferred.reject();
	        } else {
	          this.stateChanged(C.STATUS_COMPLETED);
	          this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);
	          deferred.resolve();
	        }
	        break;
	    }
	  }
	
	  return deferred.promise;
	};
	
	/**
	 * @function
	 * @param {SIP.UA} ua
	 * @param {SIP.IncomingRequest} request
	 *
	 * @return {boolean}
	 * INVITE:
	 *  _true_ if retransmission
	 *  _false_ new request
	 *
	 * ACK:
	 *  _true_  ACK to non2xx response
	 *  _false_ ACK must be passed to TU (accepted state)
	 *          ACK to 2xx response
	 *
	 * CANCEL:
	 *  _true_  no matching invite transaction
	 *  _false_ matching invite transaction and no final response sent
	 *
	 * OTHER:
	 *  _true_  retransmission
	 *  _false_ new request
	 */
	var checkTransaction = function(ua, request) {
	  var tr;
	
	  switch(request.method) {
	    case SIP.C.INVITE:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_PROCEEDING:
	            tr.transport.send(tr.last_response);
	            break;
	
	            // RFC 6026 7.1 Invite retransmission
	            //received while in C.STATUS_ACCEPTED state. Absorb it.
	          case C.STATUS_ACCEPTED:
	            break;
	        }
	        return true;
	      }
	      break;
	    case SIP.C.ACK:
	      tr = ua.transactions.ist[request.via_branch];
	
	      // RFC 6026 7.1
	      if(tr) {
	        if(tr.state === C.STATUS_ACCEPTED) {
	          return false;
	        } else if(tr.state === C.STATUS_COMPLETED) {
	          tr.state = C.STATUS_CONFIRMED;
	          tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);
	          return true;
	        }
	      }
	
	      // ACK to 2XX Response.
	      else {
	        return false;
	      }
	      break;
	    case SIP.C.CANCEL:
	      tr = ua.transactions.ist[request.via_branch];
	      if(tr) {
	        request.reply_sl(200);
	        if(tr.state === C.STATUS_PROCEEDING) {
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        request.reply_sl(481);
	        return true;
	      }
	      break;
	    default:
	
	      // Non-INVITE Server Transaction RFC 3261 17.2.2
	      tr = ua.transactions.nist[request.via_branch];
	      if(tr) {
	        switch(tr.state) {
	          case C.STATUS_TRYING:
	            break;
	          case C.STATUS_PROCEEDING:
	          case C.STATUS_COMPLETED:
	            tr.transport.send(tr.last_response);
	            break;
	        }
	        return true;
	      }
	      break;
	  }
	};
	
	SIP.Transactions = {
	  C: C,
	  checkTransaction: checkTransaction,
	  NonInviteClientTransaction: NonInviteClientTransaction,
	  InviteClientTransaction: InviteClientTransaction,
	  AckClientTransaction: AckClientTransaction,
	  NonInviteServerTransaction: NonInviteServerTransaction,
	  InviteServerTransaction: InviteServerTransaction
	};
	
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview SIP Dialog
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP dialog.
	 * @param {SIP.RTCSession} owner
	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
	 * @param {Enum} type UAC / UAS
	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
	 */
	module.exports = function (SIP) {
	
	var RequestSender = __webpack_require__(227)(SIP);
	
	var Dialog,
	  C = {
	    // Dialog states
	    STATUS_EARLY:       1,
	    STATUS_CONFIRMED:   2
	  };
	
	// RFC 3261 12.1
	Dialog = function(owner, message, type, state) {
	  var contact;
	
	  this.uac_pending_reply = false;
	  this.uas_pending_reply = false;
	
	  if(!message.hasHeader('contact')) {
	    return {
	      error: 'unable to create a Dialog without Contact header field'
	    };
	  }
	
	  if(message instanceof SIP.IncomingResponse) {
	    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
	  } else {
	    // Create confirmed dialog if state is not defined
	    state = state || C.STATUS_CONFIRMED;
	  }
	
	  contact = message.parseHeader('contact');
	
	  // RFC 3261 12.1.1
	  if(type === 'UAS') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.to_tag,
	      remote_tag: message.from_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.remote_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('to').uri;
	    this.remote_uri = message.parseHeader('from').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route');
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	  }
	  // RFC 3261 12.1.2
	  else if(type === 'UAC') {
	    this.id = {
	      call_id: message.call_id,
	      local_tag: message.from_tag,
	      remote_tag: message.to_tag,
	      toString: function() {
	        return this.call_id + this.local_tag + this.remote_tag;
	      }
	    };
	    this.state = state;
	    this.invite_seqnum = message.cseq;
	    this.local_seqnum = message.cseq;
	    this.local_uri = message.parseHeader('from').uri;
	    this.pracked = [];
	    this.remote_uri = message.parseHeader('to').uri;
	    this.remote_target = contact.uri;
	    this.route_set = message.getHeaders('record-route').reverse();
	
	    //RENDERBODY
	    if (this.state === C.STATUS_EARLY && (!owner.hasOffer)) {
	      this.mediaHandler = owner.mediaHandlerFactory(owner);
	    }
	  }
	
	  this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());
	  this.owner = owner;
	  owner.ua.dialogs[this.id.toString()] = this;
	  this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
	  owner.emit('dialog', this);
	};
	
	Dialog.prototype = {
	  /**
	   * @param {SIP.IncomingMessage} message
	   * @param {Enum} UAC/UAS
	   */
	  update: function(message, type) {
	    this.state = C.STATUS_CONFIRMED;
	
	    this.logger.log('dialog '+ this.id.toString() +'  changed to CONFIRMED state');
	
	    if(type === 'UAC') {
	      // RFC 3261 13.2.2.4
	      this.route_set = message.getHeaders('record-route').reverse();
	    }
	  },
	
	  terminate: function() {
	    this.logger.log('dialog ' + this.id.toString() + ' deleted');
	    if (this.mediaHandler && this.state !== C.STATUS_CONFIRMED) {
	      this.mediaHandler.peerConnection.close();
	    }
	    delete this.owner.ua.dialogs[this.id.toString()];
	  },
	
	  /**
	  * @param {String} method request method
	  * @param {Object} extraHeaders extra headers
	  * @returns {SIP.OutgoingRequest}
	  */
	
	  // RFC 3261 12.2.1.1
	  createRequest: function(method, extraHeaders, body) {
	    var cseq, request;
	    extraHeaders = (extraHeaders || []).slice();
	
	    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }
	
	    cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;
	
	    request = new SIP.OutgoingRequest(
	      method,
	      this.remote_target,
	      this.owner.ua, {
	        'cseq': cseq,
	        'call_id': this.id.call_id,
	        'from_uri': this.local_uri,
	        'from_tag': this.id.local_tag,
	        'to_uri': this.remote_uri,
	        'to_tag': this.id.remote_tag,
	        'route_set': this.route_set
	      }, extraHeaders, body);
	
	    request.dialog = this;
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  * @returns {Boolean}
	  */
	
	  // RFC 3261 12.2.2
	  checkInDialogRequest: function(request) {
	    var self = this;
	
	    if(!this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    } else if(request.cseq < this.remote_seqnum) {
	        //Do not try to reply to an ACK request.
	        if (request.method !== SIP.C.ACK) {
	          request.reply(500);
	        }
	        if (request.cseq === this.invite_seqnum) {
	          return true;
	        }
	        return false;
	    } else if(request.cseq > this.remote_seqnum) {
	      this.remote_seqnum = request.cseq;
	    }
	
	    switch(request.method) {
	      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
	      case SIP.C.INVITE:
	        if (this.uac_pending_reply === true) {
	          request.reply(491);
	        } else if (this.uas_pending_reply === true) {
	          var retryAfter = (Math.random() * 10 | 0) + 1;
	          request.reply(500, null, ['Retry-After:' + retryAfter]);
	          return false;
	        } else {
	          this.uas_pending_reply = true;
	          request.server_transaction.on('stateChanged', function stateChanged(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	                this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	                this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	              this.removeListener('stateChanged', stateChanged);
	              self.uas_pending_reply = false;
	
	              if (self.uac_pending_reply === false) {
	                self.owner.onReadyToReinvite();
	              }
	            }
	          });
	        }
	
	        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	      case SIP.C.NOTIFY:
	        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
	        if(request.hasHeader('contact')) {
	          request.server_transaction.on('stateChanged', function(){
	            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {
	              self.remote_target = request.parseHeader('contact').uri;
	            }
	          });
	        }
	        break;
	    }
	
	    return true;
	  },
	
	  sendRequest: function(applicant, method, options) {
	    options = options || {};
	
	    var
	      extraHeaders = (options.extraHeaders || []).slice(),
	      body = options.body || null,
	      request = this.createRequest(method, extraHeaders, body),
	      request_sender = new RequestSender(this, applicant, request);
	
	    request_sender.send();
	
	    return request;
	  },
	
	  /**
	  * @param {SIP.IncomingRequest} request
	  */
	  receiveRequest: function(request) {
	    //Check in-dialog request
	    if(!this.checkInDialogRequest(request)) {
	      return;
	    }
	
	    this.owner.receiveRequest(request);
	  }
	};
	
	Dialog.C = C;
	SIP.Dialog = Dialog;
	};


/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview In-Dialog Request Sender
	 */
	
	/**
	 * @augments SIP.Dialog
	 * @class Class creating an In-dialog request sender.
	 * @param {SIP.Dialog} dialog
	 * @param {Object} applicant
	 * @param {SIP.OutgoingRequest} request
	 */
	/**
	 * @fileoverview in-Dialog Request Sender
	 */
	
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(dialog, applicant, request) {
	
	  this.dialog = dialog;
	  this.applicant = applicant;
	  this.request = request;
	
	  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
	  this.reattempt = false;
	  this.reattemptTimer = null;
	};
	
	RequestSender.prototype = {
	  send: function() {
	    var self = this,
	      request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);
	
	      request_sender.send();
	
	    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
	    if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      this.dialog.uac_pending_reply = true;
	      request_sender.clientTransaction.on('stateChanged', function stateChanged(){
	        if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||
	            this.state === SIP.Transactions.C.STATUS_COMPLETED ||
	            this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	
	          this.removeListener('stateChanged', stateChanged);
	          self.dialog.uac_pending_reply = false;
	
	          if (self.dialog.uas_pending_reply === false) {
	            self.dialog.owner.onReadyToReinvite();
	          }
	        }
	      });
	    }
	  },
	
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  receiveResponse: function(response) {
	    var self = this;
	
	    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
	    if (response.status_code === 408 || response.status_code === 481) {
	      this.applicant.onDialogError(response);
	    } else if (response.method === SIP.C.INVITE && response.status_code === 491) {
	      if (this.reattempt) {
	        this.applicant.receiveResponse(response);
	      } else {
	        this.request.cseq.value = this.dialog.local_seqnum += 1;
	        this.reattemptTimer = SIP.Timers.setTimeout(
	          function() {
	            if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {
	              self.reattempt = true;
	              self.request_sender.send();
	            }
	          },
	          this.getReattemptTimeout()
	        );
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	return RequestSender;
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview Request Sender
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a request sender.
	 * @param {Object} applicant
	 * @param {SIP.UA} ua
	 */
	module.exports = function (SIP) {
	var RequestSender;
	
	RequestSender = function(applicant, ua) {
	  this.logger = ua.getLogger('sip.requestsender');
	  this.ua = ua;
	  this.applicant = applicant;
	  this.method = applicant.request.method;
	  this.request = applicant.request;
	  this.credentials = null;
	  this.challenged = false;
	  this.staled = false;
	
	  // If ua is in closing process or even closed just allow sending Bye and ACK
	  if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {
	    this.onTransportError();
	  }
	};
	
	/**
	* Create the client transaction and send the message.
	*/
	RequestSender.prototype = {
	  send: function() {
	    switch(this.method) {
	      case "INVITE":
	        this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
	        break;
	      case "ACK":
	        this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
	        break;
	      default:
	        this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
	    }
	    this.clientTransaction.send();
	
	    return this.clientTransaction;
	  },
	
	  /**
	  * Callback fired when receiving a request timeout error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onRequestTimeout: function() {
	    this.applicant.onRequestTimeout();
	  },
	
	  /**
	  * Callback fired when receiving a transport error from the client transaction.
	  * To be re-defined by the applicant.
	  * @event
	  */
	  onTransportError: function() {
	    this.applicant.onTransportError();
	  },
	
	  /**
	  * Called from client transaction when receiving a correct response to the request.
	  * Authenticate request if needed or pass the response back to the applicant.
	  * @param {SIP.IncomingResponse} response
	  */
	  receiveResponse: function(response) {
	    var cseq, challenge, authorization_header_name,
	      status_code = response.status_code;
	
	    /*
	    * Authentication
	    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
	    */
	    if (status_code === 401 || status_code === 407) {
	
	      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
	      if (response.status_code === 401) {
	        challenge = response.parseHeader('www-authenticate');
	        authorization_header_name = 'authorization';
	      } else {
	        challenge = response.parseHeader('proxy-authenticate');
	        authorization_header_name = 'proxy-authorization';
	      }
	
	      // Verify it seems a valid challenge.
	      if (! challenge) {
	        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
	        this.applicant.receiveResponse(response);
	        return;
	      }
	
	      if (!this.challenged || (!this.staled && challenge.stale === true)) {
	        if (!this.credentials) {
	          this.credentials = this.ua.configuration.authenticationFactory(this.ua);
	        }
	
	        // Verify that the challenge is really valid.
	        if (!this.credentials.authenticate(this.request, challenge)) {
	          this.applicant.receiveResponse(response);
	          return;
	        }
	        this.challenged = true;
	
	        if (challenge.stale) {
	          this.staled = true;
	        }
	
	        if (response.method === SIP.C.REGISTER) {
	          cseq = this.applicant.cseq += 1;
	        } else if (this.request.dialog){
	          cseq = this.request.dialog.local_seqnum += 1;
	        } else {
	          cseq = this.request.cseq + 1;
	          this.request.cseq = cseq;
	        }
	        this.request.setHeader('cseq', cseq +' '+ this.method);
	
	        this.request.setHeader(authorization_header_name, this.credentials.toString());
	        this.send();
	      } else {
	        this.applicant.receiveResponse(response);
	      }
	    } else {
	      this.applicant.receiveResponse(response);
	    }
	  }
	};
	
	SIP.RequestSender = RequestSender;
	};


/***/ },
/* 229 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	
	var RegisterContext;
	
	RegisterContext = function (ua) {
	  var params = {},
	      regId = 1;
	
	  this.registrar = ua.configuration.registrarServer;
	  this.expires = ua.configuration.registerExpires;
	
	
	  // Contact header
	  this.contact = ua.contact.toString();
	
	  if(regId) {
	    this.contact += ';reg-id='+ regId;
	    this.contact += ';+sip.instance="<urn:uuid:'+ ua.configuration.instanceId+'>"';
	  }
	
	  // Call-ID and CSeq values RFC3261 10.2
	  this.call_id = SIP.Utils.createRandomToken(22);
	  this.cseq = 80;
	
	  this.to_uri = ua.configuration.uri;
	
	  params.to_uri = this.to_uri;
	  params.to_displayName = ua.configuration.displayName;
	  params.call_id = this.call_id;
	  params.cseq = this.cseq;
	
	  // Extends ClientContext
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, {params: params}]);
	
	  this.registrationTimer = null;
	  this.registrationExpiredTimer = null;
	
	  // Set status
	  this.registered = false;
	
	  this.logger = ua.getLogger('sip.registercontext');
	};
	
	RegisterContext.prototype = {
	  register: function (options) {
	    var self = this, extraHeaders;
	
	    // Handle Options
	    this.options = options || {};
	    extraHeaders = (this.options.extraHeaders || []).slice();
	    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);
	    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	    // Save original extraHeaders to be used in .close
	    this.closeHeaders = this.options.closeWithHeaders ?
	      (this.options.extraHeaders || []).slice() : [];
	
	    this.receiveResponse = function(response) {
	      var contact, expires,
	        contacts = response.getHeaders('contact').length,
	        cause;
	
	      // Discard responses to older REGISTER/un-REGISTER requests.
	      if(response.cseq !== this.cseq) {
	        return;
	      }
	
	      // Clear registration timer
	      if (this.registrationTimer !== null) {
	        SIP.Timers.clearTimeout(this.registrationTimer);
	        this.registrationTimer = null;
	      }
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	
	          if(response.hasHeader('expires')) {
	            expires = response.getHeader('expires');
	          }
	
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	
	          // Search the Contact pointing to us and update the expires value accordingly.
	          if (!contacts) {
	            this.logger.warn('no Contact header in response to REGISTER, response ignored');
	            break;
	          }
	
	          while(contacts--) {
	            contact = response.parseHeader('contact', contacts);
	            if(contact.uri.user === this.ua.contact.uri.user) {
	              expires = contact.getParam('expires');
	              break;
	            } else {
	              contact = null;
	            }
	          }
	
	          if (!contact) {
	            this.logger.warn('no Contact header pointing to us, response ignored');
	            break;
	          }
	
	          if(!expires) {
	            expires = this.expires;
	          }
	
	          // Re-Register before the expiration interval has elapsed.
	          // For that, decrease the expires value. ie: 3 seconds
	          this.registrationTimer = SIP.Timers.setTimeout(function() {
	            self.registrationTimer = null;
	            self.register(self.options);
	          }, (expires * 1000) - 3000);
	          this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {
	            self.logger.warn('registration expired');
	            if (self.registered) {
	              self.unregistered(null, SIP.C.causes.EXPIRES);
	            }
	          }, expires * 1000);
	
	          //Save gruu values
	          if (contact.hasParam('temp-gruu')) {
	            this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/"/g,''));
	          }
	          if (contact.hasParam('pub-gruu')) {
	            this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/"/g,''));
	          }
	
	          this.registered = true;
	          this.emit('registered', response || null);
	          break;
	        // Interval too brief RFC3261 10.2.8
	        case /^423$/.test(response.status_code):
	          if(response.hasHeader('min-expires')) {
	            // Increase our registration interval to the suggested minimum
	            this.expires = response.getHeader('min-expires');
	            // Attempt the registration again immediately
	            this.register(this.options);
	          } else { //This response MUST contain a Min-Expires header field
	            this.logger.warn('423 response received for REGISTER without Min-Expires');
	            this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);
	          }
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.registrationFailure(response, cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	    this.send();
	  },
	
	  registrationFailure: function (response, cause) {
	    this.emit('failed', response || null, cause || null);
	  },
	
	  onTransportClosed: function() {
	    this.registered_before = this.registered;
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if (this.registrationExpiredTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	      this.registrationExpiredTimer = null;
	    }
	
	    if(this.registered) {
	      this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onTransportConnected: function() {
	    this.register(this.options);
	  },
	
	  close: function() {
	    var options = {
	      all: false,
	      extraHeaders: this.closeHeaders
	    };
	
	    this.registered_before = this.registered;
	    this.unregister(options);
	  },
	
	  unregister: function(options) {
	    var extraHeaders;
	
	    options = options || {};
	
	    if(!this.registered && !options.all) {
	      this.logger.warn('already unregistered');
	      return;
	    }
	
	    extraHeaders = (options.extraHeaders || []).slice();
	
	    this.registered = false;
	
	    // Clear the registration timer.
	    if (this.registrationTimer !== null) {
	      SIP.Timers.clearTimeout(this.registrationTimer);
	      this.registrationTimer = null;
	    }
	
	    if(options.all) {
	      extraHeaders.push('Contact: *');
	      extraHeaders.push('Expires: 0');
	    } else {
	      extraHeaders.push('Contact: '+ this.contact + ';expires=0');
	    }
	
	
	    this.receiveResponse = function(response) {
	      var cause;
	
	      switch(true) {
	        case /^1[0-9]{2}$/.test(response.status_code):
	          this.emit('progress', response);
	          break;
	        case /^2[0-9]{2}$/.test(response.status_code):
	          this.emit('accepted', response);
	          if (this.registrationExpiredTimer !== null) {
	            SIP.Timers.clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = null;
	          }
	          this.unregistered(response);
	          break;
	        default:
	          cause = SIP.Utils.sipErrorCause(response.status_code);
	          this.unregistered(response,cause);
	      }
	    };
	
	    this.onRequestTimeout = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);
	    };
	
	    this.onTransportError = function() {
	      // Not actually unregistered...
	      //this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);
	    };
	
	    this.cseq++;
	    this.request.cseq = this.cseq;
	    this.request.setHeader('cseq', this.cseq + ' REGISTER');
	    this.request.extraHeaders = extraHeaders;
	
	    this.send();
	  },
	
	  unregistered: function(response, cause) {
	    this.registered = false;
	    this.emit('unregistered', response || null, cause || null);
	  }
	
	};
	
	
	SIP.RegisterContext = RegisterContext;
	};


/***/ },
/* 230 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	module.exports = function (EventEmitter) {
	var MediaHandler = function(session, options) {
	  // keep jshint happy
	  session = session;
	  options = options;
	};
	
	MediaHandler.prototype = Object.create(EventEmitter.prototype, {
	  isReady: {value: function isReady () {}},
	
	  close: {value: function close () {}},
	
	  /**
	   * @param {Object} [mediaHint] A custom object describing the media to be used during this session.
	   */
	  getDescription: {value: function getDescription (mediaHint) {
	    // keep jshint happy
	    mediaHint = mediaHint;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} description
	  */
	  setDescription: {value: function setDescription (description) {
	    // keep jshint happy
	    description = description;
	  }}
	});
	
	return MediaHandler;
	};


/***/ },
/* 231 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ClientContext;
	
	ClientContext = function (ua, method, target, options) {
	  var originalTarget = target;
	
	  // Validate arguments
	  if (target === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.clientcontext');
	  this.method = method;
	  target = ua.normalizeTarget(target);
	  if (!target) {
	    throw new TypeError('Invalid target: ' + originalTarget);
	  }
	
	  /* Options
	   * - extraHeaders
	   * - params
	   * - contentType
	   * - body
	   */
	  options = Object.create(options || Object.prototype);
	  options.extraHeaders = (options.extraHeaders || []).slice();
	
	  if (options.contentType) {
	    this.contentType = options.contentType;
	    options.extraHeaders.push('Content-Type: ' + this.contentType);
	  }
	
	  // Build the request
	  this.request = new SIP.OutgoingRequest(this.method,
	                                         target,
	                                         this.ua,
	                                         options.params,
	                                         options.extraHeaders);
	  if (options.body) {
	    this.body = options.body;
	    this.request.body = this.body;
	  }
	
	  /* Set other properties from the request */
	  this.localIdentity = this.request.from;
	  this.remoteIdentity = this.request.to;
	
	  this.data = {};
	};
	ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ClientContext.prototype.send = function () {
	  (new SIP.RequestSender(this, this.ua)).send();
	  return this;
	};
	
	ClientContext.prototype.cancel = function (options) {
	  options = options || {};
	
	  var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	  this.request.cancel(cancel_reason);
	
	  this.emit('cancel');
	};
	
	ClientContext.prototype.receiveResponse = function (response) {
	  var cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      this.emit('progress', response, cause);
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('accepted', response, cause);
	      break;
	
	    default:
	      if(this.ua.applicants[this]) {
	        delete this.ua.applicants[this];
	      }
	      this.emit('rejected', response, cause);
	      this.emit('failed', response, cause);
	      break;
	  }
	
	};
	
	ClientContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ClientContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ClientContext = ClientContext;
	};


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	module.exports = function (SIP) {
	var ServerContext;
	
	ServerContext = function (ua, request) {
	  this.ua = ua;
	  this.logger = ua.getLogger('sip.servercontext');
	  this.request = request;
	  if (request.method === SIP.C.INVITE) {
	    this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);
	  } else {
	    this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);
	  }
	
	  if (request.body) {
	    this.body = request.body;
	  }
	  if (request.hasHeader('Content-Type')) {
	    this.contentType = request.getHeader('Content-Type');
	  }
	  this.method = request.method;
	
	  this.data = {};
	
	  this.localIdentity = request.to;
	  this.remoteIdentity = request.from;
	};
	
	ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);
	
	ServerContext.prototype.progress = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 180);
	  options.minCode = 100;
	  options.maxCode = 199;
	  options.events = ['progress'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.accept = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 200);
	  options.minCode = 200;
	  options.maxCode = 299;
	  options.events = ['accepted'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reject = function (options) {
	  options = Object.create(options || Object.prototype);
	  options.statusCode || (options.statusCode = 480);
	  options.minCode = 300;
	  options.maxCode = 699;
	  options.events = ['rejected', 'failed'];
	  return this.reply(options);
	};
	
	ServerContext.prototype.reply = function (options) {
	  options = options || {}; // This is okay, so long as we treat options as read-only in this method
	  var
	    statusCode = options.statusCode || 100,
	    minCode = options.minCode || 100,
	    maxCode = options.maxCode || 699,
	    reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase),
	    extraHeaders = options.extraHeaders || [],
	    body = options.body,
	    events = options.events || [],
	    response;
	
	  if (statusCode < minCode || statusCode > maxCode) {
	    throw new TypeError('Invalid statusCode: ' + statusCode);
	  }
	  response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	  events.forEach(function (event) {
	    this.emit(event, response, reasonPhrase);
	  }, this);
	
	  return this;
	};
	
	ServerContext.prototype.onRequestTimeout = function () {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	};
	
	ServerContext.prototype.onTransportError = function () {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	};
	
	SIP.ServerContext = ServerContext;
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (SIP, environment) {
	
	var DTMF = __webpack_require__(234)(SIP);
	
	var Session, InviteServerContext, InviteClientContext,
	 C = {
	    //Session states
	    STATUS_NULL:                        0,
	    STATUS_INVITE_SENT:                 1,
	    STATUS_1XX_RECEIVED:                2,
	    STATUS_INVITE_RECEIVED:             3,
	    STATUS_WAITING_FOR_ANSWER:          4,
	    STATUS_ANSWERED:                    5,
	    STATUS_WAITING_FOR_PRACK:           6,
	    STATUS_WAITING_FOR_ACK:             7,
	    STATUS_CANCELED:                    8,
	    STATUS_TERMINATED:                  9,
	    STATUS_ANSWERED_WAITING_FOR_PRACK: 10,
	    STATUS_EARLY_MEDIA:                11,
	    STATUS_CONFIRMED:                  12
	  };
	
	/*
	 * @param {function returning SIP.MediaHandler} [mediaHandlerFactory]
	 *        (See the documentation for the mediaHandlerFactory argument of the UA constructor.)
	 */
	Session = function (mediaHandlerFactory) {
	  this.status = C.STATUS_NULL;
	  this.dialog = null;
	  this.earlyDialogs = {};
	  this.mediaHandlerFactory = mediaHandlerFactory || SIP.WebRTC.MediaHandler.defaultFactory;
	  // this.mediaHandler gets set by ICC/ISC constructors
	  this.hasOffer = false;
	  this.hasAnswer = false;
	
	  // Session Timers
	  this.timers = {
	    ackTimer: null,
	    expiresTimer: null,
	    invite2xxTimer: null,
	    userNoAnswerTimer: null,
	    rel1xxTimer: null,
	    prackTimer: null
	  };
	
	  // Session info
	  this.startTime = null;
	  this.endTime = null;
	  this.tones = null;
	
	  // Mute/Hold state
	  this.local_hold = false;
	  this.remote_hold = false;
	
	  this.pending_actions = {
	    actions: [],
	
	    length: function() {
	      return this.actions.length;
	    },
	
	    isPending: function(name){
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          return true;
	        }
	      }
	      return false;
	    },
	
	    shift: function() {
	      return this.actions.shift();
	    },
	
	    push: function(name) {
	      this.actions.push({
	        name: name
	      });
	    },
	
	    pop: function(name) {
	      var
	      idx = 0,
	      length = this.actions.length;
	
	      for (idx; idx<length; idx++) {
	        if (this.actions[idx].name === name) {
	          this.actions.splice(idx,1);
	          length --;
	          idx--;
	        }
	      }
	    }
	   };
	
	  this.early_sdp = null;
	  this.rel100 = SIP.C.supported.UNSUPPORTED;
	};
	
	Session.prototype = {
	  dtmf: function(tones, options) {
	    var tone, dtmfs = [],
	        self = this;
	
	    options = options || {};
	
	    if (tones === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // Check tones
	    if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
	      throw new TypeError('Invalid tones: '+ tones);
	    }
	
	    tones = tones.toString().split('');
	
	    while (tones.length > 0) { dtmfs.push(new DTMF(this, tones.shift(), options)); }
	
	    if (this.tones) {
	      // Tones are already queued, just add to the queue
	      this.tones =  this.tones.concat(dtmfs);
	      return this;
	    }
	
	    var sendDTMF = function () {
	      var dtmf, timeout;
	
	      if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {
	        // Stop sending DTMF
	        self.tones = null;
	        return this;
	      }
	
	      dtmf = self.tones.shift();
	
	      if (tone === ',') {
	        timeout = 2000;
	      } else {
	        dtmf.on('failed', function(){self.tones = null;});
	        dtmf.send(options);
	        timeout = dtmf.duration + dtmf.interToneGap;
	      }
	
	      // Set timeout for the next tone
	      SIP.Timers.setTimeout(sendDTMF, timeout);
	    };
	
	    this.tones = dtmfs;
	    sendDTMF();
	    return this;
	  },
	
	  bye: function(options) {
	    options = Object.create(options || Object.prototype);
	    var statusCode = options.statusCode;
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      this.logger.error('Error: Attempted to send BYE in a terminated session.');
	      return this;
	    }
	
	    this.logger.log('terminating Session');
	
	    if (statusCode && (statusCode < 200 || statusCode >= 700)) {
	      throw new TypeError('Invalid statusCode: '+ statusCode);
	    }
	
	    options.receiveResponse = function () {};
	
	    return this.
	      sendRequest(SIP.C.BYE, options).
	      terminated();
	  },
	
	  refer: function(target, options) {
	    options = options || {};
	    var extraHeaders = (options.extraHeaders || []).slice(),
	        withReplaces =
	          target instanceof SIP.InviteServerContext ||
	          target instanceof SIP.InviteClientContext,
	        originalTarget = target;
	
	    if (target === undefined) {
	      throw new TypeError('Not enough arguments');
	    }
	
	    // Check Session Status
	    if (this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    // transform `target` so that it can be a Refer-To header value
	    if (withReplaces) {
	      //Attended Transfer
	      // B.transfer(C)
	      target = '"' + target.remoteIdentity.friendlyName + '" ' +
	        '<' + target.dialog.remote_target.toString() +
	        '?Replaces=' + target.dialog.id.call_id +
	        '%3Bto-tag%3D' + target.dialog.id.remote_tag +
	        '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';
	    } else {
	      //Blind Transfer
	      // normalizeTarget allows instances of SIP.URI to pass through unaltered,
	      // so try to make one ahead of time
	      try {
	        target = SIP.Grammar.parse(target, 'Refer_To').uri || target;
	      } catch (e) {
	        this.logger.debug(".refer() cannot parse Refer_To from", target);
	        this.logger.debug("...falling through to normalizeTarget()");
	      }
	
	      // Check target validity
	      target = this.ua.normalizeTarget(target);
	      if (!target) {
	        throw new TypeError('Invalid target: ' + originalTarget);
	      }
	    }
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Refer-To: '+ target);
	
	    // Send the request
	    this.sendRequest(SIP.C.REFER, {
	      extraHeaders: extraHeaders,
	      body: options.body,
	      receiveResponse: function (response) {
	        if ( ! /^2[0-9]{2}$/.test(response.status_code) ) {
	          return;
	        }
	        // hang up only if we transferred to a SIP address
	        if (withReplaces || (target.scheme && target.scheme.match("^sips?$"))) {
	          this.terminate();
	        }
	      }.bind(this)
	    });
	    return this;
	  },
	
	  followRefer: function followRefer (callback) {
	    return function referListener (callback, request) {
	      // open non-SIP URIs if possible and keep session open
	      var referTo = request.parseHeader('refer-to');
	      var target = referTo.uri;
	      if (!target.scheme.match("^sips?$")) {
	        var targetString = target.toString();
	        if (typeof environment.open === "function") {
	          environment.open(targetString);
	        } else {
	          this.logger.warn("referred to non-SIP URI but `open` isn't in the environment: " + targetString);
	        }
	        return;
	      }
	
	      var extraHeaders = [];
	
	      /* Copy the Replaces query into a Replaces header */
	      /* TODO - make sure we don't copy a poorly formatted header? */
	      var replaces = target.getHeader('Replaces');
	      if (replaces !== undefined) {
	        extraHeaders.push('Replaces: ' + decodeURIComponent(replaces));
	      }
	
	      // don't embed headers into Request-URI of INVITE
	      target.clearHeaders();
	
	      /*
	        Harmless race condition.  Both sides of REFER
	        may send a BYE, but in the end the dialogs are destroyed.
	      */
	      var getReferMedia = this.mediaHandler.getReferMedia;
	      var mediaHint = getReferMedia ? getReferMedia.call(this.mediaHandler) : this.mediaHint;
	
	      SIP.Hacks.Chrome.getsConfusedAboutGUM(this);
	
	      var referSession = this.ua.invite(target, {
	        media: mediaHint,
	        params: {
	          to_displayName: referTo.friendlyName
	        },
	        extraHeaders: extraHeaders
	      });
	
	      callback.call(this, request, referSession);
	
	      this.terminate();
	    }.bind(this, callback);
	  },
	
	  sendRequest: function(method,options) {
	    options = options || {};
	    var self = this;
	
	    var request = new SIP.OutgoingRequest(
	      method,
	      this.dialog.remote_target,
	      this.ua,
	      {
	        cseq: options.cseq || (this.dialog.local_seqnum += 1),
	        call_id: this.dialog.id.call_id,
	        from_uri: this.dialog.local_uri,
	        from_tag: this.dialog.id.local_tag,
	        to_uri: this.dialog.remote_uri,
	        to_tag: this.dialog.id.remote_tag,
	        route_set: this.dialog.route_set,
	        statusCode: options.statusCode,
	        reasonPhrase: options.reasonPhrase
	      },
	      options.extraHeaders || [],
	      options.body
	    );
	
	    new SIP.RequestSender({
	      request: request,
	      onRequestTimeout: function() {
	        self.onRequestTimeout();
	      },
	      onTransportError: function() {
	        self.onTransportError();
	      },
	      receiveResponse: options.receiveResponse || function(response) {
	        self.receiveNonInviteResponse(response);
	      }
	    }, this.ua).send();
	
	    // Emit the request event
	    this.emit(method.toLowerCase(), request);
	
	    return this;
	  },
	
	  close: function() {
	    var idx;
	
	    if(this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.logger.log('closing INVITE session ' + this.id);
	
	    // 1st Step. Terminate media.
	    if (this.mediaHandler){
	      this.mediaHandler.close();
	    }
	
	    // 2nd Step. Terminate signaling.
	
	    // Clear session timers
	    for(idx in this.timers) {
	      SIP.Timers.clearTimeout(this.timers[idx]);
	    }
	
	    // Terminate dialogs
	
	    // Terminate confirmed dialog
	    if(this.dialog) {
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	
	    // Terminate early dialogs
	    for(idx in this.earlyDialogs) {
	      this.earlyDialogs[idx].terminate();
	      delete this.earlyDialogs[idx];
	    }
	
	    this.status = C.STATUS_TERMINATED;
	
	    delete this.ua.sessions[this.id];
	    return this;
	  },
	
	  createDialog: function(message, type, early) {
	    var dialog, early_dialog,
	      local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'],
	      remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'],
	      id = message.call_id + local_tag + remote_tag;
	
	    early_dialog = this.earlyDialogs[id];
	
	    // Early Dialog
	    if (early) {
	      if (early_dialog) {
	        return true;
	      } else {
	        early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);
	
	        // Dialog has been successfully created.
	        if(early_dialog.error) {
	          this.logger.error(early_dialog.error);
	          this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	          return false;
	        } else {
	          this.earlyDialogs[id] = early_dialog;
	          return true;
	        }
	      }
	    }
	    // Confirmed Dialog
	    else {
	      // In case the dialog is in _early_ state, update it
	      if (early_dialog) {
	        early_dialog.update(message, type);
	        this.dialog = early_dialog;
	        delete this.earlyDialogs[id];
	        for (var dia in this.earlyDialogs) {
	          this.earlyDialogs[dia].terminate();
	          delete this.earlyDialogs[dia];
	        }
	        return true;
	      }
	
	      // Otherwise, create a _confirmed_ dialog
	      dialog = new SIP.Dialog(this, message, type);
	
	      if(dialog.error) {
	        this.logger.error(dialog.error);
	        this.failed(message, SIP.C.causes.INTERNAL_ERROR);
	        return false;
	      } else {
	        this.to_tag = message.to_tag;
	        this.dialog = dialog;
	        return true;
	      }
	    }
	  },
	
	  /**
	  * Check if Session is ready for a re-INVITE
	  *
	  * @returns {Boolean}
	  */
	  isReadyToReinvite: function() {
	    return this.mediaHandler.isReady() &&
	      !this.dialog.uac_pending_reply &&
	      !this.dialog.uas_pending_reply;
	  },
	
	  /**
	   * Mute
	   */
	  mute: function(options) {
	    var ret = this.mediaHandler.mute(options);
	    if (ret) {
	      this.onmute(ret);
	    }
	  },
	
	  /**
	   * Unmute
	   */
	  unmute: function(options) {
	    var ret = this.mediaHandler.unmute(options);
	    if (ret) {
	      this.onunmute(ret);
	    }
	  },
	
	  /**
	   * Hold
	   */
	  hold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.hold();
	
	    // Check if RTCSession is ready to send a reINVITE
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'unhold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'hold' action, add this one to the queue
	       * Else, if there is already a 'hold' action, skip
	       */
	      if (this.pending_actions.isPending('unhold')) {
	        this.pending_actions.pop('unhold');
	      } else if (!this.pending_actions.isPending('hold')) {
	        this.pending_actions.push('hold');
	      }
	      return;
	    } else if (this.local_hold === true) {
	        return;
	    }
	
	    this.onhold('local');
	
	    options = options || {};
	    options.mangle = function(body){
	
	      // Don't receive media
	      // TODO - This will break for media streams with different directions.
	      if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(body)) {
	        body = body.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
	      } else {
	        body = body.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
	        body = body.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
	      }
	
	      return body;
	    };
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * Unhold
	   */
	  unhold: function(options) {
	
	    if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.mediaHandler.unhold();
	
	    if (!this.isReadyToReinvite()) {
	      /* If there is a pending 'hold' action, cancel it and don't queue this one
	       * Else, if there isn't any 'unhold' action, add this one to the queue
	       * Else, if there is already a 'unhold' action, skip
	       */
	      if (this.pending_actions.isPending('hold')) {
	        this.pending_actions.pop('hold');
	      } else if (!this.pending_actions.isPending('unhold')) {
	        this.pending_actions.push('unhold');
	      }
	      return;
	    } else if (this.local_hold === false) {
	      return;
	    }
	
	    this.onunhold('local');
	
	    this.sendReinvite(options);
	  },
	
	  /**
	   * isOnHold
	   */
	  isOnHold: function() {
	    return {
	      local: this.local_hold,
	      remote: this.remote_hold
	    };
	  },
	
	  /**
	   * In dialog INVITE Reception
	   * @private
	   */
	  receiveReinvite: function(request) {
	    var self = this;
	
	    if (!request.body) {
	      return;
	    }
	
	    if (request.getHeader('Content-Type') !== 'application/sdp') {
	      this.logger.warn('invalid Content-Type');
	      request.reply(415);
	      return;
	    }
	
	    this.mediaHandler.setDescription(request.body)
	    .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	    .then(function(body) {
	      request.reply(200, null, ['Contact: ' + self.contact], body,
	        function() {
	          self.status = C.STATUS_WAITING_FOR_ACK;
	          self.setInvite2xxTimer(request, body);
	          self.setACKTimer();
	
	          // Are we holding?
	          var hold = (/a=(sendonly|inactive)/).test(request.body);
	
	          if (self.remote_hold && !hold) {
	            self.onunhold('remote');
	          } else if (!self.remote_hold && hold) {
	            self.onhold('remote');
	          }
	        });
	    })
	    .catch(function onFailure (e) {
	      var statusCode;
	      if (e instanceof SIP.Exceptions.GetDescriptionError) {
	        statusCode = 500;
	      } else {
	        self.logger.error(e);
	        statusCode = 488;
	      }
	      request.reply(statusCode);
	    });
	  },
	
	  sendReinvite: function(options) {
	    options = options || {};
	
	    var
	      self = this,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      eventHandlers = options.eventHandlers || {},
	      mangle = options.mangle || null,
	      succeeded;
	
	    if (eventHandlers.succeeded) {
	      succeeded = eventHandlers.succeeded;
	    }
	    this.reinviteSucceeded = function(){
	      SIP.Timers.clearTimeout(self.timers.ackTimer);
	      SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	      self.status = C.STATUS_CONFIRMED;
	      succeeded && succeeded.apply(this, arguments);
	    };
	    if (eventHandlers.failed) {
	      this.reinviteFailed = eventHandlers.failed;
	    } else {
	      this.reinviteFailed = function(){};
	    }
	
	    extraHeaders.push('Contact: ' + this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	    extraHeaders.push('Content-Type: application/sdp');
	
	    this.receiveResponse = this.receiveReinviteResponse;
	    //REVISIT
	    this.mediaHandler.getDescription(self.mediaHint)
	    .then(mangle)
	    .then(
	      function(body){
	        self.dialog.sendRequest(self, SIP.C.INVITE, {
	          extraHeaders: extraHeaders,
	          body: body
	        });
	      },
	      function() {
	        if (self.isReadyToReinvite()) {
	          self.onReadyToReinvite();
	        }
	        self.reinviteFailed();
	      }
	    );
	  },
	
	  receiveRequest: function (request) {
	    switch (request.method) {
	      case SIP.C.BYE:
	        request.reply(200);
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.emit('bye', request);
	          this.terminated(request, SIP.C.causes.BYE);
	        }
	        break;
	      case SIP.C.INVITE:
	        if(this.status === C.STATUS_CONFIRMED) {
	          this.logger.log('re-INVITE received');
	          this.receiveReinvite(request);
	        }
	        break;
	      case SIP.C.INFO:
	        if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {
	          var body, tone, duration,
	              contentType = request.getHeader('content-type'),
	              reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
	              reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
	
	          if (contentType) {
	            if (contentType.match(/^application\/dtmf-relay/i)) {
	              if (request.body) {
	                body = request.body.split('\r\n', 2);
	                if (body.length === 2) {
	                  if (reg_tone.test(body[0])) {
	                    tone = body[0].replace(reg_tone,"$2");
	                  }
	                  if (reg_duration.test(body[1])) {
	                    duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
	                  }
	                }
	              }
	
	              new DTMF(this, tone, {duration: duration}).init_incoming(request);
	            } else {
	              request.reply(415, null, ["Accept: application/dtmf-relay"]);
	            }
	          }
	        }
	        break;
	      case SIP.C.REFER:
	        if(this.status ===  C.STATUS_CONFIRMED) {
	          this.logger.log('REFER received');
	          var hasReferListener = this.listeners('refer').length,
	              notifyBody;
	
	          if (hasReferListener) {
	            request.reply(202, 'Accepted');
	            notifyBody = 'SIP/2.0 100 Trying';
	
	            this.sendRequest(SIP.C.NOTIFY, {
	              extraHeaders:[
	                'Event: refer',
	                'Subscription-State: terminated',
	                'Content-Type: message/sipfrag'
	              ],
	              body: notifyBody,
	              receiveResponse: function() {}
	            });
	
	            this.emit('refer', request);
	          } else {
	            // RFC 3515.2.4.2: 'the UA MAY decline the request.'
	            request.reply(603, 'Declined');
	          }
	        }
	        break;
	      case SIP.C.NOTIFY:
	        request.reply(200, 'OK');
	        this.emit('notify', request);
	        break;
	    }
	  },
	
	  /**
	   * Reception of Response for in-dialog INVITE
	   * @private
	   */
	  receiveReinviteResponse: function(response) {
	    var self = this,
	        contentType = response.getHeader('Content-Type');
	
	    if (this.status === C.STATUS_TERMINATED) {
	      return;
	    }
	
	    switch(true) {
	      case /^1[0-9]{2}$/.test(response.status_code):
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        this.status = C.STATUS_CONFIRMED;
	
	        this.sendRequest(SIP.C.ACK,{cseq:response.cseq});
	
	        if(!response.body) {
	          this.reinviteFailed();
	          break;
	        } else if (contentType !== 'application/sdp') {
	          this.reinviteFailed();
	          break;
	        }
	
	        //REVISIT
	        this.mediaHandler.setDescription(response.body)
	        .then(
	          function onSuccess () {
	            self.reinviteSucceeded();
	          },
	          function onFailure () {
	            self.reinviteFailed();
	          }
	        );
	        break;
	      default:
	        this.reinviteFailed();
	    }
	  },
	
	  acceptAndTerminate: function(response, status_code, reason_phrase) {
	    var extraHeaders = [];
	
	    if (status_code) {
	      extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if (this.dialog || this.createDialog(response, 'UAC')) {
	      this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	      this.sendRequest(SIP.C.BYE, {
	        extraHeaders: extraHeaders
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * RFC3261 13.3.1.4
	   * Response retransmissions cannot be accomplished by transaction layer
	   *  since it is destroyed when receiving the first 2xx answer
	   */
	  setInvite2xxTimer: function(request, body) {
	    var self = this,
	        timeout = SIP.Timers.T1;
	
	    this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {
	      if (self.status !== C.STATUS_WAITING_FOR_ACK) {
	        return;
	      }
	
	      self.logger.log('no ACK received, attempting to retransmit OK');
	
	      request.reply(200, null, ['Contact: ' + self.contact], body);
	
	      timeout = Math.min(timeout * 2, SIP.Timers.T2);
	
	      self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);
	    }, timeout);
	  },
	
	  /**
	   * RFC3261 14.2
	   * If a UAS generates a 2xx response and never receives an ACK,
	   *  it SHOULD generate a BYE to terminate the dialog.
	   */
	  setACKTimer: function() {
	    var self = this;
	
	    this.timers.ackTimer = SIP.Timers.setTimeout(function() {
	      if(self.status === C.STATUS_WAITING_FOR_ACK) {
	        self.logger.log('no ACK received for an extended period of time, terminating the call');
	        SIP.Timers.clearTimeout(self.timers.invite2xxTimer);
	        self.sendRequest(SIP.C.BYE);
	        self.terminated(null, SIP.C.causes.NO_ACK);
	      }
	    }, SIP.Timers.TIMER_H);
	  },
	
	  /*
	   * @private
	   */
	  onReadyToReinvite: function() {
	    var action = this.pending_actions.shift();
	
	    if (!action || !this[action.name]) {
	      return;
	    }
	
	    this[action.name]();
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  },
	
	  onDialogError: function(response) {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(response, SIP.C.causes.DIALOG_ERROR);
	      this.terminated(response, SIP.C.causes.DIALOG_ERROR);
	    }
	  },
	
	  /**
	   * @private
	   */
	  onhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = true;
	    this.emit('hold', { originator: originator });
	  },
	
	  /**
	   * @private
	   */
	  onunhold: function(originator) {
	    this[originator === 'local' ? 'local_hold' : 'remote_hold'] = false;
	    this.emit('unhold', { originator: originator });
	  },
	
	  /*
	   * @private
	   */
	  onmute: function(options) {
	    this.emit('muted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  /*
	   * @private
	   */
	  onunmute: function(options) {
	    this.emit('unmuted', {
	      audio: options.audio,
	      video: options.video
	    });
	  },
	
	  failed: function(response, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	    this.emit('failed', response || null, cause || null);
	    return this;
	  },
	
	  rejected: function(response, cause) {
	    this.emit('rejected',
	      response || null,
	      cause || null
	    );
	    return this;
	  },
	
	  canceled: function() {
	    this.emit('cancel');
	    return this;
	  },
	
	  accepted: function(response, cause) {
	    cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);
	
	    this.startTime = new Date();
	
	    if (this.replacee) {
	      this.replacee.emit('replaced', this);
	      this.replacee.terminate();
	    }
	    this.emit('accepted', response, cause);
	    return this;
	  },
	
	  terminated: function(message, cause) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    this.endTime = new Date();
	
	    this.close();
	    this.emit('terminated',
	      message || null,
	      cause || null
	    );
	    return this;
	  },
	
	  connecting: function(request) {
	    this.emit('connecting', { request: request });
	    return this;
	  }
	};
	
	Session.desugar = function desugar(options) {
	  if (environment.HTMLMediaElement && options instanceof environment.HTMLMediaElement) {
	    options = {
	      media: {
	        constraints: {
	          audio: true,
	          video: options.tagName === 'VIDEO'
	        },
	        render: {
	          remote: options
	        }
	      }
	    };
	  }
	  return options || {};
	};
	
	
	Session.C = C;
	SIP.Session = Session;
	
	
	InviteServerContext = function(ua, request) {
	  var expires,
	    self = this,
	    contentType = request.getHeader('Content-Type'),
	    contentDisp = request.parseHeader('Content-Disposition');
	
	  // Check body and content type
	  if ((!contentDisp && contentType !== 'application/sdp') || (contentDisp && contentDisp.type === 'render')) {
	    this.renderbody = request.body;
	    this.rendertype = contentType;
	  } else if (contentType !== 'application/sdp' && (contentDisp && contentDisp.type === 'session')) {
	    request.reply(415);
	    //TODO: instead of 415, pass off to the media handler, who can then decide if we can use it
	    return;
	  }
	
	  //TODO: move this into media handler
	  SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	  SIP.Hacks.AllBrowsers.maskDtls(request);
	
	  SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);
	  SIP.Utils.augment(this, SIP.Session, [ua.configuration.mediaHandlerFactory]);
	
	  this.status = C.STATUS_INVITE_RECEIVED;
	  this.from_tag = request.from_tag;
	  this.id = request.call_id + this.from_tag;
	  this.request = request;
	  this.contact = this.ua.contact.toString();
	
	  this.receiveNonInviteResponse = function () {}; // intentional no-op
	
	  this.logger = ua.getLogger('sip.inviteservercontext', this.id);
	
	  //Save the session into the ua sessions collection.
	  this.ua.sessions[this.id] = this;
	
	  //Get the Expires header value if exists
	  if(request.hasHeader('expires')) {
	    expires = request.getHeader('expires') * 1000;
	  }
	
	  //Set 100rel if necessary
	  function set100rel(h,c) {
	    if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {
	      self.rel100 = c;
	    }
	  }
	  set100rel('require', SIP.C.supported.REQUIRED);
	  set100rel('supported', SIP.C.supported.SUPPORTED);
	
	  /* Set the to_tag before
	   * replying a response code that will create a dialog.
	   */
	  request.to_tag = SIP.Utils.newTag();
	
	  // An error on dialog creation will fire 'failed' event
	  if(!this.createDialog(request, 'UAS', true)) {
	    request.reply(500, 'Missing Contact header field');
	    return;
	  }
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: {"optional": [{'DtlsSrtpKeyAgreement': 'true'}]}
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  function fireNewSession() {
	    var options = {extraHeaders: ['Contact: ' + self.contact]};
	
	    if (self.rel100 !== SIP.C.supported.REQUIRED) {
	      self.progress(options);
	    }
	    self.status = C.STATUS_WAITING_FOR_ANSWER;
	
	    // Set userNoAnswerTimer
	    self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function() {
	      request.reply(408);
	      self.failed(request, SIP.C.causes.NO_ANSWER);
	      self.terminated(request, SIP.C.causes.NO_ANSWER);
	    }, self.ua.configuration.noAnswerTimeout);
	
	    /* Set expiresTimer
	     * RFC3261 13.3.1
	     */
	    if (expires) {
	      self.timers.expiresTimer = SIP.Timers.setTimeout(function() {
	        if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
	          request.reply(487);
	          self.failed(request, SIP.C.causes.EXPIRES);
	          self.terminated(request, SIP.C.causes.EXPIRES);
	        }
	      }, expires);
	    }
	
	    self.emit('invite',request);
	  }
	
	  if (!request.body || this.renderbody) {
	    SIP.Timers.setTimeout(fireNewSession, 0);
	  } else {
	    this.hasOffer = true;
	    this.mediaHandler.setDescription(request.body)
	    .then(
	      fireNewSession,
	      function onFailure (e) {
	        self.logger.warn('invalid SDP');
	        self.logger.warn(e);
	        request.reply(488);
	      }
	    );
	  }
	};
	
	InviteServerContext.prototype = {
	  reject: function(options) {
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('rejecting RTCSession');
	
	    SIP.ServerContext.prototype.reject.call(this, options);
	    return this.terminated();
	  },
	
	  terminate: function(options) {
	    options = options || {};
	
	    var
	    extraHeaders = (options.extraHeaders || []).slice(),
	    body = options.body,
	    dialog,
	    self = this;
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK &&
	       this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {
	      dialog = this.dialog;
	
	      this.receiveRequest = function(request) {
	        if (request.method === SIP.C.ACK) {
	          this.request(SIP.C.BYE, {
	            extraHeaders: extraHeaders,
	            body: body
	          });
	          dialog.terminate();
	        }
	      };
	
	      this.request.server_transaction.on('stateChanged', function(){
	        if (this.state === SIP.Transactions.C.STATUS_TERMINATED) {
	          this.request = new SIP.OutgoingRequest(
	            SIP.C.BYE,
	            this.dialog.remote_target,
	            this.ua,
	            {
	              'cseq': this.dialog.local_seqnum+=1,
	              'call_id': this.dialog.id.call_id,
	              'from_uri': this.dialog.local_uri,
	              'from_tag': this.dialog.id.local_tag,
	              'to_uri': this.dialog.remote_uri,
	              'to_tag': this.dialog.id.remote_tag,
	              'route_set': this.dialog.route_set
	            },
	            extraHeaders,
	            body
	          );
	
	          new SIP.RequestSender(
	            {
	              request: this.request,
	              onRequestTimeout: function() {
	                self.onRequestTimeout();
	              },
	              onTransportError: function() {
	                self.onTransportError();
	              },
	              receiveResponse: function() {
	                return;
	              }
	            },
	            this.ua
	          ).send();
	          dialog.terminate();
	        }
	      });
	
	      this.emit('bye', this.request);
	      this.terminated();
	
	      // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
	      this.dialog = dialog;
	
	      // Restore the dialog into 'ua' so the ACK can reach 'this' session
	      this.ua.dialogs[dialog.id.toString()] = dialog;
	
	    } else if (this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.reject(options);
	    }
	
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  progress: function (options) {
	    options = options || {};
	    var
	      statusCode = options.statusCode || 180,
	      reasonPhrase = options.reasonPhrase,
	      extraHeaders = (options.extraHeaders || []).slice(),
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      body = options.body,
	      response;
	
	    if (statusCode < 100 || statusCode > 199) {
	      throw new TypeError('Invalid statusCode: ' + statusCode);
	    }
	
	    if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (stunServers || turnServers) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    function do100rel() {
	      /* jshint validthis: true */
	      statusCode = options.statusCode || 183;
	
	      // Set status and add extra headers
	      this.status = C.STATUS_WAITING_FOR_PRACK;
	      extraHeaders.push('Contact: '+ this.contact);
	      extraHeaders.push('Require: 100rel');
	      extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));
	
	      // Save media hint for later (referred sessions)
	      this.mediaHint = options.media;
	
	      // Get the session description to add to preaccept with
	      this.mediaHandler.getDescription(options.media)
	      .then(
	        function onSuccess (body) {
	          if (this.isCanceled || this.status === C.STATUS_TERMINATED) {
	            return;
	          }
	
	          this.early_sdp = body;
	          this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;
	
	          // Retransmit until we get a response or we time out (see prackTimer below)
	          var timeout = SIP.Timers.T1;
	          this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {
	            this.request.reply(statusCode, null, extraHeaders, body);
	            timeout *= 2;
	            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);
	          }.bind(this), timeout);
	
	          // Timeout and reject INVITE if no response
	          this.timers.prackTimer = SIP.Timers.setTimeout(function () {
	            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {
	              return;
	            }
	
	            this.logger.log('no PRACK received, rejecting the call');
	            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	            this.request.reply(504);
	            this.terminated(null, SIP.C.causes.NO_PRACK);
	          }.bind(this), SIP.Timers.T1 * 64);
	
	          // Send the initial response
	          response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	          this.emit('progress', response, reasonPhrase);
	        }.bind(this),
	
	        function onFailure () {
	          this.request.reply(480);
	          this.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }.bind(this)
	      );
	    } // end do100rel
	
	    function normalReply() {
	      /* jshint validthis:true */
	      response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	      this.emit('progress', response, reasonPhrase);
	    }
	
	    if (options.statusCode !== 100 &&
	        (this.rel100 === SIP.C.supported.REQUIRED ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||
	         (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {
	      do100rel.apply(this);
	    } else {
	      normalReply.apply(this);
	    }
	    return this;
	  },
	
	  /*
	   * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	   */
	  accept: function(options) {
	    options = Object.create(Session.desugar(options));
	    SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	    this.mediaHint = options.media;
	
	    // commented out now-unused hold-related variables for jshint. See below. JMF 2014-1-21
	    var
	      //idx, length, hasAudio, hasVideo,
	      self = this,
	      request = this.request,
	      extraHeaders = (options.extraHeaders || []).slice(),
	    //mediaStream = options.mediaStream || null,
	      iceServers,
	      stunServers = options.stunServers || null,
	      turnServers = options.turnServers || null,
	      sdpCreationSucceeded = function(body) {
	        var
	          response,
	          // run for reply success callback
	          replySucceeded = function() {
	            self.status = C.STATUS_WAITING_FOR_ACK;
	
	            self.setInvite2xxTimer(request, body);
	            self.setACKTimer();
	          },
	
	          // run for reply failure callback
	          replyFailed = function() {
	            self.failed(null, SIP.C.causes.CONNECTION_ERROR);
	            self.terminated(null, SIP.C.causes.CONNECTION_ERROR);
	          };
	
	        // Chrome might call onaddstream before accept() is called, which means
	        // mediaHandler.render() was called without a renderHint, so we need to
	        // re-render now that mediaHint.render has been set.
	        //
	        // Chrome seems to be in the right regarding this, see
	        // http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCPeerConnection-onaddstream
	        self.mediaHandler.render();
	
	        extraHeaders.push('Contact: ' + self.contact);
	        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());
	
	        if(!self.hasOffer) {
	          self.hasOffer = true;
	        } else {
	          self.hasAnswer = true;
	        }
	        response = request.reply(200, null, extraHeaders,
	                      body,
	                      replySucceeded,
	                      replyFailed
	                     );
	        if (self.status !== C.STATUS_TERMINATED) { // Didn't fail
	          self.accepted(response, SIP.Utils.getReasonPhrase(200));
	        }
	      },
	
	      sdpCreationFailed = function() {
	        if (self.status === C.STATUS_TERMINATED) {
	          return;
	        }
	        // TODO - fail out on error
	        self.request.reply(480);
	        //self.failed(response, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	        self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	        self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	      };
	
	    // Check Session Status
	    if (this.status === C.STATUS_WAITING_FOR_PRACK) {
	      this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;
	      return this;
	    } else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {
	      this.status = C.STATUS_ANSWERED;
	    } else if (this.status !== C.STATUS_EARLY_MEDIA) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    if ((stunServers || turnServers) &&
	        (this.status !== C.STATUS_EARLY_MEDIA && this.status !== C.STATUS_ANSWERED_WAITING_FOR_PRACK)) {
	      if (stunServers) {
	        iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid stunServers: '+ stunServers);
	        } else {
	          this.stunServers = iceServers;
	        }
	      }
	
	      if (turnServers) {
	        iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	        if (!iceServers) {
	          throw new TypeError('Invalid turnServers: '+ turnServers);
	        } else {
	          this.turnServers = iceServers;
	        }
	      }
	
	      this.mediaHandler.updateIceServers({
	        stunServers: this.stunServers,
	        turnServers: this.turnServers
	      });
	    }
	
	    // An error on dialog creation will fire 'failed' event
	    if(!this.createDialog(request, 'UAS')) {
	      request.reply(500, 'Missing Contact header field');
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);
	
	    // this hold-related code breaks FF accepting new calls - JMF 2014-1-21
	    /*
	    length = this.getRemoteStreams().length;
	
	    for (idx = 0; idx < length; idx++) {
	      if (this.mediaHandler.getRemoteStreams()[idx].getVideoTracks().length > 0) {
	        hasVideo = true;
	      }
	      if (this.mediaHandler.getRemoteStreams()[idx].getAudioTracks().length > 0) {
	        hasAudio = true;
	      }
	    }
	
	    if (!hasAudio && this.mediaConstraints.audio === true) {
	      this.mediaConstraints.audio = false;
	      if (mediaStream) {
	        length = mediaStream.getAudioTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
	        }
	      }
	    }
	
	    if (!hasVideo && this.mediaConstraints.video === true) {
	      this.mediaConstraints.video = false;
	      if (mediaStream) {
	        length = mediaStream.getVideoTracks().length;
	        for (idx = 0; idx < length; idx++) {
	          mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
	        }
	      }
	    }
	    */
	
	    if (this.status === C.STATUS_EARLY_MEDIA) {
	      sdpCreationSucceeded();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        sdpCreationSucceeded,
	        sdpCreationFailed
	      );
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	
	    // ISC RECEIVE REQUEST
	
	    function confirmSession() {
	      /* jshint validthis:true */
	      var contentType;
	
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      // TODO - this logic assumes Content-Disposition defaults
	      contentType = request.getHeader('Content-Type');
	      if (contentType !== 'application/sdp') {
	        this.renderbody = request.body;
	        this.rendertype = contentType;
	      }
	    }
	
	    switch(request.method) {
	    case SIP.C.CANCEL:
	      /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
	       * was in progress and that the UAC MAY continue with the session established by
	       * any 2xx response, or MAY terminate with BYE. SIP does continue with the
	       * established session. So the CANCEL is processed only if the session is not yet
	       * established.
	       */
	
	      /*
	       * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
	       *request opening the session.
	       */
	      if(this.status === C.STATUS_WAITING_FOR_ANSWER ||
	         this.status === C.STATUS_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||
	         this.status === C.STATUS_EARLY_MEDIA ||
	         this.status === C.STATUS_ANSWERED) {
	
	        this.status = C.STATUS_CANCELED;
	        this.request.reply(487);
	        this.canceled(request);
	        this.rejected(request, SIP.C.causes.CANCELED);
	        this.failed(request, SIP.C.causes.CANCELED);
	        this.terminated(request, SIP.C.causes.CANCELED);
	      }
	      break;
	    case SIP.C.ACK:
	      if(this.status === C.STATUS_WAITING_FOR_ACK) {
	        if (!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            // ACK contains answer to an INVITE w/o SDP negotiation
	            SIP.Hacks.Firefox.cannotHandleExtraWhitespace(request);
	            SIP.Hacks.AllBrowsers.maskDtls(request);
	
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              confirmSession.bind(this),
	              function onFailure (e) {
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else if (this.early_sdp) {
	            confirmSession.apply(this);
	          } else {
	            //TODO: Pass to mediahandler
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          confirmSession.apply(this);
	        }
	      }
	      break;
	    case SIP.C.PRACK:
	      if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	        //localMedia = session.mediaHandler.localMedia;
	        if(!this.hasAnswer) {
	          if(request.body && request.getHeader('content-type') === 'application/sdp') {
	            this.hasAnswer = true;
	            this.mediaHandler.setDescription(request.body)
	            .then(
	              function onSuccess () {
	                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	                SIP.Timers.clearTimeout(this.timers.prackTimer);
	                request.reply(200);
	                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                  this.status = C.STATUS_EARLY_MEDIA;
	                  this.accept();
	                }
	                this.status = C.STATUS_EARLY_MEDIA;
	                //REVISIT
	                this.mute();
	              }.bind(this),
	              function onFailure (e) {
	                //TODO: Send to media handler
	                this.logger.warn(e);
	                this.terminate({
	                  statusCode: '488',
	                  reasonPhrase: 'Bad Media Description'
	                });
	                this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	                this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }.bind(this)
	            );
	          } else {
	            this.terminate({
	              statusCode: '488',
	              reasonPhrase: 'Bad Media Description'
	            });
	            this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	          }
	        } else {
	          SIP.Timers.clearTimeout(this.timers.rel1xxTimer);
	          SIP.Timers.clearTimeout(this.timers.prackTimer);
	          request.reply(200);
	
	          if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	            this.status = C.STATUS_EARLY_MEDIA;
	            this.accept();
	          }
	          this.status = C.STATUS_EARLY_MEDIA;
	          //REVISIT
	          this.mute();
	        }
	      } else if(this.status === C.STATUS_EARLY_MEDIA) {
	        request.reply(200);
	      }
	      break;
	    default:
	      Session.prototype.receiveRequest.apply(this, [request]);
	      break;
	    }
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteServerContext = InviteServerContext;
	
	InviteClientContext = function(ua, target, options) {
	  options = Object.create(Session.desugar(options));
	  options.params = Object.create(options.params || Object.prototype);
	
	  var iceServers,
	    extraHeaders = (options.extraHeaders || []).slice(),
	    stunServers = options.stunServers || null,
	    turnServers = options.turnServers || null,
	    mediaHandlerFactory = options.mediaHandlerFactory || ua.configuration.mediaHandlerFactory,
	    isMediaSupported = mediaHandlerFactory.isSupported;
	
	  // Check WebRTC support
	  if (isMediaSupported && !isMediaSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.RTCConstraints = options.RTCConstraints || {};
	  this.inviteWithoutSdp = options.inviteWithoutSdp || false;
	
	  // Set anonymous property
	  this.anonymous = options.anonymous || false;
	
	  // Custom data to be sent either in INVITE or in ACK
	  this.renderbody = options.renderbody || null;
	  this.rendertype = options.rendertype || 'text/plain';
	
	  options.params.from_tag = this.from_tag;
	
	  /* Do not add ;ob in initial forming dialog requests if the registration over
	   *  the current connection got a GRUU URI.
	   */
	  this.contact = ua.contact.toString({
	    anonymous: this.anonymous,
	    outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu
	  });
	
	  if (this.anonymous) {
	    options.params.from_displayName = 'Anonymous';
	    options.params.from_uri = 'sip:anonymous@anonymous.invalid';
	
	    extraHeaders.push('P-Preferred-Identity: '+ ua.configuration.uri.toString());
	    extraHeaders.push('Privacy: id');
	  }
	  extraHeaders.push('Contact: '+ this.contact);
	  extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	  if (!this.inviteWithoutSdp) {
	    extraHeaders.push('Content-Type: application/sdp');
	  } else if (this.renderbody) {
	    extraHeaders.push('Content-Type: ' + this.rendertype);
	    extraHeaders.push('Content-Disposition: render;handling=optional');
	  }
	
	  if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: 100rel');
	  }
	  if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {
	    extraHeaders.push('Require: replaces');
	  }
	
	  options.extraHeaders = extraHeaders;
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);
	  SIP.Utils.augment(this, SIP.Session, [mediaHandlerFactory]);
	
	  // Check Session Status
	  if (this.status !== C.STATUS_NULL) {
	    throw new SIP.Exceptions.InvalidStateError(this.status);
	  }
	
	  // Session parameter initialization
	  this.from_tag = SIP.Utils.newTag();
	
	  // OutgoingSession specific parameters
	  this.isCanceled = false;
	  this.received_100 = false;
	
	  this.method = SIP.C.INVITE;
	
	  this.receiveNonInviteResponse = this.receiveResponse;
	  this.receiveResponse = this.receiveInviteResponse;
	
	  this.logger = ua.getLogger('sip.inviteclientcontext');
	
	  if (stunServers) {
	    iceServers = SIP.UA.configuration_check.optional['stunServers'](stunServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid stunServers: '+ stunServers);
	    } else {
	      this.stunServers = iceServers;
	    }
	  }
	
	  if (turnServers) {
	    iceServers = SIP.UA.configuration_check.optional['turnServers'](turnServers);
	    if (!iceServers) {
	      throw new TypeError('Invalid turnServers: '+ turnServers);
	    } else {
	      this.turnServers = iceServers;
	    }
	  }
	
	  ua.applicants[this] = this;
	
	  this.id = this.request.call_id + this.from_tag;
	
	  //Initialize Media Session
	  this.mediaHandler = this.mediaHandlerFactory(this, {
	    RTCConstraints: this.RTCConstraints,
	    stunServers: this.stunServers,
	    turnServers: this.turnServers
	  });
	
	  if (this.mediaHandler && this.mediaHandler.getRemoteStreams) {
	    this.getRemoteStreams = this.mediaHandler.getRemoteStreams.bind(this.mediaHandler);
	    this.getLocalStreams = this.mediaHandler.getLocalStreams.bind(this.mediaHandler);
	  }
	
	  SIP.Utils.optionsOverride(options, 'media', 'mediaConstraints', true, this.logger, this.ua.configuration.media);
	  this.mediaHint = options.media;
	};
	
	InviteClientContext.prototype = {
	  invite: function () {
	    var self = this;
	
	    //Save the session into the ua sessions collection.
	    //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
	    this.ua.sessions[this.id] = this;
	
	    //Note: due to the way Firefox handles gUM calls, it is recommended to make the gUM call at the app level
	    // and hand sip.js a stream as the mediaHint
	    if (this.inviteWithoutSdp) {
	      //just send an invite with no sdp...
	      this.request.body = self.renderbody;
	      this.status = C.STATUS_INVITE_SENT;
	      this.send();
	    } else {
	      this.mediaHandler.getDescription(self.mediaHint)
	      .then(
	        function onSuccess(offer) {
	          if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          self.hasOffer = true;
	          self.request.body = offer;
	          self.status = C.STATUS_INVITE_SENT;
	          self.send();
	        },
	        function onFailure() {
	          if (self.status === C.STATUS_TERMINATED) {
	            return;
	          }
	          // TODO...fail out
	          //self.failed(null, SIP.C.causes.USER_DENIED_MEDIA_ACCESS);
	          //self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.failed(null, SIP.C.causes.WEBRTC_ERROR);
	          self.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	        }
	      );
	    }
	
	    return this;
	  },
	
	  receiveInviteResponse: function(response) {
	    var cause, //localMedia,
	      session = this,
	      id = response.call_id + response.from_tag + response.to_tag,
	      extraHeaders = [],
	      options = {};
	
	    if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {
	      return;
	    }
	
	    if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {
	      if (id !== this.dialog.id.toString() ) {
	        if (!this.createDialog(response, 'UAC', true)) {
	          return;
	        }
	        this.earlyDialogs[id].sendRequest(this, SIP.C.ACK,
	                                          {
	                                            body: SIP.Utils.generateFakeSDP(response.body)
	                                          });
	        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);
	
	        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
	         * leg (due to peerConnection limitations) has been answered first. If your forking
	         * proxy does not hang up all unanswered branches on the first branch answered, remove this.
	         */
	        if(this.status !== C.STATUS_CONFIRMED) {
	          this.failed(response, SIP.C.causes.WEBRTC_ERROR);
	          this.terminated(response, SIP.C.causes.WEBRTC_ERROR);
	        }
	        return;
	      } else if (this.status === C.STATUS_CONFIRMED) {
	        this.sendRequest(SIP.C.ACK,{cseq: response.cseq});
	        return;
	      } else if (!this.hasAnswer) {
	        // invite w/o sdp is waiting for callback
	        //an invite with sdp must go on, and hasAnswer is true
	        return;
	      }
	    }
	
	    if (this.dialog && response.status_code < 200) {
	      /*
	        Early media has been set up with at least one other different branch,
	        but a final 2xx response hasn't been received
	      */
	      if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.dialog.pracked[this.dialog.pracked.length-1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {
	        return;
	      }
	
	      if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {
	        return;
	      }
	
	      if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	          (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	        return;
	      }
	
	      extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	      this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	
	      this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	        extraHeaders: extraHeaders,
	        body: SIP.Utils.generateFakeSDP(response.body)
	      });
	      return;
	    }
	
	    // Proceed to cancellation if the user requested.
	    if(this.isCanceled) {
	      if(response.status_code >= 100 && response.status_code < 200) {
	        this.request.cancel(this.cancelReason);
	        this.canceled(null);
	      } else if(response.status_code >= 200 && response.status_code < 299) {
	        this.acceptAndTerminate(response);
	        this.emit('bye', this.request);
	      } else if (response.status_code >= 300) {
	        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	      }
	      return;
	    }
	
	    switch(true) {
	      case /^100$/.test(response.status_code):
	        this.received_100 = true;
	        this.emit('progress', response);
	        break;
	      case (/^1[0-9]{2}$/.test(response.status_code)):
	        // Do nothing with 1xx responses without To tag.
	        if(!response.to_tag) {
	          this.logger.warn('1xx response received without to tag');
	          break;
	        }
	
	        // Create Early Dialog if 1XX comes with contact
	        if(response.hasHeader('contact')) {
	          // An error on dialog creation will fire 'failed' event
	          if (!this.createDialog(response, 'UAC', true)) {
	            break;
	          }
	        }
	
	        this.status = C.STATUS_1XX_RECEIVED;
	
	        if(response.hasHeader('require') &&
	           response.getHeader('require').indexOf('100rel') !== -1) {
	
	          // Do nothing if this.dialog is already confirmed
	          if (this.dialog || !this.earlyDialogs[id]) {
	            break;
	          }
	
	          if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||
	              (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length-1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {
	            return;
	          }
	
	          SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	          SIP.Hacks.AllBrowsers.maskDtls(response);
	
	          if (!response.body) {
	            extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	            this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));
	            this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {
	              extraHeaders: extraHeaders
	            });
	            this.emit('progress', response);
	
	          } else if (this.hasOffer) {
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasAnswer = true;
	            this.dialog.pracked.push(response.getHeader('rseq'));
	
	            this.mediaHandler.setDescription(response.body)
	            .then(
	              function onSuccess () {
	                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	
	                session.sendRequest(SIP.C.PRACK, {
	                  extraHeaders: extraHeaders,
	                  receiveResponse: function() {}
	                });
	                session.status = C.STATUS_EARLY_MEDIA;
	                session.mute();
	                session.emit('progress', response);
	                /*
	                if (session.status === C.STATUS_EARLY_MEDIA) {
	                  localMedia = session.mediaHandler.localMedia;
	                  if (localMedia.getAudioTracks().length > 0) {
	                    localMedia.getAudioTracks()[0].enabled = false;
	                  }
	                  if (localMedia.getVideoTracks().length > 0) {
	                    localMedia.getVideoTracks()[0].enabled = false;
	                  }
	                }*/
	              },
	              function onFailure (e) {
	                session.logger.warn(e);
	                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              }
	            );
	          } else {
	            var earlyDialog = this.earlyDialogs[id];
	            var earlyMedia = earlyDialog.mediaHandler;
	
	            earlyDialog.pracked.push(response.getHeader('rseq'));
	
	            earlyMedia.setDescription(response.body)
	            .then(earlyMedia.getDescription.bind(earlyMedia, session.mediaHint))
	            .then(function onSuccess(sdp) {
	              extraHeaders.push('Content-Type: application/sdp');
	              extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));
	              earlyDialog.sendRequest(session, SIP.C.PRACK, {
	                extraHeaders: extraHeaders,
	                body: sdp
	              });
	              session.status = C.STATUS_EARLY_MEDIA;
	              session.emit('progress', response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                earlyDialog.pracked.push(response.getHeader('rseq'));
	                if (session.status === C.STATUS_TERMINATED) {
	                  return;
	                }
	                // TODO - fail out on error
	                // session.failed(gum error);
	                session.failed(null, SIP.C.causes.WEBRTC_ERROR);
	                session.terminated(null, SIP.C.causes.WEBRTC_ERROR);
	              } else {
	                earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);
	                // Could not set remote description
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	              }
	            });
	          }
	        } else {
	          this.emit('progress', response);
	        }
	        break;
	      case /^2[0-9]{2}$/.test(response.status_code):
	        var cseq = this.request.cseq + ' ' + this.request.method;
	        if (cseq !== response.getHeader('cseq')) {
	          break;
	        }
	
	        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {
	          this.status = C.STATUS_CONFIRMED;
	          this.unmute();
	          /*localMedia = this.mediaHandler.localMedia;
	          if (localMedia.getAudioTracks().length > 0) {
	            localMedia.getAudioTracks()[0].enabled = true;
	          }
	          if (localMedia.getVideoTracks().length > 0) {
	            localMedia.getVideoTracks()[0].enabled = true;
	          }*/
	          options = {};
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + this.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          options.cseq = response.cseq;
	          this.sendRequest(SIP.C.ACK, options);
	          this.accepted(response);
	          break;
	        }
	        // Do nothing if this.dialog is already confirmed
	        if (this.dialog) {
	          break;
	        }
	
	        SIP.Hacks.Firefox.cannotHandleExtraWhitespace(response);
	        SIP.Hacks.AllBrowsers.maskDtls(response);
	
	        // This is an invite without sdp
	        if (!this.hasOffer) {
	          if (this.earlyDialogs[id] && this.earlyDialogs[id].mediaHandler.localMedia) {
	            //REVISIT
	            this.hasOffer = true;
	            this.hasAnswer = true;
	            this.mediaHandler = this.earlyDialogs[id].mediaHandler;
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.status = C.STATUS_CONFIRMED;
	            this.sendRequest(SIP.C.ACK, {cseq:response.cseq});
	
	            this.unmute();
	            /*
	            localMedia = session.mediaHandler.localMedia;
	            if (localMedia.getAudioTracks().length > 0) {
	              localMedia.getAudioTracks()[0].enabled = true;
	            }
	            if (localMedia.getVideoTracks().length > 0) {
	              localMedia.getVideoTracks()[0].enabled = true;
	            }*/
	            this.accepted(response);
	          } else {
	            if(!response.body) {
	              this.acceptAndTerminate(response, 400, 'Missing session description');
	              this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	              break;
	            }
	            if (!this.createDialog(response, 'UAC')) {
	              break;
	            }
	            this.hasOffer = true;
	            this.mediaHandler.setDescription(response.body)
	            .then(this.mediaHandler.getDescription.bind(this.mediaHandler, this.mediaHint))
	            .then(function onSuccess(sdp) {
	              //var localMedia;
	              if(session.isCanceled || session.status === C.STATUS_TERMINATED) {
	                return;
	              }
	
	              sdp = SIP.Hacks.Firefox.hasMissingCLineInSDP(sdp);
	
	              session.status = C.STATUS_CONFIRMED;
	              session.hasAnswer = true;
	
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              session.sendRequest(SIP.C.ACK,{
	                body: sdp,
	                extraHeaders:['Content-Type: application/sdp'],
	                cseq:response.cseq
	              });
	              session.accepted(response);
	            })
	            .catch(function onFailure(e) {
	              if (e instanceof SIP.Exceptions.GetDescriptionError) {
	                // TODO do something here
	                session.logger.warn("there was a problem");
	              } else {
	                session.logger.warn('invalid SDP');
	                session.logger.warn(e);
	                response.reply(488);
	              }
	            });
	          }
	        } else if (this.hasAnswer){
	          if (this.renderbody) {
	            extraHeaders.push('Content-Type: ' + session.rendertype);
	            options.extraHeaders = extraHeaders;
	            options.body = this.renderbody;
	          }
	          this.sendRequest(SIP.C.ACK, options);
	        } else {
	          if(!response.body) {
	            this.acceptAndTerminate(response, 400, 'Missing session description');
	            this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            break;
	          }
	          if (!this.createDialog(response, 'UAC')) {
	            break;
	          }
	          this.hasAnswer = true;
	          this.mediaHandler.setDescription(response.body)
	          .then(
	            function onSuccess () {
	              var options = {};//,localMedia;
	              session.status = C.STATUS_CONFIRMED;
	              session.unmute();
	              /*localMedia = session.mediaHandler.localMedia;
	              if (localMedia.getAudioTracks().length > 0) {
	                localMedia.getAudioTracks()[0].enabled = true;
	              }
	              if (localMedia.getVideoTracks().length > 0) {
	                localMedia.getVideoTracks()[0].enabled = true;
	              }*/
	              if (session.renderbody) {
	                extraHeaders.push('Content-Type: ' + session.rendertype);
	                options.extraHeaders = extraHeaders;
	                options.body = session.renderbody;
	              }
	              options.cseq = response.cseq;
	              session.sendRequest(SIP.C.ACK, options);
	              session.accepted(response);
	            },
	            function onFailure (e) {
	              session.logger.warn(e);
	              session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
	              session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);
	            }
	          );
	        }
	        break;
	      default:
	        cause = SIP.Utils.sipErrorCause(response.status_code);
	        this.rejected(response, cause);
	        this.failed(response, cause);
	        this.terminated(response, cause);
	    }
	  },
	
	  cancel: function(options) {
	    options = options || {};
	
	    // Check Session Status
	    if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {
	      throw new SIP.Exceptions.InvalidStateError(this.status);
	    }
	
	    this.logger.log('canceling RTCSession');
	
	    var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);
	
	    // Check Session Status
	    if (this.status === C.STATUS_NULL ||
	        (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {
	      this.isCanceled = true;
	      this.cancelReason = cancel_reason;
	    } else if (this.status === C.STATUS_INVITE_SENT ||
	               this.status === C.STATUS_1XX_RECEIVED ||
	               this.status === C.STATUS_EARLY_MEDIA) {
	      this.request.cancel(cancel_reason);
	    }
	
	    return this.canceled();
	  },
	
	  terminate: function(options) {
	    if (this.status === C.STATUS_TERMINATED) {
	      return this;
	    }
	
	    if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {
	      this.bye(options);
	    } else {
	      this.cancel(options);
	    }
	
	    return this;
	  },
	
	  receiveRequest: function(request) {
	    // ICC RECEIVE REQUEST
	
	    // Reject CANCELs
	    if (request.method === SIP.C.CANCEL) {
	      // TODO; make this a switch when it gets added
	    }
	
	    if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {
	      SIP.Timers.clearTimeout(this.timers.ackTimer);
	      SIP.Timers.clearTimeout(this.timers.invite2xxTimer);
	      this.status = C.STATUS_CONFIRMED;
	      this.unmute();
	
	      this.accepted();
	    }
	
	    return Session.prototype.receiveRequest.apply(this, [request]);
	  },
	
	  onTransportError: function() {
	    if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.CONNECTION_ERROR);
	    }
	  },
	
	  onRequestTimeout: function() {
	    if (this.status === C.STATUS_CONFIRMED) {
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    } else if (this.status !== C.STATUS_TERMINATED) {
	      this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);
	      this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);
	    }
	  }
	
	};
	
	SIP.InviteClientContext = InviteClientContext;
	
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview DTMF
	 */
	
	/**
	 * @class DTMF
	 * @param {SIP.Session} session
	 */
	module.exports = function (SIP) {
	
	var DTMF,
	  C = {
	    MIN_DURATION:            70,
	    MAX_DURATION:            6000,
	    DEFAULT_DURATION:        100,
	    MIN_INTER_TONE_GAP:      50,
	    DEFAULT_INTER_TONE_GAP:  500
	  };
	
	DTMF = function(session, tone, options) {
	  var duration, interToneGap;
	
	  if (tone === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);
	  this.owner = session;
	  this.direction = null;
	
	  options = options || {};
	  duration = options.duration || null;
	  interToneGap = options.interToneGap || null;
	
	  // Check tone type
	  if (typeof tone === 'string' ) {
	    tone = tone.toUpperCase();
	  } else if (typeof tone === 'number') {
	    tone = tone.toString();
	  } else {
	    throw new TypeError('Invalid tone: '+ tone);
	  }
	
	  // Check tone value
	  if (!tone.match(/^[0-9A-D#*]$/)) {
	    throw new TypeError('Invalid tone: '+ tone);
	  } else {
	    this.tone = tone;
	  }
	
	  // Check duration
	  if (duration && !SIP.Utils.isDecimal(duration)) {
	    throw new TypeError('Invalid tone duration: '+ duration);
	  } else if (!duration) {
	    duration = DTMF.C.DEFAULT_DURATION;
	  } else if (duration < DTMF.C.MIN_DURATION) {
	    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
	    duration = DTMF.C.MIN_DURATION;
	  } else if (duration > DTMF.C.MAX_DURATION) {
	    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
	    duration = DTMF.C.MAX_DURATION;
	  } else {
	    duration = Math.abs(duration);
	  }
	  this.duration = duration;
	
	  // Check interToneGap
	  if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {
	    throw new TypeError('Invalid interToneGap: '+ interToneGap);
	  } else if (!interToneGap) {
	    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
	  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
	    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
	    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
	  } else {
	    interToneGap = Math.abs(interToneGap);
	  }
	  this.interToneGap = interToneGap;
	};
	DTMF.prototype = Object.create(SIP.EventEmitter.prototype);
	
	
	DTMF.prototype.send = function(options) {
	  var extraHeaders, body;
	
	  this.direction = 'outgoing';
	
	  // Check RTCSession Status
	  if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&
	    this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {
	    throw new SIP.Exceptions.InvalidStateError(this.owner.status);
	  }
	
	  // Get DTMF options
	  options = options || {};
	  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
	
	  extraHeaders.push('Content-Type: application/dtmf-relay');
	
	  body = "Signal= " + this.tone + "\r\n";
	  body += "Duration= " + this.duration;
	
	  this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {
	    extraHeaders: extraHeaders,
	    body: body
	  });
	
	  this.owner.emit('dtmf', this.request, this);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.receiveResponse = function(response) {
	  var cause;
	
	  switch(true) {
	    case /^1[0-9]{2}$/.test(response.status_code):
	      // Ignore provisional responses.
	      break;
	
	    case /^2[0-9]{2}$/.test(response.status_code):
	      this.emit('succeeded', {
	        originator: 'remote',
	        response: response
	      });
	      break;
	
	    default:
	      cause = SIP.Utils.sipErrorCause(response.status_code);
	      this.emit('failed', response, cause);
	      break;
	  }
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onRequestTimeout = function() {
	  this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);
	  this.owner.onRequestTimeout();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onTransportError = function() {
	  this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);
	  this.owner.onTransportError();
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.onDialogError = function(response) {
	  this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);
	  this.owner.onDialogError(response);
	};
	
	/**
	 * @private
	 */
	DTMF.prototype.init_incoming = function(request) {
	  this.direction = 'incoming';
	  this.request = request;
	
	  request.reply(200);
	
	  if (!this.tone || !this.duration) {
	    this.logger.warn('invalid INFO DTMF received, discarded');
	  } else {
	    this.owner.emit('dtmf', request, this);
	  }
	};
	
	DTMF.C = C;
	return DTMF;
	};


/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)
	 */
	
	/**
	 * @augments SIP
	 * @class Class creating a SIP Subscription.
	 */
	module.exports = function (SIP) {
	SIP.Subscription = function (ua, target, event, options) {
	  options = Object.create(options || Object.prototype);
	  this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();
	
	  this.id = null;
	  this.state = 'init';
	
	  if (!event) {
	    throw new TypeError('Event necessary to create a subscription.');
	  } else {
	    //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
	    //The check may need to/should probably occur on the other side,
	    this.event = event;
	  }
	
	  if(typeof options.expires !== 'number'){
	    ua.logger.warn('expires must be a number. Using default of 3600.');
	    this.expires = 3600;
	  } else {
	    this.expires = options.expires;
	  }
	
	  options.extraHeaders.push('Event: ' + this.event);
	  options.extraHeaders.push('Expires: ' + this.expires);
	
	  if (options.body) {
	    this.body = options.body;
	  }
	
	  this.contact = ua.contact.toString();
	
	  options.extraHeaders.push('Contact: '+ this.contact);
	  options.extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	  SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);
	
	  this.logger = ua.getLogger('sip.subscription');
	
	  this.dialog = null;
	  this.timers = {N: null, sub_duration: null};
	  this.errorCodes  = [404,405,410,416,480,481,482,483,484,485,489,501,604];
	};
	
	SIP.Subscription.prototype = {
	  subscribe: function() {
	    var sub = this;
	
	     //these states point to an existing subscription, no subscribe is necessary
	    if (this.state === 'active') {
	      this.refresh();
	      return this;
	    } else if (this.state === 'notify_wait') {
	      return this;
	    }
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	
	    this.send();
	
	    this.state = 'notify_wait';
	
	    return this;
	  },
	
	  refresh: function () {
	    if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {
	      return;
	    }
	
	    this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {
	      extraHeaders: this.extraHeaders,
	      body: this.body
	    });
	  },
	
	  receiveResponse: function(response) {
	    var expires, sub = this,
	        cause = SIP.Utils.getReasonPhrase(response.status_code);
	
	    if ((this.state === 'notify_wait' && response.status_code >= 300) ||
	        (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {
	      this.failed(response, null);
	    } else if (/^2[0-9]{2}$/.test(response.status_code)){
	      expires = response.getHeader('Expires');
	      SIP.Timers.clearTimeout(this.timers.N);
	
	      if (this.createConfirmedDialog(response,'UAC')) {
	        this.id = this.dialog.id.toString();
	        this.ua.subscriptions[this.id] = this;
	        this.emit('accepted', response, cause);
	        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
	      }
	
	      if (expires && expires <= this.expires) {
	        // Preserve new expires value for subsequent requests
	        this.expires = expires;
	        this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);
	      } else {
	        if (!expires) {
	          this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');
	          this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);
	        } else {
	          this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');
	          this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);
	        }
	      }
	    } //Used to just ignore provisional responses; now ignores everything except errorCodes and 2xx
	  },
	
	  unsubscribe: function() {
	    var extraHeaders = [], sub = this;
	
	    this.state = 'terminated';
	
	    extraHeaders.push('Event: ' + this.event);
	    extraHeaders.push('Expires: 0');
	
	    extraHeaders.push('Contact: '+ this.contact);
	    extraHeaders.push('Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString());
	
	    //makes sure expires isn't set, and other typical resubscribe behavior
	    this.receiveResponse = function(){};
	
	    this.dialog.sendRequest(this, this.method, {
	      extraHeaders: extraHeaders,
	      body: this.body
	    });
	
	    SIP.Timers.clearTimeout(this.timers.sub_duration);
	    SIP.Timers.clearTimeout(this.timers.N);
	    this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);
	  },
	
	  /**
	  * @private
	  */
	  timer_fire: function(){
	    if (this.state === 'terminated') {
	      this.terminateDialog();
	      SIP.Timers.clearTimeout(this.timers.N);
	      SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	      delete this.ua.subscriptions[this.id];
	    } else if (this.state === 'pending' || this.state === 'notify_wait') {
	      this.close();
	    } else {
	      this.refresh();
	    }
	  },
	
	  /**
	  * @private
	  */
	  close: function() {
	    if(this.state !== 'notify_wait' && this.state !== 'terminated') {
	      this.unsubscribe();
	    }
	  },
	
	  /**
	  * @private
	  */
	  createConfirmedDialog: function(message, type) {
	    var dialog;
	
	    this.terminateDialog();
	    dialog = new SIP.Dialog(this, message, type);
	
	    if(!dialog.error) {
	      this.dialog = dialog;
	      return true;
	    }
	    // Dialog not created due to an error
	    else {
	      return false;
	    }
	  },
	
	  /**
	  * @private
	  */
	  terminateDialog: function() {
	    if(this.dialog) {
	      delete this.ua.subscriptions[this.id];
	      this.dialog.terminate();
	      delete this.dialog;
	    }
	  },
	
	  /**
	  * @private
	  */
	  receiveRequest: function(request) {
	    var sub_state, sub = this;
	
	    function setExpiresTimeout() {
	      if (sub_state.expires) {
	        SIP.Timers.clearTimeout(sub.timers.sub_duration);
	        sub_state.expires = Math.min(sub.expires,
	                                     Math.max(sub_state.expires, 0));
	        sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub),
	                                                    sub_state.expires * 900);
	      }
	    }
	
	    if (!this.matchEvent(request)) { //checks event and subscription_state headers
	      request.reply(489);
	      return;
	    }
	
	    sub_state = request.parseHeader('Subscription-State');
	
	    request.reply(200, SIP.C.REASON_200);
	
	    SIP.Timers.clearTimeout(this.timers.N);
	
	    this.emit('notify', {request: request});
	
	    // if we've set state to terminated, no further processing should take place
	    // and we are only interested in cleaning up after the appropriate NOTIFY
	    if (this.state === 'terminated') {
	      if (sub_state.state === 'terminated') {
	        this.terminateDialog();
	        SIP.Timers.clearTimeout(this.timers.N);
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	
	        delete this.ua.subscriptions[this.id];
	      }
	      return;
	    }
	
	    switch (sub_state.state) {
	      case 'active':
	        this.state = 'active';
	        setExpiresTimeout();
	        break;
	      case 'pending':
	        if (this.state === 'notify_wait') {
	          setExpiresTimeout();
	        }
	        this.state = 'pending';
	        break;
	      case 'terminated':
	        SIP.Timers.clearTimeout(this.timers.sub_duration);
	        if (sub_state.reason) {
	          this.logger.log('terminating subscription with reason '+ sub_state.reason);
	          switch (sub_state.reason) {
	            case 'deactivated':
	            case 'timeout':
	              this.subscribe();
	              return;
	            case 'probation':
	            case 'giveup':
	              if(sub_state.params && sub_state.params['retry-after']) {
	                this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);
	              } else {
	                this.subscribe();
	              }
	              return;
	            case 'rejected':
	            case 'noresource':
	            case 'invariant':
	              break;
	          }
	        }
	        this.close();
	        break;
	    }
	  },
	
	  failed: function(response, cause) {
	    this.close();
	    this.emit('failed', response, cause);
	    return this;
	  },
	
	  onDialogError: function(response) {
	    this.failed(response, SIP.C.causes.DIALOG_ERROR);
	  },
	
	  /**
	  * @private
	  */
	  matchEvent: function(request) {
	    var event;
	
	    // Check mandatory header Event
	    if (!request.hasHeader('Event')) {
	      this.logger.warn('missing Event header');
	      return false;
	    }
	    // Check mandatory header Subscription-State
	    if (!request.hasHeader('Subscription-State')) {
	      this.logger.warn('missing Subscription-State header');
	      return false;
	    }
	
	    // Check whether the event in NOTIFY matches the event in SUBSCRIBE
	    event = request.parseHeader('event').event;
	
	    if (this.event !== event) {
	      this.logger.warn('event match failed');
	      request.reply(481, 'Event Match Failed');
	      return false;
	    } else {
	      return true;
	    }
	  }
	};
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileoverview WebRTC
	 */
	
	module.exports = function (SIP, environment) {
	var WebRTC;
	
	WebRTC = {};
	
	WebRTC.MediaHandler = __webpack_require__(237)(SIP);
	WebRTC.MediaStreamManager = __webpack_require__(238)(SIP, environment);
	
	var _isSupported;
	
	WebRTC.isSupported = function () {
	  if (_isSupported !== undefined) {
	    return _isSupported;
	  }
	
	  WebRTC.MediaStream = environment.MediaStream;
	  WebRTC.getUserMedia = environment.getUserMedia;
	  WebRTC.RTCPeerConnection = environment.RTCPeerConnection;
	  WebRTC.RTCSessionDescription = environment.RTCSessionDescription;
	
	  if (WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
	    if (WebRTC.getUserMedia) {
	      WebRTC.getUserMedia = SIP.Utils.promisify(environment, 'getUserMedia');
	    }
	    _isSupported = true;
	  }
	  else {
	    _isSupported = false;
	  }
	  return _isSupported;
	};
	
	return WebRTC;
	};


/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaHandler
	 */
	
	/* MediaHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 * @param {SIP.WebRTC.MediaStreamManager} [options.mediaStreamManager]
	 *        The MediaStreamManager to acquire/release streams from/to.
	 *        If not provided, a default MediaStreamManager will be used.
	 */
	module.exports = function (SIP) {
	
	var MediaHandler = function(session, options) {
	  options = options || {};
	
	  this.logger = session.ua.getLogger('sip.invitecontext.mediahandler', session.id);
	  this.session = session;
	  this.localMedia = null;
	  this.ready = true;
	  this.mediaStreamManager = options.mediaStreamManager || new SIP.WebRTC.MediaStreamManager(this.logger);
	  this.audioMuted = false;
	  this.videoMuted = false;
	
	  // old init() from here on
	  var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	  this.RTCConstraints = options.RTCConstraints || {};
	
	  this.initPeerConnection(servers, this.RTCConstraints);
	
	  function selfEmit(mh, event) {
	    if (mh.mediaStreamManager.on) {
	      mh.mediaStreamManager.on(event, function () {
	        mh.emit.apply(mh, [event].concat(Array.prototype.slice.call(arguments)));
	      });
	    }
	  }
	
	  selfEmit(this, 'userMediaRequest');
	  selfEmit(this, 'userMedia');
	  selfEmit(this, 'userMediaFailed');
	};
	
	MediaHandler.defaultFactory = function defaultFactory (session, options) {
	  return new MediaHandler(session, options);
	};
	MediaHandler.defaultFactory.isSupported = function () {
	  return SIP.WebRTC.isSupported();
	};
	
	MediaHandler.prototype = Object.create(SIP.MediaHandler.prototype, {
	// Functions the session can use
	  isReady: {writable: true, value: function isReady () {
	    return this.ready;
	  }},
	
	  close: {writable: true, value: function close () {
	    this.logger.log('closing PeerConnection');
	    this._remoteStreams = [];
	    // have to check signalingState since this.close() gets called multiple times
	    // TODO figure out why that happens
	    if(this.peerConnection && this.peerConnection.signalingState !== 'closed') {
	      this.peerConnection.close();
	
	      if(this.localMedia) {
	        this.mediaStreamManager.release(this.localMedia);
	      }
	    }
	  }},
	
	  /**
	   * @param {SIP.WebRTC.MediaStream | (getUserMedia constraints)} [mediaHint]
	   *        the MediaStream (or the constraints describing it) to be used for the session
	   */
	  getDescription: {writable: true, value: function getDescription (mediaHint) {
	    var self = this;
	    var acquire = self.mediaStreamManager.acquire;
	    if (acquire.length > 1) {
	      acquire = SIP.Utils.promisify(this.mediaStreamManager, 'acquire', true);
	    }
	    mediaHint = mediaHint || {};
	    if (mediaHint.dataChannel === true) {
	      mediaHint.dataChannel = {};
	    }
	    this.mediaHint = mediaHint;
	
	    /*
	     * 1. acquire streams (skip if MediaStreams passed in)
	     * 2. addStreams
	     * 3. createOffer/createAnswer
	     */
	
	    var streamPromise;
	    if (self.localMedia) {
	      self.logger.log('already have local media');
	      streamPromise = SIP.Utils.Promise.resolve(self.localMedia);
	    }
	    else {
	      self.logger.log('acquiring local media');
	      streamPromise = acquire.call(self.mediaStreamManager, mediaHint)
	        .then(function acquireSucceeded(streams) {
	          self.logger.log('acquired local media streams');
	          self.localMedia = streams;
	          self.session.connecting();
	          return streams;
	        }, function acquireFailed(err) {
	          self.logger.error('unable to acquire streams');
	          self.logger.error(err);
	          self.session.connecting();
	          throw err;
	        })
	        .then(this.addStreams.bind(this))
	      ;
	    }
	
	    return streamPromise
	      .then(function streamAdditionSucceeded() {
	        if (self.hasOffer('remote')) {
	          self.peerConnection.ondatachannel = function (evt) {
	            self.dataChannel = evt.channel;
	            self.emit('dataChannel', self.dataChannel);
	          };
	        } else if (mediaHint.dataChannel &&
	                   self.peerConnection.createDataChannel) {
	          self.dataChannel = self.peerConnection.createDataChannel(
	            'sipjs',
	            mediaHint.dataChannel
	          );
	          self.emit('dataChannel', self.dataChannel);
	        }
	
	        self.render();
	        return self.createOfferOrAnswer(self.RTCConstraints);
	      })
	    ;
	  }},
	
	  /**
	  * Message reception.
	  * @param {String} type
	  * @param {String} sdp
	  */
	  setDescription: {writable: true, value: function setDescription (sdp) {
	    var rawDescription = {
	      type: this.hasOffer('local') ? 'answer' : 'offer',
	      sdp: sdp
	    };
	
	    this.emit('setDescription', rawDescription);
	
	    var description = new SIP.WebRTC.RTCSessionDescription(rawDescription);
	    return SIP.Utils.promisify(this.peerConnection, 'setRemoteDescription')(description);
	  }},
	
	  /**
	   * If the Session associated with this MediaHandler were to be referred,
	   * what mediaHint should be provided to the UA's invite method?
	   */
	  getReferMedia: {writable: true, value: function getReferMedia () {
	    function hasTracks (trackGetter, stream) {
	      return stream[trackGetter]().length > 0;
	    }
	
	    function bothHaveTracks (trackGetter) {
	      /* jshint validthis:true */
	      return this.getLocalStreams().some(hasTracks.bind(null, trackGetter)) &&
	             this.getRemoteStreams().some(hasTracks.bind(null, trackGetter));
	    }
	
	    return {
	      constraints: {
	        audio: bothHaveTracks.call(this, 'getAudioTracks'),
	        video: bothHaveTracks.call(this, 'getVideoTracks')
	      }
	    };
	  }},
	
	  updateIceServers: {writeable:true, value: function (options) {
	    var servers = this.prepareIceServers(options.stunServers, options.turnServers);
	    this.RTCConstraints = options.RTCConstraints || this.RTCConstraints;
	
	    this.initPeerConnection(servers, this.RTCConstraints);
	
	    /* once updateIce is implemented correctly, this is better than above
	    //no op if browser does not support this
	    if (!this.peerConnection.updateIce) {
	      return;
	    }
	
	    this.peerConnection.updateIce({'iceServers': servers}, this.RTCConstraints);
	    */
	  }},
	
	// Functions the session can use, but only because it's convenient for the application
	  isMuted: {writable: true, value: function isMuted () {
	    return {
	      audio: this.audioMuted,
	      video: this.videoMuted
	    };
	  }},
	
	  mute: {writable: true, value: function mute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioMuted = false,
	        videoMuted = false;
	
	    if (options.audio && !this.audioMuted) {
	      audioMuted = true;
	      this.audioMuted = true;
	      this.toggleMuteAudio(true);
	    }
	
	    if (options.video && !this.videoMuted) {
	      videoMuted = true;
	      this.videoMuted = true;
	      this.toggleMuteVideo(true);
	    }
	
	    //REVISIT
	    if (audioMuted || videoMuted) {
	      return {
	        audio: audioMuted,
	        video: videoMuted
	      };
	      /*this.session.onmute({
	        audio: audioMuted,
	        video: videoMuted
	      });*/
	    }
	  }},
	
	  unmute: {writable: true, value: function unmute (options) {
	    if (this.getLocalStreams().length === 0) {
	      return;
	    }
	
	    options = options || {
	      audio: this.getLocalStreams()[0].getAudioTracks().length > 0,
	      video: this.getLocalStreams()[0].getVideoTracks().length > 0
	    };
	
	    var audioUnMuted = false,
	        videoUnMuted = false;
	
	    if (options.audio && this.audioMuted) {
	      audioUnMuted = true;
	      this.audioMuted = false;
	      this.toggleMuteAudio(false);
	    }
	
	    if (options.video && this.videoMuted) {
	      videoUnMuted = true;
	      this.videoMuted = false;
	      this.toggleMuteVideo(false);
	    }
	
	    //REVISIT
	    if (audioUnMuted || videoUnMuted) {
	      return {
	        audio: audioUnMuted,
	        video: videoUnMuted
	      };
	      /*this.session.onunmute({
	        audio: audioUnMuted,
	        video: videoUnMuted
	      });*/
	    }
	  }},
	
	  hold: {writable: true, value: function hold () {
	    this.toggleMuteAudio(true);
	    this.toggleMuteVideo(true);
	  }},
	
	  unhold: {writable: true, value: function unhold () {
	    if (!this.audioMuted) {
	      this.toggleMuteAudio(false);
	    }
	
	    if (!this.videoMuted) {
	      this.toggleMuteVideo(false);
	    }
	  }},
	
	// Functions the application can use, but not the session
	  getLocalStreams: {writable: true, value: function getLocalStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getLocalStreams returning []');
	      return [];
	    }
	    return (pc.getLocalStreams && pc.getLocalStreams()) ||
	      pc.localStreams || [];
	  }},
	
	  getRemoteStreams: {writable: true, value: function getRemoteStreams () {
	    var pc = this.peerConnection;
	    if (pc && pc.signalingState === 'closed') {
	      this.logger.warn('peerConnection is closed, getRemoteStreams returning this._remoteStreams');
	      return this._remoteStreams;
	    }
	    return(pc.getRemoteStreams && pc.getRemoteStreams()) ||
	      pc.remoteStreams || [];
	  }},
	
	  render: {writable: true, value: function render (renderHint) {
	    renderHint = renderHint || (this.mediaHint && this.mediaHint.render);
	    if (!renderHint) {
	      return false;
	    }
	    var streamGetters = {
	      local: 'getLocalStreams',
	      remote: 'getRemoteStreams'
	    };
	    Object.keys(streamGetters).forEach(function (loc) {
	      var streamGetter = streamGetters[loc];
	      var streams = this[streamGetter]();
	      SIP.WebRTC.MediaStreamManager.render(streams, renderHint[loc]);
	    }.bind(this));
	  }},
	
	// Internal functions
	  hasOffer: {writable: true, value: function hasOffer (where) {
	    var offerState = 'have-' + where + '-offer';
	    return this.peerConnection.signalingState === offerState;
	    // TODO consider signalingStates with 'pranswer'?
	  }},
	
	  prepareIceServers: {writable: true, value: function prepareIceServers (stunServers, turnServers) {
	    var servers = [],
	      config = this.session.ua.configuration;
	
	    stunServers = stunServers || config.stunServers;
	    turnServers = turnServers || config.turnServers;
	
	    [].concat(stunServers).forEach(function (server) {
	      servers.push({'urls': server});
	    });
	
	    [].concat(turnServers).forEach(function (server) {
	      servers.push({
	        'urls': server.urls,
	        'username': server.username,
	        'credential': server.password
	      });
	    });
	
	    return servers;
	  }},
	
	  initPeerConnection: {writable: true, value: function initPeerConnection(servers, RTCConstraints) {
	    var self = this,
	      config = this.session.ua.configuration;
	
	    this.onIceCompleted = SIP.Utils.defer();
	    this.onIceCompleted.promise.then(function(pc) {
	      self.emit('iceGatheringComplete', pc);
	      if (self.iceCheckingTimer) {
	        SIP.Timers.clearTimeout(self.iceCheckingTimer);
	        self.iceCheckingTimer = null;
	      }
	    });
	
	    if (this.peerConnection) {
	      this.peerConnection.close();
	    }
	
	    this.peerConnection = new SIP.WebRTC.RTCPeerConnection({'iceServers': servers}, RTCConstraints);
	
	    // Firefox (35.0.1) sometimes throws on calls to peerConnection.getRemoteStreams
	    // even if peerConnection.onaddstream was just called. In order to make
	    // MediaHandler.prototype.getRemoteStreams work, keep track of them manually
	    this._remoteStreams = [];
	
	    this.peerConnection.onaddstream = function(e) {
	      self.logger.log('stream added: '+ e.stream.id);
	      self._remoteStreams.push(e.stream);
	      self.render();
	      self.emit('addStream', e);
	    };
	
	    this.peerConnection.onremovestream = function(e) {
	      self.logger.log('stream removed: '+ e.stream.id);
	    };
	
	    this.startIceCheckingTimer = function () {
	      if (!self.iceCheckingTimer) {
	        self.iceCheckingTimer = SIP.Timers.setTimeout(function() {
	          self.logger.log('RTCIceChecking Timeout Triggered after '+config.iceCheckingTimeout+' milliseconds');
	          self.onIceCompleted.resolve(this);
	        }.bind(this.peerConnection), config.iceCheckingTimeout);
	      }
	    };
	
	    this.peerConnection.onicecandidate = function(e) {
	      self.emit('iceCandidate', e);
	      if (e.candidate) {
	        self.logger.log('ICE candidate received: '+ (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
	        self.startIceCheckingTimer();
	      } else {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.onicegatheringstatechange = function () {
	      self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
	      if (this.iceGatheringState === 'gathering') {
	        self.emit('iceGathering', this);
	      }
	      if (this.iceGatheringState === 'complete') {
	        self.onIceCompleted.resolve(this);
	      }
	    };
	
	    this.peerConnection.oniceconnectionstatechange = function() {  //need e for commented out case
	      var stateEvent;
	
	      if (this.iceConnectionState === 'checking') {
	        self.startIceCheckingTimer();
	      }
	
	      switch (this.iceConnectionState) {
	      case 'new':
	        stateEvent = 'iceConnection';
	        break;
	      case 'checking':
	        stateEvent = 'iceConnectionChecking';
	        break;
	      case 'connected':
	        stateEvent = 'iceConnectionConnected';
	        break;
	      case 'completed':
	        stateEvent = 'iceConnectionCompleted';
	        break;
	      case 'failed':
	        stateEvent = 'iceConnectionFailed';
	        break;
	      case 'disconnected':
	        stateEvent = 'iceConnectionDisconnected';
	        break;
	      case 'closed':
	        stateEvent = 'iceConnectionClosed';
	        break;
	      default:
	        self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
	        return;
	      }
	      self.emit(stateEvent, this);
	
	      //Bria state changes are always connected -> disconnected -> connected on accept, so session gets terminated
	      //normal calls switch from failed to connected in some cases, so checking for failed and terminated
	      /*if (this.iceConnectionState === 'failed') {
	        self.session.terminate({
	        cause: SIP.C.causes.RTP_TIMEOUT,
	        status_code: 200,
	        reason_phrase: SIP.C.causes.RTP_TIMEOUT
	      });
	      } else if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
	      self.onIceCompleted(this);
	      }*/
	    };
	
	    this.peerConnection.onstatechange = function() {
	      self.logger.log('PeerConnection state changed to "'+ this.readyState +'"');
	    };
	  }},
	
	  createOfferOrAnswer: {writable: true, value: function createOfferOrAnswer (constraints) {
	    var self = this;
	    var methodName;
	    var pc = self.peerConnection;
	
	    self.ready = false;
	    methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';
	
	    return SIP.Utils.promisify(pc, methodName, true)(constraints)
	      .then(SIP.Utils.promisify(pc, 'setLocalDescription'))
	      .then(function onSetLocalDescriptionSuccess() {
	        var deferred = SIP.Utils.defer();
	        if (pc.iceGatheringState === 'complete' && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
	          deferred.resolve();
	        } else {
	          self.onIceCompleted.promise.then(deferred.resolve);
	        }
	        return deferred.promise;
	      })
	      .then(function readySuccess () {
	        var sdp = pc.localDescription.sdp;
	
	        sdp = SIP.Hacks.Chrome.needsExplicitlyInactiveSDP(sdp);
	        sdp = SIP.Hacks.AllBrowsers.unmaskDtls(sdp);
	
	        var sdpWrapper = {
	          type: methodName === 'createOffer' ? 'offer' : 'answer',
	          sdp: sdp
	        };
	
	        self.emit('getDescription', sdpWrapper);
	
	        self.ready = true;
	        return sdpWrapper.sdp;
	      })
	      .catch(function methodFailed (e) {
	        self.logger.error(e);
	        self.ready = true;
	        throw new SIP.Exceptions.GetDescriptionError(e);
	      })
	    ;
	  }},
	
	  addStreams: {writable: true, value: function addStreams (streams) {
	    try {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        this.peerConnection.addStream(stream);
	      }, this);
	    } catch(e) {
	      this.logger.error('error adding stream');
	      this.logger.error(e);
	      return SIP.Utils.Promise.reject(e);
	    }
	
	    return SIP.Utils.Promise.resolve();
	  }},
	
	  toggleMuteHelper: {writable: true, value: function toggleMuteHelper (trackGetter, mute) {
	    this.getLocalStreams().forEach(function (stream) {
	      stream[trackGetter]().forEach(function (track) {
	        track.enabled = !mute;
	      });
	    });
	  }},
	
	  toggleMuteAudio: {writable: true, value: function toggleMuteAudio (mute) {
	    this.toggleMuteHelper('getAudioTracks', mute);
	  }},
	
	  toggleMuteVideo: {writable: true, value: function toggleMuteVideo (mute) {
	    this.toggleMuteHelper('getVideoTracks', mute);
	  }}
	});
	
	// Return since it will be assigned to a variable.
	return MediaHandler;
	};


/***/ },
/* 238 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview MediaStreamManager
	 */
	
	/* MediaStreamManager
	 * @class Manages the acquisition and release of MediaStreams.
	 * @param {mediaHint} [defaultMediaHint] The mediaHint to use if none is provided to acquire()
	 */
	module.exports = function (SIP, environment) {
	
	// Default MediaStreamManager provides single-use streams created with getUserMedia
	var MediaStreamManager = function MediaStreamManager (logger, defaultMediaHint) {
	  if (!SIP.WebRTC.isSupported()) {
	    throw new SIP.Exceptions.NotSupportedError('Media not supported');
	  }
	
	  this.mediaHint = defaultMediaHint || {
	    constraints: {audio: true, video: true}
	  };
	
	  // map of streams to acquisition manner:
	  // true -> passed in as mediaHint.stream
	  // false -> getUserMedia
	  this.acquisitions = {};
	};
	MediaStreamManager.streamId = function (stream) {
	  return stream.getAudioTracks().concat(stream.getVideoTracks())
	    .map(function trackId (track) {
	      return track.id;
	    })
	    .join('');
	};
	
	/**
	 * @param {(Array of) MediaStream} streams - The streams to render
	 *
	 * @param {(Array of) HTMLMediaElement} elements
	 *        - The <audio>/<video> element(s) that should render the streams
	 *
	 * Each stream in streams renders to the corresponding element in elements,
	 * wrapping around elements if needed.
	 */
	MediaStreamManager.render = function render (streams, elements) {
	  if (!elements) {
	    return false;
	  }
	  if (Array.isArray(elements) && !elements.length) {
	    throw new TypeError('elements must not be empty');
	  }
	
	  function attachMediaStream(element, stream) {
	    if (typeof element.src !== 'undefined') {
	      environment.revokeObjectURL(element.src);
	      element.src = environment.createObjectURL(stream);
	    } else if (typeof (element.srcObject || element.mozSrcObject) !== 'undefined') {
	      element.srcObject = element.mozSrcObject = stream;
	    } else {
	      return false;
	    }
	
	    return true;
	  }
	
	  function ensureMediaPlaying (mediaElement) {
	    var interval = 100;
	    mediaElement.ensurePlayingIntervalId = SIP.Timers.setInterval(function () {
	      if (mediaElement.paused) {
	        mediaElement.play();
	      }
	      else {
	        SIP.Timers.clearInterval(mediaElement.ensurePlayingIntervalId);
	      }
	    }, interval);
	  }
	
	  function attachAndPlay (elements, stream, index) {
	    if (typeof elements === 'function') {
	      elements = elements();
	    }
	    var element = elements[index % elements.length];
	    (environment.attachMediaStream || attachMediaStream)(element, stream);
	    ensureMediaPlaying(element);
	  }
	
	  // [].concat "casts" `elements` into an array
	  // so forEach works even if `elements` was a single element
	  elements = [].concat(elements);
	  [].concat(streams).forEach(attachAndPlay.bind(null, elements));
	};
	
	MediaStreamManager.prototype = Object.create(SIP.EventEmitter.prototype, {
	  'acquire': {writable: true, value: function acquire (mediaHint) {
	    mediaHint = Object.keys(mediaHint || {}).length ? mediaHint : this.mediaHint;
	
	    var saveSuccess = function (isHintStream, streams) {
	      streams = [].concat(streams);
	      streams.forEach(function (stream) {
	        var streamId = MediaStreamManager.streamId(stream);
	        this.acquisitions[streamId] = !!isHintStream;
	      }, this);
	      return SIP.Utils.Promise.resolve(streams);
	    }.bind(this);
	
	    if (mediaHint.stream) {
	      return saveSuccess(true, mediaHint.stream);
	    } else {
	      // Fallback to audio/video enabled if no mediaHint can be found.
	      var constraints = mediaHint.constraints ||
	        (this.mediaHint && this.mediaHint.constraints) ||
	        {audio: true, video: true};
	
	      var deferred = SIP.Utils.defer();
	
	      /*
	       * Make the call asynchronous, so that ICCs have a chance
	       * to define callbacks to `userMediaRequest`
	       */
	      SIP.Timers.setTimeout(function () {
	        this.emit('userMediaRequest', constraints);
	
	        var emitThenCall = function (eventName, callback) {
	          var callbackArgs = Array.prototype.slice.call(arguments, 2);
	          // Emit with all of the arguments from the real callback.
	          var newArgs = [eventName].concat(callbackArgs);
	
	          this.emit.apply(this, newArgs);
	
	          return callback.apply(null, callbackArgs);
	        }.bind(this);
	
	        if (constraints.audio || constraints.video) {
	          deferred.resolve(
	            SIP.WebRTC.getUserMedia(constraints)
	            .then(
	              emitThenCall.bind(this, 'userMedia', saveSuccess.bind(null, false)),
	              emitThenCall.bind(this, 'userMediaFailed', function(e){throw e;})
	            )
	          );
	        } else {
	          // Local streams were explicitly excluded.
	          deferred.resolve([]);
	        }
	      }.bind(this), 0);
	
	      return deferred.promise;
	    }
	  }},
	
	  'release': {writable: true, value: function release (streams) {
	    streams = [].concat(streams);
	    streams.forEach(function (stream) {
	      var streamId = MediaStreamManager.streamId(stream);
	      if (this.acquisitions[streamId] === false) {
	        stream.getTracks().forEach(function (track) {
	          track.stop();
	        });
	      }
	      delete this.acquisitions[streamId];
	    }, this);
	  }},
	});
	
	// Return since it will be assigned to a variable.
	return MediaStreamManager;
	};


/***/ },
/* 239 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * @augments SIP
	 * @class Class creating a SIP User Agent.
	 * @param {function returning SIP.MediaHandler} [configuration.mediaHandlerFactory]
	 *        A function will be invoked by each of the UA's Sessions to build the MediaHandler for that Session.
	 *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) MediaHandler.
	 *
	 * @param {Object} [configuration.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 */
	module.exports = function (SIP, environment) {
	var UA,
	  C = {
	    // UA status codes
	    STATUS_INIT:                0,
	    STATUS_STARTING:            1,
	    STATUS_READY:               2,
	    STATUS_USER_CLOSED:         3,
	    STATUS_NOT_READY:           4,
	
	    // UA error codes
	    CONFIGURATION_ERROR:  1,
	    NETWORK_ERROR:        2,
	
	    ALLOWED_METHODS: [
	      'ACK',
	      'CANCEL',
	      'INVITE',
	      'MESSAGE',
	      'BYE',
	      'OPTIONS',
	      'INFO',
	      'NOTIFY',
	      'REFER'
	    ],
	
	    ACCEPTED_BODY_TYPES: [
	      'application/sdp',
	      'application/dtmf-relay'
	    ],
	
	    MAX_FORWARDS: 70,
	    TAG_LENGTH: 10
	  };
	
	UA = function(configuration) {
	  var self = this;
	
	  // Helper function for forwarding events
	  function selfEmit(type) {
	    //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments
	    return self.emit.bind(self, type);
	  }
	
	  // Set Accepted Body Types
	  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();
	
	  this.log = new SIP.LoggerFactory();
	  this.logger = this.getLogger('sip.ua');
	
	  this.cache = {
	    credentials: {}
	  };
	
	  this.configuration = {};
	  this.dialogs = {};
	
	  //User actions outside any session/dialog (MESSAGE)
	  this.applicants = {};
	
	  this.data = {};
	  this.sessions = {};
	  this.subscriptions = {};
	  this.transport = null;
	  this.contact = null;
	  this.status = C.STATUS_INIT;
	  this.error = null;
	  this.transactions = {
	    nist: {},
	    nict: {},
	    ist: {},
	    ict: {}
	  };
	
	  this.transportRecoverAttempts = 0;
	  this.transportRecoveryTimer = null;
	
	  Object.defineProperties(this, {
	    transactionsCount: {
	      get: function() {
	        var type,
	          transactions = ['nist','nict','ist','ict'],
	          count = 0;
	
	        for (type in transactions) {
	          count += Object.keys(this.transactions[transactions[type]]).length;
	        }
	
	        return count;
	      }
	    },
	
	    nictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nict']).length;
	      }
	    },
	
	    nistTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['nist']).length;
	      }
	    },
	
	    ictTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ict']).length;
	      }
	    },
	
	    istTransactionsCount: {
	      get: function() {
	        return Object.keys(this.transactions['ist']).length;
	      }
	    }
	  });
	
	  /**
	   * Load configuration
	   *
	   * @throws {SIP.Exceptions.ConfigurationError}
	   * @throws {TypeError}
	   */
	
	  if(configuration === undefined) {
	    configuration = {};
	  } else if (typeof configuration === 'string' || configuration instanceof String) {
	    configuration = {
	      uri: configuration
	    };
	  }
	
	  // Apply log configuration if present
	  if (configuration.log) {
	    if (configuration.log.hasOwnProperty('builtinEnabled')) {
	      this.log.builtinEnabled = configuration.log.builtinEnabled;
	    }
	
	    if (configuration.log.hasOwnProperty('level')) {
	      this.log.level = configuration.log.level;
	    }
	
	    if (configuration.log.hasOwnProperty('connector')) {
	      this.log.connector = configuration.log.connector;
	    }
	  }
	
	  try {
	    this.loadConfig(configuration);
	  } catch(e) {
	    this.status = C.STATUS_NOT_READY;
	    this.error = C.CONFIGURATION_ERROR;
	    throw e;
	  }
	
	  // Initialize registerContext
	  this.registerContext = new SIP.RegisterContext(this);
	  this.registerContext.on('failed', selfEmit('registrationFailed'));
	  this.registerContext.on('registered', selfEmit('registered'));
	  this.registerContext.on('unregistered', selfEmit('unregistered'));
	
	  if(this.configuration.autostart) {
	    this.start();
	  }
	
	  if (typeof environment.addEventListener === 'function') {
	    // Google Chrome Packaged Apps don't allow 'unload' listeners:
	    // unload is not available in packaged apps
	    if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {
	      environment.addEventListener('unload', this.stop.bind(this));
	    }
	  }
	};
	UA.prototype = Object.create(SIP.EventEmitter.prototype);
	
	//=================
	//  High Level API
	//=================
	
	UA.prototype.register = function(options) {
	  this.configuration.register = true;
	  this.registerContext.register(options);
	
	  return this;
	};
	
	/**
	 * Unregister.
	 *
	 * @param {Boolean} [all] unregister all user bindings.
	 *
	 */
	UA.prototype.unregister = function(options) {
	  this.configuration.register = false;
	
	  var context = this.registerContext;
	  this.afterConnected(context.unregister.bind(context, options));
	
	  return this;
	};
	
	UA.prototype.isRegistered = function() {
	  return this.registerContext.registered;
	};
	
	/**
	 * Connection state.
	 * @param {Boolean}
	 */
	UA.prototype.isConnected = function() {
	  return this.transport ? this.transport.connected : false;
	};
	
	UA.prototype.afterConnected = function afterConnected (callback) {
	  if (this.isConnected()) {
	    callback();
	  } else {
	    this.once('connected', callback);
	  }
	};
	
	/**
	 * Make an outgoing call.
	 *
	 * @param {String} target
	 * @param {Object} views
	 * @param {Object} [options.media] gets passed to SIP.MediaHandler.getDescription as mediaHint
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.invite = function(target, options) {
	  var context = new SIP.InviteClientContext(this, target, options);
	
	  this.afterConnected(context.invite.bind(context));
	  return context;
	};
	
	UA.prototype.subscribe = function(target, event, options) {
	  var sub = new SIP.Subscription(this, target, event, options);
	
	  this.afterConnected(sub.subscribe.bind(sub));
	  return sub;
	};
	
	/**
	 * Send a message.
	 *
	 * @param {String} target
	 * @param {String} body
	 * @param {Object} [options]
	 *
	 * @throws {TypeError}
	 *
	 */
	UA.prototype.message = function(target, body, options) {
	  if (body === undefined) {
	    throw new TypeError('Not enough arguments');
	  }
	
	  // There is no Message module, so it is okay that the UA handles defaults here.
	  options = Object.create(options || Object.prototype);
	  options.contentType || (options.contentType = 'text/plain');
	  options.body = body;
	
	  return this.request(SIP.C.MESSAGE, target, options);
	};
	
	UA.prototype.request = function (method, target, options) {
	  var req = new SIP.ClientContext(this, method, target, options);
	
	  this.afterConnected(req.send.bind(req));
	  return req;
	};
	
	/**
	 * Gracefully close.
	 *
	 */
	UA.prototype.stop = function() {
	  var session, subscription, applicant,
	    ua = this;
	
	  function transactionsListener() {
	    if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {
	        ua.removeListener('transactionDestroyed', transactionsListener);
	        ua.transport.disconnect();
	    }
	  }
	
	  this.logger.log('user requested closure...');
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.warn('UA already closed');
	    return this;
	  }
	
	  // Clear transportRecoveryTimer
	  SIP.Timers.clearTimeout(this.transportRecoveryTimer);
	
	  // Close registerContext
	  this.logger.log('closing registerContext');
	  this.registerContext.close();
	
	  // Run  _terminate_ on every Session
	  for(session in this.sessions) {
	    this.logger.log('closing session ' + session);
	    this.sessions[session].terminate();
	  }
	
	  //Run _close_ on every Subscription
	  for(subscription in this.subscriptions) {
	    this.logger.log('unsubscribing from subscription ' + subscription);
	    this.subscriptions[subscription].close();
	  }
	
	  // Run  _close_ on every applicant
	  for(applicant in this.applicants) {
	    this.applicants[applicant].close();
	  }
	
	  this.status = C.STATUS_USER_CLOSED;
	
	  /*
	   * If the remaining transactions are all INVITE transactions, there is no need to
	   * wait anymore because every session has already been closed by this method.
	   * - locally originated sessions where terminated (CANCEL or BYE)
	   * - remotely originated sessions where rejected (4XX) or terminated (BYE)
	   * Remaining INVITE transactions belong tho sessions that where answered. This are in
	   * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
	   */
	  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {
	    this.transport.disconnect();
	  } else {
	    this.on('transactionDestroyed', transactionsListener);
	  }
	
	  return this;
	};
	
	/**
	 * Connect to the WS server if status = STATUS_INIT.
	 * Resume UA after being closed.
	 *
	 */
	UA.prototype.start = function() {
	  var server;
	
	  this.logger.log('user requested startup...');
	  if (this.status === C.STATUS_INIT) {
	    server = this.getNextWsServer();
	    this.status = C.STATUS_STARTING;
	    new SIP.Transport(this, server);
	  } else if(this.status === C.STATUS_USER_CLOSED) {
	    this.logger.log('resuming');
	    this.status = C.STATUS_READY;
	    this.transport.connect();
	  } else if (this.status === C.STATUS_STARTING) {
	    this.logger.log('UA is in STARTING status, not opening new connection');
	  } else if (this.status === C.STATUS_READY) {
	    this.logger.log('UA is in READY status, not resuming');
	  } else {
	    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
	  }
	
	  return this;
	};
	
	/**
	 * Normalize a string into a valid SIP request URI
	 *
	 * @param {String} target
	 *
	 * @returns {SIP.URI|undefined}
	 */
	UA.prototype.normalizeTarget = function(target) {
	  return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);
	};
	
	
	//===============================
	//  Private (For internal use)
	//===============================
	
	UA.prototype.saveCredentials = function(credentials) {
	  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
	  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
	
	  return this;
	};
	
	UA.prototype.getCredentials = function(request) {
	  var realm, credentials;
	
	  realm = request.ruri.host;
	
	  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
	    credentials = this.cache.credentials[realm][request.ruri];
	    credentials.method = request.method;
	  }
	
	  return credentials;
	};
	
	UA.prototype.getLogger = function(category, label) {
	  return this.log.getLogger(category, label);
	};
	
	
	//==============================
	// Event Handlers
	//==============================
	
	/**
	 * Transport Close event
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportClosed = function(transport) {
	  // Run _onTransportError_ callback on every client transaction using _transport_
	  var type, idx, length,
	    client_transactions = ['nict', 'ict', 'nist', 'ist'];
	
	  transport.server.status = SIP.Transport.C.STATUS_DISCONNECTED;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_DISCONNECTED);
	
	  length = client_transactions.length;
	  for (type = 0; type < length; type++) {
	    for(idx in this.transactions[client_transactions[type]]) {
	      this.transactions[client_transactions[type]][idx].onTransportError();
	    }
	  }
	
	  // Close sessions if GRUU is not being used
	  if (!this.contact.pub_gruu) {
	    this.closeSessionsOnTransportError();
	  }
	
	};
	
	/**
	 * Unrecoverable transport event.
	 * Connection reattempt logic has been done and didn't success.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportError = function(transport) {
	  var server;
	
	  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to '+ SIP.Transport.C.STATUS_ERROR);
	
	  // Close sessions.
	  //Mark this transport as 'down'
	  transport.server.status = SIP.Transport.C.STATUS_ERROR;
	
	  this.emit('disconnected', {
	    transport: transport
	  });
	
	  // try the next transport if the UA isn't closed
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  server = this.getNextWsServer();
	
	  if(server) {
	    new SIP.Transport(this, server);
	  }else {
	    this.closeSessionsOnTransportError();
	    if (!this.error || this.error !== C.NETWORK_ERROR) {
	      this.status = C.STATUS_NOT_READY;
	      this.error = C.NETWORK_ERROR;
	    }
	    // Transport Recovery process
	    this.recoverTransport();
	  }
	};
	
	/**
	 * Transport connection event.
	 * @private
	 * @event
	 * @param {SIP.Transport} transport.
	 */
	UA.prototype.onTransportConnected = function(transport) {
	  this.transport = transport;
	
	  // Reset transport recovery counter
	  this.transportRecoverAttempts = 0;
	
	  transport.server.status = SIP.Transport.C.STATUS_READY;
	  this.logger.log('connection state set to '+ SIP.Transport.C.STATUS_READY);
	
	  if(this.status === C.STATUS_USER_CLOSED) {
	    return;
	  }
	
	  this.status = C.STATUS_READY;
	  this.error = null;
	
	  if(this.configuration.register) {
	    this.configuration.authenticationFactory.initialize().then(function () {
	      this.registerContext.onTransportConnected();
	    }.bind(this));
	  }
	
	  this.emit('connected', {
	    transport: transport
	  });
	};
	
	
	/**
	 * Transport connecting event
	 * @private
	 * @param {SIP.Transport} transport.
	 * #param {Integer} attempts.
	 */
	  UA.prototype.onTransportConnecting = function(transport, attempts) {
	    this.emit('connecting', {
	      transport: transport,
	      attempts: attempts
	    });
	  };
	
	
	/**
	 * new Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.newTransaction = function(transaction) {
	  this.transactions[transaction.type][transaction.id] = transaction;
	  this.emit('newTransaction', {transaction: transaction});
	};
	
	
	/**
	 * destroy Transaction
	 * @private
	 * @param {SIP.Transaction} transaction.
	 */
	UA.prototype.destroyTransaction = function(transaction) {
	  delete this.transactions[transaction.type][transaction.id];
	  this.emit('transactionDestroyed', {
	    transaction: transaction
	  });
	};
	
	
	//=========================
	// receiveRequest
	//=========================
	
	/**
	 * Request reception
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 */
	UA.prototype.receiveRequest = function(request) {
	  var dialog, session, message,
	    method = request.method,
	    transaction,
	    replaces,
	    replacedDialog,
	    self = this;
	
	  function ruriMatches (uri) {
	    return uri && uri.user === request.ruri.user;
	  }
	
	  // Check that request URI points to us
	  if(!(ruriMatches(this.configuration.uri) ||
	       ruriMatches(this.contact.uri) ||
	       ruriMatches(this.contact.pub_gruu) ||
	       ruriMatches(this.contact.temp_gruu))) {
	    this.logger.warn('Request-URI does not point to us');
	    if (request.method !== SIP.C.ACK) {
	      request.reply_sl(404);
	    }
	    return;
	  }
	
	  // Check request URI scheme
	  if(request.ruri.scheme === SIP.C.SIPS) {
	    request.reply_sl(416);
	    return;
	  }
	
	  // Check transaction
	  if(SIP.Transactions.checkTransaction(this, request)) {
	    return;
	  }
	
	  /* RFC3261 12.2.2
	   * Requests that do not change in any way the state of a dialog may be
	   * received within a dialog (for example, an OPTIONS request).
	   * They are processed as if they had been received outside the dialog.
	   */
	  if(method === SIP.C.OPTIONS) {
	    new SIP.Transactions.NonInviteServerTransaction(request, this);
	    request.reply(200, null, [
	      'Allow: '+ SIP.UA.C.ALLOWED_METHODS.toString(),
	      'Accept: '+ C.ACCEPTED_BODY_TYPES
	    ]);
	  } else if (method === SIP.C.MESSAGE) {
	    message = new SIP.ServerContext(this, request);
	    message.body = request.body;
	    message.content_type = request.getHeader('Content-Type') || 'text/plain';
	
	    request.reply(200, null);
	    this.emit('message', message);
	  } else if (method !== SIP.C.INVITE &&
	             method !== SIP.C.ACK) {
	    // Let those methods pass through to normal processing for now.
	    transaction = new SIP.ServerContext(this, request);
	  }
	
	  // Initial Request
	  if(!request.to_tag) {
	    switch(method) {
	      case SIP.C.INVITE:
	        replaces =
	          this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&
	          request.parseHeader('replaces');
	
	        if (replaces) {
	          replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
	
	          if (!replacedDialog) {
	            //Replaced header without a matching dialog, reject
	            request.reply_sl(481, null);
	            return;
	          } else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {
	            request.reply_sl(603, null);
	            return;
	          } else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {
	            request.reply_sl(486, null);
	            return;
	          }
	        }
	
	        var isMediaSupported = this.configuration.mediaHandlerFactory.isSupported;
	        if(!isMediaSupported || isMediaSupported()) {
	          session = new SIP.InviteServerContext(this, request);
	          session.replacee = replacedDialog && replacedDialog.owner;
	          session.on('invite', function() {
	            self.emit('invite', this);
	          });
	        } else {
	          this.logger.warn('INVITE received but WebRTC is not supported');
	          request.reply(488);
	        }
	        break;
	      case SIP.C.BYE:
	        // Out of dialog BYE received
	        request.reply(481);
	        break;
	      case SIP.C.CANCEL:
	        session = this.findSession(request);
	        if(session) {
	          session.receiveRequest(request);
	        } else {
	          this.logger.warn('received CANCEL request for a non existent session');
	        }
	        break;
	      case SIP.C.ACK:
	        /* Absorb it.
	         * ACK request without a corresponding Invite Transaction
	         * and without To tag.
	         */
	        break;
	      default:
	        request.reply(405);
	        break;
	    }
	  }
	  // In-dialog request
	  else {
	    dialog = this.findDialog(request);
	
	    if(dialog) {
	      if (method === SIP.C.INVITE) {
	        new SIP.Transactions.InviteServerTransaction(request, this);
	      }
	      dialog.receiveRequest(request);
	    } else if (method === SIP.C.NOTIFY) {
	      session = this.findSession(request);
	      if(session) {
	        session.receiveRequest(request);
	      } else {
	        this.logger.warn('received NOTIFY request for a non existent session');
	        request.reply(481, 'Subscription does not exist');
	      }
	    }
	    /* RFC3261 12.2.2
	     * Request with to tag, but no matching dialog found.
	     * Exception: ACK for an Invite request for which a dialog has not
	     * been created.
	     */
	    else {
	      if(method !== SIP.C.ACK) {
	        request.reply(481);
	      }
	    }
	  }
	};
	
	//=================
	// Utils
	//=================
	
	/**
	 * Get the session to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest} request.
	 * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}
	 */
	UA.prototype.findSession = function(request) {
	  return this.sessions[request.call_id + request.from_tag] ||
	          this.sessions[request.call_id + request.to_tag] ||
	          null;
	};
	
	/**
	 * Get the dialog to which the request belongs to, if any.
	 * @private
	 * @param {SIP.IncomingRequest}
	 * @returns {SIP.Dialog|null}
	 */
	UA.prototype.findDialog = function(request) {
	  return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||
	          this.dialogs[request.call_id + request.to_tag + request.from_tag] ||
	          null;
	};
	
	/**
	 * Retrieve the next server to which connect.
	 * @private
	 * @returns {Object} ws_server
	 */
	UA.prototype.getNextWsServer = function() {
	  // Order servers by weight
	  var idx, length, ws_server,
	    candidates = [];
	
	  length = this.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ws_server = this.configuration.wsServers[idx];
	
	    if (ws_server.status === SIP.Transport.C.STATUS_ERROR) {
	      continue;
	    } else if (candidates.length === 0) {
	      candidates.push(ws_server);
	    } else if (ws_server.weight > candidates[0].weight) {
	      candidates = [ws_server];
	    } else if (ws_server.weight === candidates[0].weight) {
	      candidates.push(ws_server);
	    }
	  }
	
	  idx = Math.floor(Math.random() * candidates.length);
	
	  return candidates[idx];
	};
	
	/**
	 * Close all sessions on transport error.
	 * @private
	 */
	UA.prototype.closeSessionsOnTransportError = function() {
	  var idx;
	
	  // Run _transportError_ for every Session
	  for(idx in this.sessions) {
	    this.sessions[idx].onTransportError();
	  }
	  // Call registerContext _onTransportClosed_
	  this.registerContext.onTransportClosed();
	};
	
	UA.prototype.recoverTransport = function(ua) {
	  var idx, length, k, nextRetry, count, server;
	
	  ua = ua || this;
	  count = ua.transportRecoverAttempts;
	
	  length = ua.configuration.wsServers.length;
	  for (idx = 0; idx < length; idx++) {
	    ua.configuration.wsServers[idx].status = 0;
	  }
	
	  server = ua.getNextWsServer();
	
	  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
	  nextRetry = k * ua.configuration.connectionRecoveryMinInterval;
	
	  if (nextRetry > ua.configuration.connectionRecoveryMaxInterval) {
	    this.logger.log('time for next connection attempt exceeds connectionRecoveryMaxInterval, resetting counter');
	    nextRetry = ua.configuration.connectionRecoveryMinInterval;
	    count = 0;
	  }
	
	  this.logger.log('next connection attempt in '+ nextRetry +' seconds');
	
	  this.transportRecoveryTimer = SIP.Timers.setTimeout(
	    function(){
	      ua.transportRecoverAttempts = count + 1;
	      new SIP.Transport(ua, server);
	    }, nextRetry * 1000);
	};
	
	function checkAuthenticationFactory (authenticationFactory) {
	  if (!(authenticationFactory instanceof Function)) {
	    return;
	  }
	  if (!authenticationFactory.initialize) {
	    authenticationFactory.initialize = function initialize () {
	      return SIP.Utils.Promise.resolve();
	    };
	  }
	  return authenticationFactory;
	}
	
	/**
	 * Configuration load.
	 * @private
	 * returns {Boolean}
	 */
	UA.prototype.loadConfig = function(configuration) {
	  // Settings and default values
	  var parameter, value, checked_value, hostportParams, registrarServer,
	    settings = {
	      /* Host address
	      * Value to be set in Via sent_by and host part of Contact FQDN
	      */
	      viaHost: SIP.Utils.createRandomToken(12) + '.invalid',
	
	      uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),
	      wsServers: [{
	        scheme: 'WSS',
	        sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',
	        status: 0,
	        weight: 0,
	        ws_uri: 'wss://edge.sip.onsip.com'
	      }],
	
	      // Password
	      password: null,
	
	      // Registration parameters
	      registerExpires: 600,
	      register: true,
	      registrarServer: null,
	
	      // Transport related parameters
	      wsServerMaxReconnection: 3,
	      wsServerReconnectionTimeout: 4,
	
	      connectionRecoveryMinInterval: 2,
	      connectionRecoveryMaxInterval: 30,
	
	      keepAliveInterval: 0,
	
	      extraSupported: [],
	
	      usePreloadedRoute: false,
	
	      //string to be inserted into User-Agent request header
	      userAgentString: SIP.C.USER_AGENT,
	
	      // Session parameters
	      iceCheckingTimeout: 5000,
	      noAnswerTimeout: 60,
	      stunServers: ['stun:stun.l.google.com:19302'],
	      turnServers: [],
	
	      // Logging parameters
	      traceSip: false,
	
	      // Hacks
	      hackViaTcp: false,
	      hackIpInContact: false,
	      hackWssInTransport: false,
	      hackAllowUnregisteredOptionTags: false,
	
	      contactTransport: 'ws',
	      forceRport: false,
	
	      //autostarting
	      autostart: true,
	
	      //Reliable Provisional Responses
	      rel100: SIP.C.supported.UNSUPPORTED,
	
	      // Replaces header (RFC 3891)
	      // http://tools.ietf.org/html/rfc3891
	      replaces: SIP.C.supported.UNSUPPORTED,
	
	      mediaHandlerFactory: SIP.WebRTC.MediaHandler.defaultFactory,
	
	      authenticationFactory: checkAuthenticationFactory(function authenticationFactory (ua) {
	        return new SIP.DigestAuthentication(ua);
	      })
	    };
	
	  // Pre-Configuration
	  function aliasUnderscored (parameter, logger) {
	    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {
	      return m[0] + '_' + m[1].toLowerCase();
	    });
	
	    if (parameter === underscored) {
	      return;
	    }
	
	    var hasParameter = configuration.hasOwnProperty(parameter);
	    if (configuration.hasOwnProperty(underscored)) {
	      logger.warn(underscored + ' is deprecated, please use ' + parameter);
	      if (hasParameter) {
	        logger.warn(parameter + ' overriding ' + underscored);
	      }
	    }
	
	    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];
	  }
	
	  // Check Mandatory parameters
	  for(parameter in UA.configuration_check.mandatory) {
	    aliasUnderscored(parameter, this.logger);
	    if(!configuration.hasOwnProperty(parameter)) {
	      throw new SIP.Exceptions.ConfigurationError(parameter);
	    } else {
	      value = configuration[parameter];
	      checked_value = UA.configuration_check.mandatory[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  SIP.Utils.optionsOverride(configuration, 'rel100', 'reliable', true, this.logger, SIP.C.supported.UNSUPPORTED);
	
	  var emptyArraysAllowed = ['stunServers', 'turnServers'];
	
	  // Check Optional parameters
	  for(parameter in UA.configuration_check.optional) {
	    aliasUnderscored(parameter, this.logger);
	    if(configuration.hasOwnProperty(parameter)) {
	      value = configuration[parameter];
	
	      // If the parameter value is an empty array, but shouldn't be, apply its default value.
	      if (value instanceof Array && value.length === 0 && emptyArraysAllowed.indexOf(parameter) < 0) { continue; }
	
	      // If the parameter value is null, empty string, or undefined then apply its default value.
	      if(value === null || value === "" || value === undefined) { continue; }
	      // If it's a number with NaN value then also apply its default value.
	      // NOTE: JS does not allow "value === NaN", the following does the work:
	      else if(typeof(value) === 'number' && isNaN(value)) { continue; }
	
	      checked_value = UA.configuration_check.optional[parameter](value);
	      if (checked_value !== undefined) {
	        settings[parameter] = checked_value;
	      } else {
	        throw new SIP.Exceptions.ConfigurationError(parameter, value);
	      }
	    }
	  }
	
	  // Sanity Checks
	
	  // Connection recovery intervals
	  if(settings.connectionRecoveryMaxInterval < settings.connectionRecoveryMinInterval) {
	    throw new SIP.Exceptions.ConfigurationError('connectionRecoveryMaxInterval', settings.connectionRecoveryMaxInterval);
	  }
	
	  // Post Configuration Process
	
	  // Allow passing 0 number as displayName.
	  if (settings.displayName === 0) {
	    settings.displayName = '0';
	  }
	
	  // Instance-id for GRUU
	  if (!settings.instanceId) {
	    settings.instanceId = SIP.Utils.newUUID();
	  }
	
	  // sipjsId instance parameter. Static random tag of length 5
	  settings.sipjsId = SIP.Utils.createRandomToken(5);
	
	  // String containing settings.uri without scheme and user.
	  hostportParams = settings.uri.clone();
	  hostportParams.user = null;
	  settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');
	
	  /* Check whether authorizationUser is explicitly defined.
	   * Take 'settings.uri.user' value if not.
	   */
	  if (!settings.authorizationUser) {
	    settings.authorizationUser = settings.uri.user;
	  }
	
	  /* If no 'registrarServer' is set use the 'uri' value without user portion. */
	  if (!settings.registrarServer) {
	    registrarServer = settings.uri.clone();
	    registrarServer.user = null;
	    settings.registrarServer = registrarServer;
	  }
	
	  // User noAnswerTimeout
	  settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
	
	  // Via Host
	  if (settings.hackIpInContact) {
	    if (typeof settings.hackIpInContact === 'boolean') {
	      settings.viaHost = SIP.Utils.getRandomTestNetIP();
	    }
	    else if (typeof settings.hackIpInContact === 'string') {
	      settings.viaHost = settings.hackIpInContact;
	    }
	  }
	
	  // Contact transport parameter
	  if (settings.hackWssInTransport) {
	    settings.contactTransport = 'wss';
	  }
	
	  this.contact = {
	    pub_gruu: null,
	    temp_gruu: null,
	    uri: new SIP.URI('sip', SIP.Utils.createRandomToken(8), settings.viaHost, null, {transport: settings.contactTransport}),
	    toString: function(options){
	      options = options || {};
	
	      var
	        anonymous = options.anonymous || null,
	        outbound = options.outbound || null,
	        contact = '<';
	
	      if (anonymous) {
	        contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport='+settings.contactTransport)).toString();
	      } else {
	        contact += (this.pub_gruu || this.uri).toString();
	      }
	
	      if (outbound) {
	        contact += ';ob';
	      }
	
	      contact += '>';
	
	      return contact;
	    }
	  };
	
	  // media overrides mediaConstraints
	  SIP.Utils.optionsOverride(settings, 'media', 'mediaConstraints', true, this.logger);
	
	  // Fill the value of the configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = settings[parameter];
	  }
	
	  Object.defineProperties(this.configuration, UA.configuration_skeleton);
	
	  // Clean UA.configuration_skeleton
	  for(parameter in settings) {
	    UA.configuration_skeleton[parameter].value = '';
	  }
	
	  this.logger.log('configuration parameters after validation:');
	  for(parameter in settings) {
	    switch(parameter) {
	      case 'uri':
	      case 'registrarServer':
	      case 'mediaHandlerFactory':
	        this.logger.log('· ' + parameter + ': ' + settings[parameter]);
	        break;
	      case 'password':
	        this.logger.log('· ' + parameter + ': ' + 'NOT SHOWN');
	        break;
	      default:
	        this.logger.log('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
	    }
	  }
	
	  return;
	};
	
	/**
	 * Configuration Object skeleton.
	 * @private
	 */
	UA.configuration_skeleton = (function() {
	  var idx,  parameter,
	    skeleton = {},
	    parameters = [
	      // Internal parameters
	      "sipjsId",
	      "hostportParams",
	
	      // Optional user configurable parameters
	      "uri",
	      "wsServers",
	      "authorizationUser",
	      "connectionRecoveryMaxInterval",
	      "connectionRecoveryMinInterval",
	      "keepAliveInterval",
	      "extraSupported",
	      "displayName",
	      "hackViaTcp", // false.
	      "hackIpInContact", //false
	      "hackWssInTransport", //false
	      "hackAllowUnregisteredOptionTags", //false
	      "contactTransport", // 'ws'
	      "forceRport", // false
	      "iceCheckingTimeout",
	      "instanceId",
	      "noAnswerTimeout", // 30 seconds.
	      "password",
	      "registerExpires", // 600 seconds.
	      "registrarServer",
	      "reliable",
	      "rel100",
	      "replaces",
	      "userAgentString", //SIP.C.USER_AGENT
	      "autostart",
	      "stunServers",
	      "traceSip",
	      "turnServers",
	      "usePreloadedRoute",
	      "wsServerMaxReconnection",
	      "wsServerReconnectionTimeout",
	      "mediaHandlerFactory",
	      "media",
	      "mediaConstraints",
	      "authenticationFactory",
	
	      // Post-configuration generated parameters
	      "via_core_value",
	      "viaHost"
	    ];
	
	  for(idx in parameters) {
	    parameter = parameters[idx];
	    skeleton[parameter] = {
	      value: '',
	      writable: false,
	      configurable: false
	    };
	  }
	
	  skeleton['register'] = {
	    value: '',
	    writable: true,
	    configurable: false
	  };
	
	  return skeleton;
	}());
	
	/**
	 * Configuration checker.
	 * @private
	 * @return {Boolean}
	 */
	UA.configuration_check = {
	  mandatory: {
	  },
	
	  optional: {
	
	    uri: function(uri) {
	      var parsed;
	
	      if (!(/^sip:/i).test(uri)) {
	        uri = SIP.C.SIP + ':' + uri;
	      }
	      parsed = SIP.URI.parse(uri);
	
	      if(!parsed) {
	        return;
	      } else if(!parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
	    wsServers: function(wsServers) {
	      var idx, length, url;
	
	      /* Allow defining wsServers parameter as:
	       *  String: "host"
	       *  Array of Strings: ["host1", "host2"]
	       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
	       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
	       */
	      if (typeof wsServers === 'string') {
	        wsServers = [{ws_uri: wsServers}];
	      } else if (wsServers instanceof Array) {
	        length = wsServers.length;
	        for (idx = 0; idx < length; idx++) {
	          if (typeof wsServers[idx] === 'string'){
	            wsServers[idx] = {ws_uri: wsServers[idx]};
	          }
	        }
	      } else {
	        return;
	      }
	
	      if (wsServers.length === 0) {
	        return false;
	      }
	
	      length = wsServers.length;
	      for (idx = 0; idx < length; idx++) {
	        if (!wsServers[idx].ws_uri) {
	          return;
	        }
	        if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {
	          return;
	        }
	
	        url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');
	
	        if(url === -1) {
	          return;
	        } else if(['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {
	          return;
	        } else {
	          wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';
	
	          if (!wsServers[idx].weight) {
	            wsServers[idx].weight = 0;
	          }
	
	          wsServers[idx].status = 0;
	          wsServers[idx].scheme = url.scheme.toUpperCase();
	        }
	      }
	      return wsServers;
	    },
	
	    authorizationUser: function(authorizationUser) {
	      if(SIP.Grammar.parse('"'+ authorizationUser +'"', 'quoted_string') === -1) {
	        return;
	      } else {
	        return authorizationUser;
	      }
	    },
	
	    connectionRecoveryMaxInterval: function(connectionRecoveryMaxInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMaxInterval)) {
	        value = Number(connectionRecoveryMaxInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    connectionRecoveryMinInterval: function(connectionRecoveryMinInterval) {
	      var value;
	      if(SIP.Utils.isDecimal(connectionRecoveryMinInterval)) {
	        value = Number(connectionRecoveryMinInterval);
	        if(value > 0) {
	          return value;
	        }
	      }
	    },
	
	    displayName: function(displayName) {
	      if(SIP.Grammar.parse('"' + displayName + '"', 'displayName') === -1) {
	        return;
	      } else {
	        return displayName;
	      }
	    },
	
	    hackViaTcp: function(hackViaTcp) {
	      if (typeof hackViaTcp === 'boolean') {
	        return hackViaTcp;
	      }
	    },
	
	    hackIpInContact: function(hackIpInContact) {
	      if (typeof hackIpInContact === 'boolean') {
	        return hackIpInContact;
	      }
	      else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {
	        return hackIpInContact;
	      }
	    },
	
	    iceCheckingTimeout: function(iceCheckingTimeout) {
	      if(SIP.Utils.isDecimal(iceCheckingTimeout)) {
	        return Math.max(500, iceCheckingTimeout);
	      }
	    },
	
	    hackWssInTransport: function(hackWssInTransport) {
	      if (typeof hackWssInTransport === 'boolean') {
	        return hackWssInTransport;
	      }
	    },
	
	    hackAllowUnregisteredOptionTags: function(hackAllowUnregisteredOptionTags) {
	      if (typeof hackAllowUnregisteredOptionTags === 'boolean') {
	        return hackAllowUnregisteredOptionTags;
	      }
	    },
	
	    contactTransport: function(contactTransport) {
	      if (typeof contactTransport === 'string') {
	        return contactTransport;
	      }
	    },
	
	    forceRport: function(forceRport) {
	      if (typeof forceRport === 'boolean') {
	        return forceRport;
	      }
	    },
	
	    instanceId: function(instanceId) {
	      if(typeof instanceId !== 'string') {
	        return;
	      }
	
	      if ((/^uuid:/i.test(instanceId))) {
	        instanceId = instanceId.substr(5);
	      }
	
	      if(SIP.Grammar.parse(instanceId, 'uuid') === -1) {
	        return;
	      } else {
	        return instanceId;
	      }
	    },
	
	    keepAliveInterval: function(keepAliveInterval) {
	      var value;
	      if (SIP.Utils.isDecimal(keepAliveInterval)) {
	        value = Number(keepAliveInterval);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    extraSupported: function(optionTags) {
	      var idx, length;
	
	      if (!(optionTags instanceof Array)) {
	        return;
	      }
	
	      length = optionTags.length;
	      for (idx = 0; idx < length; idx++) {
	        if (typeof optionTags[idx] !== 'string') {
	          return;
	        }
	      }
	
	      return optionTags;
	    },
	
	    noAnswerTimeout: function(noAnswerTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(noAnswerTimeout)) {
	        value = Number(noAnswerTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    password: function(password) {
	      return String(password);
	    },
	
	    rel100: function(rel100) {
	      if(rel100 === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (rel100 === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    replaces: function(replaces) {
	      if(replaces === SIP.C.supported.REQUIRED) {
	        return SIP.C.supported.REQUIRED;
	      } else if (replaces === SIP.C.supported.SUPPORTED) {
	        return SIP.C.supported.SUPPORTED;
	      } else  {
	        return SIP.C.supported.UNSUPPORTED;
	      }
	    },
	
	    register: function(register) {
	      if (typeof register === 'boolean') {
	        return register;
	      }
	    },
	
	    registerExpires: function(registerExpires) {
	      var value;
	      if (SIP.Utils.isDecimal(registerExpires)) {
	        value = Number(registerExpires);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    registrarServer: function(registrarServer) {
	      var parsed;
	
	      if(typeof registrarServer !== 'string') {
	        return;
	      }
	
	      if (!/^sip:/i.test(registrarServer)) {
	        registrarServer = SIP.C.SIP + ':' + registrarServer;
	      }
	      parsed = SIP.URI.parse(registrarServer);
	
	      if(!parsed) {
	        return;
	      } else if(parsed.user) {
	        return;
	      } else {
	        return parsed;
	      }
	    },
	
	    stunServers: function(stunServers) {
	      var idx, length, stun_server;
	
	      if (typeof stunServers === 'string') {
	        stunServers = [stunServers];
	      } else if (!(stunServers instanceof Array)) {
	        return;
	      }
	
	      length = stunServers.length;
	      for (idx = 0; idx < length; idx++) {
	        stun_server = stunServers[idx];
	        if (!(/^stuns?:/.test(stun_server))) {
	          stun_server = 'stun:' + stun_server;
	        }
	
	        if(SIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
	          return;
	        } else {
	          stunServers[idx] = stun_server;
	        }
	      }
	      return stunServers;
	    },
	
	    traceSip: function(traceSip) {
	      if (typeof traceSip === 'boolean') {
	        return traceSip;
	      }
	    },
	
	    turnServers: function(turnServers) {
	      var idx, jdx, length, turn_server, num_turn_server_urls, url;
	
	      if (turnServers instanceof Array) {
	        // Do nothing
	      } else {
	        turnServers = [turnServers];
	      }
	
	      length = turnServers.length;
	      for (idx = 0; idx < length; idx++) {
	        turn_server = turnServers[idx];
	        //Backwards compatibility: Allow defining the turn_server url with the 'server' property.
	        if (turn_server.server) {
	          turn_server.urls = [turn_server.server];
	        }
	
	        if (!turn_server.urls || !turn_server.username || !turn_server.password) {
	          return;
	        }
	
	        if (turn_server.urls instanceof Array) {
	          num_turn_server_urls = turn_server.urls.length;
	        } else {
	          turn_server.urls = [turn_server.urls];
	          num_turn_server_urls = 1;
	        }
	
	        for (jdx = 0; jdx < num_turn_server_urls; jdx++) {
	          url = turn_server.urls[jdx];
	
	          if (!(/^turns?:/.test(url))) {
	            url = 'turn:' + url;
	          }
	
	          if(SIP.Grammar.parse(url, 'turn_URI') === -1) {
	            return;
	          }
	        }
	      }
	      return turnServers;
	    },
	
	    userAgentString: function(userAgentString) {
	      if (typeof userAgentString === 'string') {
	        return userAgentString;
	      }
	    },
	
	    usePreloadedRoute: function(usePreloadedRoute) {
	      if (typeof usePreloadedRoute === 'boolean') {
	        return usePreloadedRoute;
	      }
	    },
	
	    wsServerMaxReconnection: function(wsServerMaxReconnection) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerMaxReconnection)) {
	        value = Number(wsServerMaxReconnection);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    wsServerReconnectionTimeout: function(wsServerReconnectionTimeout) {
	      var value;
	      if (SIP.Utils.isDecimal(wsServerReconnectionTimeout)) {
	        value = Number(wsServerReconnectionTimeout);
	        if (value > 0) {
	          return value;
	        }
	      }
	    },
	
	    autostart: function(autostart) {
	      if (typeof autostart === 'boolean') {
	        return autostart;
	      }
	    },
	
	    mediaHandlerFactory: function(mediaHandlerFactory) {
	      if (mediaHandlerFactory instanceof Function) {
	        var promisifiedFactory = function promisifiedFactory () {
	          var mediaHandler = mediaHandlerFactory.apply(this, arguments);
	
	          function patchMethod (methodName) {
	            var method = mediaHandler[methodName];
	            if (method.length > 1) {
	              var callbacksFirst = methodName === 'getDescription';
	              mediaHandler[methodName] = SIP.Utils.promisify(mediaHandler, methodName, callbacksFirst);
	            }
	          }
	
	          patchMethod('getDescription');
	          patchMethod('setDescription');
	
	          return mediaHandler;
	        };
	
	        promisifiedFactory.isSupported = mediaHandlerFactory.isSupported;
	        return promisifiedFactory;
	      }
	    },
	
	    authenticationFactory: checkAuthenticationFactory
	  }
	};
	
	UA.C = C;
	SIP.UA = UA;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Hacks - This file contains all of the things we
	 * wish we didn't have to do, just for interop.  It is similar to
	 * Utils, which provides actually useful and relevant functions for
	 * a SIP library. Methods in this file are grouped by vendor, so
	 * as to most easily track when particular hacks may not be necessary anymore.
	 */
	
	module.exports = function (SIP) {
	
	//keep to quiet jshint, and remain consistent with other files
	SIP = SIP;
	
	var Hacks = {
	  AllBrowsers: {
	    maskDtls: function (message) {
	      if (message.body) {
	        message.body = message.body.replace(/ UDP\/TLS\/RTP\/SAVP/gmi, " RTP/SAVP");
	      }
	    },
	    unmaskDtls: function (sdp) {
	      /**
	       * Chrome does not handle DTLS correctly (Canaray does, but not production)
	       * keeping Chrome as SDES until DTLS is fixed (comment out 'is_opera' condition)
	       *
	       * UPDATE: May 21, 2014
	       * Chrome 35 now properly defaults to DTLS.  Only Opera remains using SDES
	       *
	       * UPDATE: 2014-09-24
	       * Opera now supports DTLS by default as well.
	       *
	       **/
	      return sdp.replace(/ RTP\/SAVP/gmi, " UDP/TLS/RTP/SAVP");
	    }
	  },
	  Firefox: {
	    /* Condition to detect if hacks are applicable */
	    isFirefox: function () {
	      return typeof mozRTCPeerConnection !== 'undefined';
	    },
	
	    cannotHandleExtraWhitespace: function (message) {
	      if (this.isFirefox() && message.body) {
	        message.body = message.body.replace(/ \r\n/g, "\r\n");
	      }
	    },
	
	    hasMissingCLineInSDP: function (sdp) {
	      /*
	       * This is a Firefox hack to insert valid sdp when getDescription is
	       * called with the constraint offerToReceiveVideo = false.
	       * We search for either a c-line at the top of the sdp above all
	       * m-lines. If that does not exist then we search for a c-line
	       * beneath each m-line. If it is missing a c-line, we insert
	       * a fake c-line with the ip address 0.0.0.0. This is then valid
	       * sdp and no media will be sent for that m-line.
	       *
	       * Valid SDP is:
	       * m=
	       * i=
	       * c=
	       */
	      var insertAt, mlines;
	      if (sdp.indexOf('c=') > sdp.indexOf('m=')) {
	
	        // Find all m= lines
	        mlines = sdp.match(/m=.*\r\n.*/g);
	        for (var i=0; i<mlines.length; i++) {
	
	          // If it has an i= line, check if the next line is the c= line
	          if (mlines[i].toString().search(/i=.*/) >= 0) {
	            insertAt = sdp.indexOf(mlines[i].toString())+mlines[i].toString().length;
	            if (sdp.substr(insertAt,2)!=='c=') {
	              sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	            }
	
	          // else add the C line if it's missing
	          } else if (mlines[i].toString().search(/c=.*/) < 0) {
	            insertAt = sdp.indexOf(mlines[i].toString().match(/.*/))+mlines[i].toString().match(/.*/).toString().length;
	            sdp = sdp.substr(0,insertAt) + '\r\nc=IN IP4 0.0.0.0' + sdp.substr(insertAt);
	          }
	        }
	      }
	      return sdp;
	    },
	  },
	
	  Chrome: {
	    needsExplicitlyInactiveSDP: function (sdp) {
	      var sub, index;
	
	      if (Hacks.Firefox.isFirefox()) { // Fix this in Firefox before sending
	        index = sdp.indexOf('m=video 0');
	        if (index !== -1) {
	          sub = sdp.substr(index);
	          sub = sub.replace(/\r\nc=IN IP4.*\r\n$/,
	                            '\r\nc=IN IP4 0.0.0.0\r\na=inactive\r\n');
	          return sdp.substr(0, index) + sub;
	        }
	      }
	      return sdp;
	    },
	
	    getsConfusedAboutGUM: function (session) {
	      if (session.mediaHandler) {
	        session.mediaHandler.close();
	      }
	    }
	  }
	};
	return Hacks;
	};

/***/ },
/* 241 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Incoming SIP Message Sanity Check
	 */
	
	/**
	 * SIP message sanity check.
	 * @augments SIP
	 * @function
	 * @param {SIP.IncomingMessage} message
	 * @param {SIP.UA} ua
	 * @param {SIP.Transport} transport
	 * @returns {Boolean}
	 */
	module.exports = function (SIP) {
	var sanityCheck,
	 logger,
	 message, ua, transport,
	 requests = [],
	 responses = [],
	 all = [];
	
	// Reply
	function reply(status_code) {
	  var to,
	    response = SIP.Utils.buildStatusLine(status_code),
	    vias = message.getHeaders('via'),
	    length = vias.length,
	    idx = 0;
	
	  for(idx; idx < length; idx++) {
	    response += "Via: " + vias[idx] + "\r\n";
	  }
	
	  to = message.getHeader('To');
	
	  if(!message.to_tag) {
	    to += ';tag=' + SIP.Utils.newTag();
	  }
	
	  response += "To: " + to + "\r\n";
	  response += "From: " + message.getHeader('From') + "\r\n";
	  response += "Call-ID: " + message.call_id + "\r\n";
	  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
	  response += "\r\n";
	
	  transport.send(response);
	}
	
	/*
	 * Sanity Check for incoming Messages
	 *
	 * Requests:
	 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
	 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
	 *   Does not look at via sent-by but at sipjsId, which is inserted as
	 *   a prefix in all initial requests generated by the ua
	 *  - _rfc3261_18_3_request_ Body Content-Length
	 *  - _rfc3261_8_2_2_2_ Merged Requests
	 *
	 * Responses:
	 *  - _rfc3261_8_1_3_3_ Multiple Via headers
	 *  - _rfc3261_18_1_2_ sent-by mismatch
	 *  - _rfc3261_18_3_response_ Body Content-Length
	 *
	 * All:
	 *  - Minimum headers in a SIP message
	 */
	
	// Sanity Check functions for requests
	function rfc3261_8_2_2_1() {
	  if(!message.ruri || message.ruri.scheme !== 'sip') {
	    reply(416);
	    return false;
	  }
	}
	
	function rfc3261_16_3_4() {
	  if(!message.to_tag) {
	    if(message.call_id.substr(0, 5) === ua.configuration.sipjsId) {
	      reply(482);
	      return false;
	    }
	  }
	}
	
	function rfc3261_18_3_request() {
	  var len = SIP.Utils.str_utf8_length(message.body),
	  contentLength = message.getHeader('content-length');
	
	  if(len < contentLength) {
	    reply(400);
	    return false;
	  }
	}
	
	function rfc3261_8_2_2_2() {
	  var tr, idx,
	    fromTag = message.from_tag,
	    call_id = message.call_id,
	    cseq = message.cseq;
	
	  if(!message.to_tag) {
	    if(message.method === SIP.C.INVITE) {
	      tr = ua.transactions.ist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.ist) {
	          tr = ua.transactions.ist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    } else {
	      tr = ua.transactions.nist[message.via_branch];
	      if(tr) {
	        return;
	      } else {
	        for(idx in ua.transactions.nist) {
	          tr = ua.transactions.nist[idx];
	          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
	            reply(482);
	            return false;
	          }
	        }
	      }
	    }
	  }
	}
	
	// Sanity Check functions for responses
	function rfc3261_8_1_3_3() {
	  if(message.getHeaders('via').length > 1) {
	    logger.warn('More than one Via header field present in the response. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_1_2() {
	  var viaHost = ua.configuration.viaHost;
	  if(message.via.host !== viaHost || message.via.port !== undefined) {
	    logger.warn('Via sent-by in the response does not match UA Via host value. Dropping the response');
	    return false;
	  }
	}
	
	function rfc3261_18_3_response() {
	  var
	    len = SIP.Utils.str_utf8_length(message.body),
	    contentLength = message.getHeader('content-length');
	
	    if(len < contentLength) {
	      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
	      return false;
	    }
	}
	
	// Sanity Check functions for requests and responses
	function minimumHeaders() {
	  var
	    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
	    idx = mandatoryHeaders.length;
	
	  while(idx--) {
	    if(!message.hasHeader(mandatoryHeaders[idx])) {
	      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
	      return false;
	    }
	  }
	}
	
	requests.push(rfc3261_8_2_2_1);
	requests.push(rfc3261_16_3_4);
	requests.push(rfc3261_18_3_request);
	requests.push(rfc3261_8_2_2_2);
	
	responses.push(rfc3261_8_1_3_3);
	responses.push(rfc3261_18_1_2);
	responses.push(rfc3261_18_3_response);
	
	all.push(minimumHeaders);
	
	sanityCheck = function(m, u, t) {
	  var len, pass;
	
	  message = m;
	  ua = u;
	  transport = t;
	
	  logger = ua.getLogger('sip.sanitycheck');
	
	  len = all.length;
	  while(len--) {
	    pass = all[len](message);
	    if(pass === false) {
	      return false;
	    }
	  }
	
	  if(message instanceof SIP.IncomingRequest) {
	    len = requests.length;
	    while(len--) {
	      pass = requests[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  else if(message instanceof SIP.IncomingResponse) {
	    len = responses.length;
	    while(len--) {
	      pass = responses[len](message);
	      if(pass === false) {
	        return false;
	      }
	    }
	  }
	
	  //Everything is OK
	  return true;
	};
	
	SIP.sanityCheck = sanityCheck;
	};


/***/ },
/* 242 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * @fileoverview SIP Digest Authentication
	 */
	
	/**
	 * SIP Digest Authentication.
	 * @augments SIP.
	 * @function Digest Authentication
	 * @param {SIP.UA} ua
	 */
	module.exports = function (Utils) {
	var DigestAuthentication;
	
	DigestAuthentication = function(ua) {
	  this.logger = ua.getLogger('sipjs.digestauthentication');
	  this.username = ua.configuration.authorizationUser;
	  this.password = ua.configuration.password;
	  this.cnonce = null;
	  this.nc = 0;
	  this.ncHex = '00000000';
	  this.response = null;
	};
	
	
	/**
	* Performs Digest authentication given a SIP request and the challenge
	* received in a response to that request.
	* Returns true if credentials were successfully generated, false otherwise.
	*
	* @param {SIP.OutgoingRequest} request
	* @param {Object} challenge
	*/
	DigestAuthentication.prototype.authenticate = function(request, challenge) {
	  // Inspect and validate the challenge.
	
	  this.algorithm = challenge.algorithm;
	  this.realm = challenge.realm;
	  this.nonce = challenge.nonce;
	  this.opaque = challenge.opaque;
	  this.stale = challenge.stale;
	
	  if (this.algorithm) {
	    if (this.algorithm !== 'MD5') {
	      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
	      return false;
	    }
	  } else {
	    this.algorithm = 'MD5';
	  }
	
	  if (! this.realm) {
	    this.logger.warn('challenge without Digest realm, authentication aborted');
	    return false;
	  }
	
	  if (! this.nonce) {
	    this.logger.warn('challenge without Digest nonce, authentication aborted');
	    return false;
	  }
	
	  // 'qop' can contain a list of values (Array). Let's choose just one.
	  if (challenge.qop) {
	    if (challenge.qop.indexOf('auth') > -1) {
	      this.qop = 'auth';
	    } else if (challenge.qop.indexOf('auth-int') > -1) {
	      this.qop = 'auth-int';
	    } else {
	      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
	      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
	      return false;
	    }
	  } else {
	    this.qop = null;
	  }
	
	  // Fill other attributes.
	
	  this.method = request.method;
	  this.uri = request.ruri;
	  this.cnonce = Utils.createRandomToken(12);
	  this.nc += 1;
	  this.updateNcHex();
	
	  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
	  if (this.nc === 4294967296) {
	    this.nc = 1;
	    this.ncHex = '00000001';
	  }
	
	  // Calculate the Digest "response" value.
	  this.calculateResponse();
	
	  return true;
	};
	
	
	/**
	* Generate Digest 'response' value.
	* @private
	*/
	DigestAuthentication.prototype.calculateResponse = function() {
	  var ha1, ha2;
	
	  // HA1 = MD5(A1) = MD5(username:realm:password)
	  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);
	
	  if (this.qop === 'auth') {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
	
	  } else if (this.qop === 'auth-int') {
	    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
	    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
	
	  } else if (this.qop === null) {
	    // HA2 = MD5(A2) = MD5(method:digestURI)
	    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
	    // response = MD5(HA1:nonce:HA2)
	    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
	  }
	};
	
	
	/**
	* Return the Proxy-Authorization or WWW-Authorization header value.
	*/
	DigestAuthentication.prototype.toString = function() {
	  var auth_params = [];
	
	  if (! this.response) {
	    throw new Error('response field does not exist, cannot generate Authorization header');
	  }
	
	  auth_params.push('algorithm=' + this.algorithm);
	  auth_params.push('username="' + this.username + '"');
	  auth_params.push('realm="' + this.realm + '"');
	  auth_params.push('nonce="' + this.nonce + '"');
	  auth_params.push('uri="' + this.uri + '"');
	  auth_params.push('response="' + this.response + '"');
	  if (this.opaque) {
	    auth_params.push('opaque="' + this.opaque + '"');
	  }
	  if (this.qop) {
	    auth_params.push('qop=' + this.qop);
	    auth_params.push('cnonce="' + this.cnonce + '"');
	    auth_params.push('nc=' + this.ncHex);
	  }
	
	  return 'Digest ' + auth_params.join(', ');
	};
	
	
	/**
	* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
	* @private
	*/
	DigestAuthentication.prototype.updateNcHex = function() {
	  var hex = Number(this.nc).toString(16);
	  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
	};
	
	return DigestAuthentication;
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Grammar = __webpack_require__(244);
	
	module.exports = function (SIP) {
	
	return {
	  parse: function parseCustom (input, startRule) {
	    var options = {startRule: startRule, SIP: SIP};
	    try {
	      Grammar.parse(input, options);
	    } catch (e) {
	      options.data = -1;
	    }
	    return options.data;
	  }
	};
	
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	module.exports = (function() {
	  /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.majda.cz/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function SyntaxError(message, expected, found, offset, line, column) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.offset   = offset;
	    this.line     = line;
	    this.column   = column;
	
	    this.name     = "SyntaxError";
	  }
	
	  peg$subclass(SyntaxError, Error);
	
	  function parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	
	        peg$FAILED = {},
	
	        peg$startRuleIndices = { Contact: 118, Name_Addr_Header: 155, Record_Route: 175, Request_Response: 81, SIP_URI: 45, Subscription_State: 185, Supported: 190, Require: 181, Via: 193, absoluteURI: 84, Call_ID: 117, Content_Disposition: 129, Content_Length: 134, Content_Type: 135, CSeq: 145, displayName: 121, Event: 148, From: 150, host: 52, Max_Forwards: 153, Min_SE: 212, Proxy_Authenticate: 156, quoted_string: 40, Refer_To: 177, Replaces: 178, Session_Expires: 209, stun_URI: 216, To: 191, turn_URI: 223, uuid: 226, WWW_Authenticate: 208, challenge: 157 },
	        peg$startRuleIndex   = 118,
	
	        peg$consts = [
	          "\r\n",
	          { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	          /^[0-9]/,
	          { type: "class", value: "[0-9]", description: "[0-9]" },
	          /^[a-zA-Z]/,
	          { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
	          /^[0-9a-fA-F]/,
	          { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	          /^[\0-\xFF]/,
	          { type: "class", value: "[\\0-\\xFF]", description: "[\\0-\\xFF]" },
	          /^["]/,
	          { type: "class", value: "[\"]", description: "[\"]" },
	          " ",
	          { type: "literal", value: " ", description: "\" \"" },
	          "\t",
	          { type: "literal", value: "\t", description: "\"\\t\"" },
	          /^[a-zA-Z0-9]/,
	          { type: "class", value: "[a-zA-Z0-9]", description: "[a-zA-Z0-9]" },
	          ";",
	          { type: "literal", value: ";", description: "\";\"" },
	          "/",
	          { type: "literal", value: "/", description: "\"/\"" },
	          "?",
	          { type: "literal", value: "?", description: "\"?\"" },
	          ":",
	          { type: "literal", value: ":", description: "\":\"" },
	          "@",
	          { type: "literal", value: "@", description: "\"@\"" },
	          "&",
	          { type: "literal", value: "&", description: "\"&\"" },
	          "=",
	          { type: "literal", value: "=", description: "\"=\"" },
	          "+",
	          { type: "literal", value: "+", description: "\"+\"" },
	          "$",
	          { type: "literal", value: "$", description: "\"$\"" },
	          ",",
	          { type: "literal", value: ",", description: "\",\"" },
	          "-",
	          { type: "literal", value: "-", description: "\"-\"" },
	          "_",
	          { type: "literal", value: "_", description: "\"_\"" },
	          ".",
	          { type: "literal", value: ".", description: "\".\"" },
	          "!",
	          { type: "literal", value: "!", description: "\"!\"" },
	          "~",
	          { type: "literal", value: "~", description: "\"~\"" },
	          "*",
	          { type: "literal", value: "*", description: "\"*\"" },
	          "'",
	          { type: "literal", value: "'", description: "\"'\"" },
	          "(",
	          { type: "literal", value: "(", description: "\"(\"" },
	          ")",
	          { type: "literal", value: ")", description: "\")\"" },
	          peg$FAILED,
	          "%",
	          { type: "literal", value: "%", description: "\"%\"" },
	          null,
	          [],
	          function() {return " "; },
	          function() {return ':'; },
	          /^[!-~]/,
	          { type: "class", value: "[!-~]", description: "[!-~]" },
	          /^[\x80-\uFFFF]/,
	          { type: "class", value: "[\\x80-\\uFFFF]", description: "[\\x80-\\uFFFF]" },
	          /^[\x80-\xBF]/,
	          { type: "class", value: "[\\x80-\\xBF]", description: "[\\x80-\\xBF]" },
	          /^[a-f]/,
	          { type: "class", value: "[a-f]", description: "[a-f]" },
	          "`",
	          { type: "literal", value: "`", description: "\"`\"" },
	          "<",
	          { type: "literal", value: "<", description: "\"<\"" },
	          ">",
	          { type: "literal", value: ">", description: "\">\"" },
	          "\\",
	          { type: "literal", value: "\\", description: "\"\\\\\"" },
	          "[",
	          { type: "literal", value: "[", description: "\"[\"" },
	          "]",
	          { type: "literal", value: "]", description: "\"]\"" },
	          "{",
	          { type: "literal", value: "{", description: "\"{\"" },
	          "}",
	          { type: "literal", value: "}", description: "\"}\"" },
	          function() {return "*"; },
	          function() {return "/"; },
	          function() {return "="; },
	          function() {return "("; },
	          function() {return ")"; },
	          function() {return ">"; },
	          function() {return "<"; },
	          function() {return ","; },
	          function() {return ";"; },
	          function() {return ":"; },
	          function() {return "\""; },
	          /^[!-']/,
	          { type: "class", value: "[!-']", description: "[!-']" },
	          /^[*-[]/,
	          { type: "class", value: "[*-[]", description: "[*-[]" },
	          /^[\]-~]/,
	          { type: "class", value: "[\\]-~]", description: "[\\]-~]" },
	          function(contents) {
	                                  return contents; },
	          /^[#-[]/,
	          { type: "class", value: "[#-[]", description: "[#-[]" },
	          /^[\0-\t]/,
	          { type: "class", value: "[\\0-\\t]", description: "[\\0-\\t]" },
	          /^[\x0B-\f]/,
	          { type: "class", value: "[\\x0B-\\f]", description: "[\\x0B-\\f]" },
	          /^[\x0E-]/,
	          { type: "class", value: "[\\x0E-]", description: "[\\x0E-]" },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                },
	          function() {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	
	                                  if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}
	                                },
	          "sips",
	          { type: "literal", value: "sips", description: "\"sips\"" },
	          "sip",
	          { type: "literal", value: "sip", description: "\"sip\"" },
	          function(uri_scheme) {
	                              options.data.scheme = uri_scheme; },
	          function() {
	                              options.data.user = decodeURIComponent(text().slice(0, -1));},
	          function() {
	                              options.data.password = text(); },
	          function() {
	                              options.data.host = text();
	                              return options.data.host; },
	          function() {
	                            options.data.host_type = 'domain';
	                            return text(); },
	          /^[a-zA-Z0-9_\-]/,
	          { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
	          /^[a-zA-Z0-9\-]/,
	          { type: "class", value: "[a-zA-Z0-9\\-]", description: "[a-zA-Z0-9\\-]" },
	          function() {
	                              options.data.host_type = 'IPv6';
	                              return text(); },
	          "::",
	          { type: "literal", value: "::", description: "\"::\"" },
	          function() {
	                            options.data.host_type = 'IPv6';
	                            return text(); },
	          function() {
	                              options.data.host_type = 'IPv4';
	                              return text(); },
	          "25",
	          { type: "literal", value: "25", description: "\"25\"" },
	          /^[0-5]/,
	          { type: "class", value: "[0-5]", description: "[0-5]" },
	          "2",
	          { type: "literal", value: "2", description: "\"2\"" },
	          /^[0-4]/,
	          { type: "class", value: "[0-4]", description: "[0-4]" },
	          "1",
	          { type: "literal", value: "1", description: "\"1\"" },
	          /^[1-9]/,
	          { type: "class", value: "[1-9]", description: "[1-9]" },
	          function(port) {
	                              port = parseInt(port.join(''));
	                              options.data.port = port;
	                              return port; },
	          "transport=",
	          { type: "literal", value: "transport=", description: "\"transport=\"" },
	          "udp",
	          { type: "literal", value: "udp", description: "\"udp\"" },
	          "tcp",
	          { type: "literal", value: "tcp", description: "\"tcp\"" },
	          "sctp",
	          { type: "literal", value: "sctp", description: "\"sctp\"" },
	          "tls",
	          { type: "literal", value: "tls", description: "\"tls\"" },
	          function(transport) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['transport'] = transport.toLowerCase(); },
	          "user=",
	          { type: "literal", value: "user=", description: "\"user=\"" },
	          "phone",
	          { type: "literal", value: "phone", description: "\"phone\"" },
	          "ip",
	          { type: "literal", value: "ip", description: "\"ip\"" },
	          function(user) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['user'] = user.toLowerCase(); },
	          "method=",
	          { type: "literal", value: "method=", description: "\"method=\"" },
	          function(method) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['method'] = method; },
	          "ttl=",
	          { type: "literal", value: "ttl=", description: "\"ttl=\"" },
	          function(ttl) {
	                                if(!options.data.params) options.data.params={};
	                                options.data.params['ttl'] = ttl; },
	          "maddr=",
	          { type: "literal", value: "maddr=", description: "\"maddr=\"" },
	          function(maddr) {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['maddr'] = maddr; },
	          "lr",
	          { type: "literal", value: "lr", description: "\"lr\"" },
	          function() {
	                                if(!options.data.uri_params) options.data.uri_params={};
	                                options.data.uri_params['lr'] = undefined; },
	          function(param, value) {
	                                if(!options.data.uri_params) options.data.uri_params = {};
	                                if (value === null){
	                                  value = undefined;
	                                }
	                                else {
	                                  value = value[1];
	                                }
	                                options.data.uri_params[param.toLowerCase()] = value && value.toLowerCase();},
	          function(hname, hvalue) {
	                                hname = hname.join('').toLowerCase();
	                                hvalue = hvalue.join('');
	                                if(!options.data.uri_headers) options.data.uri_headers = {};
	                                if (!options.data.uri_headers[hname]) {
	                                  options.data.uri_headers[hname] = [hvalue];
	                                } else {
	                                  options.data.uri_headers[hname].push(hvalue);
	                                }},
	          function() {
	                                // lots of tests fail if this isn't guarded...
	                                if (options.startRule === 'Refer_To') {
	                                  options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	                                  delete options.data.scheme;
	                                  delete options.data.user;
	                                  delete options.data.host;
	                                  delete options.data.host_type;
	                                  delete options.data.port;
	                                  delete options.data.uri_params;
	                                }
	                              },
	          "//",
	          { type: "literal", value: "//", description: "\"//\"" },
	          function() {
	                              options.data.scheme= text(); },
	          { type: "literal", value: "SIP", description: "\"SIP\"" },
	          function() {
	                              options.data.sip_version = text(); },
	          "INVITE",
	          { type: "literal", value: "INVITE", description: "\"INVITE\"" },
	          "ACK",
	          { type: "literal", value: "ACK", description: "\"ACK\"" },
	          "VXACH",
	          { type: "literal", value: "VXACH", description: "\"VXACH\"" },
	          "OPTIONS",
	          { type: "literal", value: "OPTIONS", description: "\"OPTIONS\"" },
	          "BYE",
	          { type: "literal", value: "BYE", description: "\"BYE\"" },
	          "CANCEL",
	          { type: "literal", value: "CANCEL", description: "\"CANCEL\"" },
	          "REGISTER",
	          { type: "literal", value: "REGISTER", description: "\"REGISTER\"" },
	          "SUBSCRIBE",
	          { type: "literal", value: "SUBSCRIBE", description: "\"SUBSCRIBE\"" },
	          "NOTIFY",
	          { type: "literal", value: "NOTIFY", description: "\"NOTIFY\"" },
	          "REFER",
	          { type: "literal", value: "REFER", description: "\"REFER\"" },
	          function() {
	
	                              options.data.method = text();
	                              return options.data.method; },
	          function(status_code) {
	                            options.data.status_code = parseInt(status_code.join('')); },
	          function() {
	                            options.data.reason_phrase = text(); },
	          function() {
	                        options.data = text(); },
	          function() {
	                                  var idx, length;
	                                  length = options.data.multi_header.length;
	                                  for (idx = 0; idx < length; idx++) {
	                                    if (options.data.multi_header[idx].parsed === null) {
	                                      options.data = null;
	                                      break;
	                                    }
	                                  }
	                                  if (options.data !== null) {
	                                    options.data = options.data.multi_header;
	                                  } else {
	                                    options.data = -1;
	                                  }},
	          function() {
	                                  var header;
	                                  if(!options.data.multi_header) options.data.multi_header = [];
	                                  try {
	                                    header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                    delete options.data.uri;
	                                    delete options.data.displayName;
	                                    delete options.data.params;
	                                  } catch(e) {
	                                    header = null;
	                                  }
	                                  options.data.multi_header.push( { 'position': peg$currPos,
	                                                            'offset': offset(),
	                                                            'parsed': header
	                                                          });},
	          function(displayName) {
	                                  displayName = text().trim();
	                                  if (displayName[0] === '\"') {
	                                    displayName = displayName.substring(1, displayName.length-1);
	                                  }
	                                  options.data.displayName = displayName; },
	          "q",
	          { type: "literal", value: "q", description: "\"q\"" },
	          function(q) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['q'] = q; },
	          "expires",
	          { type: "literal", value: "expires", description: "\"expires\"" },
	          function(expires) {
	                                  if(!options.data.params) options.data.params = {};
	                                  options.data.params['expires'] = expires; },
	          function(delta_seconds) {
	                                  return parseInt(delta_seconds.join('')); },
	          "0",
	          { type: "literal", value: "0", description: "\"0\"" },
	          function() {
	                                  return parseFloat(text()); },
	          function(param, value) {
	                                  if(!options.data.params) options.data.params = {};
	                                  if (value === null){
	                                    value = undefined;
	                                  }
	                                  else {
	                                    value = value[1];
	                                  }
	                                  options.data.params[param.toLowerCase()] = value;},
	          "render",
	          { type: "literal", value: "render", description: "\"render\"" },
	          "session",
	          { type: "literal", value: "session", description: "\"session\"" },
	          "icon",
	          { type: "literal", value: "icon", description: "\"icon\"" },
	          "alert",
	          { type: "literal", value: "alert", description: "\"alert\"" },
	          function() {
	                                      if (options.startRule === 'Content_Disposition') {
	                                        options.data.type = text().toLowerCase();
	                                      }
	                                    },
	          "handling",
	          { type: "literal", value: "handling", description: "\"handling\"" },
	          "optional",
	          { type: "literal", value: "optional", description: "\"optional\"" },
	          "required",
	          { type: "literal", value: "required", description: "\"required\"" },
	          function(length) {
	                                  options.data = parseInt(length.join('')); },
	          function() {
	                                  options.data = text(); },
	          "text",
	          { type: "literal", value: "text", description: "\"text\"" },
	          "image",
	          { type: "literal", value: "image", description: "\"image\"" },
	          "audio",
	          { type: "literal", value: "audio", description: "\"audio\"" },
	          "video",
	          { type: "literal", value: "video", description: "\"video\"" },
	          "application",
	          { type: "literal", value: "application", description: "\"application\"" },
	          "message",
	          { type: "literal", value: "message", description: "\"message\"" },
	          "multipart",
	          { type: "literal", value: "multipart", description: "\"multipart\"" },
	          "x-",
	          { type: "literal", value: "x-", description: "\"x-\"" },
	          function(cseq_value) {
	                            options.data.value=parseInt(cseq_value.join('')); },
	          function(expires) {options.data = expires; },
	          function(event_type) {
	                                 options.data.event = event_type.toLowerCase(); },
	          function() {
	                          var tag = options.data.tag;
	                            options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                            if (tag) {options.data.setParam('tag',tag)}
	                          },
	          "tag",
	          { type: "literal", value: "tag", description: "\"tag\"" },
	          function(tag) {options.data.tag = tag; },
	          function(forwards) {
	                            options.data = parseInt(forwards.join('')); },
	          function(min_expires) {options.data = min_expires; },
	          function() {
	                                  options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                                },
	          "digest",
	          { type: "literal", value: "Digest", description: "\"Digest\"" },
	          "realm",
	          { type: "literal", value: "realm", description: "\"realm\"" },
	          function(realm) { options.data.realm = realm; },
	          "domain",
	          { type: "literal", value: "domain", description: "\"domain\"" },
	          "nonce",
	          { type: "literal", value: "nonce", description: "\"nonce\"" },
	          function(nonce) { options.data.nonce=nonce; },
	          "opaque",
	          { type: "literal", value: "opaque", description: "\"opaque\"" },
	          function(opaque) { options.data.opaque=opaque; },
	          "stale",
	          { type: "literal", value: "stale", description: "\"stale\"" },
	          "true",
	          { type: "literal", value: "true", description: "\"true\"" },
	          function() { options.data.stale=true; },
	          "false",
	          { type: "literal", value: "false", description: "\"false\"" },
	          function() { options.data.stale=false; },
	          "algorithm",
	          { type: "literal", value: "algorithm", description: "\"algorithm\"" },
	          "md5",
	          { type: "literal", value: "MD5", description: "\"MD5\"" },
	          "md5-sess",
	          { type: "literal", value: "MD5-sess", description: "\"MD5-sess\"" },
	          function(algorithm) {
	                                options.data.algorithm=algorithm.toUpperCase(); },
	          "qop",
	          { type: "literal", value: "qop", description: "\"qop\"" },
	          "auth-int",
	          { type: "literal", value: "auth-int", description: "\"auth-int\"" },
	          "auth",
	          { type: "literal", value: "auth", description: "\"auth\"" },
	          function(qop_value) {
	                                  options.data.qop || (options.data.qop=[]);
	                                  options.data.qop.push(qop_value.toLowerCase()); },
	          function(rack_value) {
	                            options.data.value=parseInt(rack_value.join('')); },
	          function() {
	                            var idx, length;
	                            length = options.data.multi_header.length;
	                            for (idx = 0; idx < length; idx++) {
	                              if (options.data.multi_header[idx].parsed === null) {
	                                options.data = null;
	                                break;
	                              }
	                            }
	                            if (options.data !== null) {
	                              options.data = options.data.multi_header;
	                            } else {
	                              options.data = -1;
	                            }},
	          function() {
	                            var header;
	                            if(!options.data.multi_header) options.data.multi_header = [];
	                            try {
	                              header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                              delete options.data.uri;
	                              delete options.data.displayName;
	                              delete options.data.params;
	                            } catch(e) {
	                              header = null;
	                            }
	                            options.data.multi_header.push( { 'position': peg$currPos,
	                                                      'offset': offset(),
	                                                      'parsed': header
	                                                    });},
	          function() {
	                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                      },
	          function() {
	                                if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
	                                  options.data = -1;
	                                }
	                              },
	          function() {
	                                options.data = {
	                                  call_id: options.data
	                                };
	                              },
	          "from-tag",
	          { type: "literal", value: "from-tag", description: "\"from-tag\"" },
	          function(from_tag) {
	                                options.data.replaces_from_tag = from_tag;
	                              },
	          "to-tag",
	          { type: "literal", value: "to-tag", description: "\"to-tag\"" },
	          function(to_tag) {
	                                options.data.replaces_to_tag = to_tag;
	                              },
	          "early-only",
	          { type: "literal", value: "early-only", description: "\"early-only\"" },
	          function() {
	                                options.data.early_only = true;
	                              },
	          function(r) {return r;},
	          function(first, rest) { return list(first, rest); },
	          function(value) {
	                          if (options.startRule === 'Require') {
	                            options.data = value || [];
	                          }
	                        },
	          function(rseq_value) {
	                            options.data.value=parseInt(rseq_value.join('')); },
	          "active",
	          { type: "literal", value: "active", description: "\"active\"" },
	          "pending",
	          { type: "literal", value: "pending", description: "\"pending\"" },
	          "terminated",
	          { type: "literal", value: "terminated", description: "\"terminated\"" },
	          function() {
	                                  options.data.state = text(); },
	          "reason",
	          { type: "literal", value: "reason", description: "\"reason\"" },
	          function(reason) {
	                                  if (typeof reason !== 'undefined') options.data.reason = reason; },
	          function(expires) {
	                                  if (typeof expires !== 'undefined') options.data.expires = expires; },
	          "retry_after",
	          { type: "literal", value: "retry_after", description: "\"retry_after\"" },
	          function(retry_after) {
	                                  if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },
	          "deactivated",
	          { type: "literal", value: "deactivated", description: "\"deactivated\"" },
	          "probation",
	          { type: "literal", value: "probation", description: "\"probation\"" },
	          "rejected",
	          { type: "literal", value: "rejected", description: "\"rejected\"" },
	          "timeout",
	          { type: "literal", value: "timeout", description: "\"timeout\"" },
	          "giveup",
	          { type: "literal", value: "giveup", description: "\"giveup\"" },
	          "noresource",
	          { type: "literal", value: "noresource", description: "\"noresource\"" },
	          "invariant",
	          { type: "literal", value: "invariant", description: "\"invariant\"" },
	          function(value) {
	                          if (options.startRule === 'Supported') {
	                            options.data = value || [];
	                          }
	                        },
	          function() {
	                        var tag = options.data.tag;
	                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	                          if (tag) {options.data.setParam('tag',tag)}
	                        },
	          "ttl",
	          { type: "literal", value: "ttl", description: "\"ttl\"" },
	          function(via_ttl_value) {
	                                options.data.ttl = via_ttl_value; },
	          "maddr",
	          { type: "literal", value: "maddr", description: "\"maddr\"" },
	          function(via_maddr) {
	                                options.data.maddr = via_maddr; },
	          "received",
	          { type: "literal", value: "received", description: "\"received\"" },
	          function(via_received) {
	                                options.data.received = via_received; },
	          "branch",
	          { type: "literal", value: "branch", description: "\"branch\"" },
	          function(via_branch) {
	                                options.data.branch = via_branch; },
	          "rport",
	          { type: "literal", value: "rport", description: "\"rport\"" },
	          function() {
	                                if(typeof response_port !== 'undefined')
	                                  options.data.rport = response_port.join(''); },
	          function(via_protocol) {
	                                options.data.protocol = via_protocol; },
	          { type: "literal", value: "UDP", description: "\"UDP\"" },
	          { type: "literal", value: "TCP", description: "\"TCP\"" },
	          { type: "literal", value: "TLS", description: "\"TLS\"" },
	          { type: "literal", value: "SCTP", description: "\"SCTP\"" },
	          function(via_transport) {
	                                options.data.transport = via_transport; },
	          function() {
	                                options.data.host = text(); },
	          function(via_sent_by_port) {
	                                options.data.port = parseInt(via_sent_by_port.join('')); },
	          function(ttl) {
	                                return parseInt(ttl.join('')); },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.deltaSeconds = deltaSeconds;
	                                }
	                              },
	          "refresher",
	          { type: "literal", value: "refresher", description: "\"refresher\"" },
	          "uas",
	          { type: "literal", value: "uas", description: "\"uas\"" },
	          "uac",
	          { type: "literal", value: "uac", description: "\"uac\"" },
	          function(endpoint) {
	                                if (options.startRule === 'Session_Expires') {
	                                  options.data.refresher = endpoint;
	                                }
	                              },
	          function(deltaSeconds) {
	                                if (options.startRule === 'Min_SE') {
	                                  options.data = deltaSeconds;
	                                }
	                              },
	          "stuns",
	          { type: "literal", value: "stuns", description: "\"stuns\"" },
	          "stun",
	          { type: "literal", value: "stun", description: "\"stun\"" },
	          function(scheme) {
	                                options.data.scheme = scheme; },
	          function(host) {
	                                options.data.host = host; },
	          "?transport=",
	          { type: "literal", value: "?transport=", description: "\"?transport=\"" },
	          "turns",
	          { type: "literal", value: "turns", description: "\"turns\"" },
	          "turn",
	          { type: "literal", value: "turn", description: "\"turn\"" },
	          function() {
	                                options.data.transport = transport; },
	          function() {
	                            options.data = text(); }
	        ],
	
	        peg$bytecode = [
	          peg$decode(". \"\"2 3!"),
	          peg$decode("0\"\"\"1!3#"),
	          peg$decode("0$\"\"1!3%"),
	          peg$decode("0&\"\"1!3'"),
	          peg$decode("7'*# \"7("),
	          peg$decode("0(\"\"1!3)"),
	          peg$decode("0*\"\"1!3+"),
	          peg$decode(".,\"\"2,3-"),
	          peg$decode("..\"\"2.3/"),
	          peg$decode("00\"\"1!31"),
	          peg$decode(".2\"\"2233*\x89 \".4\"\"2435*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("7)*# \"7,"),
	          peg$decode(".F\"\"2F3G*} \".H\"\"2H3I*q \".J\"\"2J3K*e \".L\"\"2L3M*Y \".N\"\"2N3O*M \".P\"\"2P3Q*A \".R\"\"2R3S*5 \".T\"\"2T3U*) \".V\"\"2V3W"),
	          peg$decode("!!.Y\"\"2Y3Z+7$7#+-%7#+#%'#%$## X$\"# X\"# X+! (%"),
	          peg$decode("!! \\7$,#&7$\"+-$7 +#%'\"%$\"# X\"# X*# \" [+@$ \\7$+&$,#&7$\"\"\" X+'%4\"6]\" %$\"# X\"# X"),
	          peg$decode("7.*# \" ["),
	          peg$decode("! \\7'*# \"7(,)&7'*# \"7(\"+A$.8\"\"2839+1%7/+'%4#6^# %$## X$\"# X\"# X"),
	          peg$decode("!! \\72+&$,#&72\"\"\" X+o$ \\! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X,@&! \\7.,#&7.\"+-$72+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("0_\"\"1!3`*# \"73"),
	          peg$decode("0a\"\"1!3b"),
	          peg$decode("0c\"\"1!3d"),
	          peg$decode("7!*) \"0e\"\"1!3f"),
	          peg$decode("! \\7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x9E$,\x9B&7)*\x95 \".F\"\"2F3G*\x89 \".J\"\"2J3K*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode("! \\7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O+\x92$,\x8F&7)*\x89 \".F\"\"2F3G*} \".L\"\"2L3M*q \".Y\"\"2Y3Z*e \".P\"\"2P3Q*Y \".H\"\"2H3I*M \".@\"\"2@3A*A \".g\"\"2g3h*5 \".R\"\"2R3S*) \".N\"\"2N3O\"\"\" X+! (%"),
	          peg$decode(".T\"\"2T3U*\xE3 \".V\"\"2V3W*\xD7 \".i\"\"2i3j*\xCB \".k\"\"2k3l*\xBF \".:\"\"2:3;*\xB3 \".D\"\"2D3E*\xA7 \".2\"\"2233*\x9B \".8\"\"2839*\x8F \".m\"\"2m3n*\x83 \"7&*} \".4\"\"2435*q \".o\"\"2o3p*e \".q\"\"2q3r*Y \".6\"\"2637*M \".>\"\"2>3?*A \".s\"\"2s3t*5 \".u\"\"2u3v*) \"7'*# \"7("),
	          peg$decode("! \\7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v+\u0134$,\u0131&7)*\u012B \".F\"\"2F3G*\u011F \".J\"\"2J3K*\u0113 \".L\"\"2L3M*\u0107 \".Y\"\"2Y3Z*\xFB \".P\"\"2P3Q*\xEF \".H\"\"2H3I*\xE3 \".@\"\"2@3A*\xD7 \".g\"\"2g3h*\xCB \".R\"\"2R3S*\xBF \".N\"\"2N3O*\xB3 \".T\"\"2T3U*\xA7 \".V\"\"2V3W*\x9B \".i\"\"2i3j*\x8F \".k\"\"2k3l*\x83 \".8\"\"2839*w \".m\"\"2m3n*k \"7&*e \".4\"\"2435*Y \".o\"\"2o3p*M \".q\"\"2q3r*A \".6\"\"2637*5 \".s\"\"2s3t*) \".u\"\"2u3v\"\"\" X+! (%"),
	          peg$decode("!7/+A$.P\"\"2P3Q+1%7/+'%4#6w# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.4\"\"2435+1%7/+'%4#6x# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.>\"\"2>3?+1%7/+'%4#6y# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.T\"\"2T3U+1%7/+'%4#6z# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.V\"\"2V3W+1%7/+'%4#6{# %$## X$\"# X\"# X"),
	          peg$decode("!.k\"\"2k3l+1$7/+'%4\"6|\" %$\"# X\"# X"),
	          peg$decode("!7/+7$.i\"\"2i3j+'%4\"6}\" %$\"# X\"# X"),
	          peg$decode("!7/+A$.D\"\"2D3E+1%7/+'%4#6~# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.2\"\"2233+1%7/+'%4#6# %$## X$\"# X\"# X"),
	          peg$decode("!7/+A$.8\"\"2839+1%7/+'%4#6\x80# %$## X$\"# X\"# X"),
	          peg$decode("!7/+1$7&+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7&+1$7/+'%4\"6\x81\" %$\"# X\"# X"),
	          peg$decode("!7=+W$ \\7G*) \"7K*# \"7F,/&7G*) \"7K*# \"7F\"+-%7>+#%'#%$## X$\"# X\"# X"),
	          peg$decode("0\x82\"\"1!3\x83*A \"0\x84\"\"1!3\x85*5 \"0\x86\"\"1!3\x87*) \"73*# \"7."),
	          peg$decode("!!7/+U$7&+K% \\7J*# \"7K,)&7J*# \"7K\"+-%7&+#%'$%$$# X$## X$\"# X\"# X+! (%"),
	          peg$decode("!7/+`$7&+V%! \\7J*# \"7K,)&7J*# \"7K\"+! (%+2%7&+(%4$6\x88$!!%$$# X$## X$\"# X\"# X"),
	          peg$decode("7.*G \".L\"\"2L3M*; \"0\x89\"\"1!3\x8A*/ \"0\x86\"\"1!3\x87*# \"73"),
	          peg$decode("!.m\"\"2m3n+K$0\x8B\"\"1!3\x8C*5 \"0\x8D\"\"1!3\x8E*) \"0\x8F\"\"1!3\x90+#%'\"%$\"# X\"# X"),
	          peg$decode("!7N+Q$.8\"\"2839+A%7O*# \" [+1%7S+'%4$6\x91$ %$$# X$## X$\"# X\"# X"),
	          peg$decode("!7N+k$.8\"\"2839+[%7O*# \" [+K%7S+A%7_+7%7l*# \" [+'%4&6\x92& %$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x93\"\"1$3\x94*) \"/\x95\"\"1#3\x96+' 4!6\x97!! %"),
	          peg$decode("!7P+b$!.8\"\"2839+-$7R+#%'\"%$\"# X\"# X*# \" [+7%.:\"\"2:3;+'%4#6\x98# %$## X$\"# X\"# X"),
	          peg$decode(" \\7+*) \"7-*# \"7Q+2$,/&7+*) \"7-*# \"7Q\"\"\" X"),
	          peg$decode(".<\"\"2<3=*q \".>\"\"2>3?*e \".@\"\"2@3A*Y \".B\"\"2B3C*M \".D\"\"2D3E*A \".2\"\"2233*5 \".6\"\"2637*) \".4\"\"2435"),
	          peg$decode("! \\7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E,e&7+*_ \"7-*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E\"+& 4!6\x99! %"),
	          peg$decode("!7T+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\x9A! %"),
	          peg$decode("! \\!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X,>&!7V+3$.J\"\"2J3K+#%'\"%$\"# X\"# X\"+G$7W+=%.J\"\"2J3K*# \" [+'%4#6\x9B# %$## X$\"# X\"# X"),
	          peg$decode(" \\0\x9C\"\"1!3\x9D+,$,)&0\x9C\"\"1!3\x9D\"\"\" X"),
	          peg$decode("!0$\"\"1!3%+A$ \\0\x9E\"\"1!3\x9F,)&0\x9E\"\"1!3\x9F\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!.o\"\"2o3p+A$7Y+7%.q\"\"2q3r+'%4#6\xA0# %$## X$\"# X\"# X"),
	          peg$decode("!!7Z+\xBF$.8\"\"2839+\xAF%7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'-%$-# X$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0838 \"!.\xA1\"\"2\xA13\xA2+\xAF$7Z+\xA5%.8\"\"2839+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%',%$,# X$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0795 \"!.\xA1\"\"2\xA13\xA2+\x95$7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u070C \"!.\xA1\"\"2\xA13\xA2+{$7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u069D \"!.\xA1\"\"2\xA13\xA2+a$7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X*\u0648 \"!.\xA1\"\"2\xA13\xA2+G$7Z+=%.8\"\"2839+-%7[+#%'$%$$# X$## X$\"# X\"# X*\u060D \"!.\xA1\"\"2\xA13\xA2+-$7[+#%'\"%$\"# X\"# X*\u05EC \"!.\xA1\"\"2\xA13\xA2+-$7Z+#%'\"%$\"# X\"# X*\u05CB \"!7Z+\xA5$.\xA1\"\"2\xA13\xA2+\x95%7Z+\x8B%.8\"\"2839+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'+%$+# X$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0538 \"!7Z+\xB6$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x8B%.\xA1\"\"2\xA13\xA2+{%7Z+q%.8\"\"2839+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%'*%$*# X$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0494 \"!7Z+\xC7$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x9C%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+q%.\xA1\"\"2\xA13\xA2+a%7Z+W%.8\"\"2839+G%7Z+=%.8\"\"2839+-%7[+#%')%$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u03DF \"!7Z+\xD8$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xAD%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x82%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+W%.\xA1\"\"2\xA13\xA2+G%7Z+=%.8\"\"2839+-%7[+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0319 \"!7Z+\xE9$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7[+#%''%$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0242 \"!7Z+\u0114$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xE9%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xBE%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x93%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+h%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+=%.\xA1\"\"2\xA13\xA2+-%7Z+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X*\u0140 \"!7Z+\u0135$!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\u010A%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xDF%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\xB4%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+\x89%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+^%!.8\"\"2839+-$7Z+#%'\"%$\"# X\"# X*# \" [+3%.\xA1\"\"2\xA13\xA2+#%'(%$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X+& 4!6\xA3! %"),
	          peg$decode("!7#+S$7#*# \" [+C%7#*# \" [+3%7#*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7Z+=$.8\"\"2839+-%7Z+#%'#%$## X$\"# X\"# X*# \"7\\"),
	          peg$decode("!7]+u$.J\"\"2J3K+e%7]+[%.J\"\"2J3K+K%7]+A%.J\"\"2J3K+1%7]+'%4'6\xA4' %$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!.\xA5\"\"2\xA53\xA6+3$0\xA7\"\"1!3\xA8+#%'\"%$\"# X\"# X*\xA0 \"!.\xA9\"\"2\xA93\xAA+=$0\xAB\"\"1!3\xAC+-%7!+#%'#%$## X$\"# X\"# X*o \"!.\xAD\"\"2\xAD3\xAE+7$7!+-%7!+#%'#%$## X$\"# X\"# X*D \"!0\xAF\"\"1!3\xB0+-$7!+#%'\"%$\"# X\"# X*# \"7!"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\xB1!! %"),
	          peg$decode(" \\!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7`+#%'\"%$\"# X\"# X\""),
	          peg$decode("7a*A \"7b*; \"7c*5 \"7d*/ \"7e*) \"7f*# \"7g"),
	          peg$decode("!/\xB2\"\"1*3\xB3+b$/\xB4\"\"1#3\xB5*G \"/\xB6\"\"1#3\xB7*; \"/\xB8\"\"1$3\xB9*/ \"/\xBA\"\"1#3\xBB*# \"76+(%4\"6\xBC\"! %$\"# X\"# X"),
	          peg$decode("!/\xBD\"\"1%3\xBE+J$/\xBF\"\"1%3\xC0*/ \"/\xC1\"\"1\"3\xC2*# \"76+(%4\"6\xC3\"! %$\"# X\"# X"),
	          peg$decode("!/\xC4\"\"1'3\xC5+2$7\x8F+(%4\"6\xC6\"! %$\"# X\"# X"),
	          peg$decode("!/\xC7\"\"1$3\xC8+2$7\xEF+(%4\"6\xC9\"! %$\"# X\"# X"),
	          peg$decode("!/\xCA\"\"1&3\xCB+2$7T+(%4\"6\xCC\"! %$\"# X\"# X"),
	          peg$decode("!/\xCD\"\"1\"3\xCE+R$!.>\"\"2>3?+-$76+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xCF\" %$\"# X\"# X"),
	          peg$decode("!7h+T$!.>\"\"2>3?+-$7i+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xD0\"\"! %$\"# X\"# X"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("! \\7j+&$,#&7j\"\"\" X+! (%"),
	          peg$decode("7k*) \"7+*# \"7-"),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".8\"\"2839*A \".<\"\"2<3=*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("!.6\"\"2637+u$7m+k% \\!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X,>&!.<\"\"2<3=+-$7m+#%'\"%$\"# X\"# X\"+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7n+C$.>\"\"2>3?+3%7o+)%4#6\xD1#\"\" %$## X$\"# X\"# X"),
	          peg$decode(" \\7p*) \"7+*# \"7-+2$,/&7p*) \"7+*# \"7-\"\"\" X"),
	          peg$decode(" \\7p*) \"7+*# \"7-,/&7p*) \"7+*# \"7-\""),
	          peg$decode(".o\"\"2o3p*e \".q\"\"2q3r*Y \".4\"\"2435*M \".6\"\"2637*A \".8\"\"2839*5 \".@\"\"2@3A*) \".B\"\"2B3C"),
	          peg$decode("7\x90*# \"7r"),
	          peg$decode("!7\x8F+K$7'+A%7s+7%7'+-%7\x84+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7M*# \"7t"),
	          peg$decode("!7+G$.8\"\"2839+7%7u*# \"7x+'%4#6\xD2# %$## X$\"# X\"# X"),
	          peg$decode("!7v*# \"7w+N$!.6\"\"2637+-$7\x83+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!.\xD3\"\"2\xD33\xD4+=$7\x80+3%7w*# \" [+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!.4\"\"2435+-$7{+#%'\"%$\"# X\"# X"),
	          peg$decode("!7z+5$ \\7y,#&7y\"+#%'\"%$\"# X\"# X"),
	          peg$decode("7**) \"7+*# \"7-"),
	          peg$decode("7+*\x8F \"7-*\x89 \".2\"\"2233*} \".6\"\"2637*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7|+k$ \\!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X,>&!.4\"\"2435+-$7|+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7~,#&7~\"+k$ \\!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X,>&!.2\"\"2233+-$7}+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode(" \\7~,#&7~\""),
	          peg$decode("7+*w \"7-*q \".8\"\"2839*e \".:\"\"2:3;*Y \".<\"\"2<3=*M \".>\"\"2>3?*A \".@\"\"2@3A*5 \".B\"\"2B3C*) \".D\"\"2D3E"),
	          peg$decode("!7\"+\x8D$ \\7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K,M&7\"*G \"7!*A \".@\"\"2@3A*5 \".F\"\"2F3G*) \".J\"\"2J3K\"+'%4\"6\xD5\" %$\"# X\"# X"),
	          peg$decode("7\x81*# \"7\x82"),
	          peg$decode("!!7O+3$.:\"\"2:3;+#%'\"%$\"# X\"# X*# \" [+-$7S+#%'\"%$\"# X\"# X*# \" ["),
	          peg$decode(" \\7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A+\x8C$,\x89&7+*\x83 \"7-*} \".B\"\"2B3C*q \".D\"\"2D3E*e \".2\"\"2233*Y \".8\"\"2839*M \".:\"\"2:3;*A \".<\"\"2<3=*5 \".>\"\"2>3?*) \".@\"\"2@3A\"\"\" X"),
	          peg$decode(" \\7y,#&7y\""),
	          peg$decode("!/\x95\"\"1#3\xD6+y$.4\"\"2435+i% \\7!+&$,#&7!\"\"\" X+P%.J\"\"2J3K+@% \\7!+&$,#&7!\"\"\" X+'%4%6\xD7% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode(".\xD8\"\"2\xD83\xD9"),
	          peg$decode(".\xDA\"\"2\xDA3\xDB"),
	          peg$decode(".\xDC\"\"2\xDC3\xDD"),
	          peg$decode(".\xDE\"\"2\xDE3\xDF"),
	          peg$decode(".\xE0\"\"2\xE03\xE1"),
	          peg$decode(".\xE2\"\"2\xE23\xE3"),
	          peg$decode(".\xE4\"\"2\xE43\xE5"),
	          peg$decode(".\xE6\"\"2\xE63\xE7"),
	          peg$decode(".\xE8\"\"2\xE83\xE9"),
	          peg$decode(".\xEA\"\"2\xEA3\xEB"),
	          peg$decode("!7\x85*S \"7\x86*M \"7\x88*G \"7\x89*A \"7\x8A*; \"7\x8B*5 \"7\x8C*/ \"7\x8D*) \"7\x8E*# \"76+& 4!6\xEC! %"),
	          peg$decode("!7\x84+K$7'+A%7\x91+7%7'+-%7\x93+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\x92+' 4!6\xED!! %"),
	          peg$decode("!7!+7$7!+-%7!+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(,G&7**A \"7+*; \"7-*5 \"73*/ \"74*) \"7'*# \"7(\"+& 4!6\xEE! %"),
	          peg$decode("!7\xB5+_$ \\!7A+-$7\xB5+#%'\"%$\"# X\"# X,8&!7A+-$7\xB5+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!79+R$!.:\"\"2:3;+-$79+#%'\"%$\"# X\"# X*# \" [+'%4\"6\xEF\" %$\"# X\"# X"),
	          peg$decode("!7:*j \"!7\x97+_$ \\!7A+-$7\x97+#%'\"%$\"# X\"# X,8&!7A+-$7\x97+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+& 4!6\xF0! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\x9A+#%'\"%$\"# X\"# X,8&!7B+-$7\x9A+#%'\"%$\"# X\"# X\"+'%4\"6\xF1\" %$\"# X\"# X"),
	          peg$decode("!7\x99*# \" [+A$7@+7%7M+-%7?+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!!76+_$ \\!7.+-$76+#%'\"%$\"# X\"# X,8&!7.+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X*# \"7H+' 4!6\xF2!! %"),
	          peg$decode("7\x9B*) \"7\x9C*# \"7\x9F"),
	          peg$decode("!/\xF3\"\"1!3\xF4+<$7<+2%7\x9E+(%4#6\xF5#! %$## X$\"# X\"# X"),
	          peg$decode("!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\xF8#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\xF9!! %"),
	          peg$decode("!.\xFA\"\"2\xFA3\xFB+x$!.J\"\"2J3K+S$7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'$%$$# X$## X$\"# X\"# X*# \" [+'%4\"6\xFC\" %$\"# X\"# X"),
	          peg$decode("!76+N$!7<+-$7\xA0+#%'\"%$\"# X\"# X*# \" [+)%4\"6\xFD\"\"! %$\"# X\"# X"),
	          peg$decode("76*) \"7T*# \"7H"),
	          peg$decode("!7\xA2+_$ \\!7B+-$7\xA3+#%'\"%$\"# X\"# X,8&!7B+-$7\xA3+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\xFE\"\"1&3\xFF*G \"/\u0100\"\"1'3\u0101*; \"/\u0102\"\"1$3\u0103*/ \"/\u0104\"\"1%3\u0105*# \"76+& 4!6\u0106! %"),
	          peg$decode("7\xA4*# \"7\x9F"),
	          peg$decode("!/\u0107\"\"1(3\u0108+O$7<+E%/\u0109\"\"1(3\u010A*/ \"/\u010B\"\"1(3\u010C*# \"76+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u010D!! %"),
	          peg$decode("!7\xA8+& 4!6\u010E! %"),
	          peg$decode("!7\xA9+s$7;+i%7\xAE+_% \\!7B+-$7\xAF+#%'\"%$\"# X\"# X,8&!7B+-$7\xAF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xAA*# \"7\xAB"),
	          peg$decode("/\u010F\"\"1$3\u0110*S \"/\u0111\"\"1%3\u0112*G \"/\u0113\"\"1%3\u0114*; \"/\u0115\"\"1%3\u0116*/ \"/\u0117\"\"1+3\u0118*# \"7\xAC"),
	          peg$decode("/\u0119\"\"1'3\u011A*/ \"/\u011B\"\"1)3\u011C*# \"7\xAC"),
	          peg$decode("76*# \"7\xAD"),
	          peg$decode("!/\u011D\"\"1\"3\u011E+-$76+#%'\"%$\"# X\"# X"),
	          peg$decode("7\xAC*# \"76"),
	          peg$decode("!76+7$7<+-%7\xB0+#%'#%$## X$\"# X\"# X"),
	          peg$decode("76*# \"7H"),
	          peg$decode("!7\xB2+7$7.+-%7\x8F+#%'#%$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u011F!! %"),
	          peg$decode("!7\x9D+' 4!6\u0120!! %"),
	          peg$decode("!7\xB5+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u0121\"!!%$\"# X\"# X"),
	          peg$decode("!!77+k$ \\!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X,>&!.J\"\"2J3K+-$77+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+! (%"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xB7+#%'\"%$\"# X\"# X,8&!7B+-$7\xB7+#%'\"%$\"# X\"# X\"+'%4\"6\u0122\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!/\u0123\"\"1#3\u0124+<$7<+2%76+(%4#6\u0125#! %$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u0126!! %"),
	          peg$decode("!7\x9D+' 4!6\u0127!! %"),
	          peg$decode("! \\7\x99,#&7\x99\"+\x81$7@+w%7M+m%7?+c% \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4%6\u0128% %$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xBD"),
	          peg$decode("!/\u0129\"\"1&3\u012A+s$7.+i%7\xC0+_% \\!7A+-$7\xC0+#%'\"%$\"# X\"# X,8&!7A+-$7\xC0+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X*# \"7\xBE"),
	          peg$decode("!76+s$7.+i%7\xBF+_% \\!7A+-$7\xBF+#%'\"%$\"# X\"# X,8&!7A+-$7\xBF+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!76+=$7<+3%76*# \"7H+#%'#%$## X$\"# X\"# X"),
	          peg$decode("7\xC1*G \"7\xC3*A \"7\xC5*; \"7\xC7*5 \"7\xC8*/ \"7\xC9*) \"7\xCA*# \"7\xBF"),
	          peg$decode("!/\u012B\"\"1%3\u012C+7$7<+-%7\xC2+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u012D!! %"),
	          peg$decode("!/\u012E\"\"1&3\u012F+\xA5$7<+\x9B%7D+\x91%7\xC4+\x87% \\! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X,G&! \\7'+&$,#&7'\"\"\" X+-$7\xC4+#%'\"%$\"# X\"# X\"+-%7E+#%'&%$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("7t*# \"7w"),
	          peg$decode("!/\u0130\"\"1%3\u0131+7$7<+-%7\xC6+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!7I+' 4!6\u0132!! %"),
	          peg$decode("!/\u0133\"\"1&3\u0134+<$7<+2%7I+(%4#6\u0135#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0136\"\"1%3\u0137+_$7<+U%!/\u0138\"\"1$3\u0139+& 4!6\u013A! %*4 \"!/\u013B\"\"1%3\u013C+& 4!6\u013D! %+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u013E\"\"1)3\u013F+T$7<+J%/\u0140\"\"1#3\u0141*/ \"/\u0142\"\"1(3\u0143*# \"76+(%4#6\u0144#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0145\"\"1#3\u0146+\x9E$7<+\x94%7D+\x8A%!7\xCB+k$ \\!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X,>&!.D\"\"2D3E+-$7\xCB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X+-%7E+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u0147\"\"1(3\u0148*/ \"/\u0149\"\"1$3\u014A*# \"76+' 4!6\u014B!! %"),
	          peg$decode("!76+_$ \\!7A+-$76+#%'\"%$\"# X\"# X,8&!7A+-$76+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xCE+K$7.+A%7\xCE+7%7.+-%7\x8F+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u014C!! %"),
	          peg$decode("!7\xD0+c$ \\!7A+-$7\xD0+#%'\"%$\"# X\"# X,8&!7A+-$7\xD0+#%'\"%$\"# X\"# X\"+'%4\"6\u014D\" %$\"# X\"# X"),
	          peg$decode("!7\x98+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014E\" %$\"# X\"# X"),
	          peg$decode("!7L*T \"7\x98*N \"!7@*# \" [+=$7t+3%7?*# \" [+#%'#%$## X$\"# X\"# X+c$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+'%4\"6\u014F\" %$\"# X\"# X"),
	          peg$decode("!7\xD3+c$ \\!7B+-$7\xD4+#%'\"%$\"# X\"# X,8&!7B+-$7\xD4+#%'\"%$\"# X\"# X\"+'%4\"6\u0150\" %$\"# X\"# X"),
	          peg$decode("!7\x95+& 4!6\u0151! %"),
	          peg$decode("!/\u0152\"\"1(3\u0153+<$7<+2%76+(%4#6\u0154#! %$## X$\"# X\"# X*j \"!/\u0155\"\"1&3\u0156+<$7<+2%76+(%4#6\u0157#! %$## X$\"# X\"# X*: \"!/\u0158\"\"1*3\u0159+& 4!6\u015A! %*# \"7\x9F"),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u015D!! %"),
	          peg$decode("!7\xD7+_$ \\!7A+-$7\xD7+#%'\"%$\"# X\"# X,8&!7A+-$7\xD7+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\x98+_$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("! \\7!+&$,#&7!\"\"\" X+' 4!6\u015E!! %"),
	          peg$decode("!7\xDA+_$ \\!7B+-$7\xDB+#%'\"%$\"# X\"# X,8&!7B+-$7\xDB+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!/\u015F\"\"1&3\u0160*; \"/\u0161\"\"1'3\u0162*/ \"/\u0163\"\"1*3\u0164*# \"76+& 4!6\u0165! %"),
	          peg$decode("!/\u0166\"\"1&3\u0167+<$7<+2%7\xDC+(%4#6\u0168#! %$## X$\"# X\"# X*\x83 \"!/\xF6\"\"1'3\xF7+<$7<+2%7\x9D+(%4#6\u0169#! %$## X$\"# X\"# X*S \"!/\u016A\"\"1+3\u016B+<$7<+2%7\x9D+(%4#6\u016C#! %$## X$\"# X\"# X*# \"7\x9F"),
	          peg$decode("/\u016D\"\"1+3\u016E*k \"/\u016F\"\"1)3\u0170*_ \"/\u0171\"\"1(3\u0172*S \"/\u0173\"\"1'3\u0174*G \"/\u0175\"\"1&3\u0176*; \"/\u0177\"\"1*3\u0178*/ \"/\u0179\"\"1)3\u017A*# \"76"),
	          peg$decode("71*# \" ["),
	          peg$decode("!!76+o$ \\!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X,=&!7A+2$76+(%4\"6\u015B\"! %$\"# X\"# X\"+)%4\"6\u015C\"\"! %$\"# X\"# X*# \" [+' 4!6\u017B!! %"),
	          peg$decode("!7L*# \"7\x98+c$ \\!7B+-$7\xE0+#%'\"%$\"# X\"# X,8&!7B+-$7\xE0+#%'\"%$\"# X\"# X\"+'%4\"6\u017C\" %$\"# X\"# X"),
	          peg$decode("7\xB8*# \"7\x9F"),
	          peg$decode("!7\xE2+_$ \\!7A+-$7\xE2+#%'\"%$\"# X\"# X,8&!7A+-$7\xE2+#%'\"%$\"# X\"# X\"+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\xE9+s$7.+i%7\xEC+_% \\!7B+-$7\xE3+#%'\"%$\"# X\"# X,8&!7B+-$7\xE3+#%'\"%$\"# X\"# X\"+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("7\xE4*; \"7\xE5*5 \"7\xE6*/ \"7\xE7*) \"7\xE8*# \"7\x9F"),
	          peg$decode("!/\u017D\"\"1#3\u017E+<$7<+2%7\xEF+(%4#6\u017F#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0180\"\"1%3\u0181+<$7<+2%7T+(%4#6\u0182#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0183\"\"1(3\u0184+B$7<+8%7\\*# \"7Y+(%4#6\u0185#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0186\"\"1&3\u0187+<$7<+2%76+(%4#6\u0188#! %$## X$\"# X\"# X"),
	          peg$decode("!/\u0189\"\"1%3\u018A+T$!7<+5$ \\7!,#&7!\"+#%'\"%$\"# X\"# X*# \" [+'%4\"6\u018B\" %$\"# X\"# X"),
	          peg$decode("!7\xEA+K$7;+A%76+7%7;+-%7\xEB+#%'%%$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\x95\"\"1#3\xD6*# \"76+' 4!6\u018C!! %"),
	          peg$decode("!/\xB4\"\"1#3\u018D*G \"/\xB6\"\"1#3\u018E*; \"/\xBA\"\"1#3\u018F*/ \"/\xB8\"\"1$3\u0190*# \"76+' 4!6\u0191!! %"),
	          peg$decode("!7\xED+H$!7C+-$7\xEE+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7U*) \"7\\*# \"7X+& 4!6\u0192! %"),
	          peg$decode("!!7!*# \" [+c$7!*# \" [+S%7!*# \" [+C%7!*# \" [+3%7!*# \" [+#%'%%$%# X$$# X$## X$\"# X\"# X+' 4!6\u0193!! %"),
	          peg$decode("!!7!+C$7!*# \" [+3%7!*# \" [+#%'#%$## X$\"# X\"# X+' 4!6\u0194!! %"),
	          peg$decode("7\xBD"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\xF2+#%'\"%$\"# X\"# X,8&!7B+-$7\xF2+#%'\"%$\"# X\"# X\"+(%4\"6\u0195\"!!%$\"# X\"# X"),
	          peg$decode("7\xF3*# \"7\x9F"),
	          peg$decode("!.\u0196\"\"2\u01963\u0197+N$7<+D%.\u0198\"\"2\u01983\u0199*) \".\u019A\"\"2\u019A3\u019B+(%4#6\u019C#! %$## X$\"# X\"# X"),
	          peg$decode("!7\x9D+d$ \\!7B+-$7\x9F+#%'\"%$\"# X\"# X,8&!7B+-$7\x9F+#%'\"%$\"# X\"# X\"+(%4\"6\u019D\"!!%$\"# X\"# X"),
	          peg$decode("!76+7$70+-%7\xF6+#%'#%$## X$\"# X\"# X"),
	          peg$decode(" \\72*) \"74*# \"7.,/&72*) \"74*# \"7.\""),
	          peg$decode(" \\7%,#&7%\""),
	          peg$decode("!7\xF9+=$.8\"\"2839+-%7\xFA+#%'#%$## X$\"# X\"# X"),
	          peg$decode("!/\u019E\"\"1%3\u019F*) \"/\u01A0\"\"1$3\u01A1+' 4!6\u01A2!! %"),
	          peg$decode("!7\xFB+N$!.8\"\"2839+-$7^+#%'\"%$\"# X\"# X*# \" [+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\\*) \"7X*# \"7\x82+' 4!6\u01A3!! %"),
	          peg$decode("! \\7\xFD*) \"7-*# \"7\xFE,/&7\xFD*) \"7-*# \"7\xFE\"+! (%"),
	          peg$decode("7\"*S \"7!*M \".F\"\"2F3G*A \".J\"\"2J3K*5 \".H\"\"2H3I*) \".N\"\"2N3O"),
	          peg$decode(".L\"\"2L3M*\x95 \".B\"\"2B3C*\x89 \".<\"\"2<3=*} \".R\"\"2R3S*q \".T\"\"2T3U*e \".V\"\"2V3W*Y \".P\"\"2P3Q*M \".@\"\"2@3A*A \".D\"\"2D3E*5 \".2\"\"2233*) \".>\"\"2>3?"),
	          peg$decode("!7\u0100+h$.8\"\"2839+X%7\xFA+N%!.\u01A4\"\"2\u01A43\u01A5+-$7\xEB+#%'\"%$\"# X\"# X*# \" [+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!/\u01A6\"\"1%3\u01A7*) \"/\u01A8\"\"1$3\u01A9+' 4!6\u01A2!! %"),
	          peg$decode("!7\xEB+Q$/\xB4\"\"1#3\xB5*7 \"/\xB6\"\"1#3\xB7*+ \" \\7+,#&7+\"+'%4\"6\u01AA\" %$\"# X\"# X"),
	          peg$decode("!7\u0104+\x8F$.F\"\"2F3G+%7\u0103+u%.F\"\"2F3G+e%7\u0103+[%.F\"\"2F3G+K%7\u0103+A%.F\"\"2F3G+1%7\u0105+'%4)6\u01AB) %$)# X$(# X$'# X$&# X$%# X$$# X$## X$\"# X\"# X"),
	          peg$decode("!7#+A$7#+7%7#+-%7#+#%'$%$$# X$## X$\"# X\"# X"),
	          peg$decode("!7\u0103+-$7\u0103+#%'\"%$\"# X\"# X"),
	          peg$decode("!7\u0103+7$7\u0103+-%7\u0103+#%'#%$## X$\"# X\"# X")
	        ],
	
	        peg$currPos          = 0,
	        peg$reportedPos      = 0,
	        peg$cachedPos        = 0,
	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleIndices)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleIndex = peg$startRuleIndices[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$reportedPos, peg$currPos);
	    }
	
	    function offset() {
	      return peg$reportedPos;
	    }
	
	    function line() {
	      return peg$computePosDetails(peg$reportedPos).line;
	    }
	
	    function column() {
	      return peg$computePosDetails(peg$reportedPos).column;
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        peg$reportedPos
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(message, null, peg$reportedPos);
	    }
	
	    function peg$computePosDetails(pos) {
	      function advance(details, startPos, endPos) {
	        var p, ch;
	
	        for (p = startPos; p < endPos; p++) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	        }
	      }
	
	      if (peg$cachedPos !== pos) {
	        if (peg$cachedPos > pos) {
	          peg$cachedPos = 0;
	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	        }
	        advance(peg$cachedPosDetails, peg$cachedPos, pos);
	        peg$cachedPos = pos;
	      }
	
	      return peg$cachedPosDetails;
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, pos) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      var posDetails = peg$computePosDetails(pos),
	          found      = pos < input.length ? input.charAt(pos) : null;
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        pos,
	        posDetails.line,
	        posDetails.column
	      );
	    }
	
	    function peg$decode(s) {
	      var bc = new Array(s.length), i;
	
	      for (i = 0; i < s.length; i++) {
	        bc[i] = s.charCodeAt(i) - 32;
	      }
	
	      return bc;
	    }
	
	    function peg$parseRule(index) {
	      var bc    = peg$bytecode[index],
	          ip    = 0,
	          ips   = [],
	          end   = bc.length,
	          ends  = [],
	          stack = [],
	          params, i;
	
	      function protect(object) {
	        return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;
	      }
	
	      while (true) {
	        while (ip < end) {
	          switch (bc[ip]) {
	            case 0:
	              stack.push(protect(peg$consts[bc[ip + 1]]));
	              ip += 2;
	              break;
	
	            case 1:
	              stack.push(peg$currPos);
	              ip++;
	              break;
	
	            case 2:
	              stack.pop();
	              ip++;
	              break;
	
	            case 3:
	              peg$currPos = stack.pop();
	              ip++;
	              break;
	
	            case 4:
	              stack.length -= bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 5:
	              stack.splice(-2, 1);
	              ip++;
	              break;
	
	            case 6:
	              stack[stack.length - 2].push(stack.pop());
	              ip++;
	              break;
	
	            case 7:
	              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 8:
	              stack.pop();
	              stack.push(input.substring(stack[stack.length - 1], peg$currPos));
	              ip++;
	              break;
	
	            case 9:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1]) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 10:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] === peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 11:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 12:
	              if (stack[stack.length - 1] !== peg$FAILED) {
	                ends.push(end);
	                ips.push(ip);
	
	                end = ip + 2 + bc[ip + 1];
	                ip += 2;
	              } else {
	                ip += 2 + bc[ip + 1];
	              }
	
	              break;
	
	            case 13:
	              ends.push(end);
	              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
	
	              if (input.length > peg$currPos) {
	                end = ip + 3 + bc[ip + 1];
	                ip += 3;
	              } else {
	                end = ip + 3 + bc[ip + 1] + bc[ip + 2];
	                ip += 3 + bc[ip + 1];
	              }
	
	              break;
	
	            case 14:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 15:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 16:
	              ends.push(end);
	              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
	
	              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
	                end = ip + 4 + bc[ip + 2];
	                ip += 4;
	              } else {
	                end = ip + 4 + bc[ip + 2] + bc[ip + 3];
	                ip += 4 + bc[ip + 2];
	              }
	
	              break;
	
	            case 17:
	              stack.push(input.substr(peg$currPos, bc[ip + 1]));
	              peg$currPos += bc[ip + 1];
	              ip += 2;
	              break;
	
	            case 18:
	              stack.push(peg$consts[bc[ip + 1]]);
	              peg$currPos += peg$consts[bc[ip + 1]].length;
	              ip += 2;
	              break;
	
	            case 19:
	              stack.push(peg$FAILED);
	              if (peg$silentFails === 0) {
	                peg$fail(peg$consts[bc[ip + 1]]);
	              }
	              ip += 2;
	              break;
	
	            case 20:
	              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];
	              ip += 2;
	              break;
	
	            case 21:
	              peg$reportedPos = peg$currPos;
	              ip++;
	              break;
	
	            case 22:
	              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
	              for (i = 0; i < bc[ip + 3]; i++) {
	                params[i] = stack[stack.length - 1 - params[i]];
	              }
	
	              stack.splice(
	                stack.length - bc[ip + 2],
	                bc[ip + 2],
	                peg$consts[bc[ip + 1]].apply(null, params)
	              );
	
	              ip += 4 + bc[ip + 3];
	              break;
	
	            case 23:
	              stack.push(peg$parseRule(bc[ip + 1]));
	              ip += 2;
	              break;
	
	            case 24:
	              peg$silentFails++;
	              ip++;
	              break;
	
	            case 25:
	              peg$silentFails--;
	              ip++;
	              break;
	
	            default:
	              throw new Error("Invalid opcode: " + bc[ip] + ".");
	          }
	        }
	
	        if (ends.length > 0) {
	          end = ends.pop();
	          ip = ips.pop();
	        } else {
	          break;
	        }
	      }
	
	      return stack[0];
	    }
	
	
	      options.data = {}; // Object to which header attributes will be assigned during parsing
	
	      function list (first, rest) {
	        return [first].concat(rest);
	      }
	
	
	    peg$result = peg$parseRule(peg$startRuleIndex);
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	    }
	  }
	
	  return {
	    SyntaxError: SyntaxError,
	    parse:       parse
	  };
	})();


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var toplevel = global.window || global;
	
	function getPrefixedProperty (object, name) {
	  if (object == null) {
	    return;
	  }
	  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];
	  for (var i in prefixedNames) {
	    var property = object[prefixedNames[i]];
	    if (property) {
	      return property.bind(object);
	    }
	  }
	}
	
	module.exports = {
	  WebSocket: toplevel.WebSocket,
	  Transport: __webpack_require__(246),
	  open: toplevel.open,
	  Promise: toplevel.Promise,
	  timers: toplevel,
	
	  // Console is not defined in ECMAScript, so just in case...
	  console: toplevel.console || {
	    debug: function () {},
	    log: function () {},
	    warn: function () {},
	    error: function () {}
	  },
	
	  MediaStream: getPrefixedProperty(toplevel, 'MediaStream'),
	  getUserMedia: getPrefixedProperty(toplevel.navigator, 'getUserMedia'),
	  RTCPeerConnection: getPrefixedProperty(toplevel, 'RTCPeerConnection'),
	  RTCSessionDescription: getPrefixedProperty(toplevel, 'RTCSessionDescription'),
	
	  addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),
	  HTMLMediaElement: toplevel.HTMLMediaElement,
	
	  attachMediaStream: toplevel.attachMediaStream,
	  createObjectURL: toplevel.URL && toplevel.URL.createObjectURL,
	  revokeObjectURL: toplevel.URL && toplevel.URL.revokeObjectURL
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 246 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @fileoverview Transport
	 */
	
	/**
	 * @augments SIP
	 * @class Transport
	 * @param {SIP.UA} ua
	 * @param {Object} server ws_server Object
	 */
	module.exports = function (SIP, WebSocket) {
	var Transport,
	  C = {
	    // Transport status codes
	    STATUS_READY:        0,
	    STATUS_DISCONNECTED: 1,
	    STATUS_ERROR:        2
	  };
	
	/**
	 * Compute an amount of time in seconds to wait before sending another
	 * keep-alive.
	 * @returns {Number}
	 */
	function computeKeepAliveTimeout(upperBound) {
	  var lowerBound = upperBound * 0.8;
	  return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
	}
	
	Transport = function(ua, server) {
	
	  this.logger = ua.getLogger('sip.transport');
	  this.ua = ua;
	  this.ws = null;
	  this.server = server;
	  this.reconnection_attempts = 0;
	  this.closed = false;
	  this.connected = false;
	  this.reconnectTimer = null;
	  this.lastTransportError = {};
	
	  this.keepAliveInterval = ua.configuration.keepAliveInterval;
	  this.keepAliveTimeout = null;
	  this.keepAliveTimer = null;
	
	  this.ua.transport = this;
	
	  // Connect
	  this.connect();
	};
	
	Transport.prototype = {
	  /**
	   * Send a message.
	   * @param {SIP.OutgoingRequest|String} msg
	   * @returns {Boolean}
	   */
	  send: function(msg) {
	    var message = msg.toString();
	
	    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('sending WebSocket message:\n\n' + message + '\n');
	      }
	      this.ws.send(message);
	      return true;
	    } else {
	      this.logger.warn('unable to send message, WebSocket is not open');
	      return false;
	    }
	  },
	
	  /**
	   * Send a keep-alive (a double-CRLF sequence).
	   * @private
	   * @returns {Boolean}
	   */
	  sendKeepAlive: function() {
	    if(this.keepAliveTimeout) { return; }
	
	    this.keepAliveTimeout = SIP.Timers.setTimeout(function() {
	      this.ua.emit('keepAliveTimeout');
	    }.bind(this), 10000);
	
	    return this.send('\r\n\r\n');
	  },
	
	  /**
	   * Start sending keep-alives.
	   * @private
	   */
	  startSendingKeepAlives: function() {
	    if (this.keepAliveInterval && !this.keepAliveTimer) {
	      this.keepAliveTimer = SIP.Timers.setTimeout(function() {
	        this.sendKeepAlive();
	        this.keepAliveTimer = null;
	        this.startSendingKeepAlives();
	      }.bind(this), computeKeepAliveTimeout(this.keepAliveInterval));
	    }
	  },
	
	  /**
	   * Stop sending keep-alives.
	   * @private
	   */
	  stopSendingKeepAlives: function() {
	    SIP.Timers.clearTimeout(this.keepAliveTimer);
	    SIP.Timers.clearTimeout(this.keepAliveTimeout);
	    this.keepAliveTimer = null;
	    this.keepAliveTimeout = null;
	  },
	
	  /**
	  * Disconnect socket.
	  */
	  disconnect: function() {
	    if(this.ws) {
	      // Clear reconnectTimer
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	
	      this.stopSendingKeepAlives();
	
	      this.closed = true;
	      this.logger.log('closing WebSocket ' + this.server.ws_uri);
	      this.ws.close();
	    }
	
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	      this.ua.emit('disconnected', {
	        transport: this,
	        code: this.lastTransportError.code,
	        reason: this.lastTransportError.reason
	      });
	    }
	  },
	
	  /**
	  * Connect socket.
	  */
	  connect: function() {
	    var transport = this;
	
	    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
	      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
	      return false;
	    }
	
	    if(this.ws) {
	      this.ws.close();
	    }
	
	    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
	    this.ua.onTransportConnecting(this,
	      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);
	
	    try {
	      this.ws = new WebSocket(this.server.ws_uri, 'sip');
	    } catch(e) {
	      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
	    }
	
	    this.ws.binaryType = 'arraybuffer';
	
	    this.ws.onopen = function() {
	      transport.onOpen();
	    };
	
	    this.ws.onclose = function(e) {
	      transport.onClose(e);
	    };
	
	    this.ws.onmessage = function(e) {
	      transport.onMessage(e);
	    };
	
	    this.ws.onerror = function(e) {
	      transport.onError(e);
	    };
	  },
	
	  // Transport Event Handlers
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onOpen: function() {
	    this.connected = true;
	
	    this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');
	    // Clear reconnectTimer since we are not disconnected
	    if (this.reconnectTimer !== null) {
	      SIP.Timers.clearTimeout(this.reconnectTimer);
	      this.reconnectTimer = null;
	    }
	    // Reset reconnection_attempts
	    this.reconnection_attempts = 0;
	    // Disable closed
	    this.closed = false;
	    // Trigger onTransportConnected callback
	    this.ua.onTransportConnected(this);
	    // Start sending keep-alives
	    this.startSendingKeepAlives();
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onClose: function(e) {
	    var connected_before = this.connected;
	
	    this.lastTransportError.code = e.code;
	    this.lastTransportError.reason = e.reason;
	
	    this.stopSendingKeepAlives();
	
	    if (this.reconnection_attempts > 0) {
	      this.logger.log('Reconnection attempt ' + this.reconnection_attempts + ' failed (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	      this.reconnect();
	    } else {
	      this.connected = false;
	      this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');
	
	      if(e.wasClean === false) {
	        this.logger.warn('WebSocket abrupt disconnection');
	      }
	      // Transport was connected
	      if(connected_before === true) {
	        this.ua.onTransportClosed(this);
	        // Check whether the user requested to close.
	        if(!this.closed) {
	          this.reconnect();
	        } else {
	          this.ua.emit('disconnected', {
	            transport: this,
	            code: this.lastTransportError.code,
	            reason: this.lastTransportError.reason
	          });
	
	        }
	      } else {
	        // This is the first connection attempt
	        //Network error
	        this.ua.onTransportError(this);
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onMessage: function(e) {
	    var message, transaction,
	      data = e.data;
	
	    // CRLF Keep Alive response from server. Ignore it.
	    if(data === '\r\n') {
	      SIP.Timers.clearTimeout(this.keepAliveTimeout);
	      this.keepAliveTimeout = null;
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket message with CRLF Keep Alive response');
	      }
	
	      return;
	    }
	
	    // WebSocket binary message.
	    else if (typeof data !== 'string') {
	      try {
	        data = String.fromCharCode.apply(null, new Uint8Array(data));
	      } catch(evt) {
	        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
	        return;
	      }
	
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket binary message:\n\n' + data + '\n');
	      }
	    }
	
	    // WebSocket text message.
	    else {
	      if (this.ua.configuration.traceSip === true) {
	        this.logger.log('received WebSocket text message:\n\n' + data + '\n');
	      }
	    }
	
	    message = SIP.Parser.parseMessage(data, this.ua);
	
	    if (!message) {
	      return;
	    }
	
	    if(this.ua.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {
	      return;
	    }
	
	    // Do some sanity check
	    if(SIP.sanityCheck(message, this.ua, this)) {
	      if(message instanceof SIP.IncomingRequest) {
	        message.transport = this;
	        this.ua.receiveRequest(message);
	      } else if(message instanceof SIP.IncomingResponse) {
	        /* Unike stated in 18.1.2, if a response does not match
	        * any transaction, it is discarded here and no passed to the core
	        * in order to be discarded there.
	        */
	        switch(message.method) {
	          case SIP.C.INVITE:
	            transaction = this.ua.transactions.ict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	          case SIP.C.ACK:
	            // Just in case ;-)
	            break;
	          default:
	            transaction = this.ua.transactions.nict[message.via_branch];
	            if(transaction) {
	              transaction.receiveResponse(message);
	            }
	            break;
	        }
	      }
	    }
	  },
	
	  /**
	  * @event
	  * @param {event} e
	  */
	  onError: function(e) {
	    this.logger.warn('WebSocket connection error: ' + JSON.stringify(e));
	  },
	
	  /**
	  * Reconnection attempt logic.
	  * @private
	  */
	  reconnect: function() {
	    var transport = this;
	
	    this.reconnection_attempts += 1;
	
	    if(this.reconnection_attempts > this.ua.configuration.wsServerMaxReconnection) {
	      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
	      this.ua.onTransportError(this);
	    } else if (this.reconnection_attempts === 1) {
	      this.logger.log('Connection to WebSocket ' + this.server.ws_uri + ' severed, attempting first reconnect');
	      transport.connect();
	    } else {
	      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');
	
	      this.reconnectTimer = SIP.Timers.setTimeout(function() {
	        transport.connect();
	        transport.reconnectTimer = null;
	      }, this.ua.configuration.wsServerReconnectionTimeout * 1000);
	    }
	  }
	};
	
	Transport.C = C;
	return Transport;
	};


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBiZmZiYWQwZGE3MzFmOWVmOWUwYiIsIndlYnBhY2s6Ly8vLi9zcmMvcmMtcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2FkZC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yaW5nY2VudHJhbC9idWlsZC9yaW5nY2VudHJhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpbmdjZW50cmFsLWNsaWVudC9idWlsZC9yaW5nY2VudHJhbC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9yYy1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9zeW1ib2wtbWFwLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3JlZHV4LWhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qva2V5cy9pcy1pbXBsZW1lbnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL2lzLWltcGxlbWVudGVkLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzIiwid2VicGFjazovLy8uL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc2V0dGluZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYnJhbmQvYnJhbmQtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2xvZ2luLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9zdWJzY3JpcHRpb24tYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdWJzY3JpcHRpb24vc3Vic2NyaXB0aW9uLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdXNlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL3dlYnBob25lLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9jYWxsLXJlZHVjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzIiwid2VicGFjazovLy8uL34vcmluZ2NlbnRyYWwtd2ViLXBob25lL3NyYy9yaW5nY2VudHJhbC13ZWItcGhvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9TSVAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9FeGNlcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9UaW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU0lQTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVVJJLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2dzLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVxdWVzdFNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvUmVnaXN0ZXJDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0NsaWVudENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1NlcnZlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1Nlc3Npb24vRFRNRi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9XZWJSVEMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYUhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL1VBLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9IYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvU2FuaXR5Q2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyLmpzIiwid2VicGFjazovLy8uL34vc2lwLmpzL3NyYy9HcmFtbWFyL2Rpc3QvR3JhbW1hci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NpcC5qcy9zcmMvVHJhbnNwb3J0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLEtBQU0sVUFBVSx1QkFBaEI7O0FBRUEsVUFBUywyQkFBVCxHQUF1QztBQUNyQyxPQUFNLFdBQVcsbUJBQWpCO0FBQ0EsVUFBTyxDQUNMLFVBQUMsRUFBRDtBQUFBLFlBQVEsU0FBUyxHQUFULENBQWEsRUFBYixDQUFSO0FBQUEsSUFESyxFQUVMLFVBQUMsS0FBRDtBQUFBLFlBQVcsU0FBUyxPQUFULENBQWlCO0FBQUEsY0FBTSxHQUFHLEtBQUgsQ0FBTjtBQUFBLE1BQWpCLENBQVg7QUFBQSxJQUZLLENBQVA7QUFJRDs7S0FFb0IsTzs7O0FBQ25CLDBCQU9HO0FBQUEsU0FORCxvQkFNQyxRQU5ELG9CQU1DO0FBQUEsU0FMRCxRQUtDLFFBTEQsUUFLQztBQUFBLFNBSkQsWUFJQyxRQUpELFdBSUM7QUFBQSw0QkFIRCxNQUdDO0FBQUEsU0FIRCxNQUdDLCtCQUhRLElBR1I7QUFBQSxTQUZELFdBRUMsUUFGRCxXQUVD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FB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QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsVUFBVTs7Ozs7OztBQ3RIdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDLDZCQUFxRDs7Ozs7OztBQzNIdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsU0FBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7O0FDbkZBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7Ozs7OytDQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVCx3QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFFBQVE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsUUFBUTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBLHNCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLHdDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQiwwQkFBMEIsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQSxPQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLG1FQUFtRTtBQUNwRztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsT0FBTTs7QUFFTjtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsbUVBQW1FO0FBQ3BHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFNBQVE7QUFDUjtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU07O0FBRU47QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWOztBQUVBLFNBQVE7QUFDUixPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMEUsVUFBVSxlQUFlLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDhGQUE4RjtBQUMvRjs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZLFdBQVcsYUFBYTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFLFVBQVUsWUFBWSxZQUFZO0FBQzVHO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLG9GQUFtRixRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkUsVUFBVSxZQUFZLFlBQVk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RSxVQUFVLFlBQVksWUFBWSxVQUFVLFVBQVU7QUFDbkk7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsK0VBQStFO0FBQzVGLGNBQWEsOEVBQThFO0FBQzNGLGNBQWEsZ0ZBQWdGO0FBQzdGLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7OztBQUdBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsbUdBQW1HO0FBQ2hILGNBQWEsaUdBQWlHO0FBQzlHLGNBQWE7QUFDYjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUM1U0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUMxRUE7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHOzs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2pIQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSCxxQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsV0FBVSxrQkFBa0I7QUFDNUIsV0FBVSxvQkFBb0I7QUFDOUIsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87O0FBRVA7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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UztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLEVBQUU7QUFDcEI7QUFDQTs7QUFFQSxtQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILHVFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUssbUJBQW1CLEVBQUU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyw2Q0FBNkM7QUFDbEQsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUF5QixpQkFBaUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxZQUFZO0FBQ3ZCLFlBQVcsT0FBTztBQUNsQixZQUFXLDhCQUE4QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1R0FBc0csVUFBVTs7QUFFaEg7QUFDQSxrRUFBaUUsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsNERBQTJELFVBQVU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0ZBQXFGLHFDQUFxQztBQUMxSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXdFO0FBQ3hFLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qix5QkFBeUIsR0FBRyx5QkFBeUI7QUFDbkYsMkNBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBLHVCQUFzQixrQkFBa0I7QUFDeEMsUUFBTztBQUNQO0FBQ0Esc0JBQXFCLGNBQWM7QUFDbkM7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULDhGQUE2RixxREFBcUQ7O0FBRWxKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzlqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLGlCQUFpQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxvQkFBb0I7QUFDL0IsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsY0FBYztBQUN6QixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNuT0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLG9CQUFvQjtBQUM5QixX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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLGNBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoicmluZ2NlbnRyYWwtanMtaW50ZWdyYXRpb24tY29tbW9ucy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlJjUGhvbmVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUmNQaG9uZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYmZmYmFkMGRhNzMxZjllZjllMGJcbiAqKi8iLCJpbXBvcnQgYWRkTW9kdWxlIGZyb20gJy4vbGliL2FkZC1tb2R1bGUnO1xuaW1wb3J0IFJpbmdDZW50cmFsIGZyb20gJ3JpbmdjZW50cmFsJztcbmltcG9ydCBSaW5nQ2VudHJhbENsaWVudCBmcm9tICdyaW5nY2VudHJhbC1jbGllbnQnO1xuXG5pbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi9saWIvcmMtbW9kdWxlJztcblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncyc7XG5pbXBvcnQgQnJhbmQgZnJvbSAnLi9tb2R1bGVzL2JyYW5kJztcbmltcG9ydCBBdXRoIGZyb20gJy4vbW9kdWxlcy9hdXRoJztcbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi9tb2R1bGVzL3N1YnNjcmlwdGlvbic7XG5pbXBvcnQgVXNlciBmcm9tICcuL21vZHVsZXMvdXNlcic7XG5pbXBvcnQgV2VicGhvbmUgZnJvbSAnLi9tb2R1bGVzL3dlYnBob25lJztcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycywgY3JlYXRlU3RvcmUgfSBmcm9tICdyZWR1eCc7XG5cbmNvbnN0IFJFRFVDRVIgPSBTeW1ib2woKTtcblxuZnVuY3Rpb24gZ2V0U3RvcmVSZWdpc3RlckFuZFJlc29sdmVyKCkge1xuICBjb25zdCBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIFtcbiAgICAoZm4pID0+IGhhbmRsZXJzLmFkZChmbiksXG4gICAgKHN0b3JlKSA9PiBoYW5kbGVycy5mb3JFYWNoKGZuID0+IGZuKHN0b3JlKSksXG4gIF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJjUGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBnZXRTdG9yZSxcbiAgICBzdGF0ZU1hcHBlcixcbiAgICBwcmVmaXggPSAncmMnLFxuICAgIHNka1NldHRpbmdzLFxuICAgIGRlZmF1bHRCcmFuZCxcbiAgfSkge1xuICAgIGxldCByZWdpc3RlciA9IHJlZ2lzdGVyU3RvcmVIYW5kbGVyO1xuICAgIGxldCByZXNvbHZlO1xuICAgIGlmICghcmVnaXN0ZXIpIHtcbiAgICAgIFtyZWdpc3RlciwgcmVzb2x2ZV0gPSBnZXRTdG9yZVJlZ2lzdGVyQW5kUmVzb2x2ZXIoKTtcbiAgICB9XG5cbiAgICBzdXBlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcixcbiAgICB9KTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnc2RrJywgbmV3IFJpbmdDZW50cmFsKHtcblxuICAgICAgY2FjaGVQcmVmaXg6IGAke3ByZWZpeH0tYCxcbiAgICAgIC4uLnNka1NldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgncGxhdGZvcm0nLCB0aGlzLnNkay5wbGF0Zm9ybSgpKTtcblxuICAgIHRoaXM6OmFkZE1vZHVsZSgnYXBpJywgbmV3IFJpbmdDZW50cmFsQ2xpZW50KHRoaXMuc2RrKSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ2F1dGgnLCBuZXcgQXV0aCh7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLmF1dGgsXG4gICAgICBwcmVmaXgsXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3NldHRpbmdzJywgbmV3IFNldHRpbmdzKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuc2V0dGluZ3MsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdkZWZhdWx0QnJhbmQnLCBuZXcgQnJhbmQoe1xuICAgICAgcmVnaXN0ZXJTdG9yZUhhbmRsZXI6IHJlZ2lzdGVyLFxuICAgICAgcHJlZml4OiBgJHtwcmVmaXh9LWRlZmF1bHRgLFxuICAgICAgc3RhdGVNYXBwZXI6IHN0YXRlID0+IHN0YXRlTWFwcGVyKHN0YXRlKS5kZWZhdWx0QnJhbmQsXG4gICAgICAuLi5kZWZhdWx0QnJhbmQsXG4gICAgfSkpO1xuXG4gICAgdGhpczo6YWRkTW9kdWxlKCdzdWJzY3JpcHRpb24nLCBuZXcgU3Vic2NyaXB0aW9uKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiBzdGF0ZSA9PiBzdGF0ZU1hcHBlcihzdGF0ZSkuc3Vic2NyaXB0aW9uLFxuICAgICAgcHJlZml4LFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgc2RrOiB0aGlzLnNkayxcbiAgICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3VzZXInLCBuZXcgVXNlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcjogcmVnaXN0ZXIsXG4gICAgICBzdGF0ZU1hcHBlcjogc3RhdGUgPT4gc3RhdGVNYXBwZXIoc3RhdGUpLnVzZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICB9KSk7XG5cbiAgICB0aGlzOjphZGRNb2R1bGUoJ3dlYnBob25lJywgbmV3IFdlYnBob25lKHtcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiByZWdpc3RlcixcbiAgICAgIHN0YXRlTWFwcGVyOiAoc3RhdGUpID0+IHN0YXRlTWFwcGVyKHN0YXRlKS53ZWJwaG9uZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgIH0pKTtcblxuICAgIC8vIGNvbWJpbmUgcmVkdWNlcnNcbiAgICB0aGlzW1JFRFVDRVJdID0gY29tYmluZVJlZHVjZXJzKHtcbiAgICAgIGF1dGg6IHRoaXMuYXV0aC5yZWR1Y2VyLFxuICAgICAgZGVmYXVsdEJyYW5kOiB0aGlzLmRlZmF1bHRCcmFuZC5yZWR1Y2VyLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLnN1YnNjcmlwdGlvbi5yZWR1Y2VyLFxuICAgICAgdXNlcjogdGhpcy51c2VyLnJlZHVjZXIsXG4gICAgICB3ZWJwaG9uZTogdGhpcy53ZWJwaG9uZS5yZWR1Y2VyLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MucmVkdWNlcixcbiAgICB9KTtcblxuICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGdldFN0b3JlKHRoaXMucmVkdWNlcikpO1xuICAgICAgLy8gcmVzb2x2ZShjcmVhdGVTdG9yZSh0aGlzLnJlZHVjZXIpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVEVUNFUl07XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3JjLXBob25lLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXHJcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXHJcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xyXG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xyXG5tb2R1bGUuZXhwb3J0cyA9IChcclxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xyXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcclxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcclxuICBPID0gdG9PYmplY3QoTyk7XHJcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XHJcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XHJcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XHJcbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xyXG5cclxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxyXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XHJcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcclxuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxyXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcclxuICAgICwgZ3QgICAgID0gJz4nXHJcbiAgICAsIGlmcmFtZURvY3VtZW50O1xyXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcclxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xyXG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xyXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcclxuICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPHNjcmlwdD5kb2N1bWVudC5GPU9iamVjdDwvc2NyaXB0JyArIGd0KTtcclxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xyXG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xyXG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcclxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcclxuICB2YXIgcmVzdWx0O1xyXG4gIGlmKE8gIT09IG51bGwpe1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xyXG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xyXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XHJcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXHJcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcclxuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xyXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xyXG4gIGFuT2JqZWN0KE8pO1xyXG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIFA7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xyXG4gIHJldHVybiBPO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcclxuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcclxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XHJcblxyXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlNldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXtcbiAgICBpZihzYWZlICYmIHRhcmdldFtrZXldKXRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWV0YSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGVhY2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICBpZighREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2U7XG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksZnVuY3Rpb24oS0VZKXtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZihLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSloaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxyXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXHJcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcclxuICB2YXIgQztcclxuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XHJcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XHJcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xyXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XHJcbiAgICBpZihpc09iamVjdChDKSl7XHJcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xyXG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZE1vZHVsZShuYW1lLCBtb2R1bGUpIHtcbiAgaWYgKHRoaXM6Ok9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG1vZHVsZSAnJHtuYW1lfScgYWxyZWFkeSBleGlzdHMuLi5gKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2FkZC1tb2R1bGUuanNcbiAqKi8iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKSwgcmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksIHJlcXVpcmUoXCJwdWJudWJcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoWywgLCBcInB1Ym51YlwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJTREtcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKSwgcmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksIHJlcXVpcmUoXCJwdWJudWJcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJpbmdDZW50cmFsXCJdID0gcm9vdFtcIlJpbmdDZW50cmFsXCJdIHx8IHt9LCByb290W1wiUmluZ0NlbnRyYWxcIl1bXCJTREtcIl0gPSBmYWN0b3J5KHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfVXRpbHMpO1xuXG52YXIgX0NhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9DYWNoZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWNoZSk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEV4dGVybmFscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9FeHRlcm5hbHMpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfQ2xpZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NsaWVudCk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbnZhciBfQ2xpZW50TW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgX0NsaWVudE1vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50TW9jayk7XG5cbnZhciBfTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9jayk7XG5cbnZhciBfUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9SZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWdpc3RyeSk7XG5cbnZhciBfUGxhdGZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9QbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QbGF0Zm9ybSk7XG5cbnZhciBfQXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0F1dGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXV0aCk7XG5cbnZhciBfUHVibnViRmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgX1B1Ym51YkZhY3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHVibnViRmFjdG9yeSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbik7XG5cbnZhciBfQ2FjaGVkU3Vic2NyaXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfQ2FjaGVkU3Vic2NyaXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NhY2hlZFN1YnNjcmlwdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTREsgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIFJpbmdDZW50cmFsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlUHJlZml4XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcHBTZWNyZXRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcEtleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwTmFtZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwVmVyc2lvbl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHVibnViRmFjdG9yeV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xpZW50XVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU0RLKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNESyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFFeHRlcm5hbHMuZmV0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmF0aXZlIEZldGNoIGlzIG1pc3NpbmcsIHNldCBSaW5nQ2VudHJhbC5TREsuY29yZS5FeHRlcm5hbHMuZmV0Y2ggdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFFeHRlcm5hbHMuUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgUHJvbWlzZSBpcyBtaXNzaW5nLCBzZXQgUmluZ0NlbnRyYWwuU0RLLmNvcmUuRXh0ZXJuYWxzLlByb21pc2UgdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgX0NhY2hlMi5kZWZhdWx0KEV4dGVybmFscy5sb2NhbFN0b3JhZ2UsIG9wdGlvbnMuY2FjaGVQcmVmaXgpO1xuXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IG9wdGlvbnMuY2xpZW50IHx8IG5ldyBfQ2xpZW50Mi5kZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBuZXcgX1BsYXRmb3JtMi5kZWZhdWx0KHRoaXMuX2NsaWVudCwgdGhpcy5fY2FjaGUsIG9wdGlvbnMuc2VydmVyLCBvcHRpb25zLmFwcEtleSwgb3B0aW9ucy5hcHBTZWNyZXQsIG9wdGlvbnMuYXBwTmFtZSwgb3B0aW9ucy5hcHBWZXJzaW9uLCBTREsudmVyc2lvbik7XG5cbiAgICAgICAgdGhpcy5fcHVibnViRmFjdG9yeSA9IG9wdGlvbnMucHVibnViRmFjdG9yeSB8fCBFeHRlcm5hbHMuUFVCTlVCO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1BsYXRmb3JtfVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLnBsYXRmb3JtID0gZnVuY3Rpb24gcGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfU3Vic2NyaXB0aW9uMi5kZWZhdWx0KHRoaXMuX3B1Ym51YkZhY3RvcnksIHRoaXMuX3BsYXRmb3JtKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2FjaGVkU3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNyZWF0ZUNhY2hlZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUNhY2hlZFN1YnNjcmlwdGlvbihjYWNoZUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IF9DYWNoZWRTdWJzY3JpcHRpb24yLmRlZmF1bHQodGhpcy5fcHVibnViRmFjdG9yeSwgdGhpcy5fcGxhdGZvcm0sIHRoaXMuX2NhY2hlLCBjYWNoZUtleSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0NhY2hlfVxuICAgICAqL1xuXG5cbiAgICBTREsucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gY2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9O1xuXG4gICAgU0RLLmhhbmRsZUxvZ2luUmVkaXJlY3QgPSBmdW5jdGlvbiBoYW5kbGVMb2dpblJlZGlyZWN0KG9yaWdpbikge1xuICAgICAgICB3aW5kb3cub3BlbmVyLnBvc3RNZXNzYWdlKHsgUkNBdXRob3JpemF0aW9uQ29kZTogd2luZG93LmxvY2F0aW9uLnNlYXJjaCB9LCBvcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgfTtcblxuICAgIHJldHVybiBTREs7XG59KCk7XG5cblNESy52ZXJzaW9uID0gIHRydWUgPyAoXCIzLjAuMC1yYzFcIikgOiAneC54LngnO1xuU0RLLnNlcnZlciA9IHtcbiAgICBzYW5kYm94OiAnaHR0cHM6Ly9wbGF0Zm9ybS5kZXZ0ZXN0LnJpbmdjZW50cmFsLmNvbScsXG4gICAgcHJvZHVjdGlvbjogJ2h0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tJ1xufTtcblNESy5jb3JlID0ge1xuICAgIENhY2hlOiBfQ2FjaGUyLmRlZmF1bHQsXG4gICAgRXZlbnRFbWl0dGVyOiBfZXZlbnRzMi5kZWZhdWx0LFxuICAgIFV0aWxzOiBVdGlscyxcbiAgICBFeHRlcm5hbHM6IEV4dGVybmFsc1xufTtcblNESy5odHRwID0ge1xuICAgIENsaWVudDogX0NsaWVudDIuZGVmYXVsdCxcbiAgICBBcGlSZXNwb25zZTogX0FwaVJlc3BvbnNlMi5kZWZhdWx0XG59O1xuU0RLLnBsYXRmb3JtID0ge1xuICAgIEF1dGg6IF9BdXRoMi5kZWZhdWx0LFxuICAgIFBsYXRmb3JtOiBfUGxhdGZvcm0yLmRlZmF1bHRcbn07XG5TREsuc3Vic2NyaXB0aW9uID0ge1xuICAgIFN1YnNjcmlwdGlvbjogX1N1YnNjcmlwdGlvbjIuZGVmYXVsdFxufTtcblNESy5tb2NrcyA9IHtcbiAgICBDbGllbnQ6IF9DbGllbnRNb2NrMi5kZWZhdWx0LFxuICAgIFJlZ2lzdHJ5OiBfUmVnaXN0cnkyLmRlZmF1bHQsXG4gICAgTW9jazogX01vY2syLmRlZmF1bHRcbn07XG5TREsucHVibnViID0ge1xuICAgIFB1Ym51Yk1vY2tGYWN0b3J5OiBfUHVibnViRmFjdG9yeTIuZGVmYXVsdFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNESztcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudFxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oaW52b2tlTmV4dCwgaW52b2tlVGhyb3cpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSBhcmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMucXVlcnlTdHJpbmdpZnkgPSBxdWVyeVN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmc7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNPYmplY3RPYmplY3QgPSBpc09iamVjdE9iamVjdDtcbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5leHBvcnRzLmlzTm9kZUpTID0gaXNOb2RlSlM7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vKipcbiAqIFRPRE8gUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9xdWVyeXN0cmluZy5qc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5naWZ5KHBhcmFtZXRlcnMpIHtcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cbiAgICAgICAgdmFyIHYgPSBwYXJhbWV0ZXJzW2tdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2LmZvckVhY2goZnVuY3Rpb24gKHZ2KSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodnYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXkucHVzaChlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJyYXkuam9pbignJicpO1xufVxuXG4vKipcbiAqIFRPRE8gUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBiZXR0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9xdWVyeXN0cmluZy5qc1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5U3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5U3RyaW5nKSB7XG5cbiAgICB2YXIgYXJnc1BhcnNlZCA9IHt9O1xuXG4gICAgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcblxuICAgICAgICBhcmcgPSBkZWNvZGVVUklDb21wb25lbnQoYXJnKTtcblxuICAgICAgICBpZiAoYXJnLmluZGV4T2YoJz0nKSA9PSAtMSkge1xuXG4gICAgICAgICAgICBhcmdzUGFyc2VkW2FyZy50cmltKCldID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIHBhaXIgPSBhcmcuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBwYWlyWzBdLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5IGluIGFyZ3NQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGFyZ3NQYXJzZWQgJiYgIWlzQXJyYXkoYXJnc1BhcnNlZFtrZXldKSkgYXJnc1BhcnNlZFtrZXldID0gW2FyZ3NQYXJzZWRba2V5XV07XG4gICAgICAgICAgICAgICAgYXJnc1BhcnNlZFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzUGFyc2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyZ3NQYXJzZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiB0eXBlb2Ygb2JqID09PSBcImFycmF5XCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgICByZXR1cm4gbyAhPSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobykpID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShvKTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICAgIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgICB2YXIgY3RvciwgcHJvdDtcblxuICAgIGlmIChpc09iamVjdE9iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICAgIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0eXBlb2YgY3RvciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICAgIHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgICBpZiAoaXNPYmplY3RPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSlMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gZGVsYXkodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2FsU3RvcmFnZSA9IGV4cG9ydHMuUFVCTlVCID0gZXhwb3J0cy5IZWFkZXJzID0gZXhwb3J0cy5SZXNwb25zZSA9IGV4cG9ydHMuUmVxdWVzdCA9IGV4cG9ydHMuZmV0Y2ggPSBleHBvcnRzLlByb21pc2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXM2UHJvbWlzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfZXM2UHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lczZQcm9taXNlKTtcblxudmFyIF9ub2RlRmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX25vZGVGZXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlRmV0Y2gpO1xuXG52YXIgX3B1Ym51YiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfcHVibnViMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3B1Ym51Yik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpcztcIikoKTtcblxudmFyIFByb21pc2UgPSBfZXM2UHJvbWlzZTIuZGVmYXVsdCAmJiBfZXM2UHJvbWlzZTIuZGVmYXVsdC5Qcm9taXNlIHx8IHJvb3QuUHJvbWlzZTtcblxudmFyIGZldGNoID0gX25vZGVGZXRjaDIuZGVmYXVsdCAmJiB0eXBlb2YgX25vZGVGZXRjaDIuZGVmYXVsdCA9PSAnZnVuY3Rpb24nID8gX25vZGVGZXRjaDIuZGVmYXVsdCA6IHJvb3QuZmV0Y2g7XG52YXIgUmVxdWVzdCA9IGZldGNoLlJlcXVlc3QgfHwgcm9vdC5SZXF1ZXN0O1xudmFyIFJlc3BvbnNlID0gZmV0Y2guUmVzcG9uc2UgfHwgcm9vdC5SZXNwb25zZTtcbnZhciBIZWFkZXJzID0gZmV0Y2guSGVhZGVycyB8fCByb290LkhlYWRlcnM7XG5cbnZhciBQVUJOVUIgPSBfcHVibnViMi5kZWZhdWx0IHx8IHJvb3QuUFVCTlVCO1xuXG52YXIgbG9jYWxTdG9yYWdlID0gdHlwZW9mIHJvb3QubG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyA/IHJvb3QubG9jYWxTdG9yYWdlIDoge307XG5cbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2U7XG5leHBvcnRzLmZldGNoID0gZmV0Y2g7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUFVCTlVCID0gUFVCTlVCO1xuZXhwb3J0cy5sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2U7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fO1xuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FjaGUoc3RvcmFnZSwgcHJlZml4KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZSk7XG5cbiAgICAgICAgdGhpcy5zZXRQcmVmaXgocHJlZml4KTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgfVxuXG4gICAgQ2FjaGUucHJvdG90eXBlLnNldFByZWZpeCA9IGZ1bmN0aW9uIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5fcHJlZml4ID0gcHJlZml4IHx8IENhY2hlLmRlZmF1bHRQcmVmaXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIHNldEl0ZW0oa2V5LCBkYXRhKSB7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2VbdGhpcy5fcHJlZml4S2V5KGtleSldID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBDYWNoZS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9zdG9yYWdlW3RoaXMuX3ByZWZpeEtleShrZXkpXTtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaXRlbSk7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKCkge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKHRoaXMuX3ByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENhY2hlLnByb3RvdHlwZS5fcHJlZml4S2V5ID0gZnVuY3Rpb24gX3ByZWZpeEtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhY2hlO1xufSgpO1xuXG5DYWNoZS5kZWZhdWx0UHJlZml4ID0gJ3JjLSc7XG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZTtcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmZpbmRIZWFkZXJOYW1lID0gZmluZEhlYWRlck5hbWU7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxudmFyIF9BcGlSZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX0FwaVJlc3BvbnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FwaVJlc3BvbnNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhDbGllbnQsIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICAgICAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnQpO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwuYXBwbHkoX0V2ZW50RW1pdHRlciwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6ICdiZWZvcmVSZXF1ZXN0JyxcbiAgICAgICAgICAgIHJlcXVlc3RTdWNjZXNzOiAncmVxdWVzdFN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVxdWVzdEVycm9yOiAncmVxdWVzdEVycm9yJ1xuICAgICAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuICAgIENsaWVudC5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgYXBpUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVzcG9uc2UgPSBuZXcgX0FwaVJlc3BvbnNlMi5kZWZhdWx0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU3RvcCByZXF1ZXN0IGlmIGxpc3RlbmVycyByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMuYmVmb3JlUmVxdWVzdCwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRSZXNwb25zZShyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlLl9yZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlc3BvbnNlLl9pbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBpUmVzcG9uc2Uub2soKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaGFzIHVuc3VjY2Vzc2Z1bCBzdGF0dXMnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZXF1ZXN0U3VjY2VzcywgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcGlSZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dC50MC5hcGlSZXNwb25zZSkgX2NvbnRleHQudDAgPSB0aGlzLm1ha2VFcnJvcihfY29udGV4dC50MCwgYXBpUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlcXVlc3RFcnJvciwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwgMTRdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kUmVxdWVzdChfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBDbGllbnQucHJvdG90eXBlLl9sb2FkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfRXh0ZXJuYWxzLmZldGNoLmNhbGwobnVsbCwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkUmVzcG9uc2UoX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbG9hZFJlc3BvbnNlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoZSBKUyBFcnJvciBvYmplY3Qgd2l0aCB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3J8SUFwaUVycm9yfSBlXG4gICAgICogQHBhcmFtIHtBcGlSZXNwb25zZX0gYXBpUmVzcG9uc2VcbiAgICAgKiBAcmV0dXJuIHtJQXBpRXJyb3J9XG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUubWFrZUVycm9yID0gZnVuY3Rpb24gbWFrZUVycm9yKGUsIGFwaVJlc3BvbnNlKSB7XG5cbiAgICAgICAgLy8gV3JhcCBvbmx5IGlmIHJlZ3VsYXIgZXJyb3JcbiAgICAgICAgaWYgKCFlLmhhc093blByb3BlcnR5KCdhcGlSZXNwb25zZScpICYmICFlLmhhc093blByb3BlcnR5KCdvcmlnaW5hbE1lc3NhZ2UnKSkge1xuXG4gICAgICAgICAgICBlLmFwaVJlc3BvbnNlID0gYXBpUmVzcG9uc2U7XG4gICAgICAgICAgICBlLm9yaWdpbmFsTWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgIGUubWVzc2FnZSA9IGFwaVJlc3BvbnNlICYmIGFwaVJlc3BvbnNlLmVycm9yKHRydWUpIHx8IGUub3JpZ2luYWxNZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluaXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2luaXQudXJsXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5ib2R5XVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaW5pdC5tZXRob2RdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtpbml0LnF1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaW5pdC5oZWFkZXJzXVxuICAgICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAgICovXG5cblxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoaW5pdCkge1xuXG4gICAgICAgIGluaXQgPSBpbml0IHx8IHt9O1xuICAgICAgICBpbml0LmhlYWRlcnMgPSBpbml0LmhlYWRlcnMgfHwge307XG5cbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrc1xuICAgICAgICBpZiAoIWluaXQudXJsKSB0aHJvdyBuZXcgRXJyb3IoJ1VybCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICBpZiAoIWluaXQubWV0aG9kKSBpbml0Lm1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBpZiAoaW5pdC5tZXRob2QgJiYgQ2xpZW50Ll9hbGxvd2VkTWV0aG9kcy5pbmRleE9mKGluaXQubWV0aG9kLnRvVXBwZXJDYXNlKCkpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgaGFzIHdyb25nIHZhbHVlOiAnICsgaW5pdC5tZXRob2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgaW5pdC5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHMgfHwgJ2luY2x1ZGUnO1xuICAgICAgICBpbml0Lm1vZGUgPSBpbml0Lm1vZGUgfHwgJ2NvcnMnO1xuXG4gICAgICAgIC8vIEFwcGVuZCBRdWVyeSBTdHJpbmdcbiAgICAgICAgaWYgKGluaXQucXVlcnkpIHtcbiAgICAgICAgICAgIGluaXQudXJsID0gaW5pdC51cmwgKyAoaW5pdC51cmwuaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPycpICsgKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoaW5pdC5xdWVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpbmRIZWFkZXJOYW1lKCdBY2NlcHQnLCBpbml0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICBpbml0LmhlYWRlcnNbJ0FjY2VwdCddID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXJpYWxpemUgYm9keVxuICAgICAgICBpZiAoKDAsIF9VdGlscy5pc1BsYWluT2JqZWN0KShpbml0LmJvZHkpIHx8ICFpbml0LmJvZHkpIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyTmFtZSA9IGZpbmRIZWFkZXJOYW1lKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fY29udGVudFR5cGUsIGluaXQuaGVhZGVycyk7XG5cbiAgICAgICAgICAgIGlmICghY29udGVudFR5cGVIZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVIZWFkZXJOYW1lID0gX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBpbml0LmhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJOYW1lXSA9IF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fanNvbkNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBpbml0LmhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJOYW1lXTtcblxuICAgICAgICAgICAgLy8gQXNzaWduIGEgbmV3IGVuY29kZWQgYm9keVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShpbml0LmJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50VHlwZS5pbmRleE9mKF9BcGlSZXNwb25zZTIuZGVmYXVsdC5fdXJsZW5jb2RlZENvbnRlbnRUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5ib2R5ID0gKDAsIF9VdGlscy5xdWVyeVN0cmluZ2lmeSkoaW5pdC5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHJlcXVlc3Qgd2l0aCBlbmNvZGVkIGJvZHlcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBfRXh0ZXJuYWxzLlJlcXVlc3QoaW5pdC51cmwsIGluaXQpO1xuXG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIGJvZHkgYWNjZXNzaWJsZSBkaXJlY3RseSAoZm9yIG1vY2tzKVxuICAgICAgICByZXEub3JpZ2luYWxCb2R5ID0gaW5pdC5ib2R5O1xuXG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfTtcblxuICAgIHJldHVybiBDbGllbnQ7XG59KF9ldmVudHMyLmRlZmF1bHQpO1xuXG5DbGllbnQuX2FsbG93ZWRNZXRob2RzID0gWydHRVQnLCAnUE9TVCcsICdQVVQnLCAnREVMRVRFJywgJ1BBVENIJywgJ09QVElPTlMnLCAnSEVBRCddO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuZnVuY3Rpb24gZmluZEhlYWRlck5hbWUobmFtZSwgaGVhZGVycykge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBrZXkpIHtcbiAgICAgICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICAgICAgaWYgKG5hbWUgPT0ga2V5LnRvTG93ZXJDYXNlKCkpIHJldHVybiBrZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgbnVsbCk7XG59XG5cbi8qKlxuICogQG5hbWUgSUFwaUVycm9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhY2tcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW5hbE1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7QXBpUmVzcG9uc2V9IGFwaVJlc3BvbnNlXG4gKi9cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IF9FeHRlcm5hbHMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIF9FeHRlcm5hbHMuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBcGlSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVGV4dFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQXBpUmVzcG9uc2UocmVxdWVzdCwgcmVzcG9uc2UsIHJlc3BvbnNlVGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBpUmVzcG9uc2UpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7UmVxdWVzdH0gKi9cbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtSZXNwb25zZX0gKi9cbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSByZXNwb25zZTtcblxuICAgICAgICB0aGlzLl90ZXh0ID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICB0aGlzLl9qc29uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXVsdGlwYXJ0ID0gW107XG4gICAgfVxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5faXNNdWx0aXBhcnQoKSB8fCB0aGlzLl9pc0pzb24oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlKCkudGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2luaXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UmVzcG9uc2V9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5yZXNwb25zZSA9IGZ1bmN0aW9uIHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uIG9rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uub2s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSnNvbigpICYmICF0aGlzLl9pc011bHRpcGFydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGlzIG5vdCB0ZXh0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cblxuICAgIEFwaVJlc3BvbnNlLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24ganNvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0pzb24oKSkgdGhyb3cgbmV3IEVycm9yKCdSZXNwb25zZSBpcyBub3QgSlNPTicpO1xuICAgICAgICBpZiAoIXRoaXMuX2pzb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2pzb24gPSB0aGlzLl90ZXh0ID8gSlNPTi5wYXJzZSh0aGlzLl90ZXh0KSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pzb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbc2tpcE9LQ2hlY2tdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihza2lwT0tDaGVjaykge1xuXG4gICAgICAgIGlmICh0aGlzLm9rKCkgJiYgIXNraXBPS0NoZWNrKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9ICh0aGlzLl9yZXNwb25zZSAmJiB0aGlzLl9yZXNwb25zZS5zdGF0dXMgPyB0aGlzLl9yZXNwb25zZS5zdGF0dXMgKyAnICcgOiAnJykgKyAodGhpcy5fcmVzcG9uc2UgJiYgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzVGV4dCA/IHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1RleHQgOiAnJyk7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLm1lc3NhZ2UpIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuanNvbigpLmVycm9yX2Rlc2NyaXB0aW9uKSBtZXNzYWdlID0gdGhpcy5qc29uKCkuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uKCkuZGVzY3JpcHRpb24pIG1lc3NhZ2UgPSB0aGlzLmpzb24oKS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXBpUmVzcG9uc2VbXX1cbiAgICAgKi9cblxuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIG11bHRpcGFydCgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzTXVsdGlwYXJ0KCkpIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgbm90IG11bHRpcGFydCcpO1xuXG4gICAgICAgIGlmICghdGhpcy5fbXVsdGlwYXJ0Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBTdGVwIDEuIFNwbGl0IG11bHRpcGFydCByZXNwb25zZVxuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoIXRleHQpIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuXG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSB0aGlzLl9nZXRDb250ZW50VHlwZSgpLm1hdGNoKC9ib3VuZGFyeT0oW147XSspL2kpWzFdO1xuXG4gICAgICAgICAgICBpZiAoIWJvdW5kYXJ5KSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGJvdW5kYXJ5Jyk7XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRleHQudG9TdHJpbmcoKS5zcGxpdChBcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IgKyBib3VuZGFyeSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1swXS50cmltKCkgPT09ICcnKSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRyaW0oKSA9PSBBcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IpIHBhcnRzLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJ0cyBpbiBib2R5Jyk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMi4gUGFyc2Ugc3RhdHVzIGluZm9cblxuICAgICAgICAgICAgdmFyIHN0YXR1c0luZm8gPSBBcGlSZXNwb25zZS5jcmVhdGUocGFydHMuc2hpZnQoKSwgdGhpcy5fcmVzcG9uc2Uuc3RhdHVzLCB0aGlzLl9yZXNwb25zZS5zdGF0dXNUZXh0KS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMy4gUGFyc2UgYWxsIG90aGVyIHBhcnRzXG5cbiAgICAgICAgICAgIHRoaXMuX211bHRpcGFydCA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHN0YXR1c0luZm8ucmVzcG9uc2VbaV0uc3RhdHVzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFwaVJlc3BvbnNlLmNyZWF0ZShwYXJ0LCBzdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbXVsdGlwYXJ0O1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2lzQ29udGVudFR5cGUgPSBmdW5jdGlvbiBfaXNDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudFR5cGUoKS5pbmRleE9mKGNvbnRlbnRUeXBlKSA+IC0xO1xuICAgIH07XG5cbiAgICBBcGlSZXNwb25zZS5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlID0gZnVuY3Rpb24gX2dldENvbnRlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UuaGVhZGVycy5nZXQoQXBpUmVzcG9uc2UuX2NvbnRlbnRUeXBlKSB8fCAnJztcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc011bHRpcGFydCA9IGZ1bmN0aW9uIF9pc011bHRpcGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ29udGVudFR5cGUoQXBpUmVzcG9uc2UuX211bHRpcGFydENvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc1VybEVuY29kZWQgPSBmdW5jdGlvbiBfaXNVcmxFbmNvZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fdXJsZW5jb2RlZENvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgQXBpUmVzcG9uc2UucHJvdG90eXBlLl9pc0pzb24gPSBmdW5jdGlvbiBfaXNKc29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDb250ZW50VHlwZShBcGlSZXNwb25zZS5fanNvbkNvbnRlbnRUeXBlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIEFwaVJlc3BvbnNlIG9iamVjdCBmcm9tIHN0cmluZyBwYXJ0cyBvZiBtdWx0aXBhcnQvbWl4ZWQgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGF0dXNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0dXNUZXh0XVxuICAgICAqIEByZXR1cm4ge0FwaVJlc3BvbnNlfVxuICAgICAqL1xuXG5cbiAgICBBcGlSZXNwb25zZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUodGV4dCwgc3RhdHVzLCBzdGF0dXNUZXh0KSB7XG5cbiAgICAgICAgdGV4dCA9IHRleHQgfHwgJyc7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyB8fCAyMDA7XG4gICAgICAgIHN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8ICdPSyc7XG5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyL2csICcnKTtcblxuICAgICAgICB2YXIgaGVhZGVycyA9IG5ldyBfRXh0ZXJuYWxzLkhlYWRlcnMoKSxcbiAgICAgICAgICAgIGhlYWRlcnNBbmRCb2R5ID0gdGV4dC5zcGxpdChBcGlSZXNwb25zZS5fYm9keVNlcGFyYXRvciksXG4gICAgICAgICAgICBoZWFkZXJzVGV4dCA9IGhlYWRlcnNBbmRCb2R5Lmxlbmd0aCA+IDEgPyBoZWFkZXJzQW5kQm9keS5zaGlmdCgpIDogJyc7XG5cbiAgICAgICAgdGV4dCA9IGhlYWRlcnNBbmRCb2R5Lmxlbmd0aCA+IDAgPyBoZWFkZXJzQW5kQm9keS5qb2luKEFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yKSA6IG51bGw7XG5cbiAgICAgICAgKGhlYWRlcnNUZXh0IHx8ICcnKS5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKCksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzcGxpdC5qb2luKEFwaVJlc3BvbnNlLl9oZWFkZXJTZXBhcmF0b3IpLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKGtleSkgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgQXBpUmVzcG9uc2UobnVsbCwgbmV3IF9FeHRlcm5hbHMuUmVzcG9uc2UodGV4dCA/IHRleHQgOiB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHRcbiAgICAgICAgfSksIHRleHQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXBpUmVzcG9uc2U7XG59KCk7XG5cbkFwaVJlc3BvbnNlLl9jb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnO1xuQXBpUmVzcG9uc2UuX2pzb25Db250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbkFwaVJlc3BvbnNlLl9tdWx0aXBhcnRDb250ZW50VHlwZSA9ICdtdWx0aXBhcnQvbWl4ZWQnO1xuQXBpUmVzcG9uc2UuX3VybGVuY29kZWRDb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuQXBpUmVzcG9uc2UuX2hlYWRlclNlcGFyYXRvciA9ICc6JztcbkFwaVJlc3BvbnNlLl9ib2R5U2VwYXJhdG9yID0gJ1xcblxcbic7XG5BcGlSZXNwb25zZS5fYm91bmRhcnlTZXBhcmF0b3IgPSAnLS0nO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBpUmVzcG9uc2U7XG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9SZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX1JlZ2lzdHJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZ2lzdHJ5KTtcblxudmFyIF9DbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9DbGllbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2xpZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiAoX0h0dHBDbGllbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2xpZW50LCBfSHR0cENsaWVudCk7XG5cbiAgICBmdW5jdGlvbiBDbGllbnQoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9IdHRwQ2xpZW50LmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLl9yZWdpc3RyeSA9IG5ldyBfUmVnaXN0cnkyLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENsaWVudC5wcm90b3R5cGUucmVnaXN0cnkgPSBmdW5jdGlvbiByZWdpc3RyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5O1xuICAgIH07XG5cbiAgICBDbGllbnQucHJvdG90eXBlLl9sb2FkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgbW9jaztcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2NrID0gdGhpcy5fcmVnaXN0cnkuZmluZChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9jay5nZXRSZXNwb25zZShyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9sb2FkUmVzcG9uc2UoX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xvYWRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICByZXR1cm4gQ2xpZW50O1xufShfQ2xpZW50Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpZW50O1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfTW9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01vY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW9jayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdpc3RyeSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZ2lzdHJ5KTtcblxuICAgICAgICB0aGlzLl9tb2NrcyA9IFtdO1xuICAgIH1cblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobW9jaykge1xuICAgICAgICB0aGlzLl9tb2Nrcy5wdXNoKG1vY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21vY2tzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQocmVxdWVzdCkge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1JlZ2lzdHJ5IGlzIGxvb2tpbmcgZm9yJywgcmVxdWVzdCk7XG5cbiAgICAgICAgdmFyIG1vY2sgPSB0aGlzLl9tb2Nrcy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICghbW9jaykgdGhyb3cgbmV3IEVycm9yKCdObyBtb2NrIGluIHJlZ2lzdHJ5IGZvciByZXF1ZXN0ICcgKyByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsKTtcblxuICAgICAgICBpZiAoIW1vY2sudGVzdChyZXF1ZXN0KSkgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZXF1ZXN0ICcgKyByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsICsgJyBmb3IgZXhwZWN0ZWQgbW9jayAnICsgbW9jay5tZXRob2QoKSArICcgJyArIG1vY2sucGF0aCgpKTtcblxuICAgICAgICByZXR1cm4gbW9jaztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLmFwaUNhbGwgPSBmdW5jdGlvbiBhcGlDYWxsKG1ldGhvZCwgcGF0aCwgcmVzcG9uc2UsIHN0YXR1cywgc3RhdHVzVGV4dCwgZGVsYXkpIHtcblxuICAgICAgICB0aGlzLmFkZChuZXcgX01vY2syLmRlZmF1bHQobWV0aG9kLCBwYXRoLCByZXNwb25zZSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuYXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBhdXRoZW50aWNhdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJzogJ0FDQ0VTU19UT0tFTicsXG4gICAgICAgICAgICAndG9rZW5fdHlwZSc6ICdiZWFyZXInLFxuICAgICAgICAgICAgJ2V4cGlyZXNfaW4nOiAzNjAwLFxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiAnUkVGUkVTSF9UT0tFTicsXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbl9leHBpcmVzX2luJzogNjA0ODAsXG4gICAgICAgICAgICAnc2NvcGUnOiAnU01TIFJDTSBGb28gQm9vJyxcbiAgICAgICAgICAgICdleHBpcmVUaW1lJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAzNjAwMDAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gbG9nb3V0KCkge1xuXG4gICAgICAgIHRoaXMuYXBpQ2FsbCgnUE9TVCcsICcvcmVzdGFwaS9vYXV0aC9yZXZva2UnLCB7fSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS5wcmVzZW5jZUxvYWQgPSBmdW5jdGlvbiBwcmVzZW5jZUxvYWQoaWQpIHtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vJyArIGlkICsgJy9wcmVzZW5jZScsIHtcbiAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL2FjY291bnQvMTIzL2V4dGVuc2lvbi9cIiArIGlkICsgXCIvcHJlc2VuY2VcIixcbiAgICAgICAgICAgIFwiZXh0ZW5zaW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tL3Jlc3RhcGkvdjEuMC9hY2NvdW50LzEyMy9leHRlbnNpb24vXCIgKyBpZCxcbiAgICAgICAgICAgICAgICBcImlkXCI6IGlkLFxuICAgICAgICAgICAgICAgIFwiZXh0ZW5zaW9uTnVtYmVyXCI6IFwiMTAxXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFjdGl2ZUNhbGxzXCI6IFtdLFxuICAgICAgICAgICAgXCJwcmVzZW5jZVN0YXR1c1wiOiBcIkF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgXCJ0ZWxlcGhvbnlTdGF0dXNcIjogXCJSaW5naW5nXCIsXG4gICAgICAgICAgICBcInVzZXJTdGF0dXNcIjogXCJBdmFpbGFibGVcIixcbiAgICAgICAgICAgIFwiZG5kU3RhdHVzXCI6IFwiVGFrZUFsbENhbGxzXCIsXG4gICAgICAgICAgICBcImV4dGVuc2lvbklkXCI6IGlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZWdpc3RyeS5wcm90b3R5cGUuc3Vic2NyaWJlR2VuZXJpYyA9IGZ1bmN0aW9uIHN1YnNjcmliZUdlbmVyaWMoZXhwaXJlc0luKSB7XG5cbiAgICAgICAgZXhwaXJlc0luID0gZXhwaXJlc0luIHx8IDE1ICogNjAgKiA2MDtcblxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uJywge1xuICAgICAgICAgICAgJ2V2ZW50RmlsdGVycyc6IFsnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2UnXSxcbiAgICAgICAgICAgICdleHBpcmF0aW9uVGltZSc6IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZXhwaXJlc0luICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICdleHBpcmVzSW4nOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAnZGVsaXZlcnlNb2RlJzoge1xuICAgICAgICAgICAgICAgICd0cmFuc3BvcnRUeXBlJzogJ1B1Yk51YicsXG4gICAgICAgICAgICAgICAgJ2VuY3J5cHRpb24nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnYWRkcmVzcyc6ICcxMjNfZm9vJyxcbiAgICAgICAgICAgICAgICAnc3Vic2NyaWJlcktleSc6ICdzdWItYy1mb28nLFxuICAgICAgICAgICAgICAgICdzZWNyZXRLZXknOiAnc2VjLWMtYmFyJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpZCc6ICdmb28tYmFyLWJheicsXG4gICAgICAgICAgICAnY3JlYXRpb25UaW1lJzogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdBY3RpdmUnLFxuICAgICAgICAgICAgJ3VyaSc6ICdodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL2Zvby1iYXItYmF6J1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVnaXN0cnkucHJvdG90eXBlLnN1YnNjcmliZU9uUHJlc2VuY2UgPSBmdW5jdGlvbiBzdWJzY3JpYmVPblByZXNlbmNlKGlkLCBkZXRhaWxlZCkge1xuXG4gICAgICAgIGlkID0gaWQgfHwgJzEnO1xuXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAnZXZlbnRGaWx0ZXJzJzogWycvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vJyArIGlkICsgJy9wcmVzZW5jZScgKyAoZGV0YWlsZWQgPyAnP2RldGFpbGVkVGVsZXBob255U3RhdGU9dHJ1ZScgOiAnJyldLFxuICAgICAgICAgICAgJ2V4cGlyYXRpb25UaW1lJzogbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgKyAxNSAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2RlbGl2ZXJ5TW9kZSc6IHtcbiAgICAgICAgICAgICAgICAndHJhbnNwb3J0VHlwZSc6ICdQdWJOdWInLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnYWRkcmVzcyc6ICcxMjNfZm9vJyxcbiAgICAgICAgICAgICAgICAnc3Vic2NyaWJlcktleSc6ICdzdWItYy1mb28nLFxuICAgICAgICAgICAgICAgICdzZWNyZXRLZXknOiAnc2VjLWMtYmFyJyxcbiAgICAgICAgICAgICAgICAnZW5jcnlwdGlvbkFsZ29yaXRobSc6ICdBRVMnLFxuICAgICAgICAgICAgICAgICdlbmNyeXB0aW9uS2V5JzogJ1ZRd2I2RVZOY1FQQmhFL0pnRloyenc9PSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3JlYXRpb25UaW1lJzogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgJ2lkJzogJ2Zvby1iYXItYmF6JyxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnQWN0aXZlJyxcbiAgICAgICAgICAgICd1cmknOiAnaHR0cHM6Ly9wbGF0Zm9ybS5yaW5nY2VudHJhbC5jb20vcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbi9mb28tYmFyLWJheidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlZ2lzdHJ5LnByb3RvdHlwZS50b2tlblJlZnJlc2ggPSBmdW5jdGlvbiB0b2tlblJlZnJlc2goZmFpbHVyZSkge1xuXG4gICAgICAgIGlmICghZmFpbHVyZSkge1xuXG4gICAgICAgICAgICB0aGlzLmFwaUNhbGwoJ1BPU1QnLCAnL3Jlc3RhcGkvb2F1dGgvdG9rZW4nLCB7XG4gICAgICAgICAgICAgICAgJ2FjY2Vzc190b2tlbic6ICdBQ0NFU1NfVE9LRU5fRlJPTV9SRUZSRVNIJyxcbiAgICAgICAgICAgICAgICAndG9rZW5fdHlwZSc6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICdleHBpcmVzX2luJzogMzYwMCxcbiAgICAgICAgICAgICAgICAncmVmcmVzaF90b2tlbic6ICdSRUZSRVNIX1RPS0VOX0ZST01fUkVGUkVTSCcsXG4gICAgICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW5fZXhwaXJlc19pbic6IDYwNDgwLFxuICAgICAgICAgICAgICAgICdzY29wZSc6ICdTTVMgUkNNIEZvbyBCb28nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5hcGlDYWxsKCdQT1NUJywgJy9yZXN0YXBpL29hdXRoL3Rva2VuJywge1xuICAgICAgICAgICAgICAgICdtZXNzYWdlJzogJ1dyb25nIHRva2VuJyxcbiAgICAgICAgICAgICAgICAnZXJyb3JfZGVzY3JpcHRpb24nOiAnV3JvbmcgdG9rZW4nLFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6ICdXcm9uZyB0b2tlbidcbiAgICAgICAgICAgIH0sIDQwMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlZ2lzdHJ5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWdpc3RyeTtcblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfQXBpUmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9BcGlSZXNwb25zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BcGlSZXNwb25zZSk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTW9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2NrKG1ldGhvZCwgcGF0aCwganNvbiwgc3RhdHVzLCBzdGF0dXNUZXh0LCBkZWxheSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9jayk7XG5cbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9qc29uID0ganNvbiB8fCB7fTtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheSB8fCAxMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gc3RhdHVzIHx8IDIwMDtcbiAgICAgICAgdGhpcy5fc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgJ09LJztcbiAgICB9XG5cbiAgICBNb2NrLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIG1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcbiAgICB9O1xuXG4gICAgTW9jay5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QocmVxdWVzdCkge1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnVybC5pbmRleE9mKHRoaXMuX3BhdGgpID4gLTEgJiYgcmVxdWVzdC5tZXRob2QudG9VcHBlckNhc2UoKSA9PSB0aGlzLl9tZXRob2Q7XG4gICAgfTtcblxuICAgIE1vY2sucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1V0aWxzLmRlbGF5KSh0aGlzLl9kZWxheSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzLmNyZWF0ZVJlc3BvbnNlKHRoaXMuX2pzb24pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZShfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRSZXNwb25zZTtcbiAgICB9KCk7XG5cbiAgICBNb2NrLnByb3RvdHlwZS5jcmVhdGVSZXNwb25zZSA9IGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlKGpzb24sIGluaXQpIHtcblxuICAgICAgICBpbml0ID0gaW5pdCB8fCB7fTtcblxuICAgICAgICBpbml0LnN0YXR1cyA9IGluaXQuc3RhdHVzIHx8IHRoaXMuX3N0YXR1cztcbiAgICAgICAgaW5pdC5zdGF0dXNUZXh0ID0gaW5pdC5zdGF0dXNUZXh0IHx8IHRoaXMuX3N0YXR1c1RleHQ7XG5cbiAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KGpzb24pLFxuICAgICAgICAgICAgcmVzID0gbmV3IF9FeHRlcm5hbHMuUmVzcG9uc2Uoc3RyLCBpbml0KTtcblxuICAgICAgICByZXMuaGVhZGVycy5zZXQoX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9jb250ZW50VHlwZSwgX0FwaVJlc3BvbnNlMi5kZWZhdWx0Ll9qc29uQ29udGVudFR5cGUpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2NrO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2NrO1xuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9FeHRlcm5hbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfQXV0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0F1dGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXV0aCk7XG5cbnZhciBfVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBfRXh0ZXJuYWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBfRXh0ZXJuYWxzLlByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQbGF0Zm9ybSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFBsYXRmb3JtLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFBsYXRmb3JtKGNsaWVudCwgY2FjaGUsIHNlcnZlciwgYXBwS2V5LCBhcHBTZWNyZXQsIGFwcE5hbWUsIGFwcFZlcnNpb24sIHNka1ZlcnNpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXRmb3JtKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIGJlZm9yZUxvZ2luOiAnYmVmb3JlTG9naW4nLFxuICAgICAgICAgICAgbG9naW5TdWNjZXNzOiAnbG9naW5TdWNjZXNzJyxcbiAgICAgICAgICAgIGxvZ2luRXJyb3I6ICdsb2dpbkVycm9yJyxcbiAgICAgICAgICAgIGJlZm9yZVJlZnJlc2g6ICdiZWZvcmVSZWZyZXNoJyxcbiAgICAgICAgICAgIHJlZnJlc2hTdWNjZXNzOiAncmVmcmVzaFN1Y2Nlc3MnLFxuICAgICAgICAgICAgcmVmcmVzaEVycm9yOiAncmVmcmVzaEVycm9yJyxcbiAgICAgICAgICAgIGJlZm9yZUxvZ291dDogJ2JlZm9yZUxvZ291dCcsXG4gICAgICAgICAgICBsb2dvdXRTdWNjZXNzOiAnbG9nb3V0U3VjY2VzcycsXG4gICAgICAgICAgICBsb2dvdXRFcnJvcjogJ2xvZ291dEVycm9yJ1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX3RoaXMuX3NlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgX3RoaXMuX2FwcEtleSA9IGFwcEtleTtcbiAgICAgICAgX3RoaXMuX2FwcFNlY3JldCA9IGFwcFNlY3JldDtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuICAgICAgICBfdGhpcy5fY2FjaGUgPSBjYWNoZTtcblxuICAgICAgICAvKiogQHR5cGUge0NsaWVudH0gKi9cbiAgICAgICAgX3RoaXMuX2NsaWVudCA9IGNsaWVudDtcblxuICAgICAgICAvKiogQHR5cGUge1Byb21pc2U8QXBpUmVzcG9uc2U+fSAqL1xuICAgICAgICBfdGhpcy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xuXG4gICAgICAgIF90aGlzLl9hdXRoID0gbmV3IF9BdXRoMi5kZWZhdWx0KF90aGlzLl9jYWNoZSwgUGxhdGZvcm0uX2NhY2hlSWQpO1xuXG4gICAgICAgIF90aGlzLl91c2VyQWdlbnQgPSAoYXBwTmFtZSA/IGFwcE5hbWUgKyAoYXBwVmVyc2lvbiA/ICcvJyArIGFwcFZlcnNpb24gOiAnJykgKyAnICcgOiAnJykgKyAnUkNKU1NESy8nICsgc2RrVmVyc2lvbjtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbiBhdXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Q2xpZW50fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuY2xpZW50ID0gZnVuY3Rpb24gY2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZFNlcnZlcl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWRkTWV0aG9kXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkVG9rZW5dXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuY3JlYXRlVXJsID0gZnVuY3Rpb24gY3JlYXRlVXJsKHBhdGgsIG9wdGlvbnMpIHtcblxuICAgICAgICBwYXRoID0gcGF0aCB8fCAnJztcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGJ1aWx0VXJsID0gJycsXG4gICAgICAgICAgICBoYXNIdHRwID0gcGF0aC5pbmRleE9mKCdodHRwOi8vJykgIT0gLTEgfHwgcGF0aC5pbmRleE9mKCdodHRwczovLycpICE9IC0xO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZFNlcnZlciAmJiAhaGFzSHR0cCkgYnVpbHRVcmwgKz0gdGhpcy5fc2VydmVyO1xuXG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoUGxhdGZvcm0uX3VybFByZWZpeCkgPT0gLTEgJiYgIWhhc0h0dHApIGJ1aWx0VXJsICs9IFBsYXRmb3JtLl91cmxQcmVmaXggKyAnLycgKyBQbGF0Zm9ybS5fYXBpVmVyc2lvbjtcblxuICAgICAgICBidWlsdFVybCArPSBwYXRoO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZE1ldGhvZCB8fCBvcHRpb25zLmFkZFRva2VuKSBidWlsdFVybCArPSBwYXRoLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFkZE1ldGhvZCkgYnVpbHRVcmwgKz0gJ19tZXRob2Q9JyArIG9wdGlvbnMuYWRkTWV0aG9kO1xuICAgICAgICBpZiAob3B0aW9ucy5hZGRUb2tlbikgYnVpbHRVcmwgKz0gKG9wdGlvbnMuYWRkTWV0aG9kID8gJyYnIDogJycpICsgJ2FjY2Vzc190b2tlbj0nICsgdGhpcy5fYXV0aC5hY2Nlc3NUb2tlbigpO1xuXG4gICAgICAgIHJldHVybiBidWlsdFVybDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJyYW5kSWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kaXNwbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucHJvbXB0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmxvZ2luVXJsID0gZnVuY3Rpb24gbG9naW5Vcmwob3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVybChQbGF0Zm9ybS5fYXV0aG9yaXplRW5kcG9pbnQgKyAnPycgKyAoMCwgX1V0aWxzLnF1ZXJ5U3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAncmVzcG9uc2VfdHlwZSc6ICdjb2RlJyxcbiAgICAgICAgICAgICdyZWRpcmVjdF91cmknOiBvcHRpb25zLnJlZGlyZWN0VXJpIHx8ICcnLFxuICAgICAgICAgICAgJ2NsaWVudF9pZCc6IHRoaXMuX2FwcEtleSxcbiAgICAgICAgICAgICdzdGF0ZSc6IG9wdGlvbnMuc3RhdGUgfHwgJycsXG4gICAgICAgICAgICAnYnJhbmRfaWQnOiBvcHRpb25zLmJyYW5kSWQgfHwgJycsXG4gICAgICAgICAgICAnZGlzcGxheSc6IG9wdGlvbnMuZGlzcGxheSB8fCAnJyxcbiAgICAgICAgICAgICdwcm9tcHQnOiBvcHRpb25zLnByb21wdCB8fCAnJ1xuICAgICAgICB9KSwgeyBhZGRTZXJ2ZXI6IHRydWUgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wYXJzZUxvZ2luUmVkaXJlY3RVcmwgPSBmdW5jdGlvbiBwYXJzZUxvZ2luUmVkaXJlY3RVcmwodXJsKSB7XG5cbiAgICAgICAgdmFyIHFzID0gKDAsIF9VdGlscy5wYXJzZVF1ZXJ5U3RyaW5nKSh1cmwuc3BsaXQoJz8nKS5yZXZlcnNlKClbMF0pLFxuICAgICAgICAgICAgZXJyb3IgPSBxcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCBxcy5lcnJvcjtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGUuZXJyb3IgPSBxcy5lcnJvcjtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBoYW5kbGUgMy1sZWdnZWQgT0F1dGhcbiAgICAgKlxuICAgICAqIEF0dGVudGlvbiEgVGhpcyBpcyBhbiBleHBlcmltZW50YWwgbWV0aG9kIGFuZCBpdCdzIHNpZ25hdHVyZSBhbmQgYmVoYXZpb3IgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubG9naW5dIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9naW4oKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3BlcnR5XSBuYW1lIG9mIHdpbmRvdy5wb3N0TWVzc2FnZSdzIGV2ZW50IGRhdGEgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFyZ2V0XSB0YXJnZXQgZm9yIHdpbmRvdy5vcGVuKClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9naW5XaW5kb3cgPSBmdW5jdGlvbiBsb2dpbldpbmRvdyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgX0V4dGVybmFscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgaWYgKCEoMCwgX1V0aWxzLmlzQnJvd3NlcikoKSkgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBvbmx5IGluIGJyb3dzZXInKTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVybCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG1hbmRhdG9yeSBVUkwgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCB8fCA0MDA7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCA0MDA7XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDYwMDtcbiAgICAgICAgICAgIG9wdGlvbnMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydHkgPSBvcHRpb25zLnByb3BlcnR5IHx8ICdSQ0F1dGhvcml6YXRpb25Db2RlJztcbiAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgJ19ibGFuayc7XG5cbiAgICAgICAgICAgIHZhciBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogc2NyZWVuLmxlZnQ7XG4gICAgICAgICAgICB2YXIgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHNjcmVlbi50b3A7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiBzY3JlZW4ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBzY3JlZW4uaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHdpZHRoIC8gMiAtIG9wdGlvbnMud2lkdGggLyAyICsgZHVhbFNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gaGVpZ2h0IC8gMiAtIG9wdGlvbnMuaGVpZ2h0IC8gMiArIGR1YWxTY3JlZW5Ub3A7XG4gICAgICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4ob3B0aW9ucy51cmwsICdfYmxhbmsnLCBvcHRpb25zLnRhcmdldCA9PSAnX2JsYW5rJyA/ICdzY3JvbGxiYXJzPXllcywgc3RhdHVzPXllcywgd2lkdGg9JyArIG9wdGlvbnMud2lkdGggKyAnLCBoZWlnaHQ9JyArIG9wdGlvbnMuaGVpZ2h0ICsgJywgbGVmdD0nICsgbGVmdCArICcsIHRvcD0nICsgdG9wIDogJycpO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmZvY3VzKSB3aW4uZm9jdXMoKTtcblxuICAgICAgICAgICAgdmFyIGV2ZW50TWV0aG9kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnO1xuICAgICAgICAgICAgdmFyIGV2ZW50UmVtb3ZlTWV0aG9kID0gZXZlbnRNZXRob2QgPT0gJ2FkZEV2ZW50TGlzdGVuZXInID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JztcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRXZlbnQgPSBldmVudE1ldGhvZCA9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnbWVzc2FnZScgOiAnb25tZXNzYWdlJztcblxuICAgICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBldmVudExpc3RlbmVyKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiAhPSBvcHRpb25zLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghZS5kYXRhIHx8ICFlLmRhdGFbb3B0aW9ucy5wcm9wZXJ0eV0pIHJldHVybjsgLy8ga2VlcCB3YWl0aW5nXG5cbiAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3dbZXZlbnRSZW1vdmVNZXRob2RdKG1lc3NhZ2VFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dpbk9wdGlvbnMgPSBfdGhpczIucGFyc2VMb2dpblJlZGlyZWN0VXJsKGUuZGF0YVtvcHRpb25zLnByb3BlcnR5XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2dpbk9wdGlvbnMuY29kZSkgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRob3JpemF0aW9uIGNvZGUnKTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxvZ2luT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2luZG93W2V2ZW50TWV0aG9kXShtZXNzYWdlRXZlbnQsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dnZWRJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUxvZ2dlZEluKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgNl1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ2dlZEluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dnZWRJbjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZXh0ZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZW5kcG9pbnRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlbWVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYWNjZXNzVG9rZW5UdGxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZWZyZXNoVG9rZW5UdGxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGJvZHksIGFwaVJlc3BvbnNlLCBqc29uO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZUxvZ2luKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB7fTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmdyYW50X3R5cGUgPSAncGFzc3dvcmQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnVzZXJuYW1lID0gb3B0aW9ucy51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5wYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuZXh0ZW5zaW9uID0gb3B0aW9ucy5leHRlbnNpb24gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmdyYW50X3R5cGUgPSAnYXV0aG9yaXphdGlvbl9jb2RlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5jb2RlID0gb3B0aW9ucy5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnJlZGlyZWN0X3VyaSA9IG9wdGlvbnMucmVkaXJlY3RVcmk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYm9keS5jbGllbnRfaWQgPSB0aGlzLmdldENyZWRlbnRpYWxzKCkua2V5OyAvLyBub3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kcG9pbnRJZCkgYm9keS5lbmRwb2ludF9pZCA9IG9wdGlvbnMuZW5kcG9pbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hY2Nlc3NUb2tlblR0bCkgYm9keS5hY2Nlc3NUb2tlblR0bCA9IG9wdGlvbnMuYWNjZXNzVG9rZW5UdGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmcmVzaFRva2VuVHRsKSBib2R5LnJlZnJlc2hUb2tlblR0bCA9IG9wdGlvbnMucmVmcmVzaFRva2VuVHRsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl90b2tlbkVuZHBvaW50LCBib2R5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBhcGlSZXNwb25zZS5qc29uKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguc2V0RGF0YShqc29uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5sb2dpblN1Y2Nlc3MsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGFwaVJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ2luRXJyb3IsIF9jb250ZXh0Mi50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxN11dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvZ2luKF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dpbjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgIHZhciByZXMsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZVJlZnJlc2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX1V0aWxzLmRlbGF5KShQbGF0Zm9ybS5fcmVmcmVzaERlbGF5TXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGgucmVmcmVzaFRva2VuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZnJlc2ggdG9rZW4gaXMgbWlzc2luZycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGgucmVmcmVzaFRva2VuVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCB0b2tlbiBoYXMgZXhwaXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5SZXF1ZXN0KFBsYXRmb3JtLl90b2tlbkVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3JhbnRfdHlwZVwiOiBcInJlZnJlc2hfdG9rZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZyZXNoX3Rva2VuXCI6IHRoaXMuX2F1dGgucmVmcmVzaFRva2VuKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWNjZXNzX3Rva2VuX3R0bFwiOiB0aGlzLl9hdXRoLmRhdGEoKS5leHBpcmVzX2luICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZyZXNoX3Rva2VuX3R0bFwiOiB0aGlzLl9hdXRoLmRhdGEoKS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlcy5qc29uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY2xpZW50Lm1ha2VFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBPQXV0aCByZXNwb25zZScpLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aC5zZXREYXRhKGpzb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLnJlZnJlc2hTdWNjZXNzLCByZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSB0aGlzLl9jbGllbnQubWFrZUVycm9yKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUGxhdGZvcm0uX2NsZWFyQ2FjaGVPblJlZnJlc2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZWZyZXNoRXJyb3IsIF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxOV1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JlZnJlc2g7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlZnJlc2hQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fcmVmcmVzaFByb21pc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAyO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IHRoaXMuX3JlZnJlc2goKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9yZWZyZXNoUHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMik7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDQudDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1syLCA3XV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZnJlc2g7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjUgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmJlZm9yZUxvZ291dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuUmVxdWVzdChQbGF0Zm9ybS5fcmV2b2tlRW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ1LnNlbnQ7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFuKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5ldmVudHMubG9nb3V0U3VjY2VzcywgcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgwKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLmxvZ291dEVycm9yLCBfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ1LnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMsIFtbMCwgMTBdXSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dvdXQ7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEF1dGhDaGVja11cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlcXVlc3Q+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuaW5mbGF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwQXV0aENoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTG9nZ2VkSW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldCgnWC1Vc2VyLUFnZW50JywgdGhpcy5fdXNlckFnZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdDbGllbnQtSWQnLCB0aGlzLl9hcHBLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCB0aGlzLl9hdXRoSGVhZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVxdWVzdC51cmwgPSB0aGlzLmNyZWF0ZVVybChyZXF1ZXN0LnVybCwge2FkZFNlcnZlcjogdHJ1ZX0pOyAvL0ZJWE1FIFNwZWMgcHJldmVudHMgdGhpcy4uLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluZmxhdGVSZXF1ZXN0KF94MiwgX3gzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmZsYXRlUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBfY29udGV4dDcuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ny5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDcudDAgPSBfY29udGV4dDdbXCJjYXRjaFwiXSgwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFfY29udGV4dDcudDAuYXBpUmVzcG9uc2UgfHwgIV9jb250ZXh0Ny50MC5hcGlSZXNwb25zZS5yZXNwb25zZSgpIHx8IF9jb250ZXh0Ny50MC5hcGlSZXNwb25zZS5yZXNwb25zZSgpLnN0YXR1cyAhPSA0MDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Ny50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGguY2FuY2VsQWNjZXNzVG9rZW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMsIFtbMCwgOV1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KF94NCwgX3g1KSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZW5kUmVxdWVzdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmFsIHB1cnBvc2UgZnVuY3Rpb24gdG8gc2VuZCBhbnl0aGluZyB0byBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuYm9keV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWV0aG9kXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5xdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjggPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9GSVhNRSBodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gvaXNzdWVzLzQzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB0aGlzLmNyZWF0ZVVybChvcHRpb25zLnVybCwgeyBhZGRTZXJ2ZXI6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QodGhpcy5fY2xpZW50LmNyZWF0ZVJlcXVlc3Qob3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ4LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBzZW5kKF94Nikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjkgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOSh1cmwsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ5LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXQoX3g4LCBfeDksIF94MTApIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEwID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHVybCwgYm9keSwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEwLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBvc3QoX3gxMSwgX3gxMiwgX3gxMywgX3gxNCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbYm9keV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3F1ZXJ5XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBBdXRoQ2hlY2tdXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTEgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEodXJsLCBib2R5LCBxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQxMS5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBwdXQoX3gxNSwgX3gxNiwgX3gxNywgX3gxOCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1dDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwQXV0aENoZWNrXVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKHVybCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEyLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9kZWxldGUoX3gxOSwgX3gyMCwgX3gyMSkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9kZWxldGU7XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl90b2tlblJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcmVmMTMgPSBfYXN5bmNUb0dlbmVyYXRvcihyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMocGF0aCwgYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwQXV0aENoZWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIHRoaXMuX2FwaUtleSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDEzLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF90b2tlblJlcXVlc3QoX3gyMiwgX3gyMykge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90b2tlblJlcXVlc3Q7XG4gICAgfSgpO1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLmVuc3VyZUxvZ2dlZEluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZjE0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNC5wcmV2ID0gX2NvbnRleHQxNC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0FjY2Vzc1Rva2VuVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDE0LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGVuc3VyZUxvZ2dlZEluKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuc3VyZUxvZ2dlZEluO1xuICAgIH0oKTtcblxuICAgIFBsYXRmb3JtLnByb3RvdHlwZS5faXNBY2Nlc3NUb2tlblZhbGlkID0gZnVuY3Rpb24gX2lzQWNjZXNzVG9rZW5WYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGguYWNjZXNzVG9rZW5WYWxpZCgpO1xuICAgIH07XG5cbiAgICBQbGF0Zm9ybS5wcm90b3R5cGUuX2FwaUtleSA9IGZ1bmN0aW9uIF9hcGlLZXkoKSB7XG4gICAgICAgIHZhciBhcGlLZXkgPSB0aGlzLl9hcHBLZXkgKyAnOicgKyB0aGlzLl9hcHBTZWNyZXQ7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYnRvYSA9PSAnZnVuY3Rpb24nID8gYnRvYShhcGlLZXkpIDogbmV3IEJ1ZmZlcihhcGlLZXkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9O1xuXG4gICAgUGxhdGZvcm0ucHJvdG90eXBlLl9hdXRoSGVhZGVyID0gZnVuY3Rpb24gX2F1dGhIZWFkZXIoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2F1dGguYWNjZXNzVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGgudG9rZW5UeXBlKCkgKyAodG9rZW4gPyAnICcgKyB0b2tlbiA6ICcnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBsYXRmb3JtO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuUGxhdGZvcm0uX3VybFByZWZpeCA9ICcvcmVzdGFwaSc7XG5QbGF0Zm9ybS5fYXBpVmVyc2lvbiA9ICd2MS4wJztcblBsYXRmb3JtLl90b2tlbkVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL3Rva2VuJztcblBsYXRmb3JtLl9yZXZva2VFbmRwb2ludCA9ICcvcmVzdGFwaS9vYXV0aC9yZXZva2UnO1xuUGxhdGZvcm0uX2F1dGhvcml6ZUVuZHBvaW50ID0gJy9yZXN0YXBpL29hdXRoL2F1dGhvcml6ZSc7XG5QbGF0Zm9ybS5fcmVmcmVzaERlbGF5TXMgPSAxMDA7XG5QbGF0Zm9ybS5fY2FjaGVJZCA9ICdwbGF0Zm9ybSc7XG5QbGF0Zm9ybS5fY2xlYXJDYWNoZU9uUmVmcmVzaEVycm9yID0gZmFsc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGF0Zm9ybTtcblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQXV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoKGNhY2hlLCBjYWNoZUlkKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdXRoKTtcblxuICAgICAgICAvKiogQHR5cGUge0NhY2hlfSAqL1xuICAgICAgICB0aGlzLl9jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLl9jYWNoZUlkID0gY2FjaGVJZDtcbiAgICB9IC8vIDEgbWludXRlXG5cblxuICAgIEF1dGgucHJvdG90eXBlLmFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5hY2Nlc3NfdG9rZW47XG4gICAgfTtcblxuICAgIEF1dGgucHJvdG90eXBlLnJlZnJlc2hUb2tlbiA9IGZ1bmN0aW9uIHJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnJlZnJlc2hfdG9rZW47XG4gICAgfTtcblxuICAgIEF1dGgucHJvdG90eXBlLnRva2VuVHlwZSA9IGZ1bmN0aW9uIHRva2VuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpLnRva2VuX3R5cGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3t0b2tlbl90eXBlOiBzdHJpbmcsIGFjY2Vzc190b2tlbjogc3RyaW5nLCBleHBpcmVzX2luOiBudW1iZXIsIHJlZnJlc2hfdG9rZW46IHN0cmluZywgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiBudW1iZXJ9fVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gZGF0YSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0SXRlbSh0aGlzLl9jYWNoZUlkKSB8fCB7XG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnJyxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJycsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW46IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld0RhdGFcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShuZXdEYXRhKSB7XG5cbiAgICAgICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge307XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEoKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhuZXdEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG5ld0RhdGFba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGF0YS5leHBpcmVfdGltZSA9IERhdGUubm93KCkgKyBkYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICBkYXRhLnJlZnJlc2hfdG9rZW5fZXhwaXJlX3RpbWUgPSBEYXRlLm5vdygpICsgZGF0YS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4gKiAxMDAwO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLnNldEl0ZW0odGhpcy5fY2FjaGVJZCwgZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgKG5vdCBleHBpcmVkKSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5hY2Nlc3NUb2tlblZhbGlkID0gZnVuY3Rpb24gYWNjZXNzVG9rZW5WYWxpZCgpIHtcblxuICAgICAgICB2YXIgYXV0aERhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGF1dGhEYXRhLnRva2VuX3R5cGUgPT09IEF1dGguZm9yY2VkVG9rZW5UeXBlIHx8IGF1dGhEYXRhLmV4cGlyZV90aW1lIC0gQXV0aC5yZWZyZXNoSGFuZGljYXBNcyA+IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgdmFsaWQgKG5vdCBleHBpcmVkKSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5yZWZyZXNoVG9rZW5WYWxpZCA9IGZ1bmN0aW9uIHJlZnJlc2hUb2tlblZhbGlkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKS5yZWZyZXNoX3Rva2VuX2V4cGlyZV90aW1lID4gRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXV0aH1cbiAgICAgKi9cblxuXG4gICAgQXV0aC5wcm90b3R5cGUuY2FuY2VsQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiBjYW5jZWxBY2Nlc3NUb2tlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJycsXG4gICAgICAgICAgICBleHBpcmVzX2luOiAwXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIGEgc3BlY2lhbCBhdXRoZW50aWNhdGlvbiBtb2RlIHVzZWQgaW4gU2VydmljZSBXZWJcbiAgICAgKiBAcmV0dXJuIHtBdXRofVxuICAgICAqL1xuXG5cbiAgICBBdXRoLnByb3RvdHlwZS5mb3JjZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gZm9yY2VBdXRoZW50aWNhdGlvbigpIHtcblxuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgICAgdG9rZW5fdHlwZTogQXV0aC5mb3JjZWRUb2tlblR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46ICcnLFxuICAgICAgICAgICAgZXhwaXJlc19pbjogMCxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46ICcnLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbl9leHBpcmVzX2luOiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXV0aDtcbn0oKTtcblxuLy9leHBvcnQgaW50ZXJmYWNlIElBdXRoRGF0YSB7XG4vLyAgICByZW1lbWJlcj86Ym9vbGVhbjtcbi8vICAgIHRva2VuX3R5cGU/OnN0cmluZztcbi8vICAgIGFjY2Vzc190b2tlbj86c3RyaW5nO1xuLy8gICAgZXhwaXJlc19pbj86bnVtYmVyOyAvLyBhY3R1YWxseSBpdCdzIHN0cmluZ1xuLy8gICAgZXhwaXJlX3RpbWU/Om51bWJlcjtcbi8vICAgIHJlZnJlc2hfdG9rZW4/OnN0cmluZztcbi8vICAgIHJlZnJlc2hfdG9rZW5fZXhwaXJlc19pbj86bnVtYmVyOyAvLyBhY3R1YWxseSBpdCdzIHN0cmluZ1xuLy8gICAgcmVmcmVzaF90b2tlbl9leHBpcmVfdGltZT86bnVtYmVyO1xuLy8gICAgc2NvcGU/OnN0cmluZztcbi8vfVxuXG5cbkF1dGgucmVmcmVzaEhhbmRpY2FwTXMgPSA2MCAqIDEwMDA7XG5BdXRoLmZvcmNlZFRva2VuVHlwZSA9ICdmb3JjZWQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aDtcblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1B1Ym51Yk1vY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIF9QdWJudWJNb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1B1Ym51Yk1vY2spO1xuXG52YXIgX0V4dGVybmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQdWJudWJNb2NrRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdWJudWJNb2NrRmFjdG9yeSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1Ym51Yk1vY2tGYWN0b3J5KTtcblxuICAgICAgICB0aGlzLmNyeXB0b19vYmogPSBfRXh0ZXJuYWxzLlBVQk5VQi5jcnlwdG9fb2JqO1xuICAgIH1cblxuICAgIFB1Ym51Yk1vY2tGYWN0b3J5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1B1Ym51Yk1vY2syLmRlZmF1bHQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBQdWJudWJNb2NrRmFjdG9yeTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHVibnViTW9ja0ZhY3Rvcnk7XG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbnZhciBfRXh0ZXJuYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUHVibnViTW9jayA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKFB1Ym51Yk1vY2ssIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgZnVuY3Rpb24gUHVibnViTW9jayhvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJudWJNb2NrKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5jcnlwdG9fb2JqID0gX0V4dGVybmFscy5QVUJOVUIuY3J5cHRvX29iajtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeSgpIHt9O1xuXG4gICAgUHVibnViTW9jay5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vbignbWVzc2FnZS0nICsgb3B0aW9ucy5jaGFubmVsLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICBQdWJudWJNb2NrLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ21lc3NhZ2UtJyArIG9wdGlvbnMuY2hhbm5lbCk7XG4gICAgfTtcblxuICAgIFB1Ym51Yk1vY2sucHJvdG90eXBlLnJlY2VpdmVNZXNzYWdlID0gZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UobXNnLCBjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZS0nICsgY2hhbm5lbCwgbXNnLCAnZW52JywgY2hhbm5lbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBQdWJudWJNb2NrO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUHVibnViTW9jaztcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoU3Vic2NyaXB0aW9uLCBfRXZlbnRFbWl0dGVyKTtcblxuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihwdWJudWJGYWN0b3J5LCBwbGF0Zm9ybSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogJ25vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICByZW1vdmVTdWNjZXNzOiAncmVtb3ZlU3VjY2VzcycsXG4gICAgICAgICAgICByZW1vdmVFcnJvcjogJ3JlbW92ZUVycm9yJyxcbiAgICAgICAgICAgIHJlbmV3U3VjY2VzczogJ3JlbmV3U3VjY2VzcycsXG4gICAgICAgICAgICByZW5ld0Vycm9yOiAncmVuZXdFcnJvcicsXG4gICAgICAgICAgICBzdWJzY3JpYmVTdWNjZXNzOiAnc3Vic2NyaWJlU3VjY2VzcycsXG4gICAgICAgICAgICBzdWJzY3JpYmVFcnJvcjogJ3N1YnNjcmliZUVycm9yJ1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX3RoaXMuX3B1Ym51YkZhY3RvcnkgPSBwdWJudWJGYWN0b3J5O1xuICAgICAgICBfdGhpcy5fcGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgX3RoaXMuX3B1Ym51YiA9IG51bGw7XG4gICAgICAgIF90aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCA9IG51bGw7XG4gICAgICAgIF90aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlZCA9IGZ1bmN0aW9uIHN1YnNjcmliZWQoKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuICEhKHN1YnNjcmlwdGlvbi5pZCAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlICYmIHN1YnNjcmlwdGlvbi5kZWxpdmVyeU1vZGUuc3Vic2NyaWJlcktleSAmJiBzdWJzY3JpcHRpb24uZGVsaXZlcnlNb2RlLmFkZHJlc3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFsaXZlID0gZnVuY3Rpb24gYWxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQoKSAmJiBEYXRlLm5vdygpIDwgdGhpcy5leHBpcmF0aW9uVGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmV4cGlyZWQgPSBmdW5jdGlvbiBleHBpcmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICF0aGlzLnN1YnNjcmliZWQoKSB8fCBEYXRlLm5vdygpID4gdGhpcy5zdWJzY3JpcHRpb24oKS5leHBpcmF0aW9uVGltZTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5leHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5zdWJzY3JpcHRpb24oKS5leHBpcmF0aW9uVGltZSB8fCAwKS5nZXRUaW1lKCkgLSBTdWJzY3JpcHRpb24uX3JlbmV3SGFuZGljYXBNcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zZXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlQXRQdWJudWIoKTtcbiAgICAgICAgdGhpcy5fc2V0VGltZW91dCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIHN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbiB8fCB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciB1cGRhdGVzIHN1YnNjcmlwdGlvbiBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgb25lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFsaXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmV3KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyO1xuICAgIH0oKTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZXZlbnRGaWx0ZXJzID0gZnVuY3Rpb24gZXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb24oKS5ldmVudEZpbHRlcnMgfHwgW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGRFdmVudEZpbHRlcnMgPSBmdW5jdGlvbiBhZGRFdmVudEZpbHRlcnMoZXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZXZlbnRGaWx0ZXJzKCkuY29uY2F0KGV2ZW50cykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnRzXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnNldEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIHNldEV2ZW50RmlsdGVycyhldmVudHMpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5ldmVudEZpbHRlcnMgPSBldmVudHM7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEZpbHRlcnMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50cyBhcmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLnBvc3QoJy9zdWJzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RmlsdGVyczogdGhpcy5fZ2V0RnVsbEV2ZW50RmlsdGVycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpdmVyeU1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydFR5cGU6ICdQdWJOdWInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oanNvbikuZW1pdCh0aGlzLmV2ZW50cy5zdWJzY3JpYmVTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKS5lbWl0KHRoaXMuZXZlbnRzLnN1YnNjcmliZUVycm9yLCBfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzAsIDEyXV0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwaVJlc3BvbnNlPn1cbiAgICAgKi9cblxuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGpzb247XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudHMgYXJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybS5wdXQoJy9zdWJzY3JpcHRpb24vJyArIHRoaXMuc3Vic2NyaXB0aW9uKCkuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRGaWx0ZXJzOiB0aGlzLl9nZXRGdWxsRXZlbnRGaWx0ZXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IHJlc3BvbnNlLmpzb24oKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdWJzY3JpcHRpb24oanNvbikuZW1pdCh0aGlzLmV2ZW50cy5yZW5ld1N1Y2Nlc3MsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCdyZXR1cm4nLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbJ2NhdGNoJ10oMCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHRoaXMuX3BsYXRmb3JtLmNsaWVudCgpLm1ha2VFcnJvcihfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpLmVtaXQodGhpcy5ldmVudHMucmVuZXdFcnJvciwgX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0My50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCAxNF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbmV3KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZXc7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBpUmVzcG9uc2U+fVxuICAgICAqL1xuXG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3Vic2NyaXB0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLmRlbGV0ZSgnL3N1YnNjcmlwdGlvbi8nICsgdGhpcy5zdWJzY3JpcHRpb24oKS5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NC5zZW50O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCkuZW1pdCh0aGlzLmV2ZW50cy5yZW1vdmVTdWNjZXNzLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJywgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0WydjYXRjaCddKDApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSB0aGlzLl9wbGF0Zm9ybS5jbGllbnQoKS5tYWtlRXJyb3IoX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmV2ZW50cy5yZW1vdmVFcnJvciwgX2NvbnRleHQ0LnQwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NC50MDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1swLCAxMF1dKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcGlSZXNwb25zZT59XG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzdWJzY3JpYmUgPSBmdW5jdGlvbiByZXN1YnNjcmliZSgpIHtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmV2ZW50RmlsdGVycygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpLnNldEV2ZW50RmlsdGVycyhmaWx0ZXJzKS5zdWJzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN1YnNjcmlwdGlvbiBhbmQgZGlzY29ubmVjdCBmcm9tIFBVQk5VQlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBzdWJzY3JpcHRpb24gYXQgY2xpZW50IHNpZGUgYnV0IGJhY2tlbmQgaXMgbm90IG5vdGlmaWVkXG4gICAgICovXG5cblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZWQoKSAmJiB0aGlzLl9wdWJudWIpIHRoaXMuX3B1Ym51Yi51bnN1YnNjcmliZSh7IGNoYW5uZWw6IHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlLmFkZHJlc3MgfSk7XG4gICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZ2V0RnVsbEV2ZW50RmlsdGVycyA9IGZ1bmN0aW9uIF9nZXRGdWxsRXZlbnRGaWx0ZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEZpbHRlcnMoKS5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9wbGF0Zm9ybS5jcmVhdGVVcmwoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fc2V0VGltZW91dCA9IGZ1bmN0aW9uIF9zZXRUaW1lb3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpcHRpb24gaXMgbm90IGFsaXZlJyk7XG5cbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKF90aGlzMy5hbGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuZXhwaXJlZCgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczMucmVuZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgU3Vic2NyaXB0aW9uLl9wb2xsSW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fZGVjcnlwdCA9IGZ1bmN0aW9uIF9kZWNyeXB0KG1lc3NhZ2UpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCgpKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnNjcmlwdGlvbicpO1xuXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5lbmNyeXB0aW9uS2V5KSB7XG5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9wdWJudWJGYWN0b3J5LmNyeXB0b19vYmouZGVjcnlwdChtZXNzYWdlLCB0aGlzLnN1YnNjcmlwdGlvbigpLmRlbGl2ZXJ5TW9kZS5lbmNyeXB0aW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgZW5jcnlwdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5RW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgIGtleUxlbmd0aDogMTI4LFxuICAgICAgICAgICAgICAgIG1vZGU6ICdlY2InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiBfbm90aWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZXZlbnRzLm5vdGlmaWNhdGlvbiwgdGhpcy5fZGVjcnlwdChtZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9zdWJzY3JpYmVBdFB1Ym51YiA9IGZ1bmN0aW9uIF9zdWJzY3JpYmVBdFB1Ym51YigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuYWxpdmUoKSkgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpcHRpb24gaXMgbm90IGFsaXZlJyk7XG5cbiAgICAgICAgdmFyIGRlbGl2ZXJ5TW9kZSA9IHRoaXMuc3Vic2NyaXB0aW9uKCkuZGVsaXZlcnlNb2RlO1xuXG4gICAgICAgIGlmICh0aGlzLl9wdWJudWIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID09IGRlbGl2ZXJ5TW9kZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byB1cGRhdGUsIGtlZXAgbGlzdGVuaW5nIHRvIHNhbWUgY2hhbm5lbFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wdWJudWJMYXN0Q2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gc3Vic2NyaWJlIHRvIG5ldyBjaGFubmVsXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibnViLnVuc3Vic2NyaWJlKHsgY2hhbm5lbDogdGhpcy5fcHVibnViTGFzdENoYW5uZWwgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLWluaXQgZm9yIG5ldyBkYXRhXG4gICAgICAgICAgICB0aGlzLl9wdWJudWIgPSB0aGlzLl9wdWJudWIuaW5pdCh7XG4gICAgICAgICAgICAgICAgc3NsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZV9rZXk6IGRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSW5pdCBmcm9tIHNjcmF0Y2hcbiAgICAgICAgICAgIHRoaXMuX3B1Ym51YiA9IHRoaXMuX3B1Ym51YkZhY3RvcnkuaW5pdCh7XG4gICAgICAgICAgICAgICAgc3NsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZV9rZXk6IGRlbGl2ZXJ5TW9kZS5zdWJzY3JpYmVyS2V5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcHVibnViLnJlYWR5KCk7IC8vVE9ETyBUaGlzIG1heSBiZSBub3QgbmVlZGVkIGFueW1vcmVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1Ym51Ykxhc3RDaGFubmVsID0gZGVsaXZlcnlNb2RlLmFkZHJlc3M7XG5cbiAgICAgICAgdGhpcy5fcHVibnViLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBjaGFubmVsOiBkZWxpdmVyeU1vZGUuYWRkcmVzcyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuX25vdGlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY29ubmVjdDogZnVuY3Rpb24gY29ubmVjdCgpIHt9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuLy9leHBvcnQgaW50ZXJmYWNlIElTdWJzY3JpcHRpb24ge1xuLy8gICAgaWQ/OnN0cmluZztcbi8vICAgIHVyaT86IHN0cmluZztcbi8vICAgIGV2ZW50RmlsdGVycz86c3RyaW5nW107XG4vLyAgICBleHBpcmF0aW9uVGltZT86c3RyaW5nOyAvLyAyMDE0LTAzLTEyVDE5OjU0OjM1LjYxM1pcbi8vICAgIGV4cGlyZXNJbj86bnVtYmVyO1xuLy8gICAgZGVsaXZlcnlNb2RlPzoge1xuLy8gICAgICAgIHRyYW5zcG9ydFR5cGU/OnN0cmluZztcbi8vICAgICAgICBlbmNyeXB0aW9uPzpib29sZWFuO1xuLy8gICAgICAgIGFkZHJlc3M/OnN0cmluZztcbi8vICAgICAgICBzdWJzY3JpYmVyS2V5PzpzdHJpbmc7XG4vLyAgICAgICAgZW5jcnlwdGlvbktleT86c3RyaW5nO1xuLy8gICAgICAgIHNlY3JldEtleT86c3RyaW5nO1xuLy8gICAgfTtcbi8vICAgIGNyZWF0aW9uVGltZT86c3RyaW5nOyAvLyAyMDE0LTAzLTEyVDE5OjU0OjM1LjYxM1pcbi8vICAgIHN0YXR1cz86c3RyaW5nOyAvLyBBY3RpdmVcbi8vfVxuXG5cblN1YnNjcmlwdGlvbi5fcmVuZXdIYW5kaWNhcE1zID0gMiAqIDYwICogMTAwMDtcblN1YnNjcmlwdGlvbi5fcG9sbEludGVydmFsID0gMTAgKiAxMDAwO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uO1xuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfU3Vic2NyaXB0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N1YnNjcmlwdGlvbjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDYWNoZWRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoX1N1YnNjcmlwdGlvbikge1xuICAgIF9pbmhlcml0cyhDYWNoZWRTdWJzY3JpcHRpb24sIF9TdWJzY3JpcHRpb24pO1xuXG4gICAgZnVuY3Rpb24gQ2FjaGVkU3Vic2NyaXB0aW9uKHB1Ym51YkZhY3RvcnksIHBsYXRmb3JtLCBjYWNoZSwgY2FjaGVLZXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlZFN1YnNjcmlwdGlvbik7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtDYWNoZX0gKi9cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgcHVibnViRmFjdG9yeSwgcGxhdGZvcm0pKTtcblxuICAgICAgICBfdGhpcy5fY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgX3RoaXMuX2NhY2hlS2V5ID0gY2FjaGVLZXk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuc3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gc3Vic2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ2V0SXRlbSh0aGlzLl9jYWNoZUtleSkgfHwge307XG4gICAgfTtcblxuICAgIENhY2hlZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3NldFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5zZXRJdGVtKHRoaXMuX2NhY2hlS2V5LCBzdWJzY3JpcHRpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcHJlLWRlZmluZWQgZXZlbnRGaWx0ZXJzIGluIGNhY2hlIGFuZCBpZiBub3QgLS0gdXNlcyBwcm92aWRlZCBhcyBkZWZhdWx0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge0NhY2hlZFN1YnNjcmlwdGlvbn1cbiAgICAgKi9cblxuXG4gICAgQ2FjaGVkU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShldmVudHMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRGaWx0ZXJzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNldEV2ZW50RmlsdGVycyhldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWNoZWRTdWJzY3JpcHRpb247XG59KF9TdWJzY3JpcHRpb24zLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZWRTdWJzY3JpcHRpb247XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbmdjZW50cmFsLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JpbmdjZW50cmFsL2J1aWxkL3JpbmdjZW50cmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gU2FmYXJpIDUtNyBsYWNrcyBzdXBwb3J0IGZvciBjaGFuZ2luZyB0aGUgYE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHByb3BlcnR5XG4gKiAgICAgb24gb2JqZWN0cy5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxufSBlbHNlIHtcbiAgLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbiAgQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbiAgQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYnVmZmVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2llZWU3NTQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaXNhcnJheS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4yLjFcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4obGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwKGFzYXBGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBhc2FwRm47XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChjaGlsZFtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbigpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgIHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ICYmXG4gICAgICAgICAgY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4odmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkID0gMDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRuZXh0SWQoKSB7XG4gICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gICAgICBwcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICAgIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlKGVudHJpZXMpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbmV4dElkKCk7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlID8gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghdGhpcy5wcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdCh0aGlzLnByb21pc2UsIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCR2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoICA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICB2YXIgcmVzb2x2ZSA9IGMucmVzb2x2ZTtcblxuICAgICAgaWYgKHJlc29sdmUgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgJiZcbiAgICAgICAgICAgIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIHRoZW4pO1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKGVudHJ5KTsgfSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWwuUHJvbWlzZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdwb2x5ZmlsbCc6IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xufSkuY2FsbCh0aGlzKTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiB2ZXJ0eCAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTsgfTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcblxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbbmFtZV1cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBbXVxuICAgICAgdGhpcy5tYXBbbmFtZV0gPSBsaXN0XG4gICAgfVxuICAgIGxpc3QucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzWzBdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSB8fCBbXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IFtub3JtYWxpemVWYWx1ZSh2YWx1ZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm1hcCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpXG4gICAgICB9LCB0aGlzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgQXJyYXlCdWZmZXJzIGZvciBQT1NUIG1ldGhvZC5cbiAgICAgICAgLy8gUmVjZWl2aW5nIEFycmF5QnVmZmVycyBoYXBwZW5zIHZpYSBCbG9icywgaW5zdGVhZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCA6IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcbiAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzKHhocikge1xuICAgIHZhciBoZWFkID0gbmV3IEhlYWRlcnMoKVxuICAgIHZhciBwYWlycyA9ICh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMpID8gMjA0IDogeGhyLnN0YXR1c1xuICAgICAgICBpZiAoc3RhdHVzIDwgMTAwIHx8IHN0YXR1cyA+IDU5OSkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyh4aHIpLFxuICAgICAgICAgIHVybDogcmVzcG9uc2VVUkwoKVxuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC9+L3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohIDMuMTUuMiAvIG1vZGVybiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUFVCTlVCXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlBVQk5VQlwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBnbG9iYWxzICdNb2Rlcm4nICovXG5cdC8qIGVzbGludCBjdXJseTogMCwgY2FtZWxjYXNlOiAwLCBkb3Qtbm90YXRpb246IDAgKi9cblxuXHR2YXIgcGFja2FnZUpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgcHViTnViQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBjcnlwdG9fb2JqID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIENyeXB0b0pTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIFdTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuXHQvKipcblx0ICogVVRJTCBMT0NBTFNcblx0ICovXG5cdHZhciBQTlNESyA9ICdQdWJOdWItSlMtJyArICdNb2Rlcm4nICsgJy8nICsgcGFja2FnZUpTT04udmVyc2lvbjtcblxuXHQvKipcblx0ICogTE9DQUwgU1RPUkFHRVxuXHQgKi9cblx0dmFyIGRiID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgbHMgPSB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhbFN0b3JhZ2U7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmIChscykgcmV0dXJuIGxzLmdldEl0ZW0oa2V5KTtcblx0ICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHJldHVybiBudWxsO1xuXHQgICAgICAgIHJldHVybiAoKGRvY3VtZW50LmNvb2tpZSB8fCAnJykubWF0Y2goXG5cdCAgICAgICAgICAgIFJlZ0V4cChrZXkgKyAnPShbXjtdKyknKVxuXHQgICAgICAgICAgKSB8fCBbXSlbMV0gfHwgbnVsbDtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAobHMpIHJldHVybiBscy5zZXRJdGVtKGtleSwgdmFsdWUpICYmIDA7XG5cdCAgICAgICAgZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgK1xuXHQgICAgICAgICAgJzsgZXhwaXJlcz1UaHUsIDEgQXVnIDIwMzAgMjA6MDA6MDAgVVRDOyBwYXRoPS8nO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fSkoKTtcblxuXG5cdC8qKlxuXHQgKiBDT1JTIFhIUiBSZXF1ZXN0XG5cdCAqID09PT09PT09PT09PT09PT1cblx0ICogIHhkcih7XG5cdCAqICAgICB1cmwgICAgIDogWydodHRwOi8vd3d3LmJsYWguY29tL3VybCddLFxuXHQgKiAgICAgc3VjY2VzcyA6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7fSxcblx0ICogICAgIGZhaWwgICAgOiBmdW5jdGlvbigpIHt9XG5cdCAqICB9KTtcblx0ICovXG5cdGZ1bmN0aW9uIHhkcihzZXR1cCkge1xuXHQgIHZhciB4aHI7XG5cdCAgdmFyIHRpbWVyO1xuXHQgIHZhciBjb21wbGV0ZSA9IDA7XG5cdCAgdmFyIGxvYWRlZCA9IDA7XG5cdCAgdmFyIGFzeW5jID0gdHJ1ZTsgLyogZG8gbm90IGFsbG93IHN5bmMgb3BlcmF0aW9ucyBpbiBtb2Rlcm4gYnVpbGRzICovXG5cdCAgdmFyIHhocnRtZSA9IHNldHVwLnRpbWVvdXQgfHwgcHViTnViQ29yZS5ERUZfVElNRU9VVDtcblx0ICB2YXIgZGF0YSA9IHNldHVwLmRhdGEgfHwge307XG5cdCAgdmFyIGZhaWwgPSBzZXR1cC5mYWlsIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgIHZhciBzdWNjZXNzID0gc2V0dXAuc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fTtcblxuXHQgIHZhciBkb25lID0gZnVuY3Rpb24gKGZhaWxlZCwgcmVzcG9uc2UpIHtcblx0ICAgIGlmIChjb21wbGV0ZSkgcmV0dXJuO1xuXHQgICAgY29tcGxldGUgPSAxO1xuXG5cdCAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG5cdCAgICBpZiAoeGhyKSB7XG5cdCAgICAgIHhoci5vbmVycm9yID0geGhyLm9ubG9hZCA9IG51bGw7XG5cdCAgICAgIGlmICh4aHIuYWJvcnQpIHhoci5hYm9ydCgpO1xuXHQgICAgICB4aHIgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZmFpbGVkKSBmYWlsKHJlc3BvbnNlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGxvYWRlZCkgcmV0dXJuO1xuXHQgICAgdmFyIHJlc3BvbnNlO1xuXHQgICAgbG9hZGVkID0gMTtcblxuXHQgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuXHQgICAgfSBjYXRjaCAocikge1xuXHQgICAgICByZXR1cm4gZG9uZSgxKTtcblx0ICAgIH1cblxuXHQgICAgc3VjY2VzcyhyZXNwb25zZSk7XG5cdCAgfTtcblxuXHQgIHRpbWVyID0gcHViTnViQ29yZS50aW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGRvbmUoMSk7XG5cdCAgfSwgeGhydG1lKTtcblxuXHQgIC8vIFNlbmRcblx0ICB0cnkge1xuXHQgICAgeGhyID0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICBuZXcgWERvbWFpblJlcXVlc3QoKSB8fFxuXHQgICAgICBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHQgICAgeGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZG9uZSgxLCB4aHIucmVzcG9uc2VUZXh0IHx8IHsgZXJyb3I6ICdOZXR3b3JrIENvbm5lY3Rpb24gRXJyb3InIH0pO1xuXHQgICAgfTtcblx0ICAgIHhoci5vbmxvYWQgPSB4aHIub25sb2FkZW5kID0gZmluaXNoZWQ7XG5cblx0ICAgIGRhdGEucG5zZGsgPSBQTlNESztcblx0ICAgIHZhciB1cmwgPSBwdWJOdWJDb3JlLmJ1aWxkX3VybChzZXR1cC51cmwsIGRhdGEpO1xuXHQgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuXHQgICAgaWYgKGFzeW5jKSB4aHIudGltZW91dCA9IHhocnRtZTtcblx0ICAgIHhoci5zZW5kKCk7XG5cdCAgfSBjYXRjaCAoZWVlKSB7XG5cdCAgICBkb25lKDEsIHsgZXJyb3I6ICdYSFIgRmFpbGVkJywgc3RhY2t0cmFjZTogZWVlIH0pO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAnZG9uZSdcblx0ICByZXR1cm4gZG9uZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCSU5EXG5cdCAqID09PT1cblx0ICogYmluZCggJ2tleWRvd24nLCBzZWFyY2goJ2EnKVswXSwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHQgKiAgICAgLi4uXG5cdCAqIH0gKTtcblx0ICovXG5cdGZ1bmN0aW9uIGJpbmQodHlwZSwgZWwsIGZ1bikge1xuXHQgIHB1Yk51YkNvcmUuZWFjaCh0eXBlLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChldHlwZSkge1xuXHQgICAgdmFyIHJhcGZ1biA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmICghZSkgZSA9IHdpbmRvdy5ldmVudDtcblx0ICAgICAgaWYgKCFmdW4oZSkpIHtcblx0ICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdCAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikgZWwuYWRkRXZlbnRMaXN0ZW5lcihldHlwZSwgcmFwZnVuLCBmYWxzZSk7XG5cdCAgICBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV0eXBlLCByYXBmdW4pO1xuXHQgICAgZWxzZSBlbFsnb24nICsgZXR5cGVdID0gcmFwZnVuO1xuXHQgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVSUk9SXG5cdCAqID09PVxuXHQgKiBlcnJvcignbWVzc2FnZScpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuXHQgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHR9XG5cblx0LyoqXG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT1cblx0ICogUFVCTlVCLmV2ZW50cy5iaW5kKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgKiAgICAgLy8gRG8gU3R1ZmYgd2l0aCBtZXNzYWdlXG5cdCAqIH0gKTtcblx0ICpcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgXCJtZXNzYWdlLWRhdGFcIiApO1xuXHQgKiBQVUJOVUIuZXZlbnRzLmZpcmUoICd5b3Utc3RlcHBlZC1vbi1mbG93ZXInLCB7bWVzc2FnZTpcImRhdGFcIn0gKTtcblx0ICogUFVCTlVCLmV2ZW50cy5maXJlKCAneW91LXN0ZXBwZWQtb24tZmxvd2VyJywgWzEsMiwzXSApO1xuXHQgKlxuXHQgKi9cblx0dmFyIGV2ZW50cyA9IHtcblx0ICBsaXN0OiB7fSxcblx0ICB1bmJpbmQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICBldmVudHMubGlzdFtuYW1lXSA9IFtdO1xuXHQgIH0sXG5cdCAgYmluZDogZnVuY3Rpb24gKG5hbWUsIGZ1bikge1xuXHQgICAgKGV2ZW50cy5saXN0W25hbWVdID0gZXZlbnRzLmxpc3RbbmFtZV0gfHwgW10pLnB1c2goZnVuKTtcblx0ICB9LFxuXHQgIGZpcmU6IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG5cdCAgICBwdWJOdWJDb3JlLmVhY2goXG5cdCAgICAgIGV2ZW50cy5saXN0W25hbWVdIHx8IFtdLFxuXHQgICAgICBmdW5jdGlvbiAoZnVuKSB7XG5cdCAgICAgICAgZnVuKGRhdGEpO1xuXHQgICAgICB9XG5cdCAgICApO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQVRUUlxuXHQgKiA9PT09XG5cdCAqIHZhciBhdHRyaWJ1dGUgPSBhdHRyKCBub2RlLCAnYXR0cmlidXRlJyApO1xuXHQgKi9cblx0ZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdCAgaWYgKHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcblx0ICBlbHNlIHJldHVybiBub2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogJFxuXHQgKiA9XG5cdCAqIHZhciBkaXYgPSAkKCdkaXZpZCcpO1xuXHQgKi9cblx0ZnVuY3Rpb24gJChpZCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTRUFSQ0hcblx0ICogPT09PT09XG5cdCAqIHZhciBlbGVtZW50cyA9IHNlYXJjaCgnYSBkaXYgc3BhbicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gc2VhcmNoKGVsZW1lbnRzLCBzdGFydCkge1xuXHQgIHZhciBsaXN0ID0gW107XG5cdCAgcHViTnViQ29yZS5lYWNoKGVsZW1lbnRzLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uIChlbCkge1xuXHQgICAgcHViTnViQ29yZS5lYWNoKChzdGFydCB8fCBkb2N1bWVudCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZWwpLCBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICBsaXN0LnB1c2gobm9kZSk7XG5cdCAgICB9KTtcblx0ICB9KTtcblx0ICByZXR1cm4gbGlzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDU1Ncblx0ICogPT09XG5cdCAqIHZhciBvYmogPSBjcmVhdGUoJ2RpdicpO1xuXHQgKi9cblx0ZnVuY3Rpb24gY3NzKGVsZW1lbnQsIHN0eWxlcykge1xuXHQgIGZvciAodmFyIHN0eWxlIGluIHN0eWxlcykgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpXG5cdCAgICB0cnkge1xuXHQgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV0gKyAoXG5cdCAgICAgICAgICAnfHdpZHRofGhlaWdodHx0b3B8bGVmdHwnLmluZGV4T2Yoc3R5bGUpID4gMCAmJlxuXHQgICAgICAgICAgdHlwZW9mIHN0eWxlc1tzdHlsZV0gPT09ICdudW1iZXInXG5cdCAgICAgICAgICAgID8gJ3B4JyA6ICcnXG5cdCAgICAgICAgKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIENSRUFURVxuXHQgKiA9PT09PT1cblx0ICogdmFyIG9iaiA9IGNyZWF0ZSgnZGl2Jyk7XG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRfaG1hY19TSEEyNTYoZGF0YSwga2V5KSB7XG5cdCAgdmFyIGhhc2ggPSBDcnlwdG9KU1snSG1hY1NIQTI1NiddKGRhdGEsIGtleSk7XG5cdCAgcmV0dXJuIGhhc2gudG9TdHJpbmcoQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXSk7XG5cdH1cblxuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cdC8qID0tPT09PT09PT09PT09PT09PT09PT09PT09PSAgICAgUFVCTlVCICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT0tPSAqL1xuXHQvKiA9LT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09LT0gKi9cblx0LyogPS09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS09ICovXG5cblx0ZnVuY3Rpb24gQ1JFQVRFX1BVQk5VQihzZXR1cCkge1xuXHQgIHNldHVwLmRiID0gZGI7XG5cdCAgc2V0dXAueGRyID0geGRyO1xuXHQgIHNldHVwLmVycm9yID0gc2V0dXAuZXJyb3IgfHwgZXJyb3I7XG5cdCAgc2V0dXAuaG1hY19TSEEyNTYgPSBnZXRfaG1hY19TSEEyNTY7XG5cdCAgc2V0dXAuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0ICBzZXR1cC5XUyA9IFdTO1xuXHQgIHNldHVwLnBhcmFtcyA9IHsgcG5zZGs6IFBOU0RLIH07XG5cblx0ICB2YXIgU0VMRiA9IGZ1bmN0aW9uIChzZXR1cCkge1xuXHQgICAgcmV0dXJuIENSRUFURV9QVUJOVUIoc2V0dXApO1xuXHQgIH07XG5cblx0ICB2YXIgUE4gPSBwdWJOdWJDb3JlLlBOX0FQSShzZXR1cCk7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBQTikge1xuXHQgICAgaWYgKFBOLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdCAgICAgIFNFTEZbcHJvcF0gPSBQTltwcm9wXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBTRUxGLmluaXQgPSBTRUxGO1xuXHQgIFNFTEYuJCA9ICQ7XG5cdCAgU0VMRi5hdHRyID0gYXR0cjtcblx0ICBTRUxGLnNlYXJjaCA9IHNlYXJjaDtcblx0ICBTRUxGLmJpbmQgPSBiaW5kO1xuXHQgIFNFTEYuY3NzID0gY3NzO1xuXHQgIFNFTEYuY3JlYXRlID0gY3JlYXRlO1xuXHQgIFNFTEYuY3J5cHRvX29iaiA9IGNyeXB0b19vYmooKTtcblx0ICBTRUxGLldTID0gV1M7XG5cdCAgU0VMRi5QTm1lc3NhZ2UgPSBwdWJOdWJDb3JlLlBObWVzc2FnZTtcblx0ICBTRUxGLnN1cHBsYW50ID0gcHViTnViQ29yZS5zdXBwbGFudDtcblxuXHQgIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGJpbmQoJ2JlZm9yZXVubG9hZCcsIHdpbmRvdywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBTRUxGWydlYWNoLWNoYW5uZWwnXShmdW5jdGlvbiAoY2gpIHtcblx0ICAgICAgICBTRUxGWydMRUFWRSddKGNoLm5hbWUsIDEpO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBTRUxGLnJlYWR5KCk7XG5cblx0ICAvLyBSZXR1cm4gd2l0aG91dCBUZXN0aW5nXG5cdCAgaWYgKHNldHVwLm5vdGVzdCkgcmV0dXJuIFNFTEY7XG5cblx0ICBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICBiaW5kKCdvZmZsaW5lJywgd2luZG93LCBTRUxGWydvZmZsaW5lJ10pO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgYmluZCgnb2ZmbGluZScsIGRvY3VtZW50LCBTRUxGWydvZmZsaW5lJ10pO1xuXHQgIH1cblxuXHQgIHJldHVybiBTRUxGO1xuXHR9XG5cblx0Q1JFQVRFX1BVQk5VQi5pbml0ID0gQ1JFQVRFX1BVQk5VQjtcblx0Q1JFQVRFX1BVQk5VQi5zZWN1cmUgPSBDUkVBVEVfUFVCTlVCO1xuXHRDUkVBVEVfUFVCTlVCLmNyeXB0b19vYmogPSBjcnlwdG9fb2JqKCk7XG5cdENSRUFURV9QVUJOVUIuV1MgPSBXUztcblx0Q1JFQVRFX1BVQk5VQi5kYiA9IGRiO1xuXHRDUkVBVEVfUFVCTlVCLlBObWVzc2FnZSA9IHB1Yk51YkNvcmUuUE5tZXNzYWdlO1xuXHRDUkVBVEVfUFVCTlVCLnV1aWQgPSBwdWJOdWJDb3JlLnV1aWQ7XG5cblx0Q1JFQVRFX1BVQk5VQi5jc3MgPSBjc3M7XG5cdENSRUFURV9QVUJOVUIuJCA9ICQ7XG5cdENSRUFURV9QVUJOVUIuY3JlYXRlID0gJDtcblx0Q1JFQVRFX1BVQk5VQi5iaW5kID0gYmluZDtcblx0Q1JFQVRFX1BVQk5VQi5zZWFyY2ggPSBzZWFyY2g7XG5cdENSRUFURV9QVUJOVUIuYXR0ciA9IGF0dHI7XG5cdENSRUFURV9QVUJOVUIuZXZlbnRzID0gZXZlbnRzO1xuXG5cdENSRUFURV9QVUJOVUIubWFwID0gcHViTnViQ29yZS5tYXA7XG5cdENSRUFURV9QVUJOVUIuZWFjaCA9IHB1Yk51YkNvcmUuZWFjaDtcblx0Q1JFQVRFX1BVQk5VQi5ncmVwID0gcHViTnViQ29yZS5ncmVwO1xuXHRDUkVBVEVfUFVCTlVCLnN1cHBsYW50ID0gcHViTnViQ29yZS5zdXBwbGFudDtcblx0Q1JFQVRFX1BVQk5VQi5ub3cgPSBwdWJOdWJDb3JlLm5vdztcblx0Q1JFQVRFX1BVQk5VQi51bmlxdWUgPSBwdWJOdWJDb3JlLnVuaXF1ZTtcblx0Q1JFQVRFX1BVQk5VQi51cGRhdGVyID0gcHViTnViQ29yZS51cGRhdGVyO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ1JFQVRFX1BVQk5VQjtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0XCJuYW1lXCI6IFwicHVibnViXCIsXG5cdFx0XCJwcmVmZXJHbG9iYWxcIjogZmFsc2UsXG5cdFx0XCJ2ZXJzaW9uXCI6IFwiMy4xNS4yXCIsXG5cdFx0XCJhdXRob3JcIjogXCJQdWJOdWIgPHN1cHBvcnRAcHVibnViLmNvbT5cIixcblx0XHRcImRlc2NyaXB0aW9uXCI6IFwiUHVibGlzaCAmIFN1YnNjcmliZSBSZWFsLXRpbWUgTWVzc2FnaW5nIHdpdGggUHViTnViXCIsXG5cdFx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdFx0e1xuXHRcdFx0XHRcIm5hbWVcIjogXCJTdGVwaGVuIEJsdW1cIixcblx0XHRcdFx0XCJlbWFpbFwiOiBcInN0ZXBoZW5AcHVibnViLmNvbVwiXG5cdFx0XHR9XG5cdFx0XSxcblx0XHRcImJpblwiOiB7fSxcblx0XHRcInNjcmlwdHNcIjoge1xuXHRcdFx0XCJ0ZXN0XCI6IFwiZ3J1bnQgdGVzdCAtLWZvcmNlXCJcblx0XHR9LFxuXHRcdFwibWFpblwiOiBcIi4vbm9kZS5qcy9wdWJudWIuanNcIixcblx0XHRcImJyb3dzZXJcIjogXCIuL21vZGVybi9kaXN0L3B1Ym51Yi5qc1wiLFxuXHRcdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcdFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9wdWJudWIvamF2YXNjcmlwdC5naXRcIlxuXHRcdH0sXG5cdFx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XHRcImNsb3VkXCIsXG5cdFx0XHRcInB1Ymxpc2hcIixcblx0XHRcdFwic3Vic2NyaWJlXCIsXG5cdFx0XHRcIndlYnNvY2tldHNcIixcblx0XHRcdFwiY29tZXRcIixcblx0XHRcdFwiYm9zaFwiLFxuXHRcdFx0XCJ4bXBwXCIsXG5cdFx0XHRcInJlYWwtdGltZVwiLFxuXHRcdFx0XCJtZXNzYWdpbmdcIlxuXHRcdF0sXG5cdFx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFx0XCJhZ2VudGtlZXBhbGl2ZVwiOiBcIn4wLjJcIixcblx0XHRcdFwibG9kYXNoXCI6IFwiXjQuMS4wXCJcblx0XHR9LFxuXHRcdFwibm9BbmFseXplXCI6IGZhbHNlLFxuXHRcdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcdFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuXHRcdFx0XCJlc2xpbnRcIjogXCIyLjQuMFwiLFxuXHRcdFx0XCJlc2xpbnQtY29uZmlnLWFpcmJuYlwiOiBcIl42LjAuMlwiLFxuXHRcdFx0XCJlc2xpbnQtcGx1Z2luLWZsb3d0eXBlXCI6IFwiXjIuMS4wXCIsXG5cdFx0XHRcImVzbGludC1wbHVnaW4tbW9jaGFcIjogXCJeMi4wLjBcIixcblx0XHRcdFwiZXNsaW50LXBsdWdpbi1yZWFjdFwiOiBcIl40LjEuMFwiLFxuXHRcdFx0XCJmbG93LWJpblwiOiBcIl4wLjIyLjBcIixcblx0XHRcdFwiZ3J1bnRcIjogXCJeMC40LjVcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi1jbGVhblwiOiBcIl4xLjAuMFwiLFxuXHRcdFx0XCJncnVudC1jb250cmliLWNvcHlcIjogXCJeMC44LjJcIixcblx0XHRcdFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMC4xMS4xXCIsXG5cdFx0XHRcImdydW50LWVudlwiOiBcIl4wLjQuNFwiLFxuXHRcdFx0XCJncnVudC1lc2xpbnRcIjogXCJeMTguMC4wXCIsXG5cdFx0XHRcImdydW50LWZsb3dcIjogXCJeMS4wLjNcIixcblx0XHRcdFwiZ3J1bnQta2FybWFcIjogXCJeMC4xMi4xXCIsXG5cdFx0XHRcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjMuMC4xXCIsXG5cdFx0XHRcImdydW50LXRleHQtcmVwbGFjZVwiOiBcIl4wLjQuMFwiLFxuXHRcdFx0XCJncnVudC13ZWJwYWNrXCI6IFwiXjEuMC4xMVwiLFxuXHRcdFx0XCJpbXBvcnRzLWxvYWRlclwiOiBcIl4wLjYuNVwiLFxuXHRcdFx0XCJpc3BhcnRhXCI6IFwiXjQuMC4wXCIsXG5cdFx0XHRcImpzb24tbG9hZGVyXCI6IFwiXjAuNS40XCIsXG5cdFx0XHRcImthcm1hXCI6IFwiXjAuMTMuMjFcIixcblx0XHRcdFwia2FybWEtY2hhaVwiOiBcIl4wLjEuMFwiLFxuXHRcdFx0XCJrYXJtYS1tb2NoYVwiOiBcIl4wLjIuMVwiLFxuXHRcdFx0XCJrYXJtYS1waGFudG9tanMtbGF1bmNoZXJcIjogXCJeMS4wLjBcIixcblx0XHRcdFwia2FybWEtc3BlYy1yZXBvcnRlclwiOiBcIjAuMC4yNFwiLFxuXHRcdFx0XCJsb2FkLWdydW50LXRhc2tzXCI6IFwiXjMuNC4wXCIsXG5cdFx0XHRcIm1vY2hhXCI6IFwiXjIuNC41XCIsXG5cdFx0XHRcIm5vY2tcIjogXCJeMS4xLjBcIixcblx0XHRcdFwibm9kZS11dWlkXCI6IFwiXjEuNC43XCIsXG5cdFx0XHRcIm5vZGV1bml0XCI6IFwiXjAuOS4wXCIsXG5cdFx0XHRcInBoYW50b21qcy1wcmVidWlsdFwiOiBcIl4yLjEuNFwiLFxuXHRcdFx0XCJwcm94eXF1aXJlXCI6IFwiXjEuNy40XCIsXG5cdFx0XHRcInNpbm9uXCI6IFwiXjEuMTcuMlwiLFxuXHRcdFx0XCJ1Z2xpZnktanNcIjogXCJeMi42LjFcIixcblx0XHRcdFwidW5kZXJzY29yZVwiOiBcIl4xLjcuMFwiLFxuXHRcdFx0XCJ3ZWJwYWNrXCI6IFwiXjEuMTIuMTNcIixcblx0XHRcdFwid2VicGFjay1kZXYtc2VydmVyXCI6IFwiXjEuMTQuMVwiXG5cdFx0fSxcblx0XHRcImJ1bmRsZURlcGVuZGVuY2llc1wiOiBbXSxcblx0XHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XHRcImVuZ2luZVwiOiB7XG5cdFx0XHRcIm5vZGVcIjogXCI+PTAuOFwiXG5cdFx0fSxcblx0XHRcImZpbGVzXCI6IFtcblx0XHRcdFwiY29yZVwiLFxuXHRcdFx0XCJub2RlLmpzXCIsXG5cdFx0XHRcIm1vZGVyblwiLFxuXHRcdFx0XCJDSEFOR0VMT0dcIixcblx0XHRcdFwiRlVUVVJFLm1kXCIsXG5cdFx0XHRcIkxJQ0VOU0VcIixcblx0XHRcdFwiUkVBRE1FLm1kXCJcblx0XHRdXG5cdH07XG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBlc2xpbnQgY2FtZWxjYXNlOiAwLCBuby11c2UtYmVmb3JlLWRlZmluZTogMCwgbm8tdW51c2VkLWV4cHJlc3Npb25zOiAwICAqL1xuXHQvKiBlc2xpbnQgZXFlcWVxOiAwLCBvbmUtdmFyOiAwICovXG5cdC8qIGVzbGludCBuby1yZWRlY2xhcmU6IDAgKi9cblx0LyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuXHQvKiBlc2xpbnQgYmxvY2stc2NvcGVkLXZhcjogMCBzcGFjZS1yZXR1cm4tdGhyb3ctY2FzZTogMCwgbm8tdW51c2VkLXZhcnM6IDAgKi9cblxuXHR2YXIgcGFja2FnZUpTT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgZGVmYXVsdENvbmZpZ3VyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBOT1cgPSAxO1xuXHR2YXIgUkVBRFkgPSBmYWxzZTtcblx0dmFyIFJFQURZX0JVRkZFUiA9IFtdO1xuXHR2YXIgUFJFU0VOQ0VfU1VGRklYID0gJy1wbnByZXMnO1xuXHR2YXIgREVGX1dJTkRPV0lORyA9IDEwOyAvLyBNSUxMSVNFQ09ORFMuXG5cdHZhciBERUZfVElNRU9VVCA9IDE1MDAwOyAvLyBNSUxMSVNFQ09ORFMuXG5cdHZhciBERUZfU1VCX1RJTUVPVVQgPSAzMTA7IC8vIFNFQ09ORFMuXG5cdHZhciBERUZfS0VFUEFMSVZFID0gNjA7IC8vIFNFQ09ORFMgKEZPUiBUSU1FU1lOQykuXG5cdHZhciBTRUNPTkQgPSAxMDAwOyAvLyBBIFRIT1VTQU5EIE1JTExJU0VDT05EUy5cblx0dmFyIFBSRVNFTkNFX0hCX1RIUkVTSE9MRCA9IDU7XG5cdHZhciBQUkVTRU5DRV9IQl9ERUZBVUxUID0gMzA7XG5cdHZhciBTREtfVkVSID0gcGFja2FnZUpTT04udmVyc2lvbjtcblxuXHQvKipcblx0ICogVVRJTElUSUVTXG5cdCAqL1xuXHRmdW5jdGlvbiB1bmlxdWUoKSB7XG5cdCAgcmV0dXJuICd4JyArICsrTk9XICsgJycgKyAoK25ldyBEYXRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBORVhUT1JJR0lOXG5cdCAqID09PT09PT09PT1cblx0ICogdmFyIG5leHRfb3JpZ2luID0gbmV4dG9yaWdpbigpO1xuXHQgKi9cblx0dmFyIG5leHRvcmlnaW4gPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBtYXggPSAyMDtcblx0ICB2YXIgb3JpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKG9yaWdpbiwgZmFpbG92ZXIpIHtcblx0ICAgIHJldHVybiBvcmlnaW4uaW5kZXhPZigncHVic3ViLicpID4gMFxuXHQgICAgICAmJiBvcmlnaW4ucmVwbGFjZShcblx0ICAgICAgICAncHVic3ViJywgJ3BzJyArIChcblx0ICAgICAgICAgIGZhaWxvdmVyID8gdXRpbHMuZ2VuZXJhdGVVVUlEKCkuc3BsaXQoJy0nKVswXSA6XG5cdCAgICAgICAgICAgICgrK29yaSA8IG1heCA/IG9yaSA6IG9yaSA9IDEpXG5cdCAgICAgICAgKSkgfHwgb3JpZ2luO1xuXHQgIH07XG5cdH0pKCk7XG5cblxuXHQvKipcblx0ICogR2VuZXJhdGUgU3Vic2NyaXB0aW9uIENoYW5uZWwgTGlzdFxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIGdlbmVyYXRlX2NoYW5uZWxfbGlzdChjaGFubmVsc19vYmplY3QpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KGNoYW5uZWxzLCBub3ByZXNlbmNlKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICB1dGlscy5lYWNoKGNoYW5uZWxzLCBmdW5jdGlvbiAoY2hhbm5lbCwgc3RhdHVzKSB7XG5cdCAgICBpZiAobm9wcmVzZW5jZSkge1xuXHQgICAgICBpZiAoY2hhbm5lbC5zZWFyY2goJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Quc29ydCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIFN1YnNjcmlwdGlvbiBDaGFubmVsIEdyb3VwcyBMaXN0XG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KGNoYW5uZWxzX2dyb3VwcyBvYmplY3QpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KGNoYW5uZWxfZ3JvdXBzLCBub3ByZXNlbmNlKSB7XG5cdCAgdmFyIGxpc3QgPSBbXTtcblx0ICB1dGlscy5lYWNoKGNoYW5uZWxfZ3JvdXBzLCBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCwgc3RhdHVzKSB7XG5cdCAgICBpZiAobm9wcmVzZW5jZSkge1xuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cC5zZWFyY2goJy1wbnByZXMnKSA8IDApIHtcblx0ICAgICAgICBpZiAoc3RhdHVzLnN1YnNjcmliZWQpIGxpc3QucHVzaChjaGFubmVsX2dyb3VwKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHN0YXR1cy5zdWJzY3JpYmVkKSBsaXN0LnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGxpc3Quc29ydCgpO1xuXHR9XG5cblx0Ly8gUFVCTlVCIFJFQURZIFRPIENPTk5FQ1Rcblx0ZnVuY3Rpb24gcmVhZHkoKSB7XG5cdCAgaWYgKFJFQURZKSByZXR1cm47XG5cdCAgUkVBRFkgPSAxO1xuXHQgIHV0aWxzLmVhY2goUkVBRFlfQlVGRkVSLCBmdW5jdGlvbiAoY29ubmVjdCkge1xuXHQgICAgY29ubmVjdCgpO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gUE5tZXNzYWdlKGFyZ3MpIHtcblx0ICB2YXIgbXNnID0gYXJncyB8fCB7IGFwbnM6IHt9IH07XG5cblx0ICBtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtID0ge307XG5cblx0ICAgIGlmIChPYmplY3Qua2V5cyhtc2dbJ2FwbnMnXSkubGVuZ3RoKSB7XG5cdCAgICAgIG1bJ3BuX2FwbnMnXSA9IHtcblx0ICAgICAgICBhcHM6IHtcblx0ICAgICAgICAgIGFsZXJ0OiBtc2dbJ2FwbnMnXVsnYWxlcnQnXSxcblx0ICAgICAgICAgIGJhZGdlOiBtc2dbJ2FwbnMnXVsnYmFkZ2UnXVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBtc2dbJ2FwbnMnXSkge1xuXHQgICAgICAgIG1bJ3BuX2FwbnMnXVtrXSA9IG1zZ1snYXBucyddW2tdO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBleGNsdWRlMSA9IFsnYmFkZ2UnLCAnYWxlcnQnXTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBleGNsdWRlMSkge1xuXHQgICAgICAgIGRlbGV0ZSBtWydwbl9hcG5zJ11bZXhjbHVkZTFba11dO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChtc2dbJ2djbSddKSB7XG5cdCAgICAgIG1bJ3BuX2djbSddID0ge1xuXHQgICAgICAgIGRhdGE6IG1zZ1snZ2NtJ11cblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgayBpbiBtc2cpIHtcblx0ICAgICAgbVtrXSA9IG1zZ1trXTtcblx0ICAgIH1cblx0ICAgIHZhciBleGNsdWRlID0gWydhcG5zJywgJ2djbScsICdwdWJsaXNoJywgJ2NoYW5uZWwnLCAnY2FsbGJhY2snLCAnZXJyb3InXTtcblx0ICAgIGZvciAodmFyIGsgaW4gZXhjbHVkZSkge1xuXHQgICAgICBkZWxldGUgbVtleGNsdWRlW2tdXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG07XG5cdCAgfTtcblx0ICBtc2dbJ3B1Ymxpc2gnXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtID0gbXNnLmdldFB1Ym51Yk1lc3NhZ2UoKTtcblxuXHQgICAgaWYgKG1zZ1sncHVibnViJ10gJiYgbXNnWydjaGFubmVsJ10pIHtcblx0ICAgICAgbXNnWydwdWJudWInXS5wdWJsaXNoKHtcblx0ICAgICAgICBtZXNzYWdlOiBtLFxuXHQgICAgICAgIGNoYW5uZWw6IG1zZ1snY2hhbm5lbCddLFxuXHQgICAgICAgIGNhbGxiYWNrOiBtc2dbJ2NhbGxiYWNrJ10sXG5cdCAgICAgICAgZXJyb3I6IG1zZ1snZXJyb3InXVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIHJldHVybiBtc2c7XG5cdH1cblxuXHRmdW5jdGlvbiBQTl9BUEkoc2V0dXApIHtcblx0ICB2YXIgU1VCX1dJTkRPV0lORyA9ICtzZXR1cFsnd2luZG93aW5nJ10gfHwgREVGX1dJTkRPV0lORztcblx0ICB2YXIgU1VCX1RJTUVPVVQgPSAoK3NldHVwWyd0aW1lb3V0J10gfHwgREVGX1NVQl9USU1FT1VUKSAqIFNFQ09ORDtcblx0ICB2YXIgS0VFUEFMSVZFID0gKCtzZXR1cFsna2VlcGFsaXZlJ10gfHwgREVGX0tFRVBBTElWRSkgKiBTRUNPTkQ7XG5cdCAgdmFyIFRJTUVfQ0hFQ0sgPSBzZXR1cFsndGltZWNoZWNrJ10gfHwgMDtcblx0ICB2YXIgTk9MRUFWRSA9IHNldHVwWydub2xlYXZlJ10gfHwgMDtcblx0ICB2YXIgUFVCTElTSF9LRVkgPSBzZXR1cFsncHVibGlzaF9rZXknXTtcblx0ICB2YXIgU1VCU0NSSUJFX0tFWSA9IHNldHVwWydzdWJzY3JpYmVfa2V5J107XG5cdCAgdmFyIEFVVEhfS0VZID0gc2V0dXBbJ2F1dGhfa2V5J10gfHwgJyc7XG5cdCAgdmFyIFNFQ1JFVF9LRVkgPSBzZXR1cFsnc2VjcmV0X2tleSddIHx8ICcnO1xuXHQgIHZhciBobWFjX1NIQTI1NiA9IHNldHVwWydobWFjX1NIQTI1NiddO1xuXHQgIHZhciBTU0wgPSBzZXR1cFsnc3NsJ10gPyAncycgOiAnJztcblx0ICB2YXIgT1JJR0lOID0gJ2h0dHAnICsgU1NMICsgJzovLycgKyAoc2V0dXBbJ29yaWdpbiddIHx8ICdwdWJzdWIucHVibnViLmNvbScpO1xuXHQgIHZhciBTVERfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgIHZhciBTVUJfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgIHZhciBDT05ORUNUID0gZnVuY3Rpb24gKCkge1xuXHQgIH07XG5cdCAgdmFyIFBVQl9RVUVVRSA9IFtdO1xuXHQgIHZhciBDTE9BSyA9IHRydWU7XG5cdCAgdmFyIFRJTUVfRFJJRlQgPSAwO1xuXHQgIHZhciBTVUJfQ0FMTEJBQ0sgPSAwO1xuXHQgIHZhciBTVUJfQ0hBTk5FTCA9IDA7XG5cdCAgdmFyIFNVQl9SRUNFSVZFUiA9IDA7XG5cdCAgdmFyIFNVQl9SRVNUT1JFID0gc2V0dXBbJ3Jlc3RvcmUnXSB8fCAwO1xuXHQgIHZhciBTVUJfQlVGRl9XQUlUID0gMDtcblx0ICB2YXIgVElNRVRPS0VOID0gMDtcblx0ICB2YXIgUkVTVU1FRCA9IGZhbHNlO1xuXHQgIHZhciBDSEFOTkVMUyA9IHt9O1xuXHQgIHZhciBDSEFOTkVMX0dST1VQUyA9IHt9O1xuXHQgIHZhciBTVUJfRVJST1IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgfTtcblx0ICB2YXIgU1RBVEUgPSB7fTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfVElNRU9VVCA9IG51bGw7XG5cdCAgdmFyIFBSRVNFTkNFX0hCID0gdmFsaWRhdGVfcHJlc2VuY2VfaGVhcnRiZWF0KFxuXHQgICAgc2V0dXBbJ2hlYXJ0YmVhdCddIHx8IHNldHVwWydwbmV4cGlyZXMnXSB8fCAwLCBzZXR1cFsnZXJyb3InXVxuXHQgICk7XG5cdCAgdmFyIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gc2V0dXBbJ2hlYXJ0YmVhdF9pbnRlcnZhbCddIHx8IChQUkVTRU5DRV9IQiAvIDIpIC0gMTtcblx0ICB2YXIgUFJFU0VOQ0VfSEJfUlVOTklORyA9IGZhbHNlO1xuXHQgIHZhciBOT19XQUlUX0ZPUl9QRU5ESU5HID0gc2V0dXBbJ25vX3dhaXRfZm9yX3BlbmRpbmcnXTtcblx0ICB2YXIgQ09NUEFUSUJMRV8zNSA9IHNldHVwWydjb21wYXRpYmxlXzMuNSddIHx8IGZhbHNlO1xuXHQgIHZhciB4ZHIgPSBzZXR1cFsneGRyJ107XG5cdCAgdmFyIHBhcmFtcyA9IHNldHVwWydwYXJhbXMnXSB8fCB7fTtcblx0ICB2YXIgZXJyb3IgPSBzZXR1cFsnZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICB2YXIgX2lzX29ubGluZSA9IHNldHVwWydfaXNfb25saW5lJ10gfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTt9O1xuXHQgIHZhciBqc29ucF9jYiA9IHNldHVwWydqc29ucF9jYiddIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG5cdCAgdmFyIGRiID0gc2V0dXBbJ2RiJ10gfHwgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9LCBzZXQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cdCAgdmFyIENJUEhFUl9LRVkgPSBzZXR1cFsnY2lwaGVyX2tleSddO1xuXHQgIHZhciBVVUlEID0gc2V0dXBbJ3V1aWQnXSB8fCAoIXNldHVwWyd1bmlxdWVfdXVpZCddICYmIGRiICYmIGRiWydnZXQnXShTVUJTQ1JJQkVfS0VZICsgJ3V1aWQnKSB8fCAnJyk7XG5cdCAgdmFyIFVTRV9JTlNUQU5DRUlEID0gc2V0dXBbJ2luc3RhbmNlX2lkJ10gfHwgZmFsc2U7XG5cdCAgdmFyIElOU1RBTkNFSUQgPSAnJztcblx0ICB2YXIgc2h1dGRvd24gPSBzZXR1cFsnc2h1dGRvd24nXTtcblx0ICB2YXIgdXNlX3NlbmRfYmVhY29uID0gKHR5cGVvZiBzZXR1cFsndXNlX3NlbmRfYmVhY29uJ10gIT0gJ3VuZGVmaW5lZCcpID8gc2V0dXBbJ3VzZV9zZW5kX2JlYWNvbiddIDogdHJ1ZTtcblx0ICB2YXIgc2VuZEJlYWNvbiA9ICh1c2Vfc2VuZF9iZWFjb24pID8gc2V0dXBbJ3NlbmRCZWFjb24nXSA6IG51bGw7XG5cdCAgdmFyIF9wb2xsX3RpbWVyO1xuXHQgIHZhciBfcG9sbF90aW1lcjI7XG5cblx0ICBpZiAoUFJFU0VOQ0VfSEIgPT09IDIpIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gMTtcblxuXHQgIHZhciBjcnlwdG9fb2JqID0gc2V0dXBbJ2NyeXB0b19vYmonXSB8fCB7XG5cdCAgICBlbmNyeXB0OiBmdW5jdGlvbiAoYSwga2V5KSB7XG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfSxcblx0ICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChiLCBrZXkpIHtcblx0ICAgICAgcmV0dXJuIGI7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIF9nZXRfdXJsX3BhcmFtcyhkYXRhKSB7XG5cdCAgICBpZiAoIWRhdGEpIGRhdGEgPSB7fTtcblx0ICAgIHV0aWxzLmVhY2gocGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBpZiAoIShrZXkgaW4gZGF0YSkpIGRhdGFba2V5XSA9IHZhbHVlO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfb2JqZWN0X3RvX2tleV9saXN0KG8pIHtcblx0ICAgIHZhciBsID0gW107XG5cdCAgICB1dGlscy5lYWNoKG8sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICAgIGwucHVzaChrZXkpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gbDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfb2JqZWN0X3RvX2tleV9saXN0X3NvcnRlZChvKSB7XG5cdCAgICByZXR1cm4gX29iamVjdF90b19rZXlfbGlzdChvKS5zb3J0KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX2dldF9wYW1fc2lnbl9pbnB1dF9mcm9tX3BhcmFtcyhwYXJhbXMpIHtcblx0ICAgIHZhciBzaSA9ICcnO1xuXHQgICAgdmFyIGwgPSBfb2JqZWN0X3RvX2tleV9saXN0X3NvcnRlZChwYXJhbXMpO1xuXG5cdCAgICBmb3IgKHZhciBpIGluIGwpIHtcblx0ICAgICAgdmFyIGsgPSBsW2ldO1xuXHQgICAgICBzaSArPSBrICsgJz0nICsgdXRpbHMucGFtRW5jb2RlKHBhcmFtc1trXSk7XG5cdCAgICAgIGlmIChpICE9IGwubGVuZ3RoIC0gMSkgc2kgKz0gJyYnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHZhbGlkYXRlX3ByZXNlbmNlX2hlYXJ0YmVhdChoZWFydGJlYXQsIGN1cl9oZWFydGJlYXQsIGVycm9yKSB7XG5cdCAgICB2YXIgZXJyID0gZmFsc2U7XG5cblx0ICAgIGlmICh0eXBlb2YgaGVhcnRiZWF0ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICByZXR1cm4gY3VyX2hlYXJ0YmVhdDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIGlmIChoZWFydGJlYXQgPiBQUkVTRU5DRV9IQl9USFJFU0hPTEQgfHwgaGVhcnRiZWF0ID09IDApIHtcblx0ICAgICAgICBlcnIgPSBmYWxzZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlcnIgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFydGJlYXQgPT09ICdib29sZWFuJykge1xuXHQgICAgICBpZiAoIWhlYXJ0YmVhdCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBQUkVTRU5DRV9IQl9ERUZBVUxUO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlcnIgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZXJyKSB7XG5cdCAgICAgIGVycm9yICYmIGVycm9yKCdQcmVzZW5jZSBIZWFydGJlYXQgdmFsdWUgaW52YWxpZC4gVmFsaWQgcmFuZ2UgKCB4ID4gJyArIFBSRVNFTkNFX0hCX1RIUkVTSE9MRCArICcgb3IgeCA9IDApLiBDdXJyZW50IFZhbHVlIDogJyArIChjdXJfaGVhcnRiZWF0IHx8IFBSRVNFTkNFX0hCX1RIUkVTSE9MRCkpO1xuXHQgICAgICByZXR1cm4gY3VyX2hlYXJ0YmVhdCB8fCBQUkVTRU5DRV9IQl9USFJFU0hPTEQ7XG5cdCAgICB9IGVsc2UgcmV0dXJuIGhlYXJ0YmVhdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBlbmNyeXB0KGlucHV0LCBrZXkpIHtcblx0ICAgIHJldHVybiBjcnlwdG9fb2JqWydlbmNyeXB0J10oaW5wdXQsIGtleSB8fCBDSVBIRVJfS0VZKSB8fCBpbnB1dDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWNyeXB0KGlucHV0LCBrZXkpIHtcblx0ICAgIHJldHVybiBjcnlwdG9fb2JqWydkZWNyeXB0J10oaW5wdXQsIGtleSB8fCBDSVBIRVJfS0VZKSB8fFxuXHQgICAgICBjcnlwdG9fb2JqWydkZWNyeXB0J10oaW5wdXQsIENJUEhFUl9LRVkpIHx8XG5cdCAgICAgIGlucHV0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVycm9yX2NvbW1vbihtZXNzYWdlLCBjYWxsYmFjaykge1xuXHQgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soeyBlcnJvcjogbWVzc2FnZSB8fCAnZXJyb3Igb2NjdXJyZWQnIH0pO1xuXHQgICAgZXJyb3IgJiYgZXJyb3IobWVzc2FnZSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX3ByZXNlbmNlX2hlYXJ0YmVhdCgpIHtcblx0ICAgIGNsZWFyVGltZW91dChQUkVTRU5DRV9IQl9USU1FT1VUKTtcblxuXHQgICAgaWYgKCFQUkVTRU5DRV9IQl9JTlRFUlZBTCB8fCBQUkVTRU5DRV9IQl9JTlRFUlZBTCA+PSA1MDAgfHxcblx0ICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPCAxIHx8XG5cdCAgICAgICghZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKS5sZW5ndGggJiYgIWdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUywgdHJ1ZSkubGVuZ3RoKSkge1xuXHQgICAgICBQUkVTRU5DRV9IQl9SVU5OSU5HID0gZmFsc2U7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgUFJFU0VOQ0VfSEJfUlVOTklORyA9IHRydWU7XG5cdCAgICBTRUxGWydwcmVzZW5jZV9oZWFydGJlYXQnXSh7XG5cdCAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAocikge1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KF9wcmVzZW5jZV9oZWFydGJlYXQsIChQUkVTRU5DRV9IQl9JTlRFUlZBTCkgKiBTRUNPTkQpO1xuXHQgICAgICB9LFxuXHQgICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBlcnJvciAmJiBlcnJvcignUHJlc2VuY2UgSGVhcnRiZWF0IHVuYWJsZSB0byByZWFjaCBQdWJudWIgc2VydmVycy4nICsgSlNPTi5zdHJpbmdpZnkoZSkpO1xuXHQgICAgICAgIFBSRVNFTkNFX0hCX1RJTUVPVVQgPSB1dGlscy50aW1lb3V0KF9wcmVzZW5jZV9oZWFydGJlYXQsIChQUkVTRU5DRV9IQl9JTlRFUlZBTCkgKiBTRUNPTkQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzdGFydF9wcmVzZW5jZV9oZWFydGJlYXQoKSB7XG5cdCAgICAhUFJFU0VOQ0VfSEJfUlVOTklORyAmJiBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcHVibGlzaChuZXh0KSB7XG5cdCAgICBpZiAoTk9fV0FJVF9GT1JfUEVORElORykge1xuXHQgICAgICBpZiAoIVBVQl9RVUVVRS5sZW5ndGgpIHJldHVybjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChuZXh0KSBQVUJfUVVFVUUuc2VuZGluZyA9IDA7XG5cdCAgICAgIGlmIChQVUJfUVVFVUUuc2VuZGluZyB8fCAhUFVCX1FVRVVFLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgICBQVUJfUVVFVUUuc2VuZGluZyA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHhkcihQVUJfUVVFVUUuc2hpZnQoKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZWFjaF9jaGFubmVsX2dyb3VwKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgY291bnQgPSAwO1xuXG5cdCAgICB1dGlscy5lYWNoKGdlbmVyYXRlX2NoYW5uZWxfZ3JvdXBfbGlzdChDSEFOTkVMX0dST1VQUyksIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgIHZhciBjaGFuZyA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdO1xuXG5cdCAgICAgIGlmICghY2hhbmcpIHJldHVybjtcblxuXHQgICAgICBjb3VudCsrO1xuXHQgICAgICAoY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB9KShjaGFuZyk7XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNvdW50O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVhY2hfY2hhbm5lbChjYWxsYmFjaykge1xuXHQgICAgdmFyIGNvdW50ID0gMDtcblxuXHQgICAgdXRpbHMuZWFjaChnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICB2YXIgY2hhbiA9IENIQU5ORUxTW2NoYW5uZWxdO1xuXG5cdCAgICAgIGlmICghY2hhbikgcmV0dXJuO1xuXG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICAgIChjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0pKGNoYW4pO1xuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBjb3VudDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKSB7XG5cdCAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdvYmplY3QnKSB7XG5cdCAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSkge1xuXHQgICAgICAgIHZhciBjYWxsYmFja19kYXRhID0ge307XG5cblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2tfZGF0YVsnbWVzc2FnZSddID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgICAgY2FsbGJhY2tfZGF0YVsncGF5bG9hZCddID0gcmVzcG9uc2VbJ3BheWxvYWQnXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBlcnIgJiYgZXJyKGNhbGxiYWNrX2RhdGEpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgIGlmIChyZXNwb25zZVsnbmV4dF9wYWdlJ10pIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlWydwYXlsb2FkJ10sIHJlc3BvbnNlWyduZXh0X3BhZ2UnXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlWydwYXlsb2FkJ10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpIHtcblx0ICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcgJiYgcmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrX2RhdGEgPSB7fTtcblxuXHQgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSkge1xuXHQgICAgICAgIGNhbGxiYWNrX2RhdGFbJ21lc3NhZ2UnXSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocmVzcG9uc2VbJ3BheWxvYWQnXSkge1xuXHQgICAgICAgIGNhbGxiYWNrX2RhdGFbJ3BheWxvYWQnXSA9IHJlc3BvbnNlWydwYXlsb2FkJ107XG5cdCAgICAgIH1cblxuXHQgICAgICBlcnIgJiYgZXJyKGNhbGxiYWNrX2RhdGEpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlcnIgJiYgZXJyKHJlc3BvbnNlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBDUihhcmdzLCBjYWxsYmFjaywgdXJsMSwgZGF0YSkge1xuXHQgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGVycm9yO1xuXHQgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblxuXHQgICAgZGF0YSA9IGRhdGEgfHwge307XG5cblx0ICAgIGlmICghZGF0YVsnYXV0aCddKSB7XG5cdCAgICAgIGRhdGFbJ2F1dGgnXSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICB9XG5cblx0ICAgIHZhciB1cmwgPSBbXG5cdCAgICAgIFNURF9PUklHSU4sICd2MScsICdjaGFubmVsLXJlZ2lzdHJhdGlvbicsXG5cdCAgICAgICdzdWIta2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgXTtcblxuXHQgICAgdXJsLnB1c2guYXBwbHkodXJsLCB1cmwxKTtcblxuXHQgICAgaWYgKGpzb25wKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgIHhkcih7XG5cdCAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpLFxuXHQgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgfSxcblx0ICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgfSxcblx0ICAgICAgdXJsOiB1cmxcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIC8vIEFubm91bmNlIExlYXZlIEV2ZW50XG5cdCAgdmFyIFNFTEYgPSB7XG5cdCAgICBMRUFWRTogZnVuY3Rpb24gKGNoYW5uZWwsIGJsb2NraW5nLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycm9yKSB7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB8fCBBVVRIX0tFWSB9O1xuXHQgICAgICB2YXIgb3JpZ2luID0gbmV4dG9yaWdpbihPUklHSU4pO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGVycm9yIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgdXJsO1xuXHQgICAgICB2YXIgcGFyYW1zO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIFByZXZlbnQgTGVhdmluZyBhIFByZXNlbmNlIENoYW5uZWxcblx0ICAgICAgaWYgKGNoYW5uZWwuaW5kZXhPZihQUkVTRU5DRV9TVUZGSVgpID4gMCkgcmV0dXJuIHRydWU7XG5cblxuXHQgICAgICBpZiAoQ09NUEFUSUJMRV8zNSkge1xuXHQgICAgICAgIGlmICghU1NMKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKGpzb25wID09ICcwJykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE5PTEVBVkUpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBvcmlnaW4sICd2MicsICdwcmVzZW5jZScsICdzdWJfa2V5Jyxcblx0ICAgICAgICBTVUJTQ1JJQkVfS0VZLCAnY2hhbm5lbCcsIHV0aWxzLmVuY29kZShjaGFubmVsKSwgJ2xlYXZlJ1xuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXG5cdCAgICAgIGlmIChzZW5kQmVhY29uKSB7XG5cdCAgICAgICAgdmFyIHVybF9zdHJpbmcgPSB1dGlscy5idWlsZFVSTCh1cmwsIHBhcmFtcyk7XG5cdCAgICAgICAgaWYgKHNlbmRCZWFjb24odXJsX3N0cmluZykpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHsgc3RhdHVzOiAyMDAsIGFjdGlvbjogJ2xlYXZlJywgbWVzc2FnZTogJ09LJywgc2VydmljZTogJ1ByZXNlbmNlJyB9KTtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBibG9ja2luZzogYmxvY2tpbmcgfHwgU1NMLFxuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBwYXJhbXMsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0sXG5cblx0ICAgIExFQVZFX0dST1VQOiBmdW5jdGlvbiAoY2hhbm5lbF9ncm91cCwgYmxvY2tpbmcsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyb3IpIHtcblx0ICAgICAgdmFyIGRhdGEgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IHx8IEFVVEhfS0VZIH07XG5cdCAgICAgIHZhciBvcmlnaW4gPSBuZXh0b3JpZ2luKE9SSUdJTik7XG5cdCAgICAgIHZhciB1cmw7XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgZXJyID0gZXJyb3IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gUHJldmVudCBMZWF2aW5nIGEgUHJlc2VuY2UgQ2hhbm5lbCBHcm91cFxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cC5pbmRleE9mKFBSRVNFTkNFX1NVRkZJWCkgPiAwKSByZXR1cm4gdHJ1ZTtcblxuXHQgICAgICBpZiAoQ09NUEFUSUJMRV8zNSkge1xuXHQgICAgICAgIGlmICghU1NMKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgaWYgKGpzb25wID09ICcwJykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE5PTEVBVkUpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgb3JpZ2luLCAndjInLCAncHJlc2VuY2UnLCAnc3ViX2tleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoJywnKSwgJ2xlYXZlJ1xuXHQgICAgICBdO1xuXG5cdCAgICAgIHBhcmFtcyA9IF9nZXRfdXJsX3BhcmFtcyhkYXRhKTtcblxuXHQgICAgICBpZiAoc2VuZEJlYWNvbikge1xuXHQgICAgICAgIHZhciB1cmxfc3RyaW5nID0gdXRpbHMuYnVpbGRVUkwodXJsLCBwYXJhbXMpO1xuXHQgICAgICAgIGlmIChzZW5kQmVhY29uKHVybF9zdHJpbmcpKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh7IHN0YXR1czogMjAwLCBhY3Rpb246ICdsZWF2ZScsIG1lc3NhZ2U6ICdPSycsIHNlcnZpY2U6ICdQcmVzZW5jZScgfSk7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGJsb2NraW5nOiBibG9ja2luZyB8fCBTU0wsXG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgc2V0X3Jlc3VtZWQ6IGZ1bmN0aW9uIChyZXN1bWVkKSB7XG5cdCAgICAgIFJFU1VNRUQgPSByZXN1bWVkO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2NpcGhlcl9rZXk6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIENJUEhFUl9LRVk7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfY2lwaGVyX2tleTogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICBDSVBIRVJfS0VZID0ga2V5O1xuXHQgICAgfSxcblxuXHQgICAgcmF3X2VuY3J5cHQ6IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG5cdCAgICAgIHJldHVybiBlbmNyeXB0KGlucHV0LCBrZXkpO1xuXHQgICAgfSxcblxuXHQgICAgcmF3X2RlY3J5cHQ6IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG5cdCAgICAgIHJldHVybiBkZWNyeXB0KGlucHV0LCBrZXkpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2hlYXJ0YmVhdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUFJFU0VOQ0VfSEI7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfaGVhcnRiZWF0OiBmdW5jdGlvbiAoaGVhcnRiZWF0LCBoZWFydGJlYXRfaW50ZXJ2YWwpIHtcblx0ICAgICAgUFJFU0VOQ0VfSEIgPSB2YWxpZGF0ZV9wcmVzZW5jZV9oZWFydGJlYXQoaGVhcnRiZWF0LCBQUkVTRU5DRV9IQiwgZXJyb3IpO1xuXHQgICAgICBQUkVTRU5DRV9IQl9JTlRFUlZBTCA9IGhlYXJ0YmVhdF9pbnRlcnZhbCB8fCAoUFJFU0VOQ0VfSEIgLyAyKSAtIDE7XG5cdCAgICAgIGlmIChQUkVTRU5DRV9IQiA9PSAyKSB7XG5cdCAgICAgICAgUFJFU0VOQ0VfSEJfSU5URVJWQUwgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIENPTk5FQ1QoKTtcblx0ICAgICAgX3ByZXNlbmNlX2hlYXJ0YmVhdCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X2hlYXJ0YmVhdF9pbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gUFJFU0VOQ0VfSEJfSU5URVJWQUw7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRfaGVhcnRiZWF0X2ludGVydmFsOiBmdW5jdGlvbiAoaGVhcnRiZWF0X2ludGVydmFsKSB7XG5cdCAgICAgIFBSRVNFTkNFX0hCX0lOVEVSVkFMID0gaGVhcnRiZWF0X2ludGVydmFsO1xuXHQgICAgICBfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfdmVyc2lvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gU0RLX1ZFUjtcblx0ICAgIH0sXG5cblx0ICAgIGdldEdjbU1lc3NhZ2VPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkYXRhOiBvYmpcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEFwbnNNZXNzYWdlT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciB4ID0ge1xuXHQgICAgICAgIGFwczogeyBiYWRnZTogMSwgYWxlcnQ6ICcnIH1cblx0ICAgICAgfTtcblx0ICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcblx0ICAgICAgICBrW3hdID0gb2JqW2tdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB4O1xuXHQgICAgfSxcblxuXHQgICAgX2FkZF9wYXJhbTogZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdCAgICAgIHBhcmFtc1trZXldID0gdmFsO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuc19jaCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXTtcblx0ICAgICAgdmFyIGNoYW5uZWxzID0gYXJnc1snY2hhbm5lbHMnXSB8fCBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjbG9hayA9IGFyZ3NbJ2Nsb2FrJ107XG5cdCAgICAgIHZhciBuYW1lc3BhY2U7XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwO1xuXHQgICAgICB2YXIgdXJsID0gW107XG5cdCAgICAgIHZhciBkYXRhID0ge307XG5cdCAgICAgIHZhciBtb2RlID0gYXJnc1snbW9kZSddIHx8ICdhZGQnO1xuXG5cblx0ICAgICAgaWYgKG5zX2NoKSB7XG5cdCAgICAgICAgdmFyIG5zX2NoX2EgPSBuc19jaC5zcGxpdCgnOicpO1xuXG5cdCAgICAgICAgaWYgKG5zX2NoX2EubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgbmFtZXNwYWNlID0gKG5zX2NoX2FbMF0gPT09ICcqJykgPyBudWxsIDogbnNfY2hfYVswXTtcblxuXHQgICAgICAgICAgY2hhbm5lbF9ncm91cCA9IG5zX2NoX2FbMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNoYW5uZWxfZ3JvdXAgPSBuc19jaF9hWzBdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIG5hbWVzcGFjZSAmJiB1cmwucHVzaCgnbmFtZXNwYWNlJykgJiYgdXJsLnB1c2godXRpbHMuZW5jb2RlKG5hbWVzcGFjZSkpO1xuXG5cdCAgICAgIHVybC5wdXNoKCdjaGFubmVsLWdyb3VwJyk7XG5cblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAgJiYgY2hhbm5lbF9ncm91cCAhPT0gJyonKSB7XG5cdCAgICAgICAgdXJsLnB1c2goY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbHMpIHtcblx0ICAgICAgICBpZiAodXRpbHMuaXNBcnJheShjaGFubmVscykpIHtcblx0ICAgICAgICAgIGNoYW5uZWxzID0gY2hhbm5lbHMuam9pbignLCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkYXRhW21vZGVdID0gY2hhbm5lbHM7XG5cdCAgICAgICAgZGF0YVsnY2xvYWsnXSA9IChDTE9BSykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChtb2RlID09PSAncmVtb3ZlJykgdXJsLnB1c2goJ3JlbW92ZScpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjbG9hayAhPSAndW5kZWZpbmVkJykgZGF0YVsnY2xvYWsnXSA9IChjbG9haykgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwsIGRhdGEpO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X2dyb3VwczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuYW1lc3BhY2U7XG5cblx0ICAgICAgbmFtZXNwYWNlID0gYXJnc1snbmFtZXNwYWNlJ10gfHwgYXJnc1snbnMnXSB8fCBhcmdzWydjaGFubmVsX2dyb3VwJ10gfHwgbnVsbDtcblx0ICAgICAgaWYgKG5hbWVzcGFjZSkge1xuXHQgICAgICAgIGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSA9IG5hbWVzcGFjZSArICc6Kic7XG5cdCAgICAgIH1cblxuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9saXN0X2NoYW5uZWxzOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX3JlbW92ZV9jaGFubmVsOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsX2dyb3VwJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIEdyb3VwJyk7XG5cdCAgICAgIGlmICghYXJnc1snY2hhbm5lbCddICYmICFhcmdzWydjaGFubmVscyddKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgQ2hhbm5lbCcpO1xuXG5cdCAgICAgIGFyZ3NbJ21vZGUnXSA9ICdyZW1vdmUnO1xuXHQgICAgICBTRUxGWydjaGFubmVsX2dyb3VwJ10oYXJncywgY2FsbGJhY2spO1xuXHQgICAgfSxcblxuXHQgICAgY2hhbm5lbF9ncm91cF9yZW1vdmVfZ3JvdXA6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKGFyZ3NbJ2NoYW5uZWwnXSkgcmV0dXJuIGVycm9yKCdVc2UgY2hhbm5lbF9ncm91cF9yZW1vdmVfY2hhbm5lbCBpZiB5b3Ugd2FudCB0byByZW1vdmUgYSBjaGFubmVsIGZyb20gYSBncm91cC4nKTtcblxuXHQgICAgICBhcmdzWydtb2RlJ10gPSAncmVtb3ZlJztcblx0ICAgICAgU0VMRlsnY2hhbm5lbF9ncm91cCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfYWRkX2NoYW5uZWw6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBpZiAoIWFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFhcmdzWydjaGFubmVsJ10gJiYgIWFyZ3NbJ2NoYW5uZWxzJ10pIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2Nsb2FrOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgaWYgKHR5cGVvZiBhcmdzWydjbG9hayddID09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgY2FsbGJhY2soQ0xPQUspO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBDTE9BSyA9IGFyZ3NbJ2Nsb2FrJ107XG5cdCAgICAgIFNFTEZbJ2NoYW5uZWxfZ3JvdXAnXShhcmdzLCBjYWxsYmFjayk7XG5cdCAgICB9LFxuXG5cdCAgICBjaGFubmVsX2dyb3VwX2xpc3RfbmFtZXNwYWNlczogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB1cmwgPSBbJ25hbWVzcGFjZSddO1xuXHQgICAgICBDUihhcmdzLCBjYWxsYmFjaywgdXJsKTtcblx0ICAgIH0sXG5cblx0ICAgIGNoYW5uZWxfZ3JvdXBfcmVtb3ZlX25hbWVzcGFjZTogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB1cmwgPSBbJ25hbWVzcGFjZScsIGFyZ3NbJ25hbWVzcGFjZSddLCAncmVtb3ZlJ107XG5cdCAgICAgIENSKGFyZ3MsIGNhbGxiYWNrLCB1cmwpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuaGlzdG9yeSh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdF9jaGFubmVsJyxcblx0ICAgICBsaW1pdCAgICA6IDEwMCxcblx0ICAgICBjYWxsYmFjayA6IGZ1bmN0aW9uKGhpc3RvcnkpIHsgfVxuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBoaXN0b3J5OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBjYWxsYmFjaztcblx0ICAgICAgdmFyIGNvdW50ID0gYXJnc1snY291bnQnXSB8fCBhcmdzWydsaW1pdCddIHx8IDEwMDtcblx0ICAgICAgdmFyIHJldmVyc2UgPSBhcmdzWydyZXZlcnNlJ10gfHwgJ2ZhbHNlJztcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gYXJnc1snY2lwaGVyX2tleSddO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBzdGFydCA9IGFyZ3NbJ3N0YXJ0J107XG5cdCAgICAgIHZhciBlbmQgPSBhcmdzWydlbmQnXTtcblx0ICAgICAgdmFyIGluY2x1ZGVfdG9rZW4gPSBhcmdzWydpbmNsdWRlX3Rva2VuJ107XG5cdCAgICAgIHZhciBzdHJpbmdfbXNnX3Rva2VuID0gYXJnc1snc3RyaW5nX21lc3NhZ2VfdG9rZW4nXSB8fCBmYWxzZTtcblx0ICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgQ2hhbm5lbFxuXHQgICAgICBpZiAoIWNoYW5uZWwgJiYgIWNoYW5uZWxfZ3JvdXApIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsJyk7XG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgcGFyYW1zWydzdHJpbmd0b2tlbiddID0gJ3RydWUnO1xuXHQgICAgICBwYXJhbXNbJ2NvdW50J10gPSBjb3VudDtcblx0ICAgICAgcGFyYW1zWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuXHQgICAgICBwYXJhbXNbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgcGFyYW1zWydjaGFubmVsLWdyb3VwJ10gPSBjaGFubmVsX2dyb3VwO1xuXHQgICAgICAgIGlmICghY2hhbm5lbCkge1xuXHQgICAgICAgICAgY2hhbm5lbCA9ICcsJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGpzb25wKSBwYXJhbXNbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgaWYgKHN0YXJ0KSBwYXJhbXNbJ3N0YXJ0J10gPSBzdGFydDtcblx0ICAgICAgaWYgKGVuZCkgcGFyYW1zWydlbmQnXSA9IGVuZDtcblx0ICAgICAgaWYgKGluY2x1ZGVfdG9rZW4pIHBhcmFtc1snaW5jbHVkZV90b2tlbiddID0gJ3RydWUnO1xuXHQgICAgICBpZiAoc3RyaW5nX21zZ190b2tlbikgcGFyYW1zWydzdHJpbmdfbWVzc2FnZV90b2tlbiddID0gJ3RydWUnO1xuXG5cdCAgICAgIC8vIFNlbmQgTWVzc2FnZVxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMocGFyYW1zKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT0gJ29iamVjdCcgJiYgcmVzcG9uc2VbJ2Vycm9yJ10pIHtcblx0ICAgICAgICAgICAgZXJyKHsgbWVzc2FnZTogcmVzcG9uc2VbJ21lc3NhZ2UnXSwgcGF5bG9hZDogcmVzcG9uc2VbJ3BheWxvYWQnXSB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gcmVzcG9uc2VbMF07XG5cdCAgICAgICAgICB2YXIgZGVjcnlwdGVkX21lc3NhZ2VzID0gW107XG5cdCAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG1lc3NhZ2VzLmxlbmd0aDsgYSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpbmNsdWRlX3Rva2VuKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5ld19tZXNzYWdlID0gZGVjcnlwdChtZXNzYWdlc1thXVsnbWVzc2FnZSddLCBjaXBoZXJfa2V5KTtcblx0ICAgICAgICAgICAgICB2YXIgdGltZXRva2VuID0gbWVzc2FnZXNbYV1bJ3RpbWV0b2tlbiddO1xuXHQgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSh7IG1lc3NhZ2U6IEpTT05bJ3BhcnNlJ10obmV3X21lc3NhZ2UpLCB0aW1ldG9rZW46IHRpbWV0b2tlbiB9KTtcblx0ICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkZWNyeXB0ZWRfbWVzc2FnZXNbJ3B1c2gnXSgoeyBtZXNzYWdlOiBuZXdfbWVzc2FnZSwgdGltZXRva2VuOiB0aW1ldG9rZW4gfSkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB2YXIgbmV3X21lc3NhZ2UgPSBkZWNyeXB0KG1lc3NhZ2VzW2FdLCBjaXBoZXJfa2V5KTtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVjcnlwdGVkX21lc3NhZ2VzWydwdXNoJ10oSlNPTlsncGFyc2UnXShuZXdfbWVzc2FnZSkpO1xuXHQgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIGRlY3J5cHRlZF9tZXNzYWdlc1sncHVzaCddKChuZXdfbWVzc2FnZSkpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgY2FsbGJhY2soW2RlY3J5cHRlZF9tZXNzYWdlcywgcmVzcG9uc2VbMV0sIHJlc3BvbnNlWzJdXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdoaXN0b3J5JywgJ3N1Yi1rZXknLFxuXHQgICAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2NoYW5uZWwnLCB1dGlscy5lbmNvZGUoY2hhbm5lbClcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucmVwbGF5KHtcblx0ICAgICBzb3VyY2UgICAgICA6ICdteV9jaGFubmVsJyxcblx0ICAgICBkZXN0aW5hdGlvbiA6ICduZXdfY2hhbm5lbCdcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgcmVwbGF5OiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbJ3NvdXJjZSddO1xuXHQgICAgICB2YXIgZGVzdGluYXRpb24gPSBhcmdzWydkZXN0aW5hdGlvbiddO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgc3RvcCA9IGFyZ3NbJ3N0b3AnXTtcblx0ICAgICAgdmFyIHN0YXJ0ID0gYXJnc1snc3RhcnQnXTtcblx0ICAgICAgdmFyIGVuZCA9IGFyZ3NbJ2VuZCddO1xuXHQgICAgICB2YXIgcmV2ZXJzZSA9IGFyZ3NbJ3JldmVyc2UnXTtcblx0ICAgICAgdmFyIGxpbWl0ID0gYXJnc1snbGltaXQnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGRhdGEgPSB7fTtcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICAvLyBDaGVjayBVc2VyIElucHV0XG5cdCAgICAgIGlmICghc291cmNlKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU291cmNlIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFkZXN0aW5hdGlvbikgcmV0dXJuIGVycm9yKCdNaXNzaW5nIERlc3RpbmF0aW9uIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICAvLyBTZXR1cCBVUkwgUGFyYW1zXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIGRhdGFbJ2NhbGxiYWNrJ10gPSBqc29ucDtcblx0ICAgICAgaWYgKHN0b3ApIGRhdGFbJ3N0b3AnXSA9ICdhbGwnO1xuXHQgICAgICBpZiAocmV2ZXJzZSkgZGF0YVsncmV2ZXJzZSddID0gJ3RydWUnO1xuXHQgICAgICBpZiAoc3RhcnQpIGRhdGFbJ3N0YXJ0J10gPSBzdGFydDtcblx0ICAgICAgaWYgKGVuZCkgZGF0YVsnZW5kJ10gPSBlbmQ7XG5cdCAgICAgIGlmIChsaW1pdCkgZGF0YVsnY291bnQnXSA9IGxpbWl0O1xuXG5cdCAgICAgIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIC8vIENvbXBvc2UgVVJMIFBhcnRzXG5cdCAgICAgIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAncmVwbGF5Jyxcblx0ICAgICAgICBQVUJMSVNIX0tFWSwgU1VCU0NSSUJFX0tFWSxcblx0ICAgICAgICBzb3VyY2UsIGRlc3RpbmF0aW9uXG5cdCAgICAgIF07XG5cblx0ICAgICAgLy8gU3RhcnQgKG9yIFN0b3ApIFJlcGxheSFcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKFswLCAnRGlzY29ubmVjdGVkJ10pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKGRhdGEpXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuYXV0aCgnQUpGTEtBSlNES0xBJyk7XG5cdCAgICAgKi9cblx0ICAgIGF1dGg6IGZ1bmN0aW9uIChhdXRoKSB7XG5cdCAgICAgIEFVVEhfS0VZID0gYXV0aDtcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIudGltZShmdW5jdGlvbih0aW1lKXsgfSk7XG5cdCAgICAgKi9cblx0ICAgIHRpbWU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9O1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgdXJsOiBbU1REX09SSUdJTiwgJ3RpbWUnLCBqc29ucF0sXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZVswXSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBjYWxsYmFjaygwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucHVibGlzaCh7XG5cdCAgICAgY2hhbm5lbCA6ICdteV9jaGF0X2NoYW5uZWwnLFxuXHQgICAgIG1lc3NhZ2UgOiAnaGVsbG8hJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBwdWJsaXNoOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIG1zZyA9IGFyZ3NbJ21lc3NhZ2UnXTtcblx0ICAgICAgaWYgKCFtc2cpIHJldHVybiBlcnJvcignTWlzc2luZyBNZXNzYWdlJyk7XG5cblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBtc2dbJ2NhbGxiYWNrJ10gfHwgYXJnc1snc3VjY2VzcyddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXSB8fCBtc2dbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIG1ldGEgPSBhcmdzWydtZXRhJ10gfHwgYXJnc1snbWV0YWRhdGEnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBhcmdzWydjaXBoZXJfa2V5J107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IG1zZ1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIHBvc3QgPSBhcmdzWydwb3N0J10gfHwgZmFsc2U7XG5cdCAgICAgIHZhciBzdG9yZSA9ICgnc3RvcmVfaW5faGlzdG9yeScgaW4gYXJncykgPyBhcmdzWydzdG9yZV9pbl9oaXN0b3J5J10gOiB0cnVlO1xuXHQgICAgICB2YXIgcmVwbGljYXRlID0gKCdyZXBsaWNhdGUnIGluIGFyZ3MpID8gYXJnc1sncmVwbGljYXRlJ10gOiB0cnVlO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgYWRkX21zZyA9ICdwdXNoJztcblx0ICAgICAgdmFyIHBhcmFtcztcblx0ICAgICAgdmFyIHVybDtcblxuXHQgICAgICBpZiAoYXJnc1sncHJlcGVuZCddKSBhZGRfbXNnID0gJ3Vuc2hpZnQnO1xuXG5cdCAgICAgIGlmICghY2hhbm5lbCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgaWYgKCFQVUJMSVNIX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFB1Ymxpc2ggS2V5Jyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAobXNnWydnZXRQdWJudWJNZXNzYWdlJ10pIHtcblx0ICAgICAgICBtc2cgPSBtc2dbJ2dldFB1Ym51Yk1lc3NhZ2UnXSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gSWYgdHJ5aW5nIHRvIHNlbmQgT2JqZWN0XG5cdCAgICAgIG1zZyA9IEpTT05bJ3N0cmluZ2lmeSddKGVuY3J5cHQobXNnLCBjaXBoZXJfa2V5KSk7XG5cblx0ICAgICAgLy8gQ3JlYXRlIFVSTFxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3B1Ymxpc2gnLFxuXHQgICAgICAgIFBVQkxJU0hfS0VZLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgIDAsIHV0aWxzLmVuY29kZShjaGFubmVsKSxcblx0ICAgICAgICBqc29ucCwgdXRpbHMuZW5jb2RlKG1zZylcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5IH07XG5cblx0ICAgICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcGFyYW1zWydtZXRhJ10gPSBKU09OLnN0cmluZ2lmeShtZXRhKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghc3RvcmUpIHBhcmFtc1snc3RvcmUnXSA9ICcwJztcblx0ICAgICAgaWYgKCFyZXBsaWNhdGUpIHBhcmFtc1snbm9yZXAnXSA9ICd0cnVlJztcblxuXHQgICAgICBpZiAoVVNFX0lOU1RBTkNFSUQpIHBhcmFtc1snaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICAvLyBRdWV1ZSBNZXNzYWdlIFNlbmRcblx0ICAgICAgUFVCX1FVRVVFW2FkZF9tc2ddKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHBhcmFtcyksXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgICAgcHVibGlzaCgxKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgICBwdWJsaXNoKDEpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbW9kZTogKHBvc3QpID8gJ1BPU1QnIDogJ0dFVCdcblx0ICAgICAgfSk7XG5cblx0ICAgICAgLy8gU2VuZCBNZXNzYWdlXG5cdCAgICAgIHB1Ymxpc2goKTtcblx0ICAgIH0sXG5cblx0ICAgIGZpcmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBhcmdzLnN0b3JlX2luX2hpc3RvcnkgPSBmYWxzZTtcblx0ICAgICAgYXJncy5yZXBsaWNhdGUgPSBmYWxzZTtcblx0ICAgICAgU0VMRlsncHVibGlzaCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLnVuc3Vic2NyaWJlKHsgY2hhbm5lbCA6ICdteV9jaGF0JyB9KTtcblx0ICAgICAqL1xuXHQgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2hhbm5lbEFyZyA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxHcm91cEFyZyA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGF1dGhfa2V5ID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgaWYgKCFjaGFubmVsQXJnICYmICFjaGFubmVsR3JvdXBBcmcpIHJldHVybiBlcnJvcignTWlzc2luZyBDaGFubmVsIG9yIENoYW5uZWwgR3JvdXAnKTtcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXG5cdCAgICAgIGlmIChjaGFubmVsQXJnKSB7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxzID0gdXRpbHMuaXNBcnJheShjaGFubmVsQXJnKSA/IGNoYW5uZWxBcmcgOiAoJycgKyBjaGFubmVsQXJnKS5zcGxpdCgnLCcpO1xuXHQgICAgICAgIHZhciBleGlzdGluZ0NoYW5uZWxzID0gW107XG5cdCAgICAgICAgdmFyIHByZXNlbmNlQ2hhbm5lbHMgPSBbXTtcblxuXHQgICAgICAgIHV0aWxzLmVhY2goY2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBpZiAoQ0hBTk5FTFNbY2hhbm5lbF0pIGV4aXN0aW5nQ2hhbm5lbHMucHVzaChjaGFubmVsKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGFueSBjaGFubmVscyB0byB1bnN1YnNjcmliZSBmcm9tLCB0cmlnZ2VyIGEgY2FsbGJhY2suXG5cdCAgICAgICAgaWYgKGV4aXN0aW5nQ2hhbm5lbHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFByZXBhcmUgcHJlc2VuY2UgY2hhbm5lbHNcblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbHMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgICBwcmVzZW5jZUNoYW5uZWxzLnB1c2goY2hhbm5lbCArIFBSRVNFTkNFX1NVRkZJWCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbHMuY29uY2F0KHByZXNlbmNlQ2hhbm5lbHMpLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gQ0hBTk5FTFMpIGRlbGV0ZSBDSEFOTkVMU1tjaGFubmVsXTtcblx0ICAgICAgICAgIGlmIChjaGFubmVsIGluIFNUQVRFKSBkZWxldGUgU1RBVEVbY2hhbm5lbF07XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoQ0hBTk5FTFMubGVuZ3RoID09PSAwICYmIENIQU5ORUxfR1JPVVBTLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgVElNRVRPS0VOID0gMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgQ0JfQ0FMTEVEID0gdHJ1ZTtcblx0ICAgICAgICBpZiAoUkVBRFkpIHtcblx0ICAgICAgICAgIENCX0NBTExFRCA9IFNFTEZbJ0xFQVZFJ10oZXhpc3RpbmdDaGFubmVscy5qb2luKCcsJyksIDAsIGF1dGhfa2V5LCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFDQl9DQUxMRUQpIGNhbGxiYWNrKHsgYWN0aW9uOiAnbGVhdmUnIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNoYW5uZWxHcm91cEFyZykge1xuXHQgICAgICAgIHZhciBjaGFubmVsR3JvdXBzID0gdXRpbHMuaXNBcnJheShjaGFubmVsR3JvdXBBcmcpID8gY2hhbm5lbEdyb3VwQXJnIDogKCcnICsgY2hhbm5lbEdyb3VwQXJnKS5zcGxpdCgnLCcpO1xuXHQgICAgICAgIHZhciBleGlzdGluZ0NoYW5uZWxHcm91cHMgPSBbXTtcblx0ICAgICAgICB2YXIgcHJlc2VuY2VDaGFubmVsR3JvdXBzID0gW107XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGNoYW5uZWxHcm91cHMsIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIGlmIChDSEFOTkVMX0dST1VQU1tjaGFubmVsR3JvdXBdKSBleGlzdGluZ0NoYW5uZWxHcm91cHMucHVzaChjaGFubmVsR3JvdXApO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gaWYgd2UgZG8gbm90IGhhdmUgYW55IGNoYW5uZWwgZ3JvdXBzIHRvIHVuc3Vic2NyaWJlIGZyb20sIHRyaWdnZXIgYSBjYWxsYmFjay5cblx0ICAgICAgICBpZiAoZXhpc3RpbmdDaGFubmVsR3JvdXBzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBQcmVwYXJlIHByZXNlbmNlIGNoYW5uZWxzXG5cdCAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ0NoYW5uZWxHcm91cHMsIGZ1bmN0aW9uIChjaGFubmVsR3JvdXApIHtcblx0ICAgICAgICAgIHByZXNlbmNlQ2hhbm5lbEdyb3Vwcy5wdXNoKGNoYW5uZWxHcm91cCArIFBSRVNFTkNFX1NVRkZJWCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB1dGlscy5lYWNoKGV4aXN0aW5nQ2hhbm5lbEdyb3Vwcy5jb25jYXQocHJlc2VuY2VDaGFubmVsR3JvdXBzKSwgZnVuY3Rpb24gKGNoYW5uZWxHcm91cCkge1xuXHQgICAgICAgICAgaWYgKGNoYW5uZWxHcm91cCBpbiBDSEFOTkVMX0dST1VQUykgZGVsZXRlIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxHcm91cF07XG5cdCAgICAgICAgICBpZiAoY2hhbm5lbEdyb3VwIGluIFNUQVRFKSBkZWxldGUgU1RBVEVbY2hhbm5lbEdyb3VwXTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChDSEFOTkVMUy5sZW5ndGggPT09IDAgJiYgQ0hBTk5FTF9HUk9VUFMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBDQl9DQUxMRUQgPSB0cnVlO1xuXHQgICAgICAgIGlmIChSRUFEWSkge1xuXHQgICAgICAgICAgQ0JfQ0FMTEVEID0gU0VMRlsnTEVBVkVfR1JPVVAnXShleGlzdGluZ0NoYW5uZWxHcm91cHMuam9pbignLCcpLCAwLCBhdXRoX2tleSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghQ0JfQ0FMTEVEKSBjYWxsYmFjayh7IGFjdGlvbjogJ2xlYXZlJyB9KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIFJlc2V0IENvbm5lY3Rpb24gaWYgQ291bnQgTGVzc1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5zdWJzY3JpYmUoe1xuXHQgICAgIGNoYW5uZWwgIDogJ215X2NoYXQnXG5cdCAgICAgY2FsbGJhY2sgOiBmdW5jdGlvbihtZXNzYWdlKSB7IH1cblx0ICAgICB9KTtcblx0ICAgICAqL1xuXHQgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBjaGFubmVsX2dyb3VwID0gYXJnc1snY2hhbm5lbF9ncm91cCddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydjYWxsYmFjayddO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBhcmdzWydtZXNzYWdlJ107XG5cdCAgICAgIHZhciBjb25uZWN0ID0gYXJnc1snY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgcmVjb25uZWN0ID0gYXJnc1sncmVjb25uZWN0J10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBkaXNjb25uZWN0ID0gYXJnc1snZGlzY29ubmVjdCddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgU1VCX0VSUk9SID0gYXJnc1snZXJyb3InXSB8fCBTVUJfRVJST1IgfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBpZGxlY2IgPSBhcmdzWydpZGxlJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBwcmVzZW5jZSA9IGFyZ3NbJ3ByZXNlbmNlJ10gfHwgMDtcblx0ICAgICAgdmFyIG5vaGVyZXN5bmMgPSBhcmdzWydub2hlcmVzeW5jJ10gfHwgMDtcblx0ICAgICAgdmFyIGJhY2tmaWxsID0gYXJnc1snYmFja2ZpbGwnXSB8fCAwO1xuXHQgICAgICB2YXIgdGltZXRva2VuID0gYXJnc1sndGltZXRva2VuJ10gfHwgMDtcblx0ICAgICAgdmFyIHN1Yl90aW1lb3V0ID0gYXJnc1sndGltZW91dCddIHx8IFNVQl9USU1FT1VUO1xuXHQgICAgICB2YXIgd2luZG93aW5nID0gYXJnc1snd2luZG93aW5nJ10gfHwgU1VCX1dJTkRPV0lORztcblx0ICAgICAgdmFyIHN0YXRlID0gYXJnc1snc3RhdGUnXTtcblx0ICAgICAgdmFyIGhlYXJ0YmVhdCA9IGFyZ3NbJ2hlYXJ0YmVhdCddIHx8IGFyZ3NbJ3BuZXhwaXJlcyddO1xuXHQgICAgICB2YXIgaGVhcnRiZWF0X2ludGVydmFsID0gYXJnc1snaGVhcnRiZWF0X2ludGVydmFsJ107XG5cdCAgICAgIHZhciByZXN0b3JlID0gYXJnc1sncmVzdG9yZSddIHx8IFNVQl9SRVNUT1JFO1xuXG5cdCAgICAgIEFVVEhfS0VZID0gYXJnc1snYXV0aF9rZXknXSB8fCBBVVRIX0tFWTtcblxuXHQgICAgICAvLyBSZXN0b3JlIEVuYWJsZWQ/XG5cdCAgICAgIFNVQl9SRVNUT1JFID0gcmVzdG9yZTtcblxuXHQgICAgICAvLyBBbHdheXMgUmVzZXQgdGhlIFRUXG5cdCAgICAgIFRJTUVUT0tFTiA9IHRpbWV0b2tlbjtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjaGFubmVsICYmICFjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgaWYgKGhlYXJ0YmVhdCB8fCBoZWFydGJlYXQgPT09IDAgfHwgaGVhcnRiZWF0X2ludGVydmFsIHx8IGhlYXJ0YmVhdF9pbnRlcnZhbCA9PT0gMCkge1xuXHQgICAgICAgIFNFTEZbJ3NldF9oZWFydGJlYXQnXShoZWFydGJlYXQsIGhlYXJ0YmVhdF9pbnRlcnZhbCk7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBTZXR1cCBDaGFubmVsKHMpXG5cdCAgICAgIGlmIChjaGFubmVsKSB7XG5cdCAgICAgICAgdXRpbHMuZWFjaCgoY2hhbm5lbC5qb2luID8gY2hhbm5lbC5qb2luKCcsJykgOiAnJyArIGNoYW5uZWwpLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICBmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBDSEFOTkVMU1tjaGFubmVsXSB8fCB7fTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSBDaGFubmVsIFN0YXRlXG5cdCAgICAgICAgICAgIENIQU5ORUxTW1NVQl9DSEFOTkVMID0gY2hhbm5lbF0gPSB7XG5cdCAgICAgICAgICAgICAgbmFtZTogY2hhbm5lbCxcblx0ICAgICAgICAgICAgICBjb25uZWN0ZWQ6IHNldHRpbmdzLmNvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0ZWQ6IHNldHRpbmdzLmRpc2Nvbm5lY3RlZCxcblx0ICAgICAgICAgICAgICBzdWJzY3JpYmVkOiAxLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBTVUJfQ0FMTEJBQ0sgPSBjYWxsYmFjayxcblx0ICAgICAgICAgICAgICBjaXBoZXJfa2V5OiBhcmdzWydjaXBoZXJfa2V5J10sXG5cdCAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdCxcblx0ICAgICAgICAgICAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0LFxuXHQgICAgICAgICAgICAgIHJlY29ubmVjdDogcmVjb25uZWN0XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgaW4gc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIFNUQVRFW2NoYW5uZWxdID0gc3RhdGVbY2hhbm5lbF07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIFNUQVRFW2NoYW5uZWxdID0gc3RhdGU7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgRW5hYmxlZD9cblx0ICAgICAgICAgICAgaWYgKCFwcmVzZW5jZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIC8vIFN1YnNjcmliZSBQcmVzZW5jZSBDaGFubmVsXG5cdCAgICAgICAgICAgIFNFTEZbJ3N1YnNjcmliZSddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsICsgUFJFU0VOQ0VfU1VGRklYLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBwcmVzZW5jZSxcblx0ICAgICAgICAgICAgICByZXN0b3JlOiByZXN0b3JlXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIFN1YnNjcmliZWQ/XG5cdCAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdWJzY3JpYmVkKSByZXR1cm47XG5cblx0ICAgICAgICAgICAgLy8gU2VlIFdobydzIEhlcmUgTm93P1xuXHQgICAgICAgICAgICBpZiAobm9oZXJlc3luYykgcmV0dXJuO1xuXHQgICAgICAgICAgICBTRUxGWydoZXJlX25vdyddKHtcblx0ICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsLFxuXHQgICAgICAgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyh7IHV1aWQ6IFVVSUQsIGF1dGg6IEFVVEhfS0VZIH0pLFxuXHQgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoaGVyZSkge1xuXHQgICAgICAgICAgICAgICAgdXRpbHMuZWFjaCgndXVpZHMnIGluIGhlcmUgPyBoZXJlWyd1dWlkcyddIDogW10sIGZ1bmN0aW9uICh1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgcHJlc2VuY2Uoe1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2pvaW4nLFxuXHQgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHVpZCxcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGguZmxvb3IodXRpbHMucm5vdygpIC8gMTAwMCksXG5cdCAgICAgICAgICAgICAgICAgICAgb2NjdXBhbmN5OiBoZXJlWydvY2N1cGFuY3knXSB8fCAxXG5cdCAgICAgICAgICAgICAgICAgIH0sIGhlcmUsIGNoYW5uZWwpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gU2V0dXAgQ2hhbm5lbCBHcm91cHNcblx0ICAgICAgaWYgKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICB1dGlscy5lYWNoKChjaGFubmVsX2dyb3VwLmpvaW4gPyBjaGFubmVsX2dyb3VwLmpvaW4oJywnKSA6ICcnICsgY2hhbm5lbF9ncm91cCkuc3BsaXQoJywnKSxcblx0ICAgICAgICAgIGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdID0ge1xuXHQgICAgICAgICAgICAgIG5hbWU6IGNoYW5uZWxfZ3JvdXAsXG5cdCAgICAgICAgICAgICAgY29ubmVjdGVkOiBzZXR0aW5ncy5jb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdGVkOiBzZXR0aW5ncy5kaXNjb25uZWN0ZWQsXG5cdCAgICAgICAgICAgICAgc3Vic2NyaWJlZDogMSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogU1VCX0NBTExCQUNLID0gY2FsbGJhY2ssXG5cdCAgICAgICAgICAgICAgY2lwaGVyX2tleTogYXJnc1snY2lwaGVyX2tleSddLFxuXHQgICAgICAgICAgICAgIGNvbm5lY3Q6IGNvbm5lY3QsXG5cdCAgICAgICAgICAgICAgZGlzY29ubmVjdDogZGlzY29ubmVjdCxcblx0ICAgICAgICAgICAgICByZWNvbm5lY3Q6IHJlY29ubmVjdFxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIC8vIFByZXNlbmNlIEVuYWJsZWQ/XG5cdCAgICAgICAgICAgIGlmICghcHJlc2VuY2UpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTdWJzY3JpYmUgUHJlc2VuY2UgQ2hhbm5lbFxuXHQgICAgICAgICAgICBTRUxGWydzdWJzY3JpYmUnXSh7XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cDogY2hhbm5lbF9ncm91cCArIFBSRVNFTkNFX1NVRkZJWCxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogcHJlc2VuY2UsXG5cdCAgICAgICAgICAgICAgcmVzdG9yZTogcmVzdG9yZSxcblx0ICAgICAgICAgICAgICBhdXRoX2tleTogQVVUSF9LRVlcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJlc2VuY2UgU3Vic2NyaWJlZD9cblx0ICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN1YnNjcmliZWQpIHJldHVybjtcblxuXHQgICAgICAgICAgICAvLyBTZWUgV2hvJ3MgSGVyZSBOb3c/XG5cdCAgICAgICAgICAgIGlmIChub2hlcmVzeW5jKSByZXR1cm47XG5cdCAgICAgICAgICAgIFNFTEZbJ2hlcmVfbm93J10oe1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXA6IGNoYW5uZWxfZ3JvdXAsXG5cdCAgICAgICAgICAgICAgZGF0YTogX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSksXG5cdCAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChoZXJlKSB7XG5cdCAgICAgICAgICAgICAgICB1dGlscy5lYWNoKCd1dWlkcycgaW4gaGVyZSA/IGhlcmVbJ3V1aWRzJ10gOiBbXSwgZnVuY3Rpb24gKHVpZCkge1xuXHQgICAgICAgICAgICAgICAgICBwcmVzZW5jZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnam9pbicsXG5cdCAgICAgICAgICAgICAgICAgICAgdXVpZDogdWlkLFxuXHQgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih1dGlscy5ybm93KCkgLyAxMDAwKSxcblx0ICAgICAgICAgICAgICAgICAgICBvY2N1cGFuY3k6IGhlcmVbJ29jY3VwYW5jeSddIHx8IDFcblx0ICAgICAgICAgICAgICAgICAgfSwgaGVyZSwgY2hhbm5lbF9ncm91cCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXG5cdCAgICAgIC8vIFRlc3QgTmV0d29yayBDb25uZWN0aW9uXG5cdCAgICAgIGZ1bmN0aW9uIF90ZXN0X2Nvbm5lY3Rpb24oc3VjY2Vzcykge1xuXHQgICAgICAgIGlmIChzdWNjZXNzKSB7XG5cdCAgICAgICAgICAvLyBCZWdpbiBOZXh0IFNvY2tldCBDb25uZWN0aW9uXG5cdCAgICAgICAgICB1dGlscy50aW1lb3V0KENPTk5FQ1QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIE5ldyBPcmlnaW4gb24gRmFpbGVkIENvbm5lY3Rpb25cblx0ICAgICAgICAgIFNURF9PUklHSU4gPSBuZXh0b3JpZ2luKE9SSUdJTiwgMSk7XG5cdCAgICAgICAgICBTVUJfT1JJR0lOID0gbmV4dG9yaWdpbihPUklHSU4sIDEpO1xuXG5cdCAgICAgICAgICAvLyBSZS10ZXN0IENvbm5lY3Rpb25cblx0ICAgICAgICAgIHV0aWxzLnRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBTRUxGWyd0aW1lJ10oX3Rlc3RfY29ubmVjdGlvbik7XG5cdCAgICAgICAgICB9LCBTRUNPTkQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIERpc2Nvbm5lY3QgJiBSZWNvbm5lY3Rcblx0ICAgICAgICBlYWNoX2NoYW5uZWwoZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICAgIC8vIFJlY29ubmVjdFxuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgY2hhbm5lbC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbC5kaXNjb25uZWN0ZWQgPSAwO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hhbm5lbC5yZWNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgLy8gRGlzY29ubmVjdFxuXHQgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFjaGFubmVsLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdChjaGFubmVsLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gRGlzY29ubmVjdCAmIFJlY29ubmVjdCBmb3IgY2hhbm5lbCBncm91cHNcblx0ICAgICAgICBlYWNoX2NoYW5uZWxfZ3JvdXAoZnVuY3Rpb24gKGNoYW5uZWxfZ3JvdXApIHtcblx0ICAgICAgICAgIC8vIFJlY29ubmVjdFxuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQpIHtcblx0ICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5kaXNjb25uZWN0ZWQgPSAwO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hhbm5lbF9ncm91cC5yZWNvbm5lY3QoY2hhbm5lbF9ncm91cC5uYW1lKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgLy8gRGlzY29ubmVjdFxuXHQgICAgICAgICAgaWYgKCFzdWNjZXNzICYmICFjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCkge1xuXHQgICAgICAgICAgICBjaGFubmVsX2dyb3VwLmRpc2Nvbm5lY3RlZCA9IDE7XG5cdCAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuZGlzY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gRXZlbnRlZCBTdWJzY3JpYmVcblx0ICAgICAgZnVuY3Rpb24gX2Nvbm5lY3QoKSB7XG5cdCAgICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgICB2YXIgY2hhbm5lbHMgPSBnZW5lcmF0ZV9jaGFubmVsX2xpc3QoQ0hBTk5FTFMpLmpvaW4oJywnKTtcblx0ICAgICAgICB2YXIgY2hhbm5lbF9ncm91cHMgPSBnZW5lcmF0ZV9jaGFubmVsX2dyb3VwX2xpc3QoQ0hBTk5FTF9HUk9VUFMpLmpvaW4oJywnKTtcblxuXHQgICAgICAgIC8vIFN0b3AgQ29ubmVjdGlvblxuXHQgICAgICAgIGlmICghY2hhbm5lbHMgJiYgIWNoYW5uZWxfZ3JvdXBzKSByZXR1cm47XG5cblx0ICAgICAgICBpZiAoIWNoYW5uZWxzKSBjaGFubmVscyA9ICcsJztcblxuXHQgICAgICAgIC8vIENvbm5lY3QgdG8gUHViTnViIFN1YnNjcmliZSBTZXJ2ZXJzXG5cdCAgICAgICAgX3Jlc2V0X29mZmxpbmUoKTtcblxuXHQgICAgICAgIHZhciBkYXRhID0gX2dldF91cmxfcGFyYW1zKHsgdXVpZDogVVVJRCwgYXV0aDogQVVUSF9LRVkgfSk7XG5cblx0ICAgICAgICBpZiAoY2hhbm5lbF9ncm91cHMpIHtcblx0ICAgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXBzO1xuXHQgICAgICAgIH1cblxuXG5cdCAgICAgICAgdmFyIHN0ID0gSlNPTi5zdHJpbmdpZnkoU1RBVEUpO1xuXHQgICAgICAgIGlmIChzdC5sZW5ndGggPiAyKSBkYXRhWydzdGF0ZSddID0gSlNPTi5zdHJpbmdpZnkoU1RBVEUpO1xuXG5cdCAgICAgICAgaWYgKFBSRVNFTkNFX0hCKSBkYXRhWydoZWFydGJlYXQnXSA9IFBSRVNFTkNFX0hCO1xuXG5cdCAgICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgICAgc3RhcnRfcHJlc2VuY2VfaGVhcnRiZWF0KCk7XG5cdCAgICAgICAgU1VCX1JFQ0VJVkVSID0geGRyKHtcblx0ICAgICAgICAgIHRpbWVvdXQ6IHN1Yl90aW1lb3V0LFxuXHQgICAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZVsnZXJyb3InXSAmJiByZXNwb25zZVsnc2VydmljZSddKSB7XG5cdCAgICAgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgU1VCX0VSUk9SKTtcblx0ICAgICAgICAgICAgICBfdGVzdF9jb25uZWN0aW9uKGZhbHNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBTRUxGWyd0aW1lJ10oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcblx0ICAgICAgICAgICAgICAgICFzdWNjZXNzICYmIChfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBTVUJfRVJST1IpKTtcblx0ICAgICAgICAgICAgICAgIF90ZXN0X2Nvbm5lY3Rpb24oc3VjY2Vzcyk7XG5cdCAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgICAgU1VCX09SSUdJTiwgJ3N1YnNjcmliZScsXG5cdCAgICAgICAgICAgIFNVQlNDUklCRV9LRVksIHV0aWxzLmVuY29kZShjaGFubmVscyksXG5cdCAgICAgICAgICAgIGpzb25wLCBUSU1FVE9LRU5cblx0ICAgICAgICAgIF0sXG5cdCAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAobWVzc2FnZXMpIHtcblx0ICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEVycm9yc1xuXHQgICAgICAgICAgICBpZiAoIW1lc3NhZ2VzIHx8ICh0eXBlb2YgbWVzc2FnZXMgPT0gJ29iamVjdCcgJiYgJ2Vycm9yJyBpbiBtZXNzYWdlcyAmJiBtZXNzYWdlc1snZXJyb3InXSkpIHtcblx0ICAgICAgICAgICAgICBTVUJfRVJST1IobWVzc2FnZXMpO1xuXHQgICAgICAgICAgICAgIHJldHVybiB1dGlscy50aW1lb3V0KENPTk5FQ1QsIFNFQ09ORCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVc2VyIElkbGUgQ2FsbGJhY2tcblx0ICAgICAgICAgICAgaWRsZWNiKG1lc3NhZ2VzWzFdKTtcblxuXHQgICAgICAgICAgICAvLyBSZXN0b3JlIFByZXZpb3VzIENvbm5lY3Rpb24gUG9pbnQgaWYgTmVlZGVkXG5cdCAgICAgICAgICAgIFRJTUVUT0tFTiA9ICFUSU1FVE9LRU4gJiYgU1VCX1JFU1RPUkUgJiYgZGJbJ2dldCddKFNVQlNDUklCRV9LRVkpIHx8IG1lc3NhZ2VzWzFdO1xuXG5cdCAgICAgICAgICAgIC8qXG5cdCAgICAgICAgICAgICAvLyBDb25uZWN0XG5cdCAgICAgICAgICAgICBlYWNoX2NoYW5uZWxfcmVnaXN0cnkoZnVuY3Rpb24ocmVnaXN0cnkpe1xuXHQgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5LmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgcmVnaXN0cnkuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgIHJlZ2lzdHJ5LmNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblxuXHQgICAgICAgICAgICAvLyBDb25uZWN0XG5cdCAgICAgICAgICAgIGVhY2hfY2hhbm5lbChmdW5jdGlvbiAoY2hhbm5lbCkge1xuXHQgICAgICAgICAgICAgIGlmIChjaGFubmVsLmNvbm5lY3RlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWwuY29ubmVjdGVkID0gMTtcblx0ICAgICAgICAgICAgICBjaGFubmVsLmNvbm5lY3QoY2hhbm5lbC5uYW1lKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgLy8gQ29ubmVjdCBmb3IgY2hhbm5lbCBncm91cHNcblx0ICAgICAgICAgICAgZWFjaF9jaGFubmVsX2dyb3VwKGZ1bmN0aW9uIChjaGFubmVsX2dyb3VwKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNoYW5uZWxfZ3JvdXAuY29ubmVjdGVkKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgY2hhbm5lbF9ncm91cC5jb25uZWN0ZWQgPSAxO1xuXHQgICAgICAgICAgICAgIGNoYW5uZWxfZ3JvdXAuY29ubmVjdChjaGFubmVsX2dyb3VwLm5hbWUpO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAoUkVTVU1FRCAmJiAhU1VCX1JFU1RPUkUpIHtcblx0ICAgICAgICAgICAgICBUSU1FVE9LRU4gPSAwO1xuXHQgICAgICAgICAgICAgIFJFU1VNRUQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAvLyBVcGRhdGUgU2F2ZWQgVGltZXRva2VuXG5cdCAgICAgICAgICAgICAgZGJbJ3NldCddKFNVQlNDUklCRV9LRVksIDApO1xuXHQgICAgICAgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW52b2tlIE1lbW9yeSBDYXRjaHVwIGFuZCBSZWNlaXZlIFVwIHRvIDEwMFxuXHQgICAgICAgICAgICAvLyBQcmV2aW91cyBNZXNzYWdlcyBmcm9tIHRoZSBRdWV1ZS5cblx0ICAgICAgICAgICAgaWYgKGJhY2tmaWxsKSB7XG5cdCAgICAgICAgICAgICAgVElNRVRPS0VOID0gMTAwMDA7XG5cdCAgICAgICAgICAgICAgYmFja2ZpbGwgPSAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIFNhdmVkIFRpbWV0b2tlblxuXHQgICAgICAgICAgICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSwgbWVzc2FnZXNbMV0pO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdXRlIENoYW5uZWwgPC0tLT4gQ2FsbGJhY2sgZm9yIE1lc3NhZ2Vcblx0ICAgICAgICAgICAgdmFyIG5leHRfY2FsbGJhY2sgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHZhciBjaGFubmVscyA9ICcnO1xuXHQgICAgICAgICAgICAgIHZhciBjaGFubmVsczIgPSAnJztcblxuXHQgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IG1lc3NhZ2VzWzNdO1xuXHQgICAgICAgICAgICAgICAgY2hhbm5lbHMyID0gbWVzc2FnZXNbMl07XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IG1lc3NhZ2VzWzJdO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVscyA9IHV0aWxzLm1hcChcblx0ICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTKSwgZnVuY3Rpb24gKGNoYW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMubWFwKFxuXHQgICAgICAgICAgICAgICAgICAgICAgQXJyYXkobWVzc2FnZXNbMF0ubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpLnNwbGl0KCcsJyksXG5cdCAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNoYW5uZWxzLnNwbGl0KCcsJyk7XG5cdCAgICAgICAgICAgICAgdmFyIGxpc3QyID0gKGNoYW5uZWxzMikgPyBjaGFubmVsczIuc3BsaXQoJywnKSA6IFtdO1xuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gbGlzdC5zaGlmdCgpIHx8IFNVQl9DSEFOTkVMO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwyID0gbGlzdDIuc2hpZnQoKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGNob2JqID0ge307XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjaGFubmVsMikge1xuXHQgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLmluZGV4T2YoJy1wbnByZXMnKSA+PSAwXG5cdCAgICAgICAgICAgICAgICAgICAgJiYgY2hhbm5lbDIuaW5kZXhPZignLXBucHJlcycpIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwyICs9ICctcG5wcmVzJztcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICBjaG9iaiA9IENIQU5ORUxfR1JPVVBTW2NoYW5uZWwyXSB8fCBDSEFOTkVMU1tjaGFubmVsMl0gfHwgeyBjYWxsYmFjazogZnVuY3Rpb24gKCkge30gfTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgIGNob2JqID0gQ0hBTk5FTFNbY2hhbm5lbF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciByID0gW1xuXHQgICAgICAgICAgICAgICAgICBjaG9ialxuXHQgICAgICAgICAgICAgICAgICAgIC5jYWxsYmFjayB8fCBTVUJfQ0FMTEJBQ0ssXG5cdCAgICAgICAgICAgICAgICAgIGNoYW5uZWwuc3BsaXQoUFJFU0VOQ0VfU1VGRklYKVswXVxuXHQgICAgICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgICAgIGNoYW5uZWwyICYmIHIucHVzaChjaGFubmVsMi5zcGxpdChQUkVTRU5DRV9TVUZGSVgpWzBdKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByO1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKCk7XG5cblx0ICAgICAgICAgICAgdmFyIGxhdGVuY3kgPSBkZXRlY3RfbGF0ZW5jeSgrbWVzc2FnZXNbMV0pO1xuXHQgICAgICAgICAgICB1dGlscy5lYWNoKG1lc3NhZ2VzWzBdLCBmdW5jdGlvbiAobXNnKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5leHQgPSBuZXh0X2NhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgICAgdmFyIGRlY3J5cHRlZF9tc2cgPSBkZWNyeXB0KG1zZyxcblx0ICAgICAgICAgICAgICAgIChDSEFOTkVMU1tuZXh0WzFdXSkgPyBDSEFOTkVMU1tuZXh0WzFdXVsnY2lwaGVyX2tleSddIDogbnVsbCk7XG5cdCAgICAgICAgICAgICAgbmV4dFswXSAmJiBuZXh0WzBdKGRlY3J5cHRlZF9tc2csIG1lc3NhZ2VzLCBuZXh0WzJdIHx8IG5leHRbMV0sIGxhdGVuY3ksIG5leHRbMV0pO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB1dGlscy50aW1lb3V0KF9jb25uZWN0LCB3aW5kb3dpbmcpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgQ09OTkVDVCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfcmVzZXRfb2ZmbGluZSgpO1xuXHQgICAgICAgIHV0aWxzLnRpbWVvdXQoX2Nvbm5lY3QsIHdpbmRvd2luZyk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgLy8gUmVkdWNlIFN0YXR1cyBGbGlja2VyXG5cdCAgICAgIGlmICghUkVBRFkpIHJldHVybiBSRUFEWV9CVUZGRVIucHVzaChDT05ORUNUKTtcblxuXHQgICAgICAvLyBDb25uZWN0IE5vd1xuXHQgICAgICBDT05ORUNUKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5oZXJlX25vdyh7IGNoYW5uZWwgOiAnbXlfY2hhdCcsIGNhbGxiYWNrIDogZnVuIH0pO1xuXHQgICAgICovXG5cdCAgICBoZXJlX25vdzogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBkZWJ1ZyA9IGFyZ3NbJ2RlYnVnJ107XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciB1dWlkcyA9ICgndXVpZHMnIGluIGFyZ3MpID8gYXJnc1sndXVpZHMnXSA6IHRydWU7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBhdXRoX2tleSB9O1xuXG5cdCAgICAgIGlmICghdXVpZHMpIGRhdGFbJ2Rpc2FibGVfdXVpZHMnXSA9IDE7XG5cdCAgICAgIGlmIChzdGF0ZSkgZGF0YVsnc3RhdGUnXSA9IDE7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHVybCA9IFtcblx0ICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICdzdWJfa2V5JywgU1VCU0NSSUJFX0tFWVxuXHQgICAgICBdO1xuXG5cdCAgICAgIGNoYW5uZWwgJiYgdXJsLnB1c2goJ2NoYW5uZWwnKSAmJiB1cmwucHVzaCh1dGlscy5lbmNvZGUoY2hhbm5lbCkpO1xuXG5cdCAgICAgIGlmIChqc29ucCAhPSAnMCcpIHtcblx0ICAgICAgICBkYXRhWydjYWxsYmFjayddID0ganNvbnA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2hhbm5lbF9ncm91cCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgICAgIWNoYW5uZWwgJiYgdXJsLnB1c2goJ2NoYW5uZWwnKSAmJiB1cmwucHVzaCgnLCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZGVidWc6IGRlYnVnLFxuXHQgICAgICAgIHVybDogdXJsXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIuY3VycmVudF9jaGFubmVsc19ieV91dWlkKHsgY2hhbm5lbCA6ICdteV9jaGF0JywgY2FsbGJhY2sgOiBmdW4gfSk7XG5cdCAgICAgKi9cblx0ICAgIHdoZXJlX25vdzogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIganNvbnAgPSBqc29ucF9jYigpO1xuXHQgICAgICB2YXIgdXVpZCA9IGFyZ3NbJ3V1aWQnXSB8fCBVVUlEO1xuXHQgICAgICB2YXIgZGF0YSA9IHsgYXV0aDogYXV0aF9rZXkgfTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENhbGxiYWNrJyk7XG5cdCAgICAgIGlmICghU1VCU0NSSUJFX0tFWSkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIFN1YnNjcmliZSBLZXknKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yl9rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dGlscy5lbmNvZGUodXVpZClcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgc3RhdGU6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGNhbGxiYWNrIHx8IGZ1bmN0aW9uIChyKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J10gfHwgQVVUSF9LRVk7XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBzdGF0ZSA9IGFyZ3NbJ3N0YXRlJ107XG5cdCAgICAgIHZhciB1dWlkID0gYXJnc1sndXVpZCddIHx8IFVVSUQ7XG5cdCAgICAgIHZhciBjaGFubmVsID0gYXJnc1snY2hhbm5lbCddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIHVybDtcblx0ICAgICAgdmFyIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoeyBhdXRoOiBhdXRoX2tleSB9KTtcblxuXHQgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIENoYW5uZWxcblx0ICAgICAgaWYgKCFTVUJTQ1JJQkVfS0VZKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgU3Vic2NyaWJlIEtleScpO1xuXHQgICAgICBpZiAoIXV1aWQpIHJldHVybiBlcnJvcignTWlzc2luZyBVVUlEJyk7XG5cdCAgICAgIGlmICghY2hhbm5lbCAmJiAhY2hhbm5lbF9ncm91cCkgcmV0dXJuIGVycm9yKCdNaXNzaW5nIENoYW5uZWwnKTtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnXG5cdCAgICAgICAgJiYgQ0hBTk5FTFNbY2hhbm5lbF0gJiYgQ0hBTk5FTFNbY2hhbm5lbF0uc3Vic2NyaWJlZCkge1xuXHQgICAgICAgIGlmIChzdGF0ZSkgU1RBVEVbY2hhbm5lbF0gPSBzdGF0ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJ1xuXHQgICAgICAgICYmIENIQU5ORUxfR1JPVVBTW2NoYW5uZWxfZ3JvdXBdXG5cdCAgICAgICAgJiYgQ0hBTk5FTF9HUk9VUFNbY2hhbm5lbF9ncm91cF0uc3Vic2NyaWJlZFxuXHQgICAgICApIHtcblx0ICAgICAgICBpZiAoc3RhdGUpIFNUQVRFW2NoYW5uZWxfZ3JvdXBdID0gc3RhdGU7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblxuXHQgICAgICAgIGlmICghY2hhbm5lbCkge1xuXHQgICAgICAgICAgY2hhbm5lbCA9ICcsJztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBkYXRhWydzdGF0ZSddID0gSlNPTi5zdHJpbmdpZnkoc3RhdGUpO1xuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgZGF0YVsnaW5zdGFuY2VpZCddID0gSU5TVEFOQ0VJRDtcblxuXHQgICAgICBpZiAoc3RhdGUpIHtcblx0ICAgICAgICB1cmwgPSBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjInLCAncHJlc2VuY2UnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZLFxuXHQgICAgICAgICAgJ2NoYW5uZWwnLCBjaGFubmVsLFxuXHQgICAgICAgICAgJ3V1aWQnLCB1dWlkLCAnZGF0YSdcblx0ICAgICAgICBdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVybCA9IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWwsXG5cdCAgICAgICAgICAndXVpZCcsIHV0aWxzLmVuY29kZSh1dWlkKVxuXHQgICAgICAgIF07XG5cdCAgICAgIH1cblxuXHQgICAgICB4ZHIoe1xuXHQgICAgICAgIGNhbGxiYWNrOiBqc29ucCxcblx0ICAgICAgICBkYXRhOiBfZ2V0X3VybF9wYXJhbXMoZGF0YSksXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogdXJsXG5cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5ncmFudCh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgdHRsICAgICAgOiAyNCAqIDYwLCAvLyBNaW51dGVzXG5cdCAgICAgcmVhZCAgICAgOiB0cnVlLFxuXHQgICAgIHdyaXRlICAgIDogdHJ1ZSxcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBncmFudDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXSB8fCBhcmdzWydjaGFubmVscyddO1xuXHQgICAgICB2YXIgY2hhbm5lbF9ncm91cCA9IGFyZ3NbJ2NoYW5uZWxfZ3JvdXAnXTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIHR0bCA9IGFyZ3NbJ3R0bCddO1xuXHQgICAgICB2YXIgciA9IChhcmdzWydyZWFkJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgdyA9IChhcmdzWyd3cml0ZSddKSA/ICcxJyA6ICcwJztcblx0ICAgICAgdmFyIG0gPSAoYXJnc1snbWFuYWdlJ10pID8gJzEnIDogJzAnO1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IGFyZ3NbJ2F1dGhfa2V5cyddO1xuXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNFQ1JFVF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTZWNyZXQgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0ICAgICAgdmFyIHNpZ25faW5wdXQgPSBTVUJTQ1JJQkVfS0VZICsgJ1xcbicgKyBQVUJMSVNIX0tFWSArICdcXG4nICsgJ2dyYW50JyArICdcXG4nO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB3OiB3LCByOiByLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuXG5cdCAgICAgIGlmIChhcmdzWydtYW5hZ2UnXSkge1xuXHQgICAgICAgIGRhdGFbJ20nXSA9IG07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoY2hhbm5lbCkpIHtcblx0ICAgICAgICBjaGFubmVsID0gY2hhbm5lbFsnam9pbiddKCcsJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoYXV0aF9rZXkpKSB7XG5cdCAgICAgICAgYXV0aF9rZXkgPSBhdXRoX2tleVsnam9pbiddKCcsJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiBjaGFubmVsICE9ICd1bmRlZmluZWQnICYmIGNoYW5uZWwgIT0gbnVsbCAmJiBjaGFubmVsLmxlbmd0aCA+IDApIGRhdGFbJ2NoYW5uZWwnXSA9IGNoYW5uZWw7XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbF9ncm91cCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsX2dyb3VwICE9IG51bGwgJiYgY2hhbm5lbF9ncm91cC5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0dGwgfHwgdHRsID09PSAwKSBkYXRhWyd0dGwnXSA9IHR0bDtcblxuXHQgICAgICBpZiAoYXV0aF9rZXkpIGRhdGFbJ2F1dGgnXSA9IGF1dGhfa2V5O1xuXG5cdCAgICAgIGRhdGEgPSBfZ2V0X3VybF9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgaWYgKCFhdXRoX2tleSkgZGVsZXRlIGRhdGFbJ2F1dGgnXTtcblxuXHQgICAgICBzaWduX2lucHV0ICs9IF9nZXRfcGFtX3NpZ25faW5wdXRfZnJvbV9wYXJhbXMoZGF0YSk7XG5cblx0ICAgICAgdmFyIHNpZ25hdHVyZSA9IGhtYWNfU0hBMjU2KHNpZ25faW5wdXQsIFNFQ1JFVF9LRVkpO1xuXG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcblx0ICAgICAgc2lnbmF0dXJlID0gc2lnbmF0dXJlLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuXG5cdCAgICAgIGRhdGFbJ3NpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2NhbGxiYWNrKHJlc3BvbnNlLCBjYWxsYmFjaywgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9lcnJvcihyZXNwb25zZSwgZXJyKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVybDogW1xuXHQgICAgICAgICAgU1REX09SSUdJTiwgJ3YxJywgJ2F1dGgnLCAnZ3JhbnQnLFxuXHQgICAgICAgICAgJ3N1Yi1rZXknLCBTVUJTQ1JJQkVfS0VZXG5cdCAgICAgICAgXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIC8qXG5cdCAgICAgUFVCTlVCLm1vYmlsZV9nd19wcm92aXNpb24gKHtcblx0ICAgICBkZXZpY2VfaWQ6ICdBNjU1RkJBOTkzMUFCJyxcblx0ICAgICBvcCAgICAgICA6ICdhZGQnIHwgJ3JlbW92ZScsXG5cdCAgICAgZ3dfdHlwZSAgOiAnYXBucycgfCAnZ2NtJyxcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICB9KTtcblx0ICAgICAqL1xuXG5cdCAgICBtb2JpbGVfZ3dfcHJvdmlzaW9uOiBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWydjYWxsYmFjayddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgYXV0aF9rZXkgPSBhcmdzWydhdXRoX2tleSddIHx8IEFVVEhfS0VZO1xuXHQgICAgICB2YXIgZXJyID0gYXJnc1snZXJyb3InXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGpzb25wID0ganNvbnBfY2IoKTtcblx0ICAgICAgdmFyIGNoYW5uZWwgPSBhcmdzWydjaGFubmVsJ107XG5cdCAgICAgIHZhciBvcCA9IGFyZ3NbJ29wJ107XG5cdCAgICAgIHZhciBnd190eXBlID0gYXJnc1snZ3dfdHlwZSddO1xuXHQgICAgICB2YXIgZGV2aWNlX2lkID0gYXJnc1snZGV2aWNlX2lkJ107XG5cdCAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgIHZhciB1cmw7XG5cblx0ICAgICAgaWYgKCFkZXZpY2VfaWQpIHJldHVybiBlcnJvcignTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZV9pZCknKTtcblx0ICAgICAgaWYgKCFnd190eXBlKSByZXR1cm4gZXJyb3IoJ01pc3NpbmcgR1cgVHlwZSAoZ3dfdHlwZTogZ2NtIG9yIGFwbnMpJyk7XG5cdCAgICAgIGlmICghb3ApIHJldHVybiBlcnJvcignTWlzc2luZyBHVyBPcGVyYXRpb24gKG9wOiBhZGQgb3IgcmVtb3ZlKScpO1xuXHQgICAgICBpZiAoIWNoYW5uZWwpIHJldHVybiBlcnJvcignTWlzc2luZyBndyBkZXN0aW5hdGlvbiBDaGFubmVsIChjaGFubmVsKScpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cblx0ICAgICAgLy8gQ3JlYXRlIFVSTFxuXHQgICAgICB1cmwgPSBbXG5cdCAgICAgICAgU1REX09SSUdJTiwgJ3YxL3B1c2gvc3ViLWtleScsXG5cdCAgICAgICAgU1VCU0NSSUJFX0tFWSwgJ2RldmljZXMnLCBkZXZpY2VfaWRcblx0ICAgICAgXTtcblxuXHQgICAgICBwYXJhbXMgPSB7IHV1aWQ6IFVVSUQsIGF1dGg6IGF1dGhfa2V5LCB0eXBlOiBnd190eXBlIH07XG5cblx0ICAgICAgaWYgKG9wID09ICdhZGQnKSB7XG5cdCAgICAgICAgcGFyYW1zWydhZGQnXSA9IGNoYW5uZWw7XG5cdCAgICAgIH0gZWxzZSBpZiAob3AgPT0gJ3JlbW92ZScpIHtcblx0ICAgICAgICBwYXJhbXNbJ3JlbW92ZSddID0gY2hhbm5lbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChVU0VfSU5TVEFOQ0VJRCkgcGFyYW1zWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IHBhcmFtcyxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKlxuXHQgICAgIFBVQk5VQi5hdWRpdCh7XG5cdCAgICAgY2hhbm5lbCAgOiAnbXlfY2hhdCcsXG5cdCAgICAgY2FsbGJhY2sgOiBmdW4sXG5cdCAgICAgZXJyb3IgICAgOiBmdW4sXG5cdCAgICAgcmVhZCAgICAgOiB0cnVlLFxuXHQgICAgIHdyaXRlICAgIDogdHJ1ZSxcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICBhdWRpdDogZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbJ2NhbGxiYWNrJ10gfHwgY2FsbGJhY2s7XG5cdCAgICAgIHZhciBlcnIgPSBhcmdzWydlcnJvciddIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IGFyZ3NbJ2NoYW5uZWwnXTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXAgPSBhcmdzWydjaGFubmVsX2dyb3VwJ107XG5cdCAgICAgIHZhciBhdXRoX2tleSA9IGFyZ3NbJ2F1dGhfa2V5J107XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cblx0ICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBDaGFubmVsXG5cdCAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBlcnJvcignTWlzc2luZyBDYWxsYmFjaycpO1xuXHQgICAgICBpZiAoIVNVQlNDUklCRV9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTdWJzY3JpYmUgS2V5Jyk7XG5cdCAgICAgIGlmICghUFVCTElTSF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBQdWJsaXNoIEtleScpO1xuXHQgICAgICBpZiAoIVNFQ1JFVF9LRVkpIHJldHVybiBlcnJvcignTWlzc2luZyBTZWNyZXQgS2V5Jyk7XG5cblx0ICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblx0ICAgICAgdmFyIHNpZ25faW5wdXQgPSBTVUJTQ1JJQkVfS0VZICsgJ1xcbicgKyBQVUJMSVNIX0tFWSArICdcXG4nICsgJ2F1ZGl0JyArICdcXG4nO1xuXG5cdCAgICAgIHZhciBkYXRhID0geyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9O1xuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPSAndW5kZWZpbmVkJyAmJiBjaGFubmVsICE9IG51bGwgJiYgY2hhbm5lbC5sZW5ndGggPiAwKSBkYXRhWydjaGFubmVsJ10gPSBjaGFubmVsO1xuXHQgICAgICBpZiAodHlwZW9mIGNoYW5uZWxfZ3JvdXAgIT0gJ3VuZGVmaW5lZCcgJiYgY2hhbm5lbF9ncm91cCAhPSBudWxsICYmIGNoYW5uZWxfZ3JvdXAubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIGRhdGFbJ2NoYW5uZWwtZ3JvdXAnXSA9IGNoYW5uZWxfZ3JvdXA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGF1dGhfa2V5KSBkYXRhWydhdXRoJ10gPSBhdXRoX2tleTtcblxuXHQgICAgICBkYXRhID0gX2dldF91cmxfcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIGlmICghYXV0aF9rZXkpIGRlbGV0ZSBkYXRhWydhdXRoJ107XG5cblx0ICAgICAgc2lnbl9pbnB1dCArPSBfZ2V0X3BhbV9zaWduX2lucHV0X2Zyb21fcGFyYW1zKGRhdGEpO1xuXG5cdCAgICAgIHZhciBzaWduYXR1cmUgPSBobWFjX1NIQTI1NihzaWduX2lucHV0LCBTRUNSRVRfS0VZKTtcblxuXHQgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmUucmVwbGFjZSgvXFwrL2csICctJyk7XG5cdCAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5yZXBsYWNlKC9cXC8vZywgJ18nKTtcblxuXHQgICAgICBkYXRhWydzaWduYXR1cmUnXSA9IHNpZ25hdHVyZTtcblx0ICAgICAgeGRyKHtcblx0ICAgICAgICBjYWxsYmFjazoganNvbnAsXG5cdCAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfY2FsbGJhY2socmVzcG9uc2UsIGNhbGxiYWNrLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZmFpbDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICBfaW52b2tlX2Vycm9yKHJlc3BvbnNlLCBlcnIpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgdXJsOiBbXG5cdCAgICAgICAgICBTVERfT1JJR0lOLCAndjEnLCAnYXV0aCcsICdhdWRpdCcsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVlcblx0ICAgICAgICBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgLypcblx0ICAgICBQVUJOVUIucmV2b2tlKHtcblx0ICAgICBjaGFubmVsICA6ICdteV9jaGF0Jyxcblx0ICAgICBjYWxsYmFjayA6IGZ1bixcblx0ICAgICBlcnJvciAgICA6IGZ1bixcblx0ICAgICBhdXRoX2tleSA6ICczeTh1aWFqZGtseXRvd3NqJ1xuXHQgICAgIH0pO1xuXHQgICAgICovXG5cdCAgICByZXZva2U6IGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuXHQgICAgICBhcmdzWydyZWFkJ10gPSBmYWxzZTtcblx0ICAgICAgYXJnc1snd3JpdGUnXSA9IGZhbHNlO1xuXHQgICAgICBTRUxGWydncmFudCddKGFyZ3MsIGNhbGxiYWNrKTtcblx0ICAgIH0sXG5cblx0ICAgIHNldF91dWlkOiBmdW5jdGlvbiAodXVpZCkge1xuXHQgICAgICBVVUlEID0gdXVpZDtcblx0ICAgICAgQ09OTkVDVCgpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0X3V1aWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFVVSUQ7XG5cdCAgICB9LFxuXG5cdCAgICBpc0FycmF5OiBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgIHJldHVybiB1dGlscy5pc0FycmF5KGFyZyk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRfc3Vic2NyaWJlZF9jaGFubmVsczogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gZ2VuZXJhdGVfY2hhbm5lbF9saXN0KENIQU5ORUxTLCB0cnVlKTtcblx0ICAgIH0sXG5cblx0ICAgIHByZXNlbmNlX2hlYXJ0YmVhdDogZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1snY2FsbGJhY2snXSB8fCBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgdmFyIGVyciA9IGFyZ3NbJ2Vycm9yJ10gfHwgZnVuY3Rpb24gKCkge307XG5cdCAgICAgIHZhciBqc29ucCA9IGpzb25wX2NiKCk7XG5cdCAgICAgIHZhciBkYXRhID0geyB1dWlkOiBVVUlELCBhdXRoOiBBVVRIX0tFWSB9O1xuXG5cdCAgICAgIHZhciBzdCA9IEpTT05bJ3N0cmluZ2lmeSddKFNUQVRFKTtcblx0ICAgICAgaWYgKHN0Lmxlbmd0aCA+IDIpIGRhdGFbJ3N0YXRlJ10gPSBKU09OWydzdHJpbmdpZnknXShTVEFURSk7XG5cblx0ICAgICAgaWYgKFBSRVNFTkNFX0hCID4gMCAmJiBQUkVTRU5DRV9IQiA8IDMyMCkgZGF0YVsnaGVhcnRiZWF0J10gPSBQUkVTRU5DRV9IQjtcblxuXHQgICAgICBpZiAoanNvbnAgIT0gJzAnKSB7XG5cdCAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9IGpzb25wO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNoYW5uZWxzID0gdXRpbHMuZW5jb2RlKGdlbmVyYXRlX2NoYW5uZWxfbGlzdChDSEFOTkVMUywgdHJ1ZSlbJ2pvaW4nXSgnLCcpKTtcblx0ICAgICAgdmFyIGNoYW5uZWxfZ3JvdXBzID0gZ2VuZXJhdGVfY2hhbm5lbF9ncm91cF9saXN0KENIQU5ORUxfR1JPVVBTLCB0cnVlKVsnam9pbiddKCcsJyk7XG5cblx0ICAgICAgaWYgKCFjaGFubmVscykgY2hhbm5lbHMgPSAnLCc7XG5cdCAgICAgIGlmIChjaGFubmVsX2dyb3VwcykgZGF0YVsnY2hhbm5lbC1ncm91cCddID0gY2hhbm5lbF9ncm91cHM7XG5cblx0ICAgICAgaWYgKFVTRV9JTlNUQU5DRUlEKSBkYXRhWydpbnN0YW5jZWlkJ10gPSBJTlNUQU5DRUlEO1xuXG5cdCAgICAgIHhkcih7XG5cdCAgICAgICAgY2FsbGJhY2s6IGpzb25wLFxuXHQgICAgICAgIGRhdGE6IF9nZXRfdXJsX3BhcmFtcyhkYXRhKSxcblx0ICAgICAgICB1cmw6IFtcblx0ICAgICAgICAgIFNURF9PUklHSU4sICd2MicsICdwcmVzZW5jZScsXG5cdCAgICAgICAgICAnc3ViLWtleScsIFNVQlNDUklCRV9LRVksXG5cdCAgICAgICAgICAnY2hhbm5lbCcsIGNoYW5uZWxzLFxuXHQgICAgICAgICAgJ2hlYXJ0YmVhdCdcblx0ICAgICAgICBdLFxuXHQgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgICAgX2ludm9rZV9jYWxsYmFjayhyZXNwb25zZSwgY2FsbGJhY2ssIGVycik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmYWlsOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0ICAgICAgICAgIF9pbnZva2VfZXJyb3IocmVzcG9uc2UsIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHN0b3BfdGltZXJzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcjIpO1xuXHQgICAgICBjbGVhclRpbWVvdXQoUFJFU0VOQ0VfSEJfVElNRU9VVCk7XG5cdCAgICB9LFxuXG5cdCAgICBzaHV0ZG93bjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBTRUxGWydzdG9wX3RpbWVycyddKCk7XG5cdCAgICAgIHNodXRkb3duICYmIHNodXRkb3duKCk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBFeHBvc2UgUFVCTlVCIEZ1bmN0aW9uc1xuXHQgICAgeGRyOiB4ZHIsXG5cdCAgICByZWFkeTogcmVhZHksXG5cdCAgICBkYjogZGIsXG5cdCAgICB1dWlkOiB1dGlscy5nZW5lcmF0ZVVVSUQsXG5cdCAgICBtYXA6IHV0aWxzLm1hcCxcblx0ICAgIGVhY2g6IHV0aWxzLmVhY2gsXG5cdCAgICAnZWFjaC1jaGFubmVsJzogZWFjaF9jaGFubmVsLFxuXHQgICAgZ3JlcDogdXRpbHMuZ3JlcCxcblx0ICAgIG9mZmxpbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgX3Jlc2V0X29mZmxpbmUoMSwgeyBtZXNzYWdlOiAnT2ZmbGluZS4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nIH0pO1xuXHQgICAgfSxcblx0ICAgIHN1cHBsYW50OiB1dGlscy5zdXBwbGFudCxcblx0ICAgIG5vdzogdXRpbHMucm5vdyxcblx0ICAgIHVuaXF1ZTogdW5pcXVlLFxuXHQgICAgdXBkYXRlcjogdXRpbHMudXBkYXRlclxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBfcG9sbF9vbmxpbmUoKSB7XG5cdCAgICBfaXNfb25saW5lKCkgfHwgX3Jlc2V0X29mZmxpbmUoMSwgeyBlcnJvcjogJ09mZmxpbmUuIFBsZWFzZSBjaGVjayB5b3VyIG5ldHdvcmsgc2V0dGluZ3MuJyB9KTtcblx0ICAgIF9wb2xsX3RpbWVyICYmIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICBfcG9sbF90aW1lciA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lLCBTRUNPTkQpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9wb2xsX29ubGluZTIoKSB7XG5cdCAgICBpZiAoIVRJTUVfQ0hFQ0spIHJldHVybjtcblx0ICAgIFNFTEZbJ3RpbWUnXShmdW5jdGlvbiAoc3VjY2Vzcykge1xuXHQgICAgICBkZXRlY3RfdGltZV9kZXRsYShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIH0sIHN1Y2Nlc3MpO1xuXHQgICAgICBzdWNjZXNzIHx8IF9yZXNldF9vZmZsaW5lKDEsIHtcblx0ICAgICAgICBlcnJvcjogJ0hlYXJ0YmVhdCBmYWlsZWQgdG8gY29ubmVjdCB0byBQdWJudWIgU2VydmVycy4nICtcblx0ICAgICAgICAnUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBzZXR0aW5ncy4nXG5cdCAgICAgIH0pO1xuXHQgICAgICBfcG9sbF90aW1lcjIgJiYgY2xlYXJUaW1lb3V0KF9wb2xsX3RpbWVyMik7XG5cdCAgICAgIF9wb2xsX3RpbWVyMiA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lMiwgS0VFUEFMSVZFKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIF9yZXNldF9vZmZsaW5lKGVyciwgbXNnKSB7XG5cdCAgICBTVUJfUkVDRUlWRVIgJiYgU1VCX1JFQ0VJVkVSKGVyciwgbXNnKTtcblx0ICAgIFNVQl9SRUNFSVZFUiA9IG51bGw7XG5cblx0ICAgIGNsZWFyVGltZW91dChfcG9sbF90aW1lcik7XG5cdCAgICBjbGVhclRpbWVvdXQoX3BvbGxfdGltZXIyKTtcblx0ICB9XG5cblx0ICBpZiAoIVVVSUQpIFVVSUQgPSBTRUxGWyd1dWlkJ10oKTtcblx0ICBpZiAoIUlOU1RBTkNFSUQpIElOU1RBTkNFSUQgPSBTRUxGWyd1dWlkJ10oKTtcblx0ICBkYlsnc2V0J10oU1VCU0NSSUJFX0tFWSArICd1dWlkJywgVVVJRCk7XG5cblx0ICBfcG9sbF90aW1lciA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lLCBTRUNPTkQpO1xuXHQgIF9wb2xsX3RpbWVyMiA9IHV0aWxzLnRpbWVvdXQoX3BvbGxfb25saW5lMiwgS0VFUEFMSVZFKTtcblx0ICBQUkVTRU5DRV9IQl9USU1FT1VUID0gdXRpbHMudGltZW91dChcblx0ICAgIHN0YXJ0X3ByZXNlbmNlX2hlYXJ0YmVhdCxcblx0ICAgIChQUkVTRU5DRV9IQl9JTlRFUlZBTCAtIDMpICogU0VDT05EXG5cdCAgKTtcblxuXHQgIC8vIERldGVjdCBBZ2Ugb2YgTWVzc2FnZVxuXHQgIGZ1bmN0aW9uIGRldGVjdF9sYXRlbmN5KHR0KSB7XG5cdCAgICB2YXIgYWRqdXN0ZWRfdGltZSA9IHV0aWxzLnJub3coKSAtIFRJTUVfRFJJRlQ7XG5cdCAgICByZXR1cm4gYWRqdXN0ZWRfdGltZSAtIHR0IC8gMTAwMDA7XG5cdCAgfVxuXG5cdCAgZGV0ZWN0X3RpbWVfZGV0bGEoKTtcblx0ICBmdW5jdGlvbiBkZXRlY3RfdGltZV9kZXRsYShjYiwgdGltZSkge1xuXHQgICAgdmFyIHN0aW1lID0gdXRpbHMucm5vdygpO1xuXG5cdCAgICB0aW1lICYmIGNhbGN1bGF0ZSh0aW1lKSB8fCBTRUxGWyd0aW1lJ10oY2FsY3VsYXRlKTtcblxuXHQgICAgZnVuY3Rpb24gY2FsY3VsYXRlKHRpbWUpIHtcblx0ICAgICAgaWYgKCF0aW1lKSByZXR1cm47XG5cdCAgICAgIHZhciBwdGltZSA9IHRpbWUgLyAxMDAwMDtcblx0ICAgICAgdmFyIGxhdGVuY3kgPSAodXRpbHMucm5vdygpIC0gc3RpbWUpIC8gMjtcblx0ICAgICAgVElNRV9EUklGVCA9IHV0aWxzLnJub3coKSAtIChwdGltZSArIGxhdGVuY3kpO1xuXHQgICAgICBjYiAmJiBjYihUSU1FX0RSSUZUKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gU0VMRjtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIFBOX0FQSTogUE5fQVBJLFxuXHQgIHVuaXF1ZTogdW5pcXVlLFxuXHQgIFBObWVzc2FnZTogUE5tZXNzYWdlLFxuXHQgIERFRl9USU1FT1VUOiBERUZfVElNRU9VVCxcblx0ICB0aW1lb3V0OiB1dGlscy50aW1lb3V0LFxuXHQgIGJ1aWxkX3VybDogdXRpbHMuYnVpbGRVUkwsXG5cdCAgZWFjaDogdXRpbHMuZWFjaCxcblx0ICB1dWlkOiB1dGlscy5nZW5lcmF0ZVVVSUQsXG5cdCAgVVJMQklUOiBkZWZhdWx0Q29uZmlndXJhdGlvbi5VUkxCSVQsXG5cdCAgZ3JlcDogdXRpbHMuZ3JlcCxcblx0ICBzdXBwbGFudDogdXRpbHMuc3VwcGxhbnQsXG5cdCAgbm93OiB1dGlscy5ybm93LFxuXHQgIHVwZGF0ZXI6IHV0aWxzLnVwZGF0ZXIsXG5cdCAgbWFwOiB1dGlscy5tYXBcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdFx0XCJQQVJBTVNCSVRcIjogXCImXCIsXG5cdFx0XCJVUkxCSVRcIjogXCIvXCJcblx0fTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IDAsIGJsb2NrLXNjb3BlZC12YXI6IDAsIG5vLXJlZGVjbGFyZTogMCwgZ3VhcmQtZm9yLWluOiAwICovXG5cblx0dmFyIGRlZmF1bHRDb25maWd1cmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIFJFUEwgPSAveyhbXFx3XFwtXSspfS9nO1xuXG5cdGZ1bmN0aW9uIHJub3coKSB7XG5cdCAgcmV0dXJuICtuZXcgRGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG5cdCAgcmV0dXJuICEhYXJnICYmIHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoYXJnKSB8fCB0eXBlb2YoYXJnLmxlbmd0aCkgPT09ICdudW1iZXInKTtcblx0ICAvLyByZXR1cm4gISFhcmcgJiYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShhcmcpIHx8IHR5cGVvZihhcmcubGVuZ3RoKSA9PT0gXCJudW1iZXJcIilcblx0fVxuXG5cdC8qKlxuXHQgKiBFQUNIXG5cdCAqID09PT1cblx0ICogZWFjaCggWzEsMiwzXSwgZnVuY3Rpb24oaXRlbSkgeyB9IClcblx0ICovXG5cdGZ1bmN0aW9uIGVhY2gobywgZikge1xuXHQgIGlmICghbyB8fCAhZikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIGlmIChpc0FycmF5KG8pKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IG8ubGVuZ3RoOyBpIDwgbDspIHtcblx0ICAgICAgZi5jYWxsKG9baV0sIG9baV0sIGkrKyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAodmFyIGkgaW4gbykge1xuXHQgICAgICBvLmhhc093blByb3BlcnR5ICYmXG5cdCAgICAgIG8uaGFzT3duUHJvcGVydHkoaSkgJiZcblx0ICAgICAgZi5jYWxsKG9baV0sIGksIG9baV0pO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFTkNPREVcblx0ICogPT09PT09XG5cdCAqIHZhciBlbmNvZGVkX2RhdGEgPSBlbmNvZGUoJ3BhdGgnKTtcblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShwYXRoKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocGF0aCk7IH1cblxuXHQvKipcblx0ICogQnVpbGQgVXJsXG5cdCAqID09PT09PT1cblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIGJ1aWxkVVJMKHVybENvbXBvbmVudHMsIHVybFBhcmFtcykge1xuXHQgIHZhciB1cmwgPSB1cmxDb21wb25lbnRzLmpvaW4oZGVmYXVsdENvbmZpZ3VyYXRpb24uVVJMQklUKTtcblx0ICB2YXIgcGFyYW1zID0gW107XG5cblx0ICBpZiAoIXVybFBhcmFtcykgcmV0dXJuIHVybDtcblxuXHQgIGVhY2godXJsUGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIHZhbHVlU3RyID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gSlNPTlsnc3RyaW5naWZ5J10odmFsdWUpIDogdmFsdWU7XG5cdCAgICAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICB2YWx1ZSAhPT0gbnVsbCAmJiBlbmNvZGUodmFsdWVTdHIpLmxlbmd0aCA+IDBcblx0ICAgICkgJiYgcGFyYW1zLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlKHZhbHVlU3RyKSk7XG5cdCAgfSk7XG5cblx0ICB1cmwgKz0gJz8nICsgcGFyYW1zLmpvaW4oZGVmYXVsdENvbmZpZ3VyYXRpb24uUEFSQU1TQklUKTtcblx0ICByZXR1cm4gdXJsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVQREFURVJcblx0ICogPT09PT09PVxuXHQgKiB2YXIgdGltZXN0YW1wID0gdW5pcXVlKCk7XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVyKGZ1biwgcmF0ZSkge1xuXHQgIHZhciB0aW1lb3V0O1xuXHQgIHZhciBsYXN0ID0gMDtcblx0ICB2YXIgcnVubml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGxhc3QgKyByYXRlID4gcm5vdygpKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocnVubml0LCByYXRlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxhc3QgPSBybm93KCk7XG5cdCAgICAgIGZ1bigpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gcnVubml0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdSRVBcblx0ICogPT09PVxuXHQgKiB2YXIgbGlzdCA9IGdyZXAoIFsxLDIsM10sIGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gJSAyIH0gKVxuXHQgKi9cblx0ZnVuY3Rpb24gZ3JlcChsaXN0LCBmdW4pIHtcblx0ICB2YXIgZmluID0gW107XG5cdCAgZWFjaChsaXN0IHx8IFtdLCBmdW5jdGlvbiAobCkge1xuXHQgICAgZnVuKGwpICYmIGZpbi5wdXNoKGwpO1xuXHQgIH0pO1xuXHQgIHJldHVybiBmaW47XG5cdH1cblxuXHQvKipcblx0ICogU1VQUExBTlRcblx0ICogPT09PT09PT1cblx0ICogdmFyIHRleHQgPSBzdXBwbGFudCggJ0hlbGxvIHtuYW1lfSEnLCB7IG5hbWUgOiAnSm9obicgfSApXG5cdCAqL1xuXHRmdW5jdGlvbiBzdXBwbGFudChzdHIsIHZhbHVlcykge1xuXHQgIHJldHVybiBzdHIucmVwbGFjZShSRVBMLCBmdW5jdGlvbiAoXywgbWF0Y2gpIHtcblx0ICAgIHJldHVybiB2YWx1ZXNbbWF0Y2hdIHx8IF87XG5cdCAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogdGltZW91dFxuXHQgKiA9PT09PT09XG5cdCAqIHRpbWVvdXQoIGZ1bmN0aW9uKCl7fSwgMTAwICk7XG5cdCAqL1xuXHRmdW5jdGlvbiB0aW1lb3V0KGZ1biwgd2FpdCkge1xuXHQgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICByZXR1cm4gc2V0VGltZW91dChmdW4sIHdhaXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIHV1aWRcblx0ICogPT09PVxuXHQgKiB2YXIgbXlfdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKGNhbGxiYWNrKSB7XG5cdCAgdmFyIHUgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csXG5cdCAgICBmdW5jdGlvbiAoYykge1xuXHQgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG5cdCAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcblx0ICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHQgICAgfSk7XG5cdCAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh1KTtcblx0ICByZXR1cm4gdTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNQVBcblx0ICogPT09XG5cdCAqIHZhciBsaXN0ID0gbWFwKCBbMSwyLDNdLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtICsgMSB9IClcblx0ICovXG5cdGZ1bmN0aW9uIG1hcChsaXN0LCBmdW4pIHtcblx0ICB2YXIgZmluID0gW107XG5cdCAgZWFjaChsaXN0IHx8IFtdLCBmdW5jdGlvbiAoaywgdikge1xuXHQgICAgZmluLnB1c2goZnVuKGssIHYpKTtcblx0ICB9KTtcblx0ICByZXR1cm4gZmluO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBwYW1FbmNvZGUoc3RyKSB7XG5cdCAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKn5dL2csIGZ1bmN0aW9uIChjKSB7XG5cdCAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHQgIH0pO1xuXHR9XG5cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBidWlsZFVSTDogYnVpbGRVUkwsXG5cdCAgZW5jb2RlOiBlbmNvZGUsXG5cdCAgZWFjaDogZWFjaCxcblx0ICB1cGRhdGVyOiB1cGRhdGVyLFxuXHQgIHJub3c6IHJub3csXG5cdCAgaXNBcnJheTogaXNBcnJheSxcblx0ICBtYXA6IG1hcCxcblx0ICBwYW1FbmNvZGU6IHBhbUVuY29kZSxcblx0ICBnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0ICB0aW1lb3V0OiB0aW1lb3V0LFxuXHQgIHN1cHBsYW50OiBzdXBwbGFudCxcblx0ICBncmVwOiBncmVwXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIGVzbGludCBjYW1lbGNhc2U6IDAgZXFlcWVxOiAwICovXG5cblx0dmFyIENyeXB0b0pTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHRmdW5jdGlvbiBjcnlwdG9fb2JqKCkge1xuXHQgIGZ1bmN0aW9uIFNIQTI1NihzKSB7XG5cdCAgICByZXR1cm4gQ3J5cHRvSlNbJ1NIQTI1NiddKHMpWyd0b1N0cmluZyddKENyeXB0b0pTWydlbmMnXVsnSGV4J10pO1xuXHQgIH1cblxuXHQgIHZhciBpdiA9ICcwMTIzNDU2Nzg5MDEyMzQ1JztcblxuXHQgIHZhciBhbGxvd2VkS2V5RW5jb2RpbmdzID0gWydoZXgnLCAndXRmOCcsICdiYXNlNjQnLCAnYmluYXJ5J107XG5cdCAgdmFyIGFsbG93ZWRLZXlMZW5ndGhzID0gWzEyOCwgMjU2XTtcblx0ICB2YXIgYWxsb3dlZE1vZGVzID0gWydlY2InLCAnY2JjJ107XG5cblx0ICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdCAgICBlbmNyeXB0S2V5OiB0cnVlLFxuXHQgICAga2V5RW5jb2Rpbmc6ICd1dGY4Jyxcblx0ICAgIGtleUxlbmd0aDogMjU2LFxuXHQgICAgbW9kZTogJ2NiYydcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcGFyc2Vfb3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgICAvLyBEZWZhdWx0c1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ2VuY3J5cHRLZXknKSkgb3B0aW9uc1snZW5jcnlwdEtleSddID0gZGVmYXVsdE9wdGlvbnNbJ2VuY3J5cHRLZXknXTtcblx0ICAgIGlmICghb3B0aW9uc1snaGFzT3duUHJvcGVydHknXSgna2V5RW5jb2RpbmcnKSkgb3B0aW9uc1sna2V5RW5jb2RpbmcnXSA9IGRlZmF1bHRPcHRpb25zWydrZXlFbmNvZGluZyddO1xuXHQgICAgaWYgKCFvcHRpb25zWydoYXNPd25Qcm9wZXJ0eSddKCdrZXlMZW5ndGgnKSkgb3B0aW9uc1sna2V5TGVuZ3RoJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5TGVuZ3RoJ107XG5cdCAgICBpZiAoIW9wdGlvbnNbJ2hhc093blByb3BlcnR5J10oJ21vZGUnKSkgb3B0aW9uc1snbW9kZSddID0gZGVmYXVsdE9wdGlvbnNbJ21vZGUnXTtcblxuXHQgICAgLy8gVmFsaWRhdGlvblxuXHQgICAgaWYgKGFsbG93ZWRLZXlFbmNvZGluZ3NbJ2luZGV4T2YnXShvcHRpb25zWydrZXlFbmNvZGluZyddWyd0b0xvd2VyQ2FzZSddKCkpID09IC0xKSBvcHRpb25zWydrZXlFbmNvZGluZyddID0gZGVmYXVsdE9wdGlvbnNbJ2tleUVuY29kaW5nJ107XG5cdCAgICBpZiAoYWxsb3dlZEtleUxlbmd0aHNbJ2luZGV4T2YnXShwYXJzZUludChvcHRpb25zWydrZXlMZW5ndGgnXSwgMTApKSA9PSAtMSkgb3B0aW9uc1sna2V5TGVuZ3RoJ10gPSBkZWZhdWx0T3B0aW9uc1sna2V5TGVuZ3RoJ107XG5cdCAgICBpZiAoYWxsb3dlZE1vZGVzWydpbmRleE9mJ10ob3B0aW9uc1snbW9kZSddWyd0b0xvd2VyQ2FzZSddKCkpID09IC0xKSBvcHRpb25zWydtb2RlJ10gPSBkZWZhdWx0T3B0aW9uc1snbW9kZSddO1xuXG5cdCAgICByZXR1cm4gb3B0aW9ucztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWNvZGVfa2V5KGtleSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPT09ICdiYXNlNjQnKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddWydwYXJzZSddKGtleSk7XG5cdCAgICB9IGVsc2UgaWYgKG9wdGlvbnNbJ2tleUVuY29kaW5nJ10gPT09ICdoZXgnKSB7XG5cdCAgICAgIHJldHVybiBDcnlwdG9KU1snZW5jJ11bJ0hleCddWydwYXJzZSddKGtleSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4ga2V5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9wYWRkZWRfa2V5KGtleSwgb3B0aW9ucykge1xuXHQgICAga2V5ID0gZGVjb2RlX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgaWYgKG9wdGlvbnNbJ2VuY3J5cHRLZXknXSkge1xuXHQgICAgICByZXR1cm4gQ3J5cHRvSlNbJ2VuYyddWydVdGY4J11bJ3BhcnNlJ10oU0hBMjU2KGtleSlbJ3NsaWNlJ10oMCwgMzIpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBrZXk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZ2V0X21vZGUob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnNbJ21vZGUnXSA9PT0gJ2VjYicpIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydtb2RlJ11bJ0VDQiddO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIENyeXB0b0pTWydtb2RlJ11bJ0NCQyddO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldF9pdihvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gKG9wdGlvbnNbJ21vZGUnXSA9PT0gJ2NiYycpID8gQ3J5cHRvSlNbJ2VuYyddWydVdGY4J11bJ3BhcnNlJ10oaXYpIDogbnVsbDtcblx0ICB9XG5cblx0ICByZXR1cm4ge1xuXHQgICAgZW5jcnlwdDogZnVuY3Rpb24gKGRhdGEsIGtleSwgb3B0aW9ucykge1xuXHQgICAgICBpZiAoIWtleSkgcmV0dXJuIGRhdGE7XG5cdCAgICAgIG9wdGlvbnMgPSBwYXJzZV9vcHRpb25zKG9wdGlvbnMpO1xuXHQgICAgICB2YXIgaXYgPSBnZXRfaXYob3B0aW9ucyk7XG5cdCAgICAgIHZhciBtb2RlID0gZ2V0X21vZGUob3B0aW9ucyk7XG5cdCAgICAgIHZhciBjaXBoZXJfa2V5ID0gZ2V0X3BhZGRlZF9rZXkoa2V5LCBvcHRpb25zKTtcblx0ICAgICAgdmFyIGhleF9tZXNzYWdlID0gSlNPTlsnc3RyaW5naWZ5J10oZGF0YSk7XG5cdCAgICAgIHZhciBlbmNyeXB0ZWRIZXhBcnJheSA9IENyeXB0b0pTWydBRVMnXVsnZW5jcnlwdCddKGhleF9tZXNzYWdlLCBjaXBoZXJfa2V5LCB7IGl2OiBpdiwgbW9kZTogbW9kZSB9KVsnY2lwaGVydGV4dCddO1xuXHQgICAgICB2YXIgYmFzZV82NF9lbmNyeXB0ZWQgPSBlbmNyeXB0ZWRIZXhBcnJheVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ0Jhc2U2NCddKTtcblx0ICAgICAgcmV0dXJuIGJhc2VfNjRfZW5jcnlwdGVkIHx8IGRhdGE7XG5cdCAgICB9LFxuXG5cdCAgICBkZWNyeXB0OiBmdW5jdGlvbiAoZGF0YSwga2V5LCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICgha2V5KSByZXR1cm4gZGF0YTtcblx0ICAgICAgb3B0aW9ucyA9IHBhcnNlX29wdGlvbnMob3B0aW9ucyk7XG5cdCAgICAgIHZhciBpdiA9IGdldF9pdihvcHRpb25zKTtcblx0ICAgICAgdmFyIG1vZGUgPSBnZXRfbW9kZShvcHRpb25zKTtcblx0ICAgICAgdmFyIGNpcGhlcl9rZXkgPSBnZXRfcGFkZGVkX2tleShrZXksIG9wdGlvbnMpO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHZhciBiaW5hcnlfZW5jID0gQ3J5cHRvSlNbJ2VuYyddWydCYXNlNjQnXVsncGFyc2UnXShkYXRhKTtcblx0ICAgICAgICB2YXIganNvbl9wbGFpbiA9IENyeXB0b0pTWydBRVMnXVsnZGVjcnlwdCddKHsgY2lwaGVydGV4dDogYmluYXJ5X2VuYyB9LCBjaXBoZXJfa2V5LCB7IGl2OiBpdiwgbW9kZTogbW9kZSB9KVsndG9TdHJpbmcnXShDcnlwdG9KU1snZW5jJ11bJ1V0ZjgnXSk7XG5cdCAgICAgICAgdmFyIHBsYWludGV4dCA9IEpTT05bJ3BhcnNlJ10oanNvbl9wbGFpbik7XG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBjcnlwdG9fb2JqO1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHQgQ3J5cHRvSlMgdjMuMS4yXG5cdCBjb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcblx0IChjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuXHQgKi9cblx0dmFyIENyeXB0b0pTPUNyeXB0b0pTfHxmdW5jdGlvbihoLHMpe3ZhciBmPXt9LGc9Zi5saWI9e30scT1mdW5jdGlvbigpe30sbT1nLkJhc2U9e2V4dGVuZDpmdW5jdGlvbihhKXtxLnByb3RvdHlwZT10aGlzO3ZhciBjPW5ldyBxO2EmJmMubWl4SW4oYSk7Yy5oYXNPd25Qcm9wZXJ0eShcImluaXRcIil8fChjLmluaXQ9ZnVuY3Rpb24oKXtjLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pO2MuaW5pdC5wcm90b3R5cGU9YztjLiRzdXBlcj10aGlzO3JldHVybiBjfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmV4dGVuZCgpO2EuaW5pdC5hcHBseShhLGFyZ3VtZW50cyk7cmV0dXJuIGF9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJih0aGlzW2NdPWFbY10pO2EuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSYmKHRoaXMudG9TdHJpbmc9YS50b1N0cmluZyl9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpfX0sXG5cdCAgICByPWcuV29yZEFycmF5PW0uZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGEsYyl7YT10aGlzLndvcmRzPWF8fFtdO3RoaXMuc2lnQnl0ZXM9YyE9cz9jOjQqYS5sZW5ndGh9LHRvU3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybihhfHxrKS5zdHJpbmdpZnkodGhpcyl9LGNvbmNhdDpmdW5jdGlvbihhKXt2YXIgYz10aGlzLndvcmRzLGQ9YS53b3JkcyxiPXRoaXMuc2lnQnl0ZXM7YT1hLnNpZ0J5dGVzO3RoaXMuY2xhbXAoKTtpZihiJTQpZm9yKHZhciBlPTA7ZTxhO2UrKyljW2IrZT4+PjJdfD0oZFtlPj4+Ml0+Pj4yNC04KihlJTQpJjI1NSk8PDI0LTgqKChiK2UpJTQpO2Vsc2UgaWYoNjU1MzU8ZC5sZW5ndGgpZm9yKGU9MDtlPGE7ZSs9NCljW2IrZT4+PjJdPWRbZT4+PjJdO2Vsc2UgYy5wdXNoLmFwcGx5KGMsZCk7dGhpcy5zaWdCeXRlcys9YTtyZXR1cm4gdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLndvcmRzLGM9dGhpcy5zaWdCeXRlczthW2M+Pj4yXSY9NDI5NDk2NzI5NTw8XG5cdCAgICAgIDMyLTgqKGMlNCk7YS5sZW5ndGg9aC5jZWlsKGMvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bS5jbG9uZS5jYWxsKHRoaXMpO2Eud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKTtyZXR1cm4gYX0scmFuZG9tOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1bXSxkPTA7ZDxhO2QrPTQpYy5wdXNoKDQyOTQ5NjcyOTYqaC5yYW5kb20oKXwwKTtyZXR1cm4gbmV3IHIuaW5pdChjLGEpfX0pLGw9Zi5lbmM9e30saz1sLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBjPWEud29yZHM7YT1hLnNpZ0J5dGVzO2Zvcih2YXIgZD1bXSxiPTA7YjxhO2IrKyl7dmFyIGU9Y1tiPj4+Ml0+Pj4yNC04KihiJTQpJjI1NTtkLnB1c2goKGU+Pj40KS50b1N0cmluZygxNikpO2QucHVzaCgoZSYxNSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gZC5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihhKXtmb3IodmFyIGM9YS5sZW5ndGgsZD1bXSxiPTA7YjxjO2IrPTIpZFtiPj4+M118PXBhcnNlSW50KGEuc3Vic3RyKGIsXG5cdCAgICAgICAgMiksMTYpPDwyNC00KihiJTgpO3JldHVybiBuZXcgci5pbml0KGQsYy8yKX19LG49bC5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbihhKXt2YXIgYz1hLndvcmRzO2E9YS5zaWdCeXRlcztmb3IodmFyIGQ9W10sYj0wO2I8YTtiKyspZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY1tiPj4+Ml0+Pj4yNC04KihiJTQpJjI1NSkpO3JldHVybiBkLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLmxlbmd0aCxkPVtdLGI9MDtiPGM7YisrKWRbYj4+PjJdfD0oYS5jaGFyQ29kZUF0KGIpJjI1NSk8PDI0LTgqKGIlNCk7cmV0dXJuIG5ldyByLmluaXQoZCxjKX19LGo9bC5VdGY4PXtzdHJpbmdpZnk6ZnVuY3Rpb24oYSl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKG4uc3RyaW5naWZ5KGEpKSl9Y2F0Y2goYyl7dGhyb3cgRXJyb3IoXCJNYWxmb3JtZWQgVVRGLTggZGF0YVwiKTt9fSxwYXJzZTpmdW5jdGlvbihhKXtyZXR1cm4gbi5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYSkpKX19LFxuXHQgICAgdT1nLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09bS5leHRlbmQoe3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fZGF0YT1uZXcgci5pbml0O3RoaXMuX25EYXRhQnl0ZXM9MH0sX2FwcGVuZDpmdW5jdGlvbihhKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9ai5wYXJzZShhKSk7dGhpcy5fZGF0YS5jb25jYXQoYSk7dGhpcy5fbkRhdGFCeXRlcys9YS5zaWdCeXRlc30sX3Byb2Nlc3M6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5fZGF0YSxkPWMud29yZHMsYj1jLnNpZ0J5dGVzLGU9dGhpcy5ibG9ja1NpemUsZj1iLyg0KmUpLGY9YT9oLmNlaWwoZik6aC5tYXgoKGZ8MCktdGhpcy5fbWluQnVmZmVyU2l6ZSwwKTthPWYqZTtiPWgubWluKDQqYSxiKTtpZihhKXtmb3IodmFyIGc9MDtnPGE7Zys9ZSl0aGlzLl9kb1Byb2Nlc3NCbG9jayhkLGcpO2c9ZC5zcGxpY2UoMCxhKTtjLnNpZ0J5dGVzLT1ifXJldHVybiBuZXcgci5pbml0KGcsYil9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGE9bS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICBhLl9kYXRhPXRoaXMuX2RhdGEuY2xvbmUoKTtyZXR1cm4gYX0sX21pbkJ1ZmZlclNpemU6MH0pO2cuSGFzaGVyPXUuZXh0ZW5kKHtjZmc6bS5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKGEpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChhKTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dS5yZXNldC5jYWxsKHRoaXMpO3RoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKGEpe3RoaXMuX2FwcGVuZChhKTt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGEpe2EmJnRoaXMuX2FwcGVuZChhKTtyZXR1cm4gdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4obmV3IGEuaW5pdChkKSkuZmluYWxpemUoYyl9fSxfY3JlYXRlSG1hY0hlbHBlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4obmV3IHQuSE1BQy5pbml0KGEsXG5cdCAgICBkKSkuZmluYWxpemUoYyl9fX0pO3ZhciB0PWYuYWxnbz17fTtyZXR1cm4gZn0oTWF0aCk7XG5cblx0Ly8gU0hBMjU2XG5cdChmdW5jdGlvbihoKXtmb3IodmFyIHM9Q3J5cHRvSlMsZj1zLmxpYixnPWYuV29yZEFycmF5LHE9Zi5IYXNoZXIsZj1zLmFsZ28sbT1bXSxyPVtdLGw9ZnVuY3Rpb24oYSl7cmV0dXJuIDQyOTQ5NjcyOTYqKGEtKGF8MCkpfDB9LGs9MixuPTA7NjQ+bjspe3ZhciBqO2E6e2o9aztmb3IodmFyIHU9aC5zcXJ0KGopLHQ9Mjt0PD11O3QrKylpZighKGoldCkpe2o9ITE7YnJlYWsgYX1qPSEwfWomJig4Pm4mJihtW25dPWwoaC5wb3coaywwLjUpKSkscltuXT1sKGgucG93KGssMS8zKSksbisrKTtrKyt9dmFyIGE9W10sZj1mLlNIQTI1Nj1xLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBnLmluaXQobS5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihjLGQpe2Zvcih2YXIgYj10aGlzLl9oYXNoLndvcmRzLGU9YlswXSxmPWJbMV0sZz1iWzJdLGo9YlszXSxoPWJbNF0sbT1iWzVdLG49Yls2XSxxPWJbN10scD0wOzY0PnA7cCsrKXtpZigxNj5wKWFbcF09XG5cdCAgY1tkK3BdfDA7ZWxzZXt2YXIgaz1hW3AtMTVdLGw9YVtwLTJdO2FbcF09KChrPDwyNXxrPj4+NyleKGs8PDE0fGs+Pj4xOCleaz4+PjMpK2FbcC03XSsoKGw8PDE1fGw+Pj4xNyleKGw8PDEzfGw+Pj4xOSlebD4+PjEwKSthW3AtMTZdfWs9cSsoKGg8PDI2fGg+Pj42KV4oaDw8MjF8aD4+PjExKV4oaDw8N3xoPj4+MjUpKSsoaCZtXn5oJm4pK3JbcF0rYVtwXTtsPSgoZTw8MzB8ZT4+PjIpXihlPDwxOXxlPj4+MTMpXihlPDwxMHxlPj4+MjIpKSsoZSZmXmUmZ15mJmcpO3E9bjtuPW07bT1oO2g9aitrfDA7aj1nO2c9ZjtmPWU7ZT1rK2x8MH1iWzBdPWJbMF0rZXwwO2JbMV09YlsxXStmfDA7YlsyXT1iWzJdK2d8MDtiWzNdPWJbM10ranwwO2JbNF09Yls0XStofDA7Yls1XT1iWzVdK218MDtiWzZdPWJbNl0rbnwwO2JbN109Yls3XStxfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fZGF0YSxkPWEud29yZHMsYj04KnRoaXMuX25EYXRhQnl0ZXMsZT04KmEuc2lnQnl0ZXM7XG5cdCAgZFtlPj4+NV18PTEyODw8MjQtZSUzMjtkWyhlKzY0Pj4+OTw8NCkrMTRdPWguZmxvb3IoYi80Mjk0OTY3Mjk2KTtkWyhlKzY0Pj4+OTw8NCkrMTVdPWI7YS5zaWdCeXRlcz00KmQubGVuZ3RoO3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1xLmNsb25lLmNhbGwodGhpcyk7YS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGF9fSk7cy5TSEEyNTY9cS5fY3JlYXRlSGVscGVyKGYpO3MuSG1hY1NIQTI1Nj1xLl9jcmVhdGVIbWFjSGVscGVyKGYpfSkoTWF0aCk7XG5cblx0Ly8gSE1BQyBTSEEyNTZcblx0KGZ1bmN0aW9uKCl7dmFyIGg9Q3J5cHRvSlMscz1oLmVuYy5VdGY4O2guYWxnby5ITUFDPWgubGliLkJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGYsZyl7Zj10aGlzLl9oYXNoZXI9bmV3IGYuaW5pdDtcInN0cmluZ1wiPT10eXBlb2YgZyYmKGc9cy5wYXJzZShnKSk7dmFyIGg9Zi5ibG9ja1NpemUsbT00Kmg7Zy5zaWdCeXRlcz5tJiYoZz1mLmZpbmFsaXplKGcpKTtnLmNsYW1wKCk7Zm9yKHZhciByPXRoaXMuX29LZXk9Zy5jbG9uZSgpLGw9dGhpcy5faUtleT1nLmNsb25lKCksaz1yLndvcmRzLG49bC53b3JkcyxqPTA7ajxoO2orKylrW2pdXj0xNTQ5NTU2ODI4LG5bal1ePTkwOTUyMjQ4NjtyLnNpZ0J5dGVzPWwuc2lnQnl0ZXM9bTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dmFyIGY9dGhpcy5faGFzaGVyO2YucmVzZXQoKTtmLnVwZGF0ZSh0aGlzLl9pS2V5KX0sdXBkYXRlOmZ1bmN0aW9uKGYpe3RoaXMuX2hhc2hlci51cGRhdGUoZik7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGYpe3ZhciBnPVxuXHQgIHRoaXMuX2hhc2hlcjtmPWcuZmluYWxpemUoZik7Zy5yZXNldCgpO3JldHVybiBnLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoZikpfX0pfSkoKTtcblxuXHQvLyBCYXNlNjRcblx0KGZ1bmN0aW9uKCl7dmFyIHU9Q3J5cHRvSlMscD11LmxpYi5Xb3JkQXJyYXk7dS5lbmMuQmFzZTY0PXtzdHJpbmdpZnk6ZnVuY3Rpb24oZCl7dmFyIGw9ZC53b3JkcyxwPWQuc2lnQnl0ZXMsdD10aGlzLl9tYXA7ZC5jbGFtcCgpO2Q9W107Zm9yKHZhciByPTA7cjxwO3IrPTMpZm9yKHZhciB3PShsW3I+Pj4yXT4+PjI0LTgqKHIlNCkmMjU1KTw8MTZ8KGxbcisxPj4+Ml0+Pj4yNC04KigocisxKSU0KSYyNTUpPDw4fGxbcisyPj4+Ml0+Pj4yNC04KigocisyKSU0KSYyNTUsdj0wOzQ+diYmciswLjc1KnY8cDt2KyspZC5wdXNoKHQuY2hhckF0KHc+Pj42KigzLXYpJjYzKSk7aWYobD10LmNoYXJBdCg2NCkpZm9yKDtkLmxlbmd0aCU0OylkLnB1c2gobCk7cmV0dXJuIGQuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZCl7dmFyIGw9ZC5sZW5ndGgscz10aGlzLl9tYXAsdD1zLmNoYXJBdCg2NCk7dCYmKHQ9ZC5pbmRleE9mKHQpLC0xIT10JiYobD10KSk7Zm9yKHZhciB0PVtdLHI9MCx3PTA7dzxcblx0bDt3KyspaWYodyU0KXt2YXIgdj1zLmluZGV4T2YoZC5jaGFyQXQody0xKSk8PDIqKHclNCksYj1zLmluZGV4T2YoZC5jaGFyQXQodykpPj4+Ni0yKih3JTQpO3Rbcj4+PjJdfD0odnxiKTw8MjQtOCoociU0KTtyKyt9cmV0dXJuIHAuY3JlYXRlKHQscil9LF9tYXA6XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwifX0pKCk7XG5cblx0Ly8gQmxvY2tDaXBoZXJcblx0KGZ1bmN0aW9uKHUpe2Z1bmN0aW9uIHAoYixuLGEsYyxlLGosayl7Yj1iKyhuJmF8fm4mYykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIGQoYixuLGEsYyxlLGosayl7Yj1iKyhuJmN8YSZ+YykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIGwoYixuLGEsYyxlLGosayl7Yj1iKyhuXmFeYykrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZ1bmN0aW9uIHMoYixuLGEsYyxlLGosayl7Yj1iKyhhXihufH5jKSkrZStrO3JldHVybihiPDxqfGI+Pj4zMi1qKStufWZvcih2YXIgdD1DcnlwdG9KUyxyPXQubGliLHc9ci5Xb3JkQXJyYXksdj1yLkhhc2hlcixyPXQuYWxnbyxiPVtdLHg9MDs2ND54O3grKyliW3hdPTQyOTQ5NjcyOTYqdS5hYnModS5zaW4oeCsxKSl8MDtyPXIuTUQ1PXYuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IHcuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LFxuXHQgIF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihxLG4pe2Zvcih2YXIgYT0wOzE2PmE7YSsrKXt2YXIgYz1uK2EsZT1xW2NdO3FbY109KGU8PDh8ZT4+PjI0KSYxNjcxMTkzNXwoZTw8MjR8ZT4+PjgpJjQyNzgyNTUzNjB9dmFyIGE9dGhpcy5faGFzaC53b3JkcyxjPXFbbiswXSxlPXFbbisxXSxqPXFbbisyXSxrPXFbbiszXSx6PXFbbis0XSxyPXFbbis1XSx0PXFbbis2XSx3PXFbbis3XSx2PXFbbis4XSxBPXFbbis5XSxCPXFbbisxMF0sQz1xW24rMTFdLHU9cVtuKzEyXSxEPXFbbisxM10sRT1xW24rMTRdLHg9cVtuKzE1XSxmPWFbMF0sbT1hWzFdLGc9YVsyXSxoPWFbM10sZj1wKGYsbSxnLGgsYyw3LGJbMF0pLGg9cChoLGYsbSxnLGUsMTIsYlsxXSksZz1wKGcsaCxmLG0saiwxNyxiWzJdKSxtPXAobSxnLGgsZixrLDIyLGJbM10pLGY9cChmLG0sZyxoLHosNyxiWzRdKSxoPXAoaCxmLG0sZyxyLDEyLGJbNV0pLGc9cChnLGgsZixtLHQsMTcsYls2XSksbT1wKG0sZyxoLGYsdywyMixiWzddKSxcblx0ICAgIGY9cChmLG0sZyxoLHYsNyxiWzhdKSxoPXAoaCxmLG0sZyxBLDEyLGJbOV0pLGc9cChnLGgsZixtLEIsMTcsYlsxMF0pLG09cChtLGcsaCxmLEMsMjIsYlsxMV0pLGY9cChmLG0sZyxoLHUsNyxiWzEyXSksaD1wKGgsZixtLGcsRCwxMixiWzEzXSksZz1wKGcsaCxmLG0sRSwxNyxiWzE0XSksbT1wKG0sZyxoLGYseCwyMixiWzE1XSksZj1kKGYsbSxnLGgsZSw1LGJbMTZdKSxoPWQoaCxmLG0sZyx0LDksYlsxN10pLGc9ZChnLGgsZixtLEMsMTQsYlsxOF0pLG09ZChtLGcsaCxmLGMsMjAsYlsxOV0pLGY9ZChmLG0sZyxoLHIsNSxiWzIwXSksaD1kKGgsZixtLGcsQiw5LGJbMjFdKSxnPWQoZyxoLGYsbSx4LDE0LGJbMjJdKSxtPWQobSxnLGgsZix6LDIwLGJbMjNdKSxmPWQoZixtLGcsaCxBLDUsYlsyNF0pLGg9ZChoLGYsbSxnLEUsOSxiWzI1XSksZz1kKGcsaCxmLG0saywxNCxiWzI2XSksbT1kKG0sZyxoLGYsdiwyMCxiWzI3XSksZj1kKGYsbSxnLGgsRCw1LGJbMjhdKSxoPWQoaCxmLFxuXHQgICAgICBtLGcsaiw5LGJbMjldKSxnPWQoZyxoLGYsbSx3LDE0LGJbMzBdKSxtPWQobSxnLGgsZix1LDIwLGJbMzFdKSxmPWwoZixtLGcsaCxyLDQsYlszMl0pLGg9bChoLGYsbSxnLHYsMTEsYlszM10pLGc9bChnLGgsZixtLEMsMTYsYlszNF0pLG09bChtLGcsaCxmLEUsMjMsYlszNV0pLGY9bChmLG0sZyxoLGUsNCxiWzM2XSksaD1sKGgsZixtLGcseiwxMSxiWzM3XSksZz1sKGcsaCxmLG0sdywxNixiWzM4XSksbT1sKG0sZyxoLGYsQiwyMyxiWzM5XSksZj1sKGYsbSxnLGgsRCw0LGJbNDBdKSxoPWwoaCxmLG0sZyxjLDExLGJbNDFdKSxnPWwoZyxoLGYsbSxrLDE2LGJbNDJdKSxtPWwobSxnLGgsZix0LDIzLGJbNDNdKSxmPWwoZixtLGcsaCxBLDQsYls0NF0pLGg9bChoLGYsbSxnLHUsMTEsYls0NV0pLGc9bChnLGgsZixtLHgsMTYsYls0Nl0pLG09bChtLGcsaCxmLGosMjMsYls0N10pLGY9cyhmLG0sZyxoLGMsNixiWzQ4XSksaD1zKGgsZixtLGcsdywxMCxiWzQ5XSksZz1zKGcsaCxmLG0sXG5cdCAgICAgIEUsMTUsYls1MF0pLG09cyhtLGcsaCxmLHIsMjEsYls1MV0pLGY9cyhmLG0sZyxoLHUsNixiWzUyXSksaD1zKGgsZixtLGcsaywxMCxiWzUzXSksZz1zKGcsaCxmLG0sQiwxNSxiWzU0XSksbT1zKG0sZyxoLGYsZSwyMSxiWzU1XSksZj1zKGYsbSxnLGgsdiw2LGJbNTZdKSxoPXMoaCxmLG0sZyx4LDEwLGJbNTddKSxnPXMoZyxoLGYsbSx0LDE1LGJbNThdKSxtPXMobSxnLGgsZixELDIxLGJbNTldKSxmPXMoZixtLGcsaCx6LDYsYls2MF0pLGg9cyhoLGYsbSxnLEMsMTAsYls2MV0pLGc9cyhnLGgsZixtLGosMTUsYls2Ml0pLG09cyhtLGcsaCxmLEEsMjEsYls2M10pO2FbMF09YVswXStmfDA7YVsxXT1hWzFdK218MDthWzJdPWFbMl0rZ3wwO2FbM109YVszXStofDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fZGF0YSxuPWIud29yZHMsYT04KnRoaXMuX25EYXRhQnl0ZXMsYz04KmIuc2lnQnl0ZXM7bltjPj4+NV18PTEyODw8MjQtYyUzMjt2YXIgZT11LmZsb29yKGEvXG5cdCAgICA0Mjk0OTY3Mjk2KTtuWyhjKzY0Pj4+OTw8NCkrMTVdPShlPDw4fGU+Pj4yNCkmMTY3MTE5MzV8KGU8PDI0fGU+Pj44KSY0Mjc4MjU1MzYwO25bKGMrNjQ+Pj45PDw0KSsxNF09KGE8PDh8YT4+PjI0KSYxNjcxMTkzNXwoYTw8MjR8YT4+PjgpJjQyNzgyNTUzNjA7Yi5zaWdCeXRlcz00KihuLmxlbmd0aCsxKTt0aGlzLl9wcm9jZXNzKCk7Yj10aGlzLl9oYXNoO249Yi53b3Jkcztmb3IoYT0wOzQ+YTthKyspYz1uW2FdLG5bYV09KGM8PDh8Yz4+PjI0KSYxNjcxMTkzNXwoYzw8MjR8Yz4+PjgpJjQyNzgyNTUzNjA7cmV0dXJuIGJ9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGI9di5jbG9uZS5jYWxsKHRoaXMpO2IuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBifX0pO3QuTUQ1PXYuX2NyZWF0ZUhlbHBlcihyKTt0LkhtYWNNRDU9di5fY3JlYXRlSG1hY0hlbHBlcihyKX0pKE1hdGgpO1xuXHQoZnVuY3Rpb24oKXt2YXIgdT1DcnlwdG9KUyxwPXUubGliLGQ9cC5CYXNlLGw9cC5Xb3JkQXJyYXkscD11LmFsZ28scz1wLkV2cEtERj1kLmV4dGVuZCh7Y2ZnOmQuZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOnAuTUQ1LGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24oZCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGQpfSxjb21wdXRlOmZ1bmN0aW9uKGQscil7Zm9yKHZhciBwPXRoaXMuY2ZnLHM9cC5oYXNoZXIuY3JlYXRlKCksYj1sLmNyZWF0ZSgpLHU9Yi53b3JkcyxxPXAua2V5U2l6ZSxwPXAuaXRlcmF0aW9uczt1Lmxlbmd0aDxxOyl7biYmcy51cGRhdGUobik7dmFyIG49cy51cGRhdGUoZCkuZmluYWxpemUocik7cy5yZXNldCgpO2Zvcih2YXIgYT0xO2E8cDthKyspbj1zLmZpbmFsaXplKG4pLHMucmVzZXQoKTtiLmNvbmNhdChuKX1iLnNpZ0J5dGVzPTQqcTtyZXR1cm4gYn19KTt1LkV2cEtERj1mdW5jdGlvbihkLGwscCl7cmV0dXJuIHMuY3JlYXRlKHApLmNvbXB1dGUoZCxcblx0ICBsKX19KSgpO1xuXG5cdC8vIENpcGhlclxuXHRDcnlwdG9KUy5saWIuQ2lwaGVyfHxmdW5jdGlvbih1KXt2YXIgcD1DcnlwdG9KUyxkPXAubGliLGw9ZC5CYXNlLHM9ZC5Xb3JkQXJyYXksdD1kLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0scj1wLmVuYy5CYXNlNjQsdz1wLmFsZ28uRXZwS0RGLHY9ZC5DaXBoZXI9dC5leHRlbmQoe2NmZzpsLmV4dGVuZCgpLGNyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSxlLGEpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oZSxhKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsZSxhKX0saW5pdDpmdW5jdGlvbihlLGEsYil7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGIpO3RoaXMuX3hmb3JtTW9kZT1lO3RoaXMuX2tleT1hO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt0LnJlc2V0LmNhbGwodGhpcyk7dGhpcy5fZG9SZXNldCgpfSxwcm9jZXNzOmZ1bmN0aW9uKGUpe3RoaXMuX2FwcGVuZChlKTtyZXR1cm4gdGhpcy5fcHJvY2VzcygpfSxcblx0ICBmaW5hbGl6ZTpmdW5jdGlvbihlKXtlJiZ0aGlzLl9hcHBlbmQoZSk7cmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKX0sa2V5U2l6ZTo0LGl2U2l6ZTo0LF9FTkNfWEZPUk1fTU9ERToxLF9ERUNfWEZPUk1fTU9ERToyLF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oZSl7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24oYixrLGQpe3JldHVybihcInN0cmluZ1wiPT10eXBlb2Ygaz9jOmEpLmVuY3J5cHQoZSxiLGssZCl9LGRlY3J5cHQ6ZnVuY3Rpb24oYixrLGQpe3JldHVybihcInN0cmluZ1wiPT10eXBlb2Ygaz9jOmEpLmRlY3J5cHQoZSxiLGssZCl9fX19KTtkLlN0cmVhbUNpcGhlcj12LmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvY2VzcyghMCl9LGJsb2NrU2l6ZToxfSk7dmFyIGI9cC5tb2RlPXt9LHg9ZnVuY3Rpb24oZSxhLGIpe3ZhciBjPXRoaXMuX2l2O2M/dGhpcy5faXY9dTpjPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIGQ9MDtkPGI7ZCsrKWVbYStkXV49XG5cdCAgY1tkXX0scT0oZC5CbG9ja0NpcGhlck1vZGU9bC5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLGEpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoZSxhKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsYSl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShlLGEpfSxpbml0OmZ1bmN0aW9uKGUsYSl7dGhpcy5fY2lwaGVyPWU7dGhpcy5faXY9YX19KSkuZXh0ZW5kKCk7cS5FbmNyeXB0b3I9cS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLGEpe3ZhciBiPXRoaXMuX2NpcGhlcixjPWIuYmxvY2tTaXplO3guY2FsbCh0aGlzLGUsYSxjKTtiLmVuY3J5cHRCbG9jayhlLGEpO3RoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKGEsYStjKX19KTtxLkRlY3J5cHRvcj1xLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsYSl7dmFyIGI9dGhpcy5fY2lwaGVyLGM9Yi5ibG9ja1NpemUsZD1lLnNsaWNlKGEsYStjKTtiLmRlY3J5cHRCbG9jayhlLGEpO3guY2FsbCh0aGlzLFxuXHQgIGUsYSxjKTt0aGlzLl9wcmV2QmxvY2s9ZH19KTtiPWIuQ0JDPXE7cT0ocC5wYWQ9e30pLlBrY3M3PXtwYWQ6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9NCpiLGM9Yy1hLnNpZ0J5dGVzJWMsZD1jPDwyNHxjPDwxNnxjPDw4fGMsbD1bXSxuPTA7bjxjO24rPTQpbC5wdXNoKGQpO2M9cy5jcmVhdGUobCxjKTthLmNvbmNhdChjKX0sdW5wYWQ6ZnVuY3Rpb24oYSl7YS5zaWdCeXRlcy09YS53b3Jkc1thLnNpZ0J5dGVzLTE+Pj4yXSYyNTV9fTtkLkJsb2NrQ2lwaGVyPXYuZXh0ZW5kKHtjZmc6di5jZmcuZXh0ZW5kKHttb2RlOmIscGFkZGluZzpxfSkscmVzZXQ6ZnVuY3Rpb24oKXt2LnJlc2V0LmNhbGwodGhpcyk7dmFyIGE9dGhpcy5jZmcsYj1hLml2LGE9YS5tb2RlO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpdmFyIGM9YS5jcmVhdGVFbmNyeXB0b3I7ZWxzZSBjPWEuY3JlYXRlRGVjcnlwdG9yLHRoaXMuX21pbkJ1ZmZlclNpemU9MTt0aGlzLl9tb2RlPWMuY2FsbChhLFxuXHQgIHRoaXMsYiYmYi53b3Jkcyl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihhLGIpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKGEsYil9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jZmcucGFkZGluZztpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXthLnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKTt2YXIgYj10aGlzLl9wcm9jZXNzKCEwKX1lbHNlIGI9dGhpcy5fcHJvY2VzcyghMCksYS51bnBhZChiKTtyZXR1cm4gYn0sYmxvY2tTaXplOjR9KTt2YXIgbj1kLkNpcGhlclBhcmFtcz1sLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihhKXt0aGlzLm1peEluKGEpfSx0b1N0cmluZzpmdW5jdGlvbihhKXtyZXR1cm4oYXx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KSxiPShwLmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKGEpe3ZhciBiPWEuY2lwaGVydGV4dDthPWEuc2FsdDtyZXR1cm4oYT9zLmNyZWF0ZShbMTM5ODg5MzY4NCxcblx0ICAxNzAxMDc2ODMxXSkuY29uY2F0KGEpLmNvbmNhdChiKTpiKS50b1N0cmluZyhyKX0scGFyc2U6ZnVuY3Rpb24oYSl7YT1yLnBhcnNlKGEpO3ZhciBiPWEud29yZHM7aWYoMTM5ODg5MzY4ND09YlswXSYmMTcwMTA3NjgzMT09YlsxXSl7dmFyIGM9cy5jcmVhdGUoYi5zbGljZSgyLDQpKTtiLnNwbGljZSgwLDQpO2Euc2lnQnl0ZXMtPTE2fXJldHVybiBuLmNyZWF0ZSh7Y2lwaGVydGV4dDphLHNhbHQ6Y30pfX0sYT1kLlNlcmlhbGl6YWJsZUNpcGhlcj1sLmV4dGVuZCh7Y2ZnOmwuZXh0ZW5kKHtmb3JtYXQ6Yn0pLGVuY3J5cHQ6ZnVuY3Rpb24oYSxiLGMsZCl7ZD10aGlzLmNmZy5leHRlbmQoZCk7dmFyIGw9YS5jcmVhdGVFbmNyeXB0b3IoYyxkKTtiPWwuZmluYWxpemUoYik7bD1sLmNmZztyZXR1cm4gbi5jcmVhdGUoe2NpcGhlcnRleHQ6YixrZXk6YyxpdjpsLml2LGFsZ29yaXRobTphLG1vZGU6bC5tb2RlLHBhZGRpbmc6bC5wYWRkaW5nLGJsb2NrU2l6ZTphLmJsb2NrU2l6ZSxmb3JtYXR0ZXI6ZC5mb3JtYXR9KX0sXG5cdCAgZGVjcnlwdDpmdW5jdGlvbihhLGIsYyxkKXtkPXRoaXMuY2ZnLmV4dGVuZChkKTtiPXRoaXMuX3BhcnNlKGIsZC5mb3JtYXQpO3JldHVybiBhLmNyZWF0ZURlY3J5cHRvcihjLGQpLmZpbmFsaXplKGIuY2lwaGVydGV4dCl9LF9wYXJzZTpmdW5jdGlvbihhLGIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhP2IucGFyc2UoYSx0aGlzKTphfX0pLHA9KHAua2RmPXt9KS5PcGVuU1NMPXtleGVjdXRlOmZ1bmN0aW9uKGEsYixjLGQpe2R8fChkPXMucmFuZG9tKDgpKTthPXcuY3JlYXRlKHtrZXlTaXplOmIrY30pLmNvbXB1dGUoYSxkKTtjPXMuY3JlYXRlKGEud29yZHMuc2xpY2UoYiksNCpjKTthLnNpZ0J5dGVzPTQqYjtyZXR1cm4gbi5jcmVhdGUoe2tleTphLGl2OmMsc2FsdDpkfSl9fSxjPWQuUGFzc3dvcmRCYXNlZENpcGhlcj1hLmV4dGVuZCh7Y2ZnOmEuY2ZnLmV4dGVuZCh7a2RmOnB9KSxlbmNyeXB0OmZ1bmN0aW9uKGIsYyxkLGwpe2w9dGhpcy5jZmcuZXh0ZW5kKGwpO2Q9bC5rZGYuZXhlY3V0ZShkLFxuXHQgIGIua2V5U2l6ZSxiLml2U2l6ZSk7bC5pdj1kLml2O2I9YS5lbmNyeXB0LmNhbGwodGhpcyxiLGMsZC5rZXksbCk7Yi5taXhJbihkKTtyZXR1cm4gYn0sZGVjcnlwdDpmdW5jdGlvbihiLGMsZCxsKXtsPXRoaXMuY2ZnLmV4dGVuZChsKTtjPXRoaXMuX3BhcnNlKGMsbC5mb3JtYXQpO2Q9bC5rZGYuZXhlY3V0ZShkLGIua2V5U2l6ZSxiLml2U2l6ZSxjLnNhbHQpO2wuaXY9ZC5pdjtyZXR1cm4gYS5kZWNyeXB0LmNhbGwodGhpcyxiLGMsZC5rZXksbCl9fSl9KCk7XG5cblx0Ly8gQUVTXG5cdChmdW5jdGlvbigpe2Zvcih2YXIgdT1DcnlwdG9KUyxwPXUubGliLkJsb2NrQ2lwaGVyLGQ9dS5hbGdvLGw9W10scz1bXSx0PVtdLHI9W10sdz1bXSx2PVtdLGI9W10seD1bXSxxPVtdLG49W10sYT1bXSxjPTA7MjU2PmM7YysrKWFbY109MTI4PmM/Yzw8MTpjPDwxXjI4Mztmb3IodmFyIGU9MCxqPTAsYz0wOzI1Nj5jO2MrKyl7dmFyIGs9al5qPDwxXmo8PDJeajw8M15qPDw0LGs9az4+PjheayYyNTVeOTk7bFtlXT1rO3Nba109ZTt2YXIgej1hW2VdLEY9YVt6XSxHPWFbRl0seT0yNTcqYVtrXV4xNjg0MzAwOCprO3RbZV09eTw8MjR8eT4+Pjg7cltlXT15PDwxNnx5Pj4+MTY7d1tlXT15PDw4fHk+Pj4yNDt2W2VdPXk7eT0xNjg0MzAwOSpHXjY1NTM3KkZeMjU3KnpeMTY4NDMwMDgqZTtiW2tdPXk8PDI0fHk+Pj44O3hba109eTw8MTZ8eT4+PjE2O3Fba109eTw8OHx5Pj4+MjQ7bltrXT15O2U/KGU9el5hW2FbYVtHXnpdXV0sal49YVthW2pdXSk6ZT1qPTF9dmFyIEg9WzAsMSwyLDQsOCxcblx0ICAxNiwzMiw2NCwxMjgsMjcsNTRdLGQ9ZC5BRVM9cC5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuX2tleSxjPWEud29yZHMsZD1hLnNpZ0J5dGVzLzQsYT00KigodGhpcy5fblJvdW5kcz1kKzYpKzEpLGU9dGhpcy5fa2V5U2NoZWR1bGU9W10saj0wO2o8YTtqKyspaWYoajxkKWVbal09Y1tqXTtlbHNle3ZhciBrPWVbai0xXTtqJWQ/NjxkJiY0PT1qJWQmJihrPWxbaz4+PjI0XTw8MjR8bFtrPj4+MTYmMjU1XTw8MTZ8bFtrPj4+OCYyNTVdPDw4fGxbayYyNTVdKTooaz1rPDw4fGs+Pj4yNCxrPWxbaz4+PjI0XTw8MjR8bFtrPj4+MTYmMjU1XTw8MTZ8bFtrPj4+OCYyNTVdPDw4fGxbayYyNTVdLGtePUhbai9kfDBdPDwyNCk7ZVtqXT1lW2otZF1ea31jPXRoaXMuX2ludktleVNjaGVkdWxlPVtdO2ZvcihkPTA7ZDxhO2QrKylqPWEtZCxrPWQlND9lW2pdOmVbai00XSxjW2RdPTQ+ZHx8ND49aj9rOmJbbFtrPj4+MjRdXV54W2xbaz4+PjE2JjI1NV1dXnFbbFtrPj4+XG5cdDgmMjU1XV1ebltsW2smMjU1XV19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihhLGIpe3RoaXMuX2RvQ3J5cHRCbG9jayhhLGIsdGhpcy5fa2V5U2NoZWR1bGUsdCxyLHcsdixsKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9YVtjKzFdO2FbYysxXT1hW2MrM107YVtjKzNdPWQ7dGhpcy5fZG9DcnlwdEJsb2NrKGEsYyx0aGlzLl9pbnZLZXlTY2hlZHVsZSxiLHgscSxuLHMpO2Q9YVtjKzFdO2FbYysxXT1hW2MrM107YVtjKzNdPWR9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oYSxiLGMsZCxlLGosbCxmKXtmb3IodmFyIG09dGhpcy5fblJvdW5kcyxnPWFbYl1eY1swXSxoPWFbYisxXV5jWzFdLGs9YVtiKzJdXmNbMl0sbj1hW2IrM11eY1szXSxwPTQscj0xO3I8bTtyKyspdmFyIHE9ZFtnPj4+MjRdXmVbaD4+PjE2JjI1NV1ealtrPj4+OCYyNTVdXmxbbiYyNTVdXmNbcCsrXSxzPWRbaD4+PjI0XV5lW2s+Pj4xNiYyNTVdXmpbbj4+PjgmMjU1XV5sW2cmMjU1XV5jW3ArK10sdD1cblx0ICBkW2s+Pj4yNF1eZVtuPj4+MTYmMjU1XV5qW2c+Pj44JjI1NV1ebFtoJjI1NV1eY1twKytdLG49ZFtuPj4+MjRdXmVbZz4+PjE2JjI1NV1ealtoPj4+OCYyNTVdXmxbayYyNTVdXmNbcCsrXSxnPXEsaD1zLGs9dDtxPShmW2c+Pj4yNF08PDI0fGZbaD4+PjE2JjI1NV08PDE2fGZbaz4+PjgmMjU1XTw8OHxmW24mMjU1XSleY1twKytdO3M9KGZbaD4+PjI0XTw8MjR8ZltrPj4+MTYmMjU1XTw8MTZ8ZltuPj4+OCYyNTVdPDw4fGZbZyYyNTVdKV5jW3ArK107dD0oZltrPj4+MjRdPDwyNHxmW24+Pj4xNiYyNTVdPDwxNnxmW2c+Pj44JjI1NV08PDh8ZltoJjI1NV0pXmNbcCsrXTtuPShmW24+Pj4yNF08PDI0fGZbZz4+PjE2JjI1NV08PDE2fGZbaD4+PjgmMjU1XTw8OHxmW2smMjU1XSleY1twKytdO2FbYl09cTthW2IrMV09czthW2IrMl09dDthW2IrM109bn0sa2V5U2l6ZTo4fSk7dS5BRVM9cC5fY3JlYXRlSGVscGVyKGQpfSkoKTtcblxuXHQvLyBNb2RlIEVDQlxuXHRDcnlwdG9KUy5tb2RlLkVDQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIEVDQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICBFQ0IuRW5jcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBFQ0IuRGVjcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICByZXR1cm4gRUNCO1xuXHR9KCkpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ3J5cHRvSlM7XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBXRUJTT0NLRVQgSU5URVJGQUNFXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHR2YXIgV1MgPSBmdW5jdGlvbiggdXJsLCBwcm90b2NvbHMgKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdTKSkgcmV0dXJuIG5ldyBXUyggdXJsLCBwcm90b2NvbHMgKTtcblxuXHQgIHZhciBzZWxmICAgICA9IHRoaXNcblx0ICAgICwgICB1cmwgICAgICA9IHNlbGYudXJsICAgICAgPSB1cmwgfHwgJydcblx0ICAgICwgICBwcm90b2NvbCA9IHNlbGYucHJvdG9jb2wgPSBwcm90b2NvbHMgfHwgJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXG5cdCAgICAsICAgYml0cyAgICAgPSB1cmwuc3BsaXQoJy8nKVxuXHQgICAgLCAgIHNldHVwICAgID0ge1xuXHQgICAgJ3NzbCcgICAgICAgICAgIDogYml0c1swXSA9PT0gJ3dzczonXG5cdCAgICAsJ29yaWdpbicgICAgICAgIDogYml0c1syXVxuXHQgICAgLCdwdWJsaXNoX2tleScgICA6IGJpdHNbM11cblx0ICAgICwnc3Vic2NyaWJlX2tleScgOiBiaXRzWzRdXG5cdCAgICAsJ2NoYW5uZWwnICAgICAgIDogYml0c1s1XVxuXHQgIH07XG5cblx0ICAvLyBSRUFEWSBTVEFURVNcblx0ICBzZWxmWydDT05ORUNUSU5HJ10gPSAwOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBub3QgeWV0IG9wZW4uXG5cdCAgc2VsZlsnT1BFTiddICAgICAgID0gMTsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBhbmQgcmVhZHkgdG8gY29tbXVuaWNhdGUuXG5cdCAgc2VsZlsnQ0xPU0lORyddICAgID0gMjsgLy8gVGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cblx0ICBzZWxmWydDTE9TRUQnXSAgICAgPSAzOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgb3IgY291bGRuJ3QgYmUgb3BlbmVkLlxuXG5cdCAgLy8gQ0xPU0UgU1RBVEVTXG5cdCAgc2VsZlsnQ0xPU0VfTk9STUFMJ10gICAgICAgICA9IDEwMDA7IC8vIE5vcm1hbCBJbnRlbmRlZCBDbG9zZTsgY29tcGxldGVkLlxuXHQgIHNlbGZbJ0NMT1NFX0dPSU5HX0FXQVknXSAgICAgPSAxMDAxOyAvLyBDbG9zZWQgVW5leHBlY3R0ZWRseS5cblx0ICBzZWxmWydDTE9TRV9QUk9UT0NPTF9FUlJPUiddID0gMTAwMjsgLy8gU2VydmVyOiBOb3QgU3VwcG9ydGVkLlxuXHQgIHNlbGZbJ0NMT1NFX1VOU1VQUE9SVEVEJ10gICAgPSAxMDAzOyAvLyBTZXJ2ZXI6IFVuc3VwcG9ydGVkIFByb3RvY29sLlxuXHQgIHNlbGZbJ0NMT1NFX1RPT19MQVJHRSddICAgICAgPSAxMDA0OyAvLyBTZXJ2ZXI6IFRvbyBNdWNoIERhdGEuXG5cdCAgc2VsZlsnQ0xPU0VfTk9fU1RBVFVTJ10gICAgICA9IDEwMDU7IC8vIFNlcnZlcjogTm8gcmVhc29uLlxuXHQgIHNlbGZbJ0NMT1NFX0FCTk9STUFMJ10gICAgICAgPSAxMDA2OyAvLyBBYm5vcm1hbCBEaXNjb25uZWN0LlxuXG5cdCAgLy8gRXZlbnRzIERlZmF1bHRcblx0ICBzZWxmWydvbmNsb3NlJ10gICA9IHNlbGZbJ29uZXJyb3InXSA9XG5cdCAgICBzZWxmWydvbm1lc3NhZ2UnXSA9IHNlbGZbJ29ub3BlbiddICA9XG5cdCAgICAgIHNlbGZbJ29uc2VuZCddICAgID0gIGZ1bmN0aW9uKCl7fTtcblxuXHQgIC8vIEF0dHJpYnV0ZXNcblx0ICBzZWxmWydiaW5hcnlUeXBlJ10gICAgID0gJyc7XG5cdCAgc2VsZlsnZXh0ZW5zaW9ucyddICAgICA9ICcnO1xuXHQgIHNlbGZbJ2J1ZmZlcmVkQW1vdW50J10gPSAwO1xuXHQgIHNlbGZbJ3RyYXNubWl0dGluZyddICAgPSBmYWxzZTtcblx0ICBzZWxmWydidWZmZXInXSAgICAgICAgID0gW107XG5cdCAgc2VsZlsncmVhZHlTdGF0ZSddICAgICA9IHNlbGZbJ0NPTk5FQ1RJTkcnXTtcblxuXHQgIC8vIENsb3NlIGlmIG5vIHNldHVwLlxuXHQgIGlmICghdXJsKSB7XG5cdCAgICBzZWxmWydyZWFkeVN0YXRlJ10gPSBzZWxmWydDTE9TRUQnXTtcblx0ICAgIHNlbGZbJ29uY2xvc2UnXSh7XG5cdCAgICAgICdjb2RlJyAgICAgOiBzZWxmWydDTE9TRV9BQk5PUk1BTCddLFxuXHQgICAgICAncmVhc29uJyAgIDogJ01pc3NpbmcgVVJMJyxcblx0ICAgICAgJ3dhc0NsZWFuJyA6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHNlbGY7XG5cdCAgfVxuXG5cdCAgLy8gUHViTnViIFdlYlNvY2tldCBFbXVsYXRpb25cblx0ICBzZWxmLnB1Ym51YiAgICAgICA9IFBVQk5VQlsnaW5pdCddKHNldHVwKTtcblx0ICBzZWxmLnB1Ym51Yi5zZXR1cCA9IHNldHVwO1xuXHQgIHNlbGYuc2V0dXAgICAgICAgID0gc2V0dXA7XG5cblx0ICBzZWxmLnB1Ym51Ylsnc3Vic2NyaWJlJ10oe1xuXHQgICAgJ3Jlc3RvcmUnICAgIDogZmFsc2UsXG5cdCAgICAnY2hhbm5lbCcgICAgOiBzZXR1cFsnY2hhbm5lbCddLFxuXHQgICAgJ2Rpc2Nvbm5lY3QnIDogc2VsZlsnb25lcnJvciddLFxuXHQgICAgJ3JlY29ubmVjdCcgIDogc2VsZlsnb25vcGVuJ10sXG5cdCAgICAnZXJyb3InICAgICAgOiBmdW5jdGlvbigpIHtcblx0ICAgICAgc2VsZlsnb25jbG9zZSddKHtcblx0ICAgICAgICAnY29kZScgICAgIDogc2VsZlsnQ0xPU0VfQUJOT1JNQUwnXSxcblx0ICAgICAgICAncmVhc29uJyAgIDogJ01pc3NpbmcgVVJMJyxcblx0ICAgICAgICAnd2FzQ2xlYW4nIDogZmFsc2Vcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgJ2NhbGxiYWNrJyAgIDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgICAgICBzZWxmWydvbm1lc3NhZ2UnXSh7ICdkYXRhJyA6IG1lc3NhZ2UgfSk7XG5cdCAgICB9LFxuXHQgICAgJ2Nvbm5lY3QnICAgIDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ09QRU4nXTtcblx0ICAgICAgc2VsZlsnb25vcGVuJ10oKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIFNFTkRcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFdTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnB1Ym51YlsncHVibGlzaCddKHtcblx0ICAgICdjaGFubmVsJyAgOiBzZWxmLnB1Ym51Yi5zZXR1cFsnY2hhbm5lbCddLFxuXHQgICAgJ21lc3NhZ2UnICA6IGRhdGEsXG5cdCAgICAnY2FsbGJhY2snIDogZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0ICAgICAgc2VsZlsnb25zZW5kJ10oeyAnZGF0YScgOiByZXNwb25zZSB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gV0VCU09DS0VUIENMT1NFXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRXUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgc2VsZi5wdWJudWJbJ3Vuc3Vic2NyaWJlJ10oeyAnY2hhbm5lbCcgOiBzZWxmLnB1Ym51Yi5zZXR1cFsnY2hhbm5lbCddIH0pO1xuXHQgIHNlbGZbJ3JlYWR5U3RhdGUnXSA9IHNlbGZbJ0NMT1NFRCddO1xuXHQgIHNlbGZbJ29uY2xvc2UnXSh7fSk7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcHVibnViL21vZGVybi9kaXN0L3B1Ym51Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlJpbmdDZW50cmFsXCJdID0gcm9vdFtcIlJpbmdDZW50cmFsXCJdIHx8IHt9LCByb290W1wiUmluZ0NlbnRyYWxcIl1bXCJDbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBhY2NvdW50Q2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBjYWxsTG9nQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG52YXIgZGljdGlvbmFyeUNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xudmFyIGV4dGVuc2lvbkNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xudmFyIG1lc3NhZ2VzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG52YXIgbm90aWZpY2F0aW9uc0NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xudmFyIHByZXNlbmNlQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG52YXIgcmluZ291dENsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xudmFyIGZvcndhcmRpbmdOdW1iZXJzQ2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XG52YXIgYmxvY2tlZE51bWJlcnNDbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcbnZhciBDbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaWVudChzZGspIHtcbiAgICAgICAgdGhpcy5fc2RrID0gc2RrO1xuICAgICAgICB0aGlzLl9hY2NvdW50ID0gbmV3IGFjY291bnRDbGllbnQuQWNjb3VudChzZGspO1xuICAgICAgICB0aGlzLl9jYWxsTG9nID0gbmV3IGNhbGxMb2dDbGllbnQuQ2FsbExvZyhzZGspO1xuICAgICAgICB0aGlzLl9kaWN0aW9uYXJ5ID0gbmV3IGRpY3Rpb25hcnlDbGllbnQuRGljdGlvbmFyeShzZGspO1xuICAgICAgICB0aGlzLl9leHRlbnNpb24gPSBuZXcgZXh0ZW5zaW9uQ2xpZW50LkV4dGVuc2lvbihzZGspO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IG5ldyBtZXNzYWdlc0NsaWVudC5NZXNzYWdlcyhzZGspO1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25zID0gbmV3IG5vdGlmaWNhdGlvbnNDbGllbnQuTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSShzZGspO1xuICAgICAgICB0aGlzLl9wcmVzZW5jZSA9IG5ldyBwcmVzZW5jZUNsaWVudC5QcmVzZW5jZShzZGspO1xuICAgICAgICB0aGlzLl9yaW5nb3V0ID0gbmV3IHJpbmdvdXRDbGllbnQuUmluZ091dChzZGspO1xuICAgICAgICB0aGlzLl9mb3J3YXJkaW5nTnVtYmVycyA9IG5ldyBmb3J3YXJkaW5nTnVtYmVyc0NsaWVudC5Gb3J3YXJkaW5nTnVtYmVycyhzZGspO1xuICAgICAgICB0aGlzLl9ibG9ja2VkTnVtYmVycyA9IG5ldyBibG9ja2VkTnVtYmVyc0NsaWVudC5CbG9ja2VkTnVtYmVycyhzZGspO1xuICAgIH1cbiAgICBDbGllbnQucHJvdG90eXBlLmFjY291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hY2NvdW50OyB9O1xuICAgIENsaWVudC5wcm90b3R5cGUuY2FsbExvZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NhbGxMb2c7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGljdGlvbmFyeTsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmV4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2V4dGVuc2lvbjsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLm1lc3NhZ2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZXM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5ub3RpZmljYXRpb25zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbm90aWZpY2F0aW9uczsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLnByZXNlbmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJlc2VuY2U7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5yaW5nb3V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmluZ291dDsgfTtcbiAgICBDbGllbnQucHJvdG90eXBlLmZvcndhcmRpbmdOdW1iZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZm9yd2FyZGluZ051bWJlcnM7IH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5ibG9ja2VkTnVtYmVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jsb2NrZWROdW1iZXJzOyB9O1xuICAgIENsaWVudC52ZXJzaW9uID0gJzAuMS4wJztcbiAgICByZXR1cm4gQ2xpZW50O1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50O1xuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBhY2NvdW50aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgYWNjb3VudGJ1c2luZXNzYWRkcmVzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xudmFyIGRpYWxpbmdwbGFuaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIGFjY291bnRwaG9uZW51bWJlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBhY2NvdW50c2VydmljZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbnZhciBBY2NvdW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEFjY291bnRcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgdGhlIGFjY291bnQgaW4gSW5pdGlhbCBzdGF0ZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+TWFuYWdpbmcgYWNjb3VudHM6IGNyZWF0aW5nIG5ldyBhY2NvdW50cywgdmlld2luZyBhbmQgdXBkYXRpbmcgYWNjb3VudCBpbmZvcm1hdGlvbiwgZGVsZXRpbmcgZXhpc3RpbmcgYWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlciwgYXNzaWduZWQgcGhvbmUgbnVtYmVycywgZGV2aWNlcyBhbmQgb3RoZXIgZXh0ZW5zaW9uIHNldHRpbmdzKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmNyZWF0ZUFjY291bnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudCcsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlQWNjb3VudE9wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGEgcGFydGljdWxhciBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEFjY291bnRPcHRpb25zKSwgYWNjb3VudGluZm8uQWNjb3VudEluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQnVzaW5lc3MgQWRkcmVzc1xuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9idXNpbmVzcy1hZGRyZXNzJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMpLCBhY2NvdW50aW5mby5BY2NvdW50SW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQWNjb3VudCBCdXNpbmVzcyBBZGRyZXNzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0QWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYnVzaW5lc3MtYWRkcmVzcycsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMpLCBhY2NvdW50YnVzaW5lc3NhZGRyZXNzLkFjY291bnRCdXNpbmVzc0FkZHJlc3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgRGlhbGluZyBQbGFuXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyBsaXN0IG9mIGNvdW50cmllcyB3aGljaCBjYW4gYmUgc2VsZWN0ZWQgZm9yIGEgZGlhbGluZyBwbGFuICh0byBjYWxsIHNob3J0IG51bWJlcnMgYW5kIHNwZWNpYWwgc2VydmljZXMpLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxpc3REaWFsaW5nUGxhbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2RpYWxpbmctcGxhbicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdERpYWxpbmdQbGFuc09wdGlvbnMpLCBkaWFsaW5ncGxhbmluZm8uRGlhbGluZ1BsYW5JbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3Zpc2lvbiBQaG9uZSBOdW1iZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTEgKFJlbGVhc2UgNi4zKTwvcD5cbiAgICAgKiA8cD5Qcm92aXNpb25zIGEgcGhvbmUgbnVtYmVyLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLnByb3Zpc2lvblBob25lTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vcGhvbmUtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5wcm92aXNpb25QaG9uZU51bWJlck9wdGlvbnMpLCBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBBY2NvdW50IFBob25lIE51bWJlcnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgcGhvbmUgbnVtYmVycyBhc3NpZ25lZCB0byB0aGUgUmluZ0NlbnRyYWwgY3VzdG9tZXIgYWNjb3VudC4gQm90aCBjb21wYW55LWxldmVsIGFuZCBleHRlbnNpb24tbGV2ZWwgbnVtYmVycyBhcmUgcmV0dXJuZWQuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUubGlzdEFjY291bnRQaG9uZU51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L3Bob25lLW51bWJlcicsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEFjY291bnRQaG9uZU51bWJlcnNPcHRpb25zKSwgYWNjb3VudHBob25lbnVtYmVycy5BY2NvdW50UGhvbmVOdW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBQaG9uZSBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5sb2FkQWNjb3VudFBob25lTnVtYmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9waG9uZS1udW1iZXIve3Bob25lTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudFBob25lTnVtYmVyT3B0aW9ucyksIHBob25lbnVtYmVyaW5mby5QaG9uZU51bWJlckluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgU2VydmljZSBJbmZvXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMDwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBzZXJ2aWNlIHBsYW4sIGF2YWlsYWJsZSBmZWF0dXJlcyBhbmQgbGltaXRhdGlvbnMgZm9yIGEgcGFydGljdWxhciBSaW5nQ2VudHJhbCBjdXN0b21lciBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLmxvYWRTZXJ2aWNlSW5mbyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vc2VydmljZS1pbmZvJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkU2VydmljZUluZm9PcHRpb25zKSwgYWNjb3VudHNlcnZpY2VpbmZvLkFjY291bnRTZXJ2aWNlSW5mbyk7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudDtcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVBY2NvdW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZUFjY291bnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcImNyZWF0ZWFjY291bnRyZXF1ZXN0LkNyZWF0ZUFjY291bnRSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50T3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50QnVzaW5lc3NBZGRyZXNzT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUFjY291bnRCdXNpbmVzc0FkZHJlc3Mgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlQWNjb3VudEJ1c2luZXNzQWRkcmVzc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kaWZ5YWNjb3VudGJ1c2luZXNzYWRkcmVzc3JlcXVlc3QuTW9kaWZ5QWNjb3VudEJ1c2luZXNzQWRkcmVzc1JlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdERpYWxpbmdQbGFucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RGlhbGluZ1BsYW5zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHByb3Zpc2lvblBob25lTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnByb3Zpc2lvblBob25lTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInByb3Zpc2lvbnBob25lbnVtYmVycy5Qcm92aXNpb25QaG9uZU51bWJlcnNcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEFjY291bnRQaG9uZU51bWJlcnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEFjY291bnRQaG9uZU51bWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ1c2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTWFpbkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueU51bWJlclwiLFxuICAgICAgICAgICAgXCJEaXJlY3ROdW1iZXJcIixcbiAgICAgICAgICAgIFwiQ29tcGFueUZheE51bWJlclwiLFxuICAgICAgICAgICAgXCJGb3J3YXJkZWROdW1iZXJcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRQaG9uZU51bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudFBob25lTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU2VydmljZUluZm8gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFNlcnZpY2VJbmZvT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGUpIHtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiTWFpbkNvbXBhbnlOdW1iZXJcIl0gPSAnTWFpbkNvbXBhbnlOdW1iZXInXSA9IFwiTWFpbkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueU51bWJlclwiXSA9ICdDb21wYW55TnVtYmVyJ10gPSBcIkNvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRGlyZWN0TnVtYmVyXCJdID0gJ0RpcmVjdE51bWJlciddID0gXCJEaXJlY3ROdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBJTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiRm9yd2FyZGVkTnVtYmVyXCJdID0gJ0ZvcndhcmRlZE51bWJlciddID0gXCJGb3J3YXJkZWROdW1iZXJcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0QWNjb3VudFBob25lTnVtYmVyc1VzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50UGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdEFjY291bnRQaG9uZU51bWJlcnNVc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnQoc2RrKSB7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICB9XG4gICAgQ2xpZW50LnByb3RvdHlwZS5wYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIG9wdGlvbnMsIG9wZXJhdGlvblBhcmFtZXRlcnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBvcGVyYXRpb25QYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0ucmVxdWlyZWQgJiYgIXBhcmFtLmRlZmF1bHQgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIHBhcmFtZXRlciBcIicgKyBwYXJhbS5uYW1lICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmRlZmF1bHQgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW3BhcmFtLm5hbWVdID0gcGFyYW0uZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5pbiA9PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsLnJlcGxhY2UoJ3snICsgcGFyYW0ubmFtZSArICd9Jywgb3B0aW9uc1twYXJhbS5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ3F1ZXJ5JyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5xdWVyeVtwYXJhbS5uYW1lXSA9IG9wdGlvbnNbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0uaW4gPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gb3B0aW9uc1twYXJhbS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG4gICAgQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGFwaU9wdGlvbnMsIENsYXNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZGsucGxhdGZvcm0oKVxuICAgICAgICAgICAgLnNlbmQoYXBpT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIC8vVE9ETyBTdXBwb3J0IG11bHRpcGFydFxuICAgICAgICAgICAgLy9UT0RPIFRoaW5rIGhvdyB0byBwYXNzIGhlYWRlcnMmc3R1ZmYgdG8gb3V0c2lkZVxuICAgICAgICAgICAgaWYgKENsYXNzICYmICFyZXMuX2lzTXVsdGlwYXJ0KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzcyhfdGhpcy5fc2RrLCByZXMuanNvbigpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBzZXJ2aWNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGFjY291bnRzdGF0dXNpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgQWNjb3VudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21haW5OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ29wZXJhdG9yJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFydG5lcklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlSW5mbycsIENsYXNzOiBzZXJ2aWNlaW5mby5TZXJ2aWNlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2V0dXBXaXphcmRTdGF0ZScsIENsYXNzOiBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXR1cycsIENsYXNzOiBBY2NvdW50SW5mb1N0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzSW5mbycsIENsYXNzOiBhY2NvdW50c3RhdHVzaW5mby5BY2NvdW50U3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50SW5mbyA9IEFjY291bnRJbmZvO1xuKGZ1bmN0aW9uIChBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGUpIHtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiTm90U3RhcnRlZFwiXSA9ICdOb3RTdGFydGVkJ10gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiSW5jb21wbGV0ZVwiXSA9ICdJbmNvbXBsZXRlJ10gPSBcIkluY29tcGxldGVcIjtcbiAgICBBY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGVbQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlIHx8IChleHBvcnRzLkFjY291bnRJbmZvU2V0dXBXaXphcmRTdGF0ZSA9IHt9KSk7XG52YXIgQWNjb3VudEluZm9TZXR1cFdpemFyZFN0YXRlID0gZXhwb3J0cy5BY2NvdW50SW5mb1NldHVwV2l6YXJkU3RhdGU7XG4oZnVuY3Rpb24gKEFjY291bnRJbmZvU3RhdHVzKSB7XG4gICAgQWNjb3VudEluZm9TdGF0dXNbQWNjb3VudEluZm9TdGF0dXNbXCJDb25maXJtZWRcIl0gPSAnQ29uZmlybWVkJ10gPSBcIkNvbmZpcm1lZFwiO1xuICAgIEFjY291bnRJbmZvU3RhdHVzW0FjY291bnRJbmZvU3RhdHVzW1wiRGlzYWJsZWRcIl0gPSAnRGlzYWJsZWQnXSA9IFwiRGlzYWJsZWRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXMgfHwgKGV4cG9ydHMuQWNjb3VudEluZm9TdGF0dXMgPSB7fSkpO1xudmFyIEFjY291bnRJbmZvU3RhdHVzID0gZXhwb3J0cy5BY2NvdW50SW5mb1N0YXR1cztcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBNb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kZWwoc2RrLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NkayA9IHNkaztcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIHRoaXMuZ2V0UHJvcGVydHlNYXBwaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHZhciBDbGFzcyA9IG1hcHBpbmcuQ2xhc3MsIHByb3AgPSBtYXBwaW5nLnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBpbmcuaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZXF1aXJlZCBwcm9wZXJ0eSBcIicgKyBwcm9wICsgJ1wiIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb2Nlc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uIChkYXRhUGFydCkge1xuICAgICAgICAgICAgICAgIGlmICghQ2xhc3MgfHwgdHlwZW9mIENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2xhc3MoX3RoaXMuX3NkaywgZGF0YVBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobWFwcGluZy5pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBkYXRhW3Byb3BdLm1hcChwcm9jZXNzUHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0gPSBwcm9jZXNzUHJvcGVydHkoZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNb2RlbCc7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydpZCddO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb250YWN0aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgZGVwYXJ0bWVudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xudmFyIGV4dGVuc2lvbnBlcm1pc3Npb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgcHJvZmlsZWltYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIHJlZmVyZW5jZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciByZWdpb25hbHNldHRpbmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgZXh0ZW5zaW9uc2VydmljZWZlYXR1cmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgZXh0ZW5zaW9uc3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIEV4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb250YWN0JywgQ2xhc3M6IGNvbnRhY3RpbmZvLkNvbnRhY3RJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXBhcnRtZW50cycsIENsYXNzOiBkZXBhcnRtZW50aW5mby5EZXBhcnRtZW50SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYXJ0bmVySWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Blcm1pc3Npb25zJywgQ2xhc3M6IGV4dGVuc2lvbnBlcm1pc3Npb25zLkV4dGVuc2lvblBlcm1pc3Npb25zLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcm9maWxlSW1hZ2UnLCBDbGFzczogcHJvZmlsZWltYWdlaW5mby5Qcm9maWxlSW1hZ2VJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZmVyZW5jZXMnLCBDbGFzczogcmVmZXJlbmNlaW5mby5SZWZlcmVuY2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZ2lvbmFsU2V0dGluZ3MnLCBDbGFzczogcmVnaW9uYWxzZXR0aW5ncy5SZWdpb25hbFNldHRpbmdzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlRmVhdHVyZXMnLCBDbGFzczogZXh0ZW5zaW9uc2VydmljZWZlYXR1cmVpbmZvLkV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXR1cFdpemFyZFN0YXRlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogRXh0ZW5zaW9uSW5mb1N0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXNJbmZvJywgQ2xhc3M6IGV4dGVuc2lvbnN0YXR1c2luZm8uRXh0ZW5zaW9uU3RhdHVzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25JbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm8gPSBFeHRlbnNpb25JbmZvO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSkge1xuICAgIEV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW0V4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlW1wiTm90U3RhcnRlZFwiXSA9ICdOb3RTdGFydGVkJ10gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtFeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZVtcIkluY29tcGxldGVcIl0gPSAnSW5jb21wbGV0ZSddID0gXCJJbmNvbXBsZXRlXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGVbXCJDb21wbGV0ZWRcIl0gPSAnQ29tcGxldGVkJ10gPSBcIkNvbXBsZXRlZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvU2V0dXBXaXphcmRTdGF0ZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1NldHVwV2l6YXJkU3RhdGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9TZXR1cFdpemFyZFN0YXRlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvU3RhdHVzKSB7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiRW5hYmxlZFwiXSA9ICdFbmFibGVkJ10gPSBcIkVuYWJsZWRcIjtcbiAgICBFeHRlbnNpb25JbmZvU3RhdHVzW0V4dGVuc2lvbkluZm9TdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xuICAgIEV4dGVuc2lvbkluZm9TdGF0dXNbRXh0ZW5zaW9uSW5mb1N0YXR1c1tcIk5vdEFjdGl2YXRlZFwiXSA9ICdOb3RBY3RpdmF0ZWQnXSA9IFwiTm90QWN0aXZhdGVkXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1N0YXR1c1tFeHRlbnNpb25JbmZvU3RhdHVzW1wiVW5hc3NpZ25lZFwiXSA9ICdVbmFzc2lnbmVkJ10gPSBcIlVuYXNzaWduZWRcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uSW5mb1N0YXR1cyB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvU3RhdHVzID0gZXhwb3J0cy5FeHRlbnNpb25JbmZvU3RhdHVzO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvVHlwZSkge1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4VXNlciddID0gXCJGYXhVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiRGlnaXRhbFVzZXJcIl0gPSAnRGlnaXRhbFVzZXInXSA9IFwiRGlnaXRhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkRlcGFydG1lbnRcIl0gPSAnRGVwYXJ0bWVudCddID0gXCJEZXBhcnRtZW50XCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIlNoYXJlZExpbmVzR3JvdXBcIl0gPSAnU2hhcmVkTGluZXNHcm91cCddID0gXCJTaGFyZWRMaW5lc0dyb3VwXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYWdpbmdPbmx5R3JvdXBcIl0gPSAnUGFnaW5nT25seUdyb3VwJ10gPSBcIlBhZ2luZ09ubHlHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9UeXBlW0V4dGVuc2lvbkluZm9UeXBlW1wiSXZyTWVudVwiXSA9ICdJdnJNZW51J10gPSBcIkl2ck1lbnVcIjtcbiAgICBFeHRlbnNpb25JbmZvVHlwZVtFeHRlbnNpb25JbmZvVHlwZVtcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCJdID0gJ0FwcGxpY2F0aW9uRXh0ZW5zaW9uJ10gPSBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCI7XG4gICAgRXh0ZW5zaW9uSW5mb1R5cGVbRXh0ZW5zaW9uSW5mb1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25JbmZvVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uSW5mb1R5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvbnRhY3RhZGRyZXNzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgQ29udGFjdEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250YWN0SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWN0SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvbnRhY3RJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZpcnN0TmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE5hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbXBhbnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtYWlsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc1Bob25lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc0FkZHJlc3MnLCBDbGFzczogY29udGFjdGFkZHJlc3NpbmZvLkNvbnRhY3RBZGRyZXNzSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENvbnRhY3RJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ29udGFjdEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhY3RJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Db250YWN0SW5mbyA9IENvbnRhY3RJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbnRhY3RBZGRyZXNzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhY3RBZGRyZXNzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250YWN0QWRkcmVzc0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDb250YWN0QWRkcmVzc0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY291bnRyeScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0cmVldCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnemlwJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ29udGFjdEFkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ29udGFjdEFkZHJlc3NJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb250YWN0QWRkcmVzc0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvbnRhY3RBZGRyZXNzSW5mbyA9IENvbnRhY3RBZGRyZXNzSW5mbztcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEZXBhcnRtZW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlcGFydG1lbnRJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlcGFydG1lbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGVwYXJ0bWVudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGVwYXJ0bWVudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEZXBhcnRtZW50SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVwYXJ0bWVudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRlcGFydG1lbnRJbmZvID0gRGVwYXJ0bWVudEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBlcm1pc3Npb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgRXh0ZW5zaW9uUGVybWlzc2lvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25QZXJtaXNzaW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25QZXJtaXNzaW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblBlcm1pc3Npb25zLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FkbWluJywgQ2xhc3M6IHBlcm1pc3Npb25pbmZvLlBlcm1pc3Npb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpbnRlcm5hdGlvbmFsQ2FsbGluZycsIENsYXNzOiBwZXJtaXNzaW9uaW5mby5QZXJtaXNzaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvblBlcm1pc3Npb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uUGVybWlzc2lvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblBlcm1pc3Npb25zO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25QZXJtaXNzaW9ucyA9IEV4dGVuc2lvblBlcm1pc3Npb25zO1xuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQZXJtaXNzaW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlcm1pc3Npb25JbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBlcm1pc3Npb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGVybWlzc2lvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5hYmxlZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQZXJtaXNzaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Blcm1pc3Npb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQZXJtaXNzaW9uSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGVybWlzc2lvbkluZm8gPSBQZXJtaXNzaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUHJvZmlsZUltYWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb2ZpbGVJbWFnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvZmlsZUltYWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByb2ZpbGVJbWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V0YWcnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3NjYWxlcycsIENsYXNzOiBudWxsIC8qIHN0cmluZ1tdICovLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQcm9maWxlSW1hZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJvZmlsZUltYWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvZmlsZUltYWdlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUHJvZmlsZUltYWdlSW5mbyA9IFByb2ZpbGVJbWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlZmVyZW5jZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZlcmVuY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWZlcmVuY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlZicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBSZWZlcmVuY2VJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWZlcmVuY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWZlcmVuY2VJbmZvID0gUmVmZXJlbmNlSW5mbztcbihmdW5jdGlvbiAoUmVmZXJlbmNlSW5mb1R5cGUpIHtcbiAgICBSZWZlcmVuY2VJbmZvVHlwZVtSZWZlcmVuY2VJbmZvVHlwZVtcIlBhcnRuZXJJZFwiXSA9ICdQYXJ0bmVySWQnXSA9IFwiUGFydG5lcklkXCI7XG4gICAgUmVmZXJlbmNlSW5mb1R5cGVbUmVmZXJlbmNlSW5mb1R5cGVbXCJDdXN0b21lckRpcmVjdG9yeUlkXCJdID0gJ0N1c3RvbWVyRGlyZWN0b3J5SWQnXSA9IFwiQ3VzdG9tZXJEaXJlY3RvcnlJZFwiO1xufSkoZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZSB8fCAoZXhwb3J0cy5SZWZlcmVuY2VJbmZvVHlwZSA9IHt9KSk7XG52YXIgUmVmZXJlbmNlSW5mb1R5cGUgPSBleHBvcnRzLlJlZmVyZW5jZUluZm9UeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIHRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIGdyZWV0aW5nbGFuZ3VhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgZm9ybWF0dGluZ2xvY2FsZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBSZWdpb25hbFNldHRpbmdzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVnaW9uYWxTZXR0aW5ncywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWdpb25hbFNldHRpbmdzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdob21lQ291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGltZXpvbmUnLCBDbGFzczogdGltZXpvbmVpbmZvLlRpbWV6b25lSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFuZ3VhZ2UnLCBDbGFzczogbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZ3JlZXRpbmdMYW5ndWFnZScsIENsYXNzOiBncmVldGluZ2xhbmd1YWdlaW5mby5HcmVldGluZ0xhbmd1YWdlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZm9ybWF0dGluZ0xvY2FsZScsIENsYXNzOiBmb3JtYXR0aW5nbG9jYWxlaW5mby5Gb3JtYXR0aW5nTG9jYWxlSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlZ2lvbmFsU2V0dGluZ3MucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdSZWdpb25hbFNldHRpbmdzJztcbiAgICB9O1xuICAgIHJldHVybiBSZWdpb25hbFNldHRpbmdzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5SZWdpb25hbFNldHRpbmdzID0gUmVnaW9uYWxTZXR0aW5ncztcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBDb3VudHJ5SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQ291bnRyeUluZm8gPSBDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgVGltZXpvbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXpvbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWV6b25lSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkZXNjcmlwdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1RpbWV6b25lSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXpvbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5UaW1lem9uZUluZm8gPSBUaW1lem9uZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIExhbmd1YWdlSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhbmd1YWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYW5ndWFnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZ3JlZXRpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmb3JtYXR0aW5nTG9jYWxlJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndWknLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGFuZ3VhZ2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBMYW5ndWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxhbmd1YWdlSW5mbyA9IExhbmd1YWdlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgR3JlZXRpbmdMYW5ndWFnZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcmVldGluZ0xhbmd1YWdlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmVldGluZ0xhbmd1YWdlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdyZWV0aW5nTGFuZ3VhZ2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhbGVDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR3JlZXRpbmdMYW5ndWFnZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHcmVldGluZ0xhbmd1YWdlSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gR3JlZXRpbmdMYW5ndWFnZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdyZWV0aW5nTGFuZ3VhZ2VJbmZvID0gR3JlZXRpbmdMYW5ndWFnZUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEZvcm1hdHRpbmdMb2NhbGVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ybWF0dGluZ0xvY2FsZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybWF0dGluZ0xvY2FsZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nTG9jYWxlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYWxlQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEZvcm1hdHRpbmdMb2NhbGVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRm9ybWF0dGluZ0xvY2FsZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdHRpbmdMb2NhbGVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Gb3JtYXR0aW5nTG9jYWxlSW5mbyA9IEZvcm1hdHRpbmdMb2NhbGVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuYWJsZWQnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uU2VydmljZUZlYXR1cmVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25TZXJ2aWNlRmVhdHVyZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbyA9IEV4dGVuc2lvblNlcnZpY2VGZWF0dXJlSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uU3RhdHVzSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uU3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvblN0YXR1c0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29tbWVudCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVhc29uJywgQ2xhc3M6IEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uU3RhdHVzSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uU3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mbyA9IEV4dGVuc2lvblN0YXR1c0luZm87XG4oZnVuY3Rpb24gKEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24pIHtcbiAgICBFeHRlbnNpb25TdGF0dXNJbmZvUmVhc29uW0V4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bXCJWb2x1bnRhcmlseVwiXSA9ICdWb2x1bnRhcmlseSddID0gXCJWb2x1bnRhcmlseVwiO1xuICAgIEV4dGVuc2lvblN0YXR1c0luZm9SZWFzb25bRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbltcIkludm9sdW50YXJpbHlcIl0gPSAnSW52b2x1bnRhcmlseSddID0gXCJJbnZvbHVudGFyaWx5XCI7XG59KShleHBvcnRzLkV4dGVuc2lvblN0YXR1c0luZm9SZWFzb24gfHwgKGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbiA9IGV4cG9ydHMuRXh0ZW5zaW9uU3RhdHVzSW5mb1JlYXNvbjtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYmlsbGluZ3BsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG52YXIgYnJhbmRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgc2VydmljZXBsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG52YXIgdGFyZ2V0c2VydmljZXBsYW5pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG52YXIgU2VydmljZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYmlsbGluZ1BsYW4nLCBDbGFzczogYmlsbGluZ3BsYW5pbmZvLkJpbGxpbmdQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYnJhbmQnLCBDbGFzczogYnJhbmRpbmZvLkJyYW5kSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZVBsYW4nLCBDbGFzczogc2VydmljZXBsYW5pbmZvLlNlcnZpY2VQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGFyZ2V0U2VydmljZVBsYW4nLCBDbGFzczogdGFyZ2V0c2VydmljZXBsYW5pbmZvLlRhcmdldFNlcnZpY2VQbGFuSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VydmljZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TZXJ2aWNlSW5mbyA9IFNlcnZpY2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBCaWxsaW5nUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaWxsaW5nUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmlsbGluZ1BsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQmlsbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvblVuaXQnLCBDbGFzczogQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0LCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBCaWxsaW5nUGxhbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQmlsbGluZ1BsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmlsbGluZ1BsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCaWxsaW5nUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkJpbGxpbmdQbGFuSW5mbyA9IEJpbGxpbmdQbGFuSW5mbztcbihmdW5jdGlvbiAoQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0KSB7XG4gICAgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W0JpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtcIk1vbnRoXCJdID0gJ01vbnRoJ10gPSBcIk1vbnRoXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0W0JpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdFtcIkRheVwiXSA9ICdEYXknXSA9IFwiRGF5XCI7XG59KShleHBvcnRzLkJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCB8fCAoZXhwb3J0cy5CaWxsaW5nUGxhbkluZm9EdXJhdGlvblVuaXQgPSB7fSkpO1xudmFyIEJpbGxpbmdQbGFuSW5mb0R1cmF0aW9uVW5pdCA9IGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvRHVyYXRpb25Vbml0O1xuKGZ1bmN0aW9uIChCaWxsaW5nUGxhbkluZm9UeXBlKSB7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiSW5pdGlhbFwiXSA9ICdJbml0aWFsJ10gPSBcIkluaXRpYWxcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJSZWd1bGFyXCJdID0gJ1JlZ3VsYXInXSA9IFwiUmVndWxhclwiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQmlsbGluZ1BsYW5JbmZvVHlwZVtCaWxsaW5nUGxhbkluZm9UeXBlW1wiVHJpYWxcIl0gPSAnVHJpYWwnXSA9IFwiVHJpYWxcIjtcbiAgICBCaWxsaW5nUGxhbkluZm9UeXBlW0JpbGxpbmdQbGFuSW5mb1R5cGVbXCJUcmlhbE5vQ0NcIl0gPSAnVHJpYWxOb0NDJ10gPSBcIlRyaWFsTm9DQ1wiO1xuICAgIEJpbGxpbmdQbGFuSW5mb1R5cGVbQmlsbGluZ1BsYW5JbmZvVHlwZVtcIkZyZWVcIl0gPSAnRnJlZSddID0gXCJGcmVlXCI7XG59KShleHBvcnRzLkJpbGxpbmdQbGFuSW5mb1R5cGUgfHwgKGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZSA9IHt9KSk7XG52YXIgQmlsbGluZ1BsYW5JbmZvVHlwZSA9IGV4cG9ydHMuQmlsbGluZ1BsYW5JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBCcmFuZEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcmFuZEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnJhbmRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQnJhbmRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdob21lQ291bnRyeScsIENsYXNzOiBjb3VudHJ5aW5mby5Db3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJyYW5kSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0JyYW5kSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQnJhbmRJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CcmFuZEluZm8gPSBCcmFuZEluZm87XG5cblxuLyoqKi8gfSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlcnZpY2VQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcnZpY2VQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VkaXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlUGxhbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlUGxhbkluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VQbGFuSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZVBsYW5JbmZvID0gU2VydmljZVBsYW5JbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBUYXJnZXRTZXJ2aWNlUGxhbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYXJnZXRTZXJ2aWNlUGxhbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFyZ2V0U2VydmljZVBsYW5JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVGFyZ2V0U2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgVGFyZ2V0U2VydmljZVBsYW5JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnVGFyZ2V0U2VydmljZVBsYW5JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBUYXJnZXRTZXJ2aWNlUGxhbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlRhcmdldFNlcnZpY2VQbGFuSW5mbyA9IFRhcmdldFNlcnZpY2VQbGFuSW5mbztcblxuXG4vKioqLyB9LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQWNjb3VudFN0YXR1c0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50U3RhdHVzSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50U3RhdHVzSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbW1lbnQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYXNvbicsIENsYXNzOiBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRTdGF0dXNJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFN0YXR1c0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRTdGF0dXNJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50U3RhdHVzSW5mbyA9IEFjY291bnRTdGF0dXNJbmZvO1xuKGZ1bmN0aW9uIChBY2NvdW50U3RhdHVzSW5mb1JlYXNvbikge1xuICAgIEFjY291bnRTdGF0dXNJbmZvUmVhc29uW0FjY291bnRTdGF0dXNJbmZvUmVhc29uW1wiVm9sdW50YXJpbHlcIl0gPSAnVm9sdW50YXJpbHknXSA9IFwiVm9sdW50YXJpbHlcIjtcbiAgICBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltBY2NvdW50U3RhdHVzSW5mb1JlYXNvbltcIkludm9sdW50YXJpbHlcIl0gPSAnSW52b2x1bnRhcmlseSddID0gXCJJbnZvbHVudGFyaWx5XCI7XG59KShleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uIHx8IChleHBvcnRzLkFjY291bnRTdGF0dXNJbmZvUmVhc29uID0ge30pKTtcbnZhciBBY2NvdW50U3RhdHVzSW5mb1JlYXNvbiA9IGV4cG9ydHMuQWNjb3VudFN0YXR1c0luZm9SZWFzb247XG5cblxuLyoqKi8gfSxcbi8qIDI4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGJ1c2luZXNzYWRkcmVzc2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBBY2NvdW50QnVzaW5lc3NBZGRyZXNzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudEJ1c2luZXNzQWRkcmVzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50QnVzaW5lc3NBZGRyZXNzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudEJ1c2luZXNzQWRkcmVzcy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbXBhbnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtYWlsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdidXNpbmVzc0FkZHJlc3MnLCBDbGFzczogYnVzaW5lc3NhZGRyZXNzaW5mby5CdXNpbmVzc0FkZHJlc3NJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50QnVzaW5lc3NBZGRyZXNzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudEJ1c2luZXNzQWRkcmVzcyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEJ1c2luZXNzQWRkcmVzcztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudEJ1c2luZXNzQWRkcmVzcyA9IEFjY291bnRCdXNpbmVzc0FkZHJlc3M7XG5cblxuLyoqKi8gfSxcbi8qIDI5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJ1c2luZXNzQWRkcmVzc0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXNpbmVzc0FkZHJlc3NJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1c2luZXNzQWRkcmVzc0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCdXNpbmVzc0FkZHJlc3NJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXRlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjaXR5JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdHJlZXQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ppcCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJ1c2luZXNzQWRkcmVzc0luZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCdXNpbmVzc0FkZHJlc3NJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBCdXNpbmVzc0FkZHJlc3NJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CdXNpbmVzc0FkZHJlc3NJbmZvID0gQnVzaW5lc3NBZGRyZXNzSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGlhbGluZ3BsYW5jb3VudHJ5aW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIERpYWxpbmdQbGFuSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpYWxpbmdQbGFuSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWFsaW5nUGxhbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFsaW5nUGxhbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBkaWFsaW5ncGxhbmNvdW50cnlpbmZvLkRpYWxpbmdQbGFuQ291bnRyeUluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpYWxpbmdQbGFuSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpYWxpbmdQbGFuSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbGluZ1BsYW5JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWFsaW5nUGxhbkluZm8gPSBEaWFsaW5nUGxhbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpYWxpbmdQbGFuQ291bnRyeUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWFsaW5nUGxhbkNvdW50cnlJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpYWxpbmdQbGFuQ291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFsaW5nUGxhbkNvdW50cnlJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NhbGxpbmdDb2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGlhbGluZ1BsYW5Db3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpYWxpbmdQbGFuQ291bnRyeUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpYWxpbmdQbGFuQ291bnRyeUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpYWxpbmdQbGFuQ291bnRyeUluZm8gPSBEaWFsaW5nUGxhbkNvdW50cnlJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQYWdpbmdJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFnaW5nSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYWdpbmdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGFnaW5nSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZXJQYWdlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdlU3RhcnQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2VFbmQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvdGFsUGFnZXMnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvdGFsRWxlbWVudHMnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQYWdpbmdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUGFnaW5nSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5nSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGFnaW5nSW5mbyA9IFBhZ2luZ0luZm87XG5cblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE5hdmlnYXRpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOYXZpZ2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmaXJzdFBhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25leHRQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwcmV2aW91c1BhZ2UnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RQYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTmF2aWdhdGlvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdOYXZpZ2F0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTmF2aWdhdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk5hdmlnYXRpb25JbmZvID0gTmF2aWdhdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgcGhvbmVudW1iZXJzZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xudmFyIFBob25lTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBob25lTnVtYmVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaG9uZU51bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQaG9uZU51bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvdW50cnknLCBDbGFzczogY291bnRyeWluZm8uQ291bnRyeUluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBwaG9uZW51bWJlcnNleHRlbnNpb25pbmZvLlBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nW10gKi8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9jYXRpb24nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BheW1lbnRUeXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhdHVzJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IFBob25lTnVtYmVySW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VzYWdlVHlwZScsIENsYXNzOiBQaG9uZU51bWJlckluZm9Vc2FnZVR5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBQaG9uZU51bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQaG9uZU51bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFBob25lTnVtYmVySW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvID0gUGhvbmVOdW1iZXJJbmZvO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9QYXltZW50VHlwZSkge1xuICAgIFBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1Bob25lTnVtYmVySW5mb1BheW1lbnRUeXBlW1wiRXh0ZXJuYWxcIl0gPSAnRXh0ZXJuYWwnXSA9IFwiRXh0ZXJuYWxcIjtcbiAgICBQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtQaG9uZU51bWJlckluZm9QYXltZW50VHlwZVtcIlRvbGxGcmVlXCJdID0gJ1RvbGxGcmVlJ10gPSBcIlRvbGxGcmVlXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGVbXCJMb2NhbFwiXSA9ICdMb2NhbCddID0gXCJMb2NhbFwiO1xufSkoZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9QYXltZW50VHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvUGF5bWVudFR5cGUgPSBleHBvcnRzLlBob25lTnVtYmVySW5mb1BheW1lbnRUeXBlO1xuKGZ1bmN0aW9uIChQaG9uZU51bWJlckluZm9UeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvVHlwZVtQaG9uZU51bWJlckluZm9UeXBlW1wiVm9pY2VGYXhcIl0gPSAnVm9pY2VGYXgnXSA9IFwiVm9pY2VGYXhcIjtcbiAgICBQaG9uZU51bWJlckluZm9UeXBlW1Bob25lTnVtYmVySW5mb1R5cGVbXCJGYXhPbmx5XCJdID0gJ0ZheE9ubHknXSA9IFwiRmF4T25seVwiO1xuICAgIFBob25lTnVtYmVySW5mb1R5cGVbUGhvbmVOdW1iZXJJbmZvVHlwZVtcIlZvaWNlT25seVwiXSA9ICdWb2ljZU9ubHknXSA9IFwiVm9pY2VPbmx5XCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1R5cGUgfHwgKGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZSA9IHt9KSk7XG52YXIgUGhvbmVOdW1iZXJJbmZvVHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVHlwZTtcbihmdW5jdGlvbiAoUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlKSB7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIk1haW5Db21wYW55TnVtYmVyXCJdID0gJ01haW5Db21wYW55TnVtYmVyJ10gPSBcIk1haW5Db21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCJdID0gJ0FkZGl0aW9uYWxDb21wYW55TnVtYmVyJ10gPSBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkRpcmVjdE51bWJlclwiXSA9ICdEaXJlY3ROdW1iZXInXSA9IFwiRGlyZWN0TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkNvbXBhbnlGYXhOdW1iZXJcIl0gPSAnQ29tcGFueUZheE51bWJlciddID0gXCJDb21wYW55RmF4TnVtYmVyXCI7XG4gICAgUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlW1Bob25lTnVtYmVySW5mb1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLlBob25lTnVtYmVySW5mb1VzYWdlVHlwZSB8fCAoZXhwb3J0cy5QaG9uZU51bWJlckluZm9Vc2FnZVR5cGUgPSB7fSkpO1xudmFyIFBob25lTnVtYmVySW5mb1VzYWdlVHlwZSA9IGV4cG9ydHMuUGhvbmVOdW1iZXJJbmZvVXNhZ2VUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhcnRuZXJJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFBob25lTnVtYmVyc0V4dGVuc2lvbkluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QaG9uZU51bWJlcnNFeHRlbnNpb25JbmZvID0gUGhvbmVOdW1iZXJzRXh0ZW5zaW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcGhvbmVudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgQWNjb3VudFBob25lTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRQaG9uZU51bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFBob25lTnVtYmVycygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFjY291bnRQaG9uZU51bWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50UGhvbmVOdW1iZXJzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudFBob25lTnVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudFBob25lTnVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFBob25lTnVtYmVycyA9IEFjY291bnRQaG9uZU51bWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNlcnZpY2VmZWF0dXJlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIGFjY291bnRsaW1pdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbnZhciBBY2NvdW50U2VydmljZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50U2VydmljZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudFNlcnZpY2VJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQWNjb3VudFNlcnZpY2VJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2VydmljZVBsYW5OYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXJ2aWNlRmVhdHVyZXMnLCBDbGFzczogc2VydmljZWZlYXR1cmVpbmZvLlNlcnZpY2VGZWF0dXJlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsaW1pdHMnLCBDbGFzczogYWNjb3VudGxpbWl0cy5BY2NvdW50TGltaXRzLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBBY2NvdW50U2VydmljZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50U2VydmljZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRTZXJ2aWNlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQWNjb3VudFNlcnZpY2VJbmZvID0gQWNjb3VudFNlcnZpY2VJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTZXJ2aWNlRmVhdHVyZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXJ2aWNlRmVhdHVyZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VydmljZUZlYXR1cmVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2VydmljZUZlYXR1cmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZlYXR1cmVOYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdlbmFibGVkJywgQ2xhc3M6IFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlRmVhdHVyZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2VGZWF0dXJlSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuU2VydmljZUZlYXR1cmVJbmZvID0gU2VydmljZUZlYXR1cmVJbmZvO1xuKGZ1bmN0aW9uIChTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkKSB7XG4gICAgU2VydmljZUZlYXR1cmVJbmZvRW5hYmxlZFtTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1wiVHJ1ZVwiXSA9ICdUcnVlJ10gPSBcIlRydWVcIjtcbiAgICBTZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkW1NlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWRbXCJGYWxzZVwiXSA9ICdGYWxzZSddID0gXCJGYWxzZVwiO1xufSkoZXhwb3J0cy5TZXJ2aWNlRmVhdHVyZUluZm9FbmFibGVkIHx8IChleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgPSB7fSkpO1xudmFyIFNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQgPSBleHBvcnRzLlNlcnZpY2VGZWF0dXJlSW5mb0VuYWJsZWQ7XG5cblxuLyoqKi8gfSxcbi8qIDM5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEFjY291bnRMaW1pdHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY2NvdW50TGltaXRzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRMaW1pdHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50TGltaXRzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2ZyZWVTb2Z0UGhvbmVMaW5lc1BlckV4dGVuc2lvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVldGluZ1NpemUnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21heE1vbml0b3JlZEV4dGVuc2lvbnNQZXJVc2VyJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudExpbWl0cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRMaW1pdHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRMaW1pdHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRMaW1pdHMgPSBBY2NvdW50TGltaXRzO1xuXG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgYWNjb3VudGFjdGl2ZWNhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgYWNjb3VudGNhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBhY2NvdW50Y2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIGV4dGVuc2lvbmFjdGl2ZWNhbGxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgZXh0ZW5zaW9uY2FsbGxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xudmFyIGV4dGVuc2lvbmNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBjYWxsbG9nc3luYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xudmFyIGNhbGxyZWNvcmRpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcbnZhciBDYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEFjY291bnQgQWN0aXZlIENhbGxzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHJlY29yZHMgb2YgYWxsIGNhbGxzIHRoYXQgYXJlIGluIHByb2dyZXNzLCBvcmRlcmVkIGJ5IHN0YXJ0IHRpbWUgaW4gZGVzY2VuZGluZyBvcmRlci48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubGlzdEFjY291bnRBY3RpdmVDYWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vYWN0aXZlLWNhbGxzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QWNjb3VudEFjdGl2ZUNhbGxzT3B0aW9ucyksIGFjY291bnRhY3RpdmVjYWxscy5BY2NvdW50QWN0aXZlQ2FsbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZHMgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQWNjb3VudENhbGxMb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2NhbGwtbG9nJywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dPcHRpb25zKSwgYWNjb3VudGNhbGxsb2cuQWNjb3VudENhbGxMb2cpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0Q2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmRlbGV0ZUFjY291bnRDYWxsTG9nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9jYWxsLWxvZycsIG9wdGlvbnMsIGV4cG9ydHMuZGVsZXRlQWNjb3VudENhbGxMb2dPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWNjb3VudCBDYWxsIExvZyBSZWNvcmQocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4zIChSZWxlYXNlIDUuMTEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgaW5kaXZpZHVhbCBjYWxsIGxvZyByZWNvcmQocykgYnkgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vY2FsbC1sb2cve2NhbGxSZWNvcmRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZE9wdGlvbnMpLCBhY2NvdW50Y2FsbGxvZ3JlY29yZC5BY2NvdW50Q2FsbExvZ1JlY29yZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQWN0aXZlIENhbGxzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHJlY29yZHMgb2YgYWxsIGV4dGVuc2lvbiBjYWxscyB0aGF0IGFyZSBpbiBwcm9ncmVzcywgb3JkZXJlZCBieSBzdGFydCB0aW1lIGluIGRlc2NlbmRpbmcgb3JkZXIuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxscyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYWN0aXZlLWNhbGxzJywgb3B0aW9ucywgZXhwb3J0cy5saXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNPcHRpb25zKSwgZXh0ZW5zaW9uYWN0aXZlY2FsbHMuRXh0ZW5zaW9uQWN0aXZlQ2FsbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgTG9nIFJlY29yZHMgYnkgRmlsdGVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMyAoUmVsZWFzZSA1LjExKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGNhbGwgbG9nIHJlY29yZHMgZmlsdGVyZWQgYnkgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyksIGV4dGVuc2lvbmNhbGxsb2cuRXh0ZW5zaW9uQ2FsbExvZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgQ2FsbCBMb2cgUmVjb3JkcyBieSBGaWx0ZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsTG9nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGNhbGwgbG9nczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUuZGVsZXRlRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2cnLCBvcHRpb25zLCBleHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIENhbGwgTG9nIFJlY29yZChzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjMgKFJlbGVhc2UgNS4xMSk8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIGxvZyByZWNvcmQocykgYnkgdGhlaXIgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQ2FsbExvZzwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBjYWxsIGxvZ3M8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkhlYXZ5PC9wPlxuICAgICAqL1xuICAgIENhbGxMb2cucHJvdG90eXBlLmxvYWRFeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9jYWxsLWxvZy97Y2FsbFJlY29yZElkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRPcHRpb25zKSwgZXh0ZW5zaW9uY2FsbGxvZ3JlY29yZC5FeHRlbnNpb25DYWxsTG9nUmVjb3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGwgTG9nIFN5bmNocm9uaXphdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5zeW5jRXh0ZW5zaW9uQ2FsbExvZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vY2FsbC1sb2ctc3luYycsIG9wdGlvbnMsIGV4cG9ydHMuc3luY0V4dGVuc2lvbkNhbGxMb2dPcHRpb25zKSwgY2FsbGxvZ3N5bmMuQ2FsbExvZ1N5bmMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgUmVjb3JkaW5nXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTg8L3A+XG4gICAgICogPHA+UmV0dXJucyBjYWxsIHJlY29yZGluZyBtZXRhZGF0YS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsUmVjb3JkaW5nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+RG93bmxvYWRpbmcgY2FsbCByZWNvcmRpbmcgY29udGVudDwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZENhbGxMb2c8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgY2FsbCBsb2dzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IZWF2eTwvcD5cbiAgICAgKi9cbiAgICBDYWxsTG9nLnByb3RvdHlwZS5sb2FkQ2FsbFJlY29yZGluZ01ldGFkYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9yZWNvcmRpbmcve3JlY29yZGluZ0lkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YU9wdGlvbnMpLCBjYWxscmVjb3JkaW5nLkNhbGxSZWNvcmRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IENhbGwgUmVjb3JkaW5nIERhdGFcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRDYWxsUmVjb3JkaW5nPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+RG93bmxvYWRpbmcgY2FsbCByZWNvcmRpbmcgY29udGVudDwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgQ2FsbExvZy5wcm90b3R5cGUubG9hZENhbGxSZWNvcmRpbmdDb250ZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9yZWNvcmRpbmcve3JlY29yZGluZ0lkfS9jb250ZW50Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnRPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZztcbn0oY2xpZW50LkNsaWVudCkpO1xuZXhwb3J0cy5DYWxsTG9nID0gQ2FsbExvZztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0QWNjb3VudEFjdGl2ZUNhbGxzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RBY2NvdW50QWN0aXZlQ2FsbHNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEFjY291bnRDYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRBY2NvdW50Q2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbk51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJWb2ljZVwiLFxuICAgICAgICAgICAgXCJGYXhcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ2aWV3XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMb2FkQWNjb3VudENhbGxMb2dWaWV3XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiU2ltcGxlXCIsXG4gICAgICAgICAgICBcIkRldGFpbGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFJlY29yZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVBY2NvdW50Q2FsbExvZyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5kZWxldGVBY2NvdW50Q2FsbExvZ09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRBY2NvdW50Q2FsbExvZ1JlY29yZCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQWNjb3VudENhbGxMb2dSZWNvcmRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYWxsUmVjb3JkSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvblwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkluYm91bmRcIixcbiAgICAgICAgICAgIFwiT3V0Ym91bmRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbk51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGhvbmVOdW1iZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVm9pY2VcIixcbiAgICAgICAgICAgIFwiRmF4XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidmlld1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiU2ltcGxlXCIsXG4gICAgICAgICAgICBcIkRldGFpbGVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFJlY29yZGluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBkZWxldGVFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmRlbGV0ZUV4dGVuc2lvbkNhbGxMb2dPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZVRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FsbFJlY29yZElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHN5bmNFeHRlbnNpb25DYWxsTG9nIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnN5bmNFeHRlbnNpb25DYWxsTG9nT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRlN5bmNcIixcbiAgICAgICAgICAgIFwiSVN5bmNcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVG9rZW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRDb3VudFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzR3JvdXBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJNaXNzZWRcIixcbiAgICAgICAgICAgIFwiQWxsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDYWxsUmVjb3JkaW5nTWV0YWRhdGEgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENhbGxSZWNvcmRpbmdNZXRhZGF0YU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZGluZ0lkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRDYWxsUmVjb3JkaW5nQ29udGVudCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkQ2FsbFJlY29yZGluZ0NvbnRlbnRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWNvcmRpbmdJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbihmdW5jdGlvbiAoSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltJTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNEaXJlY3Rpb24gPSBleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGUpIHtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBJTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGVbSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlIHx8IChleHBvcnRzLklMaXN0QWNjb3VudEFjdGl2ZUNhbGxzVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RBY2NvdW50QWN0aXZlQ2FsbHNUeXBlID0gZXhwb3J0cy5JTGlzdEFjY291bnRBY3RpdmVDYWxsc1R5cGU7XG4oZnVuY3Rpb24gKElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24pIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nRGlyZWN0aW9uW0lMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb25bSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUpIHtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtJTG9hZEFjY291bnRDYWxsTG9nVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZSB8fCAoZXhwb3J0cy5JTG9hZEFjY291bnRDYWxsTG9nVHlwZSA9IHt9KSk7XG52YXIgSUxvYWRBY2NvdW50Q2FsbExvZ1R5cGUgPSBleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEFjY291bnRDYWxsTG9nVmlldykge1xuICAgIElMb2FkQWNjb3VudENhbGxMb2dWaWV3W0lMb2FkQWNjb3VudENhbGxMb2dWaWV3W1wiU2ltcGxlXCJdID0gJ1NpbXBsZSddID0gXCJTaW1wbGVcIjtcbiAgICBJTG9hZEFjY291bnRDYWxsTG9nVmlld1tJTG9hZEFjY291bnRDYWxsTG9nVmlld1tcIkRldGFpbGVkXCJdID0gJ0RldGFpbGVkJ10gPSBcIkRldGFpbGVkXCI7XG59KShleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3IHx8IChleHBvcnRzLklMb2FkQWNjb3VudENhbGxMb2dWaWV3ID0ge30pKTtcbnZhciBJTG9hZEFjY291bnRDYWxsTG9nVmlldyA9IGV4cG9ydHMuSUxvYWRBY2NvdW50Q2FsbExvZ1ZpZXc7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24pIHtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzRGlyZWN0aW9uW0lMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb25bSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNEaXJlY3Rpb24gfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbiA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc0RpcmVjdGlvbjtcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUpIHtcbiAgICBJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtJTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSB8fCAoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbkFjdGl2ZUNhbGxzVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RFeHRlbnNpb25BY3RpdmVDYWxsc1R5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uQWN0aXZlQ2FsbHNUeXBlO1xuKGZ1bmN0aW9uIChJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb24pIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb25bSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uIHx8IChleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ0RpcmVjdGlvbiA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nRGlyZWN0aW9uID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dEaXJlY3Rpb247XG4oZnVuY3Rpb24gKElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUpIHtcbiAgICBJTG9hZEV4dGVuc2lvbkNhbGxMb2dUeXBlW0lMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGVbSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLklMb2FkRXh0ZW5zaW9uQ2FsbExvZ1R5cGUgfHwgKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSA9IHt9KSk7XG52YXIgSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZSA9IGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVHlwZTtcbihmdW5jdGlvbiAoSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldykge1xuICAgIElMb2FkRXh0ZW5zaW9uQ2FsbExvZ1ZpZXdbSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tcIlNpbXBsZVwiXSA9ICdTaW1wbGUnXSA9IFwiU2ltcGxlXCI7XG4gICAgSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlld1tJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3W1wiRGV0YWlsZWRcIl0gPSAnRGV0YWlsZWQnXSA9IFwiRGV0YWlsZWRcIjtcbn0pKGV4cG9ydHMuSUxvYWRFeHRlbnNpb25DYWxsTG9nVmlldyB8fCAoZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3ID0ge30pKTtcbnZhciBJTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3ID0gZXhwb3J0cy5JTG9hZEV4dGVuc2lvbkNhbGxMb2dWaWV3O1xuKGZ1bmN0aW9uIChJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSkge1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZVtcIklTeW5jXCJdID0gJ0lTeW5jJ10gPSBcIklTeW5jXCI7XG59KShleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlIHx8IChleHBvcnRzLklTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N5bmNUeXBlID0ge30pKTtcbnZhciBJU3luY0V4dGVuc2lvbkNhbGxMb2dTeW5jVHlwZSA9IGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3luY1R5cGU7XG4oZnVuY3Rpb24gKElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwKSB7XG4gICAgSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXBbXCJNaXNzZWRcIl0gPSAnTWlzc2VkJ10gPSBcIk1pc3NlZFwiO1xuICAgIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW0lTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwW1wiQWxsXCJdID0gJ0FsbCddID0gXCJBbGxcIjtcbn0pKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgfHwgKGV4cG9ydHMuSVN5bmNFeHRlbnNpb25DYWxsTG9nU3RhdHVzR3JvdXAgPSB7fSkpO1xudmFyIElTeW5jRXh0ZW5zaW9uQ2FsbExvZ1N0YXR1c0dyb3VwID0gZXhwb3J0cy5JU3luY0V4dGVuc2lvbkNhbGxMb2dTdGF0dXNHcm91cDtcblxuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEFjY291bnRBY3RpdmVDYWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjY291bnRBY3RpdmVDYWxscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY2NvdW50QWN0aXZlQ2FsbHMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50QWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRBY3RpdmVDYWxscy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0FjY291bnRBY3RpdmVDYWxscyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudEFjdGl2ZUNhbGxzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50QWN0aXZlQ2FsbHMgPSBBY2NvdW50QWN0aXZlQ2FsbHM7XG5cblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIGNhbGxsb2dyZWNvcmRsZWdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG52YXIgQ2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBDYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBDYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogQ2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFzdE1vZGlmaWVkVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0JywgQ2xhc3M6IENhbGxMb2dSZWNvcmRUcmFuc3BvcnQsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xlZ3MnLCBDbGFzczogY2FsbGxvZ3JlY29yZGxlZ2luZm8uQ2FsbExvZ1JlY29yZExlZ0luZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dSZWNvcmQ7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dSZWNvcmQgPSBDYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkVHlwZSkge1xuICAgIENhbGxMb2dSZWNvcmRUeXBlW0NhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBDYWxsTG9nUmVjb3JkVHlwZVtDYWxsTG9nUmVjb3JkVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRUeXBlID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkVHlwZSA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmREaXJlY3Rpb24pIHtcbiAgICBDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQ2FsbExvZ1JlY29yZERpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZERpcmVjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZEFjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVDYWxsXCJdID0gJ1Bob25lIENhbGwnXSA9IFwiUGhvbmVDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiQWNjZXB0Q2FsbFwiXSA9ICdBY2NlcHQgQ2FsbCddID0gXCJBY2NlcHRDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIk91dGdvaW5nRmF4XCJdID0gJ091dGdvaW5nIEZheCddID0gXCJPdXRnb2luZ0ZheFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdEaXJlY3RseVwiXSA9ICdSaW5nIERpcmVjdGx5J10gPSBcIlJpbmdEaXJlY3RseVwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRQQ1wiXSA9ICdSaW5nT3V0IFBDJ10gPSBcIlJpbmdPdXRQQ1wiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bJzQxMUluZm8nXSA9ICc0MTEgSW5mbyddID0gJzQxMUluZm8nO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZEFjdGlvbltDYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBDYWxsTG9nUmVjb3JkQWN0aW9uW0NhbGxMb2dSZWNvcmRBY3Rpb25bXCJTdXBwb3J0XCJdID0gJ1N1cHBvcnQnXSA9IFwiU3VwcG9ydFwiO1xuICAgIENhbGxMb2dSZWNvcmRBY3Rpb25bQ2FsbExvZ1JlY29yZEFjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkQWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRBY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRBY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEluUHJvZ3Jlc3NcIl0gPSAnUmVzdWx0SW5Qcm9ncmVzcyddID0gXCJSZXN1bHRJblByb2dyZXNzXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsYWNjZXB0ZWRcIl0gPSAnQ2FsbCBhY2NlcHRlZCddID0gXCJDYWxsYWNjZXB0ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJWb2ljZW1haWxcIl0gPSAnVm9pY2VtYWlsJ10gPSBcIlZvaWNlbWFpbFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVwbHlcIl0gPSAnUmVwbHknXSA9IFwiUmVwbHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheG9uRGVtYW5kXCJdID0gJ0ZheCBvbiBEZW1hbmQnXSA9IFwiRmF4b25EZW1hbmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsUmVjZWl2ZVwiXSA9ICdQYXJ0aWFsIFJlY2VpdmUnXSA9IFwiUGFydGlhbFJlY2VpdmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxjb25uZWN0ZWRcIl0gPSAnQ2FsbCBjb25uZWN0ZWQnXSA9IFwiQ2FsbGNvbm5lY3RlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vQW5zd2VyXCJdID0gJ05vIEFuc3dlciddID0gXCJOb0Fuc3dlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VuZEVycm9yXCJdID0gJ1NlbmQgRXJyb3InXSA9IFwiU2VuZEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb2ZheG1hY2hpbmVcIl0gPSAnTm8gZmF4IG1hY2hpbmUnXSA9IFwiTm9mYXhtYWNoaW5lXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVzdWx0RW1wdHlcIl0gPSAnUmVzdWx0RW1wdHknXSA9IFwiUmVzdWx0RW1wdHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN1c3BlbmRlZFwiXSA9ICdTdXNwZW5kZWQnXSA9IFwiU3VzcGVuZGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWxlZFwiXSA9ICdDYWxsIEZhaWxlZCddID0gXCJDYWxsRmFpbGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9ICdJbnRlcm5hbCBFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSVBQaG9uZW9mZmxpbmVcIl0gPSAnSVAgUGhvbmUgb2ZmbGluZSddID0gXCJJUFBob25lb2ZmbGluZVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIldyb25nTnVtYmVyXCJdID0gJ1dyb25nIE51bWJlciddID0gXCJXcm9uZ051bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlN0b3BwZWRcIl0gPSAnU3RvcHBlZCddID0gXCJTdG9wcGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUG9vckxpbmVRdWFsaXR5XCJdID0gJ1Bvb3IgTGluZSBRdWFsaXR5J10gPSBcIlBvb3JMaW5lUXVhbGl0eVwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBhcnRpYWxseVNlbnRcIl0gPSAnUGFydGlhbGx5IFNlbnQnXSA9IFwiUGFydGlhbGx5U2VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIENhbGxMb2dSZWNvcmRSZXN1bHRbQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkFiYW5kb25lZFwiXSA9ICdBYmFuZG9uZWQnXSA9IFwiQWJhbmRvbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRGVjbGluZWRcIl0gPSAnRGVjbGluZWQnXSA9IFwiRGVjbGluZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkUmVzdWx0W0NhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZFJlc3VsdFtDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4U2VuZEVycm9yXCJdID0gJ0ZheCBTZW5kIEVycm9yJ10gPSBcIkZheFNlbmRFcnJvclwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRSZXN1bHQgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRSZXN1bHQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRUcmFuc3BvcnQpIHtcbiAgICBDYWxsTG9nUmVjb3JkVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRUcmFuc3BvcnRbXCJQU1ROXCJdID0gJ1BTVE4nXSA9IFwiUFNUTlwiO1xuICAgIENhbGxMb2dSZWNvcmRUcmFuc3BvcnRbQ2FsbExvZ1JlY29yZFRyYW5zcG9ydFtcIlZvSVBcIl0gPSAnVm9JUCddID0gXCJWb0lQXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRUcmFuc3BvcnQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZFRyYW5zcG9ydCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZFRyYW5zcG9ydDtcblxuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ2FsbExvZ0NhbGxlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nQ2FsbGVySW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nQ2FsbGVySW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb25OdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xvY2F0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbExvZ0NhbGxlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDYWxsTG9nQ2FsbGVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsbExvZ0NhbGxlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxMb2dDYWxsZXJJbmZvID0gQ2FsbExvZ0NhbGxlckluZm87XG5cblxuLyoqKi8gfSxcbi8qIDQ0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJlY29yZGluZ0luZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNvcmRpbmdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY29yZGluZ0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWNvcmRpbmdJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogUmVjb3JkaW5nSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NvbnRlbnRVcmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSZWNvcmRpbmdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmVjb3JkaW5nSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb3JkaW5nSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmVjb3JkaW5nSW5mbyA9IFJlY29yZGluZ0luZm87XG4oZnVuY3Rpb24gKFJlY29yZGluZ0luZm9UeXBlKSB7XG4gICAgUmVjb3JkaW5nSW5mb1R5cGVbUmVjb3JkaW5nSW5mb1R5cGVbXCJBdXRvbWF0aWNcIl0gPSAnQXV0b21hdGljJ10gPSBcIkF1dG9tYXRpY1wiO1xuICAgIFJlY29yZGluZ0luZm9UeXBlW1JlY29yZGluZ0luZm9UeXBlW1wiT25EZW1hbmRcIl0gPSAnT25EZW1hbmQnXSA9IFwiT25EZW1hbmRcIjtcbn0pKGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGUgfHwgKGV4cG9ydHMuUmVjb3JkaW5nSW5mb1R5cGUgPSB7fSkpO1xudmFyIFJlY29yZGluZ0luZm9UeXBlID0gZXhwb3J0cy5SZWNvcmRpbmdJbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mb2NhbGxsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcbnZhciBjYWxsbG9nY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xudmFyIHJlY29yZGluZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbGxMb2dSZWNvcmRMZWdJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGxMb2dSZWNvcmRMZWdJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYWN0aW9uJywgQ2xhc3M6IENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkaXJlY3Rpb24nLCBDbGFzczogQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogZXh0ZW5zaW9uaW5mb2NhbGxsb2cuRXh0ZW5zaW9uSW5mb0NhbGxMb2csIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xlZ1R5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N0YXJ0VGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndG8nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RyYW5zcG9ydCcsIENsYXNzOiBDYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1JlY29yZExlZ0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dSZWNvcmRMZWdJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mbyA9IENhbGxMb2dSZWNvcmRMZWdJbmZvO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiUGhvbmVMb2dpblwiXSA9ICdQaG9uZSBMb2dpbiddID0gXCJQaG9uZUxvZ2luXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJJbmNvbWluZ0ZheFwiXSA9ICdJbmNvbWluZyBGYXgnXSA9IFwiSW5jb21pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiRmluZE1lXCJdID0gJ0ZpbmRNZSddID0gXCJGaW5kTWVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkZvbGxvd01lXCJdID0gJ0ZvbGxvd01lJ10gPSBcIkZvbGxvd01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkNhbGxSZXR1cm5cIl0gPSAnQ2FsbCBSZXR1cm4nXSA9IFwiQ2FsbFJldHVyblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiQ2FsbGluZ0NhcmRcIl0gPSAnQ2FsbGluZyBDYXJkJ10gPSBcIkNhbGxpbmdDYXJkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRXZWJcIl0gPSAnUmluZ091dCBXZWInXSA9IFwiUmluZ091dFdlYlwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiVm9JUENhbGxcIl0gPSAnVm9JUCBDYWxsJ10gPSBcIlZvSVBDYWxsXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdNZVwiXSA9ICdSaW5nTWUnXSA9IFwiUmluZ01lXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bXCJUcmFuc2ZlclwiXSA9ICdUcmFuc2ZlciddID0gXCJUcmFuc2ZlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIkVtZXJnZW5jeVwiXSA9ICdFbWVyZ2VuY3knXSA9IFwiRW1lcmdlbmN5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb25bJ0U5MTFVcGRhdGUnXSA9ICdFOTExIFVwZGF0ZSddID0gJ0U5MTFVcGRhdGUnO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbltcIlJpbmdPdXRNb2JpbGVcIl0gPSAnUmluZ091dCBNb2JpbGUnXSA9IFwiUmluZ091dE1vYmlsZVwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiB8fCAoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb0FjdGlvbiA9IHt9KSk7XG52YXIgQ2FsbExvZ1JlY29yZExlZ0luZm9BY3Rpb24gPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvQWN0aW9uO1xuKGZ1bmN0aW9uIChDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbikge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW0NhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uIHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvRGlyZWN0aW9uID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb0RpcmVjdGlvbiA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9EaXJlY3Rpb247XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZSkge1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbXCJWb2ljZVwiXSA9ICdWb2ljZSddID0gXCJWb2ljZVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZVtDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UeXBlID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1R5cGUgPSBleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvVHlwZTtcbihmdW5jdGlvbiAoQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQpIHtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W0NhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0IHx8IChleHBvcnRzLkNhbGxMb2dSZWNvcmRMZWdJbmZvUmVzdWx0ID0ge30pKTtcbnZhciBDYWxsTG9nUmVjb3JkTGVnSW5mb1Jlc3VsdCA9IGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9SZXN1bHQ7XG4oZnVuY3Rpb24gKENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0KSB7XG4gICAgQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnRbXCJQU1ROXCJdID0gJ1BTVE4nXSA9IFwiUFNUTlwiO1xuICAgIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W0NhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0W1wiVm9JUFwiXSA9ICdWb0lQJ10gPSBcIlZvSVBcIjtcbn0pKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgfHwgKGV4cG9ydHMuQ2FsbExvZ1JlY29yZExlZ0luZm9UcmFuc3BvcnQgPSB7fSkpO1xudmFyIENhbGxMb2dSZWNvcmRMZWdJbmZvVHJhbnNwb3J0ID0gZXhwb3J0cy5DYWxsTG9nUmVjb3JkTGVnSW5mb1RyYW5zcG9ydDtcblxuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uSW5mb0NhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25JbmZvQ2FsbExvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25JbmZvQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25JbmZvQ2FsbExvZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm9DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25JbmZvQ2FsbExvZztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSW5mb0NhbGxMb2cgPSBFeHRlbnNpb25JbmZvQ2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ3JlY29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEFjY291bnRDYWxsTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudENhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudENhbGxMb2coKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50Q2FsbExvZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGNhbGxsb2dyZWNvcmQuQ2FsbExvZ1JlY29yZCwgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQWNjb3VudENhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBY2NvdW50Q2FsbExvZyc7XG4gICAgfTtcbiAgICByZXR1cm4gQWNjb3VudENhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkFjY291bnRDYWxsTG9nID0gQWNjb3VudENhbGxMb2c7XG5cblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2djYWxsZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG52YXIgcmVjb3JkaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudENhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWNjb3VudENhbGxMb2dSZWNvcmQoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzZXNzaW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Zyb20nLCBDbGFzczogY2FsbGxvZ2NhbGxlcmluZm8uQ2FsbExvZ0NhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3RvJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhY3Rpb24nLCBDbGFzczogQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Jlc3VsdCcsIENsYXNzOiBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQWNjb3VudENhbGxMb2dSZWNvcmQnO1xuICAgIH07XG4gICAgcmV0dXJuIEFjY291bnRDYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZCA9IEFjY291bnRDYWxsTG9nUmVjb3JkO1xuKGZ1bmN0aW9uIChBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW1wiVm9pY2VcIl0gPSAnVm9pY2UnXSA9IFwiVm9pY2VcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFR5cGVbQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlIHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgQWNjb3VudENhbGxMb2dSZWNvcmRUeXBlID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZFR5cGU7XG4oZnVuY3Rpb24gKEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJJbmJvdW5kXCJdID0gJ0luYm91bmQnXSA9IFwiSW5ib3VuZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkRGlyZWN0aW9uID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZERpcmVjdGlvbjtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJQaG9uZUNhbGxcIl0gPSAnUGhvbmUgQ2FsbCddID0gXCJQaG9uZUNhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiSW5jb21pbmdGYXhcIl0gPSAnSW5jb21pbmcgRmF4J10gPSBcIkluY29taW5nRmF4XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJBY2NlcHRDYWxsXCJdID0gJ0FjY2VwdCBDYWxsJ10gPSBcIkFjY2VwdENhbGxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJGb2xsb3dNZVwiXSA9ICdGb2xsb3dNZSddID0gXCJGb2xsb3dNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiT3V0Z29pbmdGYXhcIl0gPSAnT3V0Z29pbmcgRmF4J10gPSBcIk91dGdvaW5nRmF4XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIkNhbGxpbmdDYXJkXCJdID0gJ0NhbGxpbmcgQ2FyZCddID0gXCJDYWxsaW5nQ2FyZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ0RpcmVjdGx5XCJdID0gJ1JpbmcgRGlyZWN0bHknXSA9IFwiUmluZ0RpcmVjdGx5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlZvSVBDYWxsXCJdID0gJ1ZvSVAgQ2FsbCddID0gXCJWb0lQQ2FsbFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiUmluZ091dFBDXCJdID0gJ1JpbmdPdXQgUEMnXSA9IFwiUmluZ091dFBDXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW1wiVHJhbnNmZXJcIl0gPSAnVHJhbnNmZXInXSA9IFwiVHJhbnNmZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvblsnNDExSW5mbyddID0gJzQxMSBJbmZvJ10gPSAnNDExSW5mbyc7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uW0FjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uWydFOTExVXBkYXRlJ10gPSAnRTkxMSBVcGRhdGUnXSA9ICdFOTExVXBkYXRlJztcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltBY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbltcIlN1cHBvcnRcIl0gPSAnU3VwcG9ydCddID0gXCJTdXBwb3J0XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gfHwgKGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRBY3Rpb24gPSB7fSkpO1xudmFyIEFjY291bnRDYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5BY2NvdW50Q2FsbExvZ1JlY29yZEFjdGlvbjtcbihmdW5jdGlvbiAoQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQpIHtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlVua25vd25cIl0gPSAnVW5rbm93biddID0gXCJVbmtub3duXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiTWlzc2VkXCJdID0gJ01pc3NlZCddID0gXCJNaXNzZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxhY2NlcHRlZFwiXSA9ICdDYWxsIGFjY2VwdGVkJ10gPSBcIkNhbGxhY2NlcHRlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXBseVwiXSA9ICdSZXBseSddID0gXCJSZXBseVwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlY2VpdmVFcnJvclwiXSA9ICdSZWNlaXZlIEVycm9yJ10gPSBcIlJlY2VpdmVFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4b25EZW1hbmRcIl0gPSAnRmF4IG9uIERlbWFuZCddID0gXCJGYXhvbkRlbWFuZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJCbG9ja2VkXCJdID0gJ0Jsb2NrZWQnXSA9IFwiQmxvY2tlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGNvbm5lY3RlZFwiXSA9ICdDYWxsIGNvbm5lY3RlZCddID0gXCJDYWxsY29ubmVjdGVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsIERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU2VudFwiXSA9ICdTZW50J10gPSBcIlNlbnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIk5vZmF4bWFjaGluZVwiXSA9ICdObyBmYXggbWFjaGluZSddID0gXCJOb2ZheG1hY2hpbmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJBY2NvdW50XCJdID0gJ0FjY291bnQnXSA9IFwiQWNjb3VudFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbEZhaWx1cmVcIl0gPSAnQ2FsbCBGYWlsdXJlJ10gPSBcIkNhbGxGYWlsdXJlXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hbEVycm9yXCJdID0gJ0ludGVybmFsIEVycm9yJ10gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3RyaWN0ZWROdW1iZXJcIl0gPSAnUmVzdHJpY3RlZCBOdW1iZXInXSA9IFwiUmVzdHJpY3RlZE51bWJlclwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmcgTnVtYmVyJ10gPSBcIldyb25nTnVtYmVyXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiSGFuZ3VwXCJdID0gJ0hhbmcgdXAnXSA9IFwiSGFuZ3VwXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQb29yTGluZVF1YWxpdHlcIl0gPSAnUG9vciBMaW5lIFF1YWxpdHknXSA9IFwiUG9vckxpbmVRdWFsaXR5XCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiXSA9ICdJbnRlcm5hdGlvbmFsIFJlc3RyaWN0aW9uJ10gPSBcIkludGVybmF0aW9uYWxSZXN0cmljdGlvblwiO1xuICAgIEFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W0FjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWJhbmRvbmVkXCJdID0gJ0FiYW5kb25lZCddID0gXCJBYmFuZG9uZWRcIjtcbiAgICBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhSZWNlaXB0RXJyb3JcIl0gPSAnRmF4IFJlY2VpcHQgRXJyb3InXSA9IFwiRmF4UmVjZWlwdEVycm9yXCI7XG4gICAgQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhTZW5kRXJyb3JcIl0gPSAnRmF4IFNlbmQgRXJyb3InXSA9IFwiRmF4U2VuZEVycm9yXCI7XG59KShleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0IHx8IChleHBvcnRzLkFjY291bnRDYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBBY2NvdW50Q2FsbExvZ1JlY29yZFJlc3VsdCA9IGV4cG9ydHMuQWNjb3VudENhbGxMb2dSZWNvcmRSZXN1bHQ7XG5cblxuLyoqKi8gfSxcbi8qIDQ5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGNhbGxsb2dyZWNvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25BY3RpdmVDYWxscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkFjdGl2ZUNhbGxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkFjdGl2ZUNhbGxzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uQWN0aXZlQ2FsbHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkFjdGl2ZUNhbGxzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uQWN0aXZlQ2FsbHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkFjdGl2ZUNhbGxzO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25BY3RpdmVDYWxscyA9IEV4dGVuc2lvbkFjdGl2ZUNhbGxzO1xuXG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkNhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQ2FsbExvZygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNhbGxMb2cucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBjYWxsbG9ncmVjb3JkLkNhbGxMb2dSZWNvcmQsIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYXZpZ2F0aW9uJywgQ2xhc3M6IG5hdmlnYXRpb25pbmZvLk5hdmlnYXRpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkNhbGxMb2cucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25DYWxsTG9nO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nID0gRXh0ZW5zaW9uQ2FsbExvZztcblxuXG4vKioqLyB9LFxuLyogNTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgY2FsbGxvZ2NhbGxlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciByZWNvcmRpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc2Vzc2lvbklkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmcm9tJywgQ2xhc3M6IGNhbGxsb2djYWxsZXJpbmZvLkNhbGxMb2dDYWxsZXJJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBjYWxsbG9nY2FsbGVyaW5mby5DYWxsTG9nQ2FsbGVySW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGlyZWN0aW9uJywgQ2xhc3M6IEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FjdGlvbicsIENsYXNzOiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZXN1bHQnLCBDbGFzczogRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3RhcnRUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdkdXJhdGlvbicsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkaW5nJywgQ2xhc3M6IHJlY29yZGluZ2luZm8uUmVjb3JkaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25DYWxsTG9nUmVjb3JkJztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25DYWxsTG9nUmVjb3JkO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkID0gRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZDtcbihmdW5jdGlvbiAoRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUpIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtFeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZVtcIlZvaWNlXCJdID0gJ1ZvaWNlJ10gPSBcIlZvaWNlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGVbXCJGYXhcIl0gPSAnRmF4J10gPSBcIkZheFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkVHlwZSA9IHt9KSk7XG52YXIgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFR5cGUgPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmRUeXBlO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uKSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZERpcmVjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb25bXCJPdXRib3VuZFwiXSA9ICdPdXRib3VuZCddID0gXCJPdXRib3VuZFwiO1xufSkoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkRGlyZWN0aW9uIHx8IChleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSB7fSkpO1xudmFyIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb24gPSBleHBvcnRzLkV4dGVuc2lvbkNhbGxMb2dSZWNvcmREaXJlY3Rpb247XG4oZnVuY3Rpb24gKEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb24pIHtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJVbmtub3duXCJdID0gJ1Vua25vd24nXSA9IFwiVW5rbm93blwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lQ2FsbFwiXSA9ICdQaG9uZSBDYWxsJ10gPSBcIlBob25lQ2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlBob25lTG9naW5cIl0gPSAnUGhvbmUgTG9naW4nXSA9IFwiUGhvbmVMb2dpblwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkluY29taW5nRmF4XCJdID0gJ0luY29taW5nIEZheCddID0gXCJJbmNvbWluZ0ZheFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkFjY2VwdENhbGxcIl0gPSAnQWNjZXB0IENhbGwnXSA9IFwiQWNjZXB0Q2FsbFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIkZpbmRNZVwiXSA9ICdGaW5kTWUnXSA9IFwiRmluZE1lXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiRm9sbG93TWVcIl0gPSAnRm9sbG93TWUnXSA9IFwiRm9sbG93TWVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJPdXRnb2luZ0ZheFwiXSA9ICdPdXRnb2luZyBGYXgnXSA9IFwiT3V0Z29pbmdGYXhcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsUmV0dXJuXCJdID0gJ0NhbGwgUmV0dXJuJ10gPSBcIkNhbGxSZXR1cm5cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJDYWxsaW5nQ2FyZFwiXSA9ICdDYWxsaW5nIENhcmQnXSA9IFwiQ2FsbGluZ0NhcmRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nRGlyZWN0bHlcIl0gPSAnUmluZyBEaXJlY3RseSddID0gXCJSaW5nRGlyZWN0bHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0V2ViXCJdID0gJ1JpbmdPdXQgV2ViJ10gPSBcIlJpbmdPdXRXZWJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJWb0lQQ2FsbFwiXSA9ICdWb0lQIENhbGwnXSA9IFwiVm9JUENhbGxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0UENcIl0gPSAnUmluZ091dCBQQyddID0gXCJSaW5nT3V0UENcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nTWVcIl0gPSAnUmluZ01lJ10gPSBcIlJpbmdNZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltcIlRyYW5zZmVyXCJdID0gJ1RyYW5zZmVyJ10gPSBcIlRyYW5zZmVyXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uWyc0MTFJbmZvJ10gPSAnNDExIEluZm8nXSA9ICc0MTFJbmZvJztcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJFbWVyZ2VuY3lcIl0gPSAnRW1lcmdlbmN5J10gPSBcIkVtZXJnZW5jeVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvblsnRTkxMVVwZGF0ZSddID0gJ0U5MTEgVXBkYXRlJ10gPSAnRTkxMVVwZGF0ZSc7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbltFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW1wiU3VwcG9ydFwiXSA9ICdTdXBwb3J0J10gPSBcIlN1cHBvcnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uW0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRBY3Rpb25bXCJSaW5nT3V0TW9iaWxlXCJdID0gJ1JpbmdPdXQgTW9iaWxlJ10gPSBcIlJpbmdPdXRNb2JpbGVcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZEFjdGlvbiB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkQWN0aW9uO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0KSB7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiVW5rbm93blwiXSA9ICdVbmtub3duJ10gPSBcIlVua25vd25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN1bHRJblByb2dyZXNzXCJdID0gJ1Jlc3VsdEluUHJvZ3Jlc3MnXSA9IFwiUmVzdWx0SW5Qcm9ncmVzc1wiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIk1pc3NlZFwiXSA9ICdNaXNzZWQnXSA9IFwiTWlzc2VkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQ2FsbGFjY2VwdGVkXCJdID0gJ0NhbGwgYWNjZXB0ZWQnXSA9IFwiQ2FsbGFjY2VwdGVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiVm9pY2VtYWlsXCJdID0gJ1ZvaWNlbWFpbCddID0gXCJWb2ljZW1haWxcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlcGx5XCJdID0gJ1JlcGx5J10gPSBcIlJlcGx5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUmVjZWl2ZWRcIl0gPSAnUmVjZWl2ZWQnXSA9IFwiUmVjZWl2ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZWNlaXZlRXJyb3JcIl0gPSAnUmVjZWl2ZSBFcnJvciddID0gXCJSZWNlaXZlRXJyb3JcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJGYXhvbkRlbWFuZFwiXSA9ICdGYXggb24gRGVtYW5kJ10gPSBcIkZheG9uRGVtYW5kXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiUGFydGlhbFJlY2VpdmVcIl0gPSAnUGFydGlhbCBSZWNlaXZlJ10gPSBcIlBhcnRpYWxSZWNlaXZlXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQmxvY2tlZFwiXSA9ICdCbG9ja2VkJ10gPSBcIkJsb2NrZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJDYWxsY29ubmVjdGVkXCJdID0gJ0NhbGwgY29ubmVjdGVkJ10gPSBcIkNhbGxjb25uZWN0ZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJOb0Fuc3dlclwiXSA9ICdObyBBbnN3ZXInXSA9IFwiTm9BbnN3ZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbCBEaXNhYmxlZCddID0gXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJCdXN5XCJdID0gJ0J1c3knXSA9IFwiQnVzeVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbmRFcnJvclwiXSA9ICdTZW5kIEVycm9yJ10gPSBcIlNlbmRFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiTm9mYXhtYWNoaW5lXCJdID0gJ05vIGZheCBtYWNoaW5lJ10gPSBcIk5vZmF4bWFjaGluZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlJlc3VsdEVtcHR5XCJdID0gJ1Jlc3VsdEVtcHR5J10gPSBcIlJlc3VsdEVtcHR5XCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiQWNjb3VudFwiXSA9ICdBY2NvdW50J10gPSBcIkFjY291bnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdXNwZW5kZWRcIl0gPSAnU3VzcGVuZGVkJ10gPSBcIlN1c3BlbmRlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsZWRcIl0gPSAnQ2FsbCBGYWlsZWQnXSA9IFwiQ2FsbEZhaWxlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkNhbGxGYWlsdXJlXCJdID0gJ0NhbGwgRmFpbHVyZSddID0gXCJDYWxsRmFpbHVyZVwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWwgRXJyb3InXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIklQUGhvbmVvZmZsaW5lXCJdID0gJ0lQIFBob25lIG9mZmxpbmUnXSA9IFwiSVBQaG9uZW9mZmxpbmVcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJSZXN0cmljdGVkTnVtYmVyXCJdID0gJ1Jlc3RyaWN0ZWQgTnVtYmVyJ10gPSBcIlJlc3RyaWN0ZWROdW1iZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJXcm9uZ051bWJlclwiXSA9ICdXcm9uZyBOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJTdG9wcGVkXCJdID0gJ1N0b3BwZWQnXSA9IFwiU3RvcHBlZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkhhbmd1cFwiXSA9ICdIYW5nIHVwJ10gPSBcIkhhbmd1cFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIlBvb3JMaW5lUXVhbGl0eVwiXSA9ICdQb29yIExpbmUgUXVhbGl0eSddID0gXCJQb29yTGluZVF1YWxpdHlcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJQYXJ0aWFsbHlTZW50XCJdID0gJ1BhcnRpYWxseSBTZW50J10gPSBcIlBhcnRpYWxseVNlbnRcIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIl0gPSAnSW50ZXJuYXRpb25hbCBSZXN0cmljdGlvbiddID0gXCJJbnRlcm5hdGlvbmFsUmVzdHJpY3Rpb25cIjtcbiAgICBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W0V4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbXCJBYmFuZG9uZWRcIl0gPSAnQWJhbmRvbmVkJ10gPSBcIkFiYW5kb25lZFwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkRlY2xpbmVkXCJdID0gJ0RlY2xpbmVkJ10gPSBcIkRlY2xpbmVkXCI7XG4gICAgRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0W1wiRmF4UmVjZWlwdEVycm9yXCJdID0gJ0ZheCBSZWNlaXB0IEVycm9yJ10gPSBcIkZheFJlY2VpcHRFcnJvclwiO1xuICAgIEV4dGVuc2lvbkNhbGxMb2dSZWNvcmRSZXN1bHRbRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdFtcIkZheFNlbmRFcnJvclwiXSA9ICdGYXggU2VuZCBFcnJvciddID0gXCJGYXhTZW5kRXJyb3JcIjtcbn0pKGV4cG9ydHMuRXh0ZW5zaW9uQ2FsbExvZ1JlY29yZFJlc3VsdCB8fCAoZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0ID0ge30pKTtcbnZhciBFeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0ID0gZXhwb3J0cy5FeHRlbnNpb25DYWxsTG9nUmVjb3JkUmVzdWx0O1xuXG5cbi8qKiovIH0sXG4vKiA1MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBjYWxsbG9ncmVjb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG52YXIgc3luY2luZm9jYWxsbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG52YXIgQ2FsbExvZ1N5bmMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxsTG9nU3luYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsTG9nU3luYygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENhbGxMb2dTeW5jLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogY2FsbGxvZ3JlY29yZC5DYWxsTG9nUmVjb3JkLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY0luZm8nLCBDbGFzczogc3luY2luZm9jYWxsbG9nLlN5bmNJbmZvQ2FsbExvZywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbGxMb2dTeW5jLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQ2FsbExvZ1N5bmMnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxMb2dTeW5jO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5DYWxsTG9nU3luYyA9IENhbGxMb2dTeW5jO1xuXG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTeW5jSW5mb0NhbGxMb2cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTeW5jSW5mb0NhbGxMb2csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3luY0luZm9DYWxsTG9nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU3luY0luZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUeXBlJywgQ2xhc3M6IFN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVG9rZW4nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU3luY0luZm9DYWxsTG9nLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU3luY0luZm9DYWxsTG9nJztcbiAgICB9O1xuICAgIHJldHVybiBTeW5jSW5mb0NhbGxMb2c7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlN5bmNJbmZvQ2FsbExvZyA9IFN5bmNJbmZvQ2FsbExvZztcbihmdW5jdGlvbiAoU3luY0luZm9DYWxsTG9nU3luY1R5cGUpIHtcbiAgICBTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtTeW5jSW5mb0NhbGxMb2dTeW5jVHlwZVtcIkZTeW5jXCJdID0gJ0ZTeW5jJ10gPSBcIkZTeW5jXCI7XG4gICAgU3luY0luZm9DYWxsTG9nU3luY1R5cGVbU3luY0luZm9DYWxsTG9nU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSB8fCAoZXhwb3J0cy5TeW5jSW5mb0NhbGxMb2dTeW5jVHlwZSA9IHt9KSk7XG52YXIgU3luY0luZm9DYWxsTG9nU3luY1R5cGUgPSBleHBvcnRzLlN5bmNJbmZvQ2FsbExvZ1N5bmNUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiA1NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDYWxsUmVjb3JkaW5nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsbFJlY29yZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxsUmVjb3JkaW5nKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2FsbFJlY29yZGluZy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFVyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2R1cmF0aW9uJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2FsbFJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0NhbGxSZWNvcmRpbmcnO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGxSZWNvcmRpbmc7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNhbGxSZWNvcmRpbmcgPSBDYWxsUmVjb3JkaW5nO1xuXG5cbi8qKiovIH0sXG4vKiA1NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgY291bnRyeWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbnZhciBkaWN0aW9uYXJ5Y291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcbnZhciBsYW5ndWFnZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBsYW5ndWFnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBkaWN0aW9uYXJ5bG9jYXRpb25saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG52YXIgZGljdGlvbmFyeXNlY3JldHF1ZXN0aW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIHNlY3JldHF1ZXN0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIGRpY3Rpb25hcnlzaGlwcGluZ29wdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBkaWN0aW9uYXJ5c3RhdGVsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG52YXIgZGljdGlvbmFyeXN0YXRlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xudmFyIGRpY3Rpb25hcnl0aW1lem9uZWxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcbnZhciBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG52YXIgRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBDb3VudHJ5IExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBjb3VudHJpZXMgYXZhaWxhYmxlIGZvciBjYWxsaW5nLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0Q291bnRyaWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9jb3VudHJ5Jywgb3B0aW9ucywgZXhwb3J0cy5saXN0Q291bnRyaWVzT3B0aW9ucyksIGNvdW50cnlsaXN0LkNvdW50cnlMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBDb3VudHJ5XG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTAgKFJlbGVhc2UgNi4yKTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGUgcmVxdWlyZWQgY291bnRyeS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZENvdW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2NvdW50cnkve2NvdW50cnlJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRDb3VudHJ5T3B0aW9ucyksIGRpY3Rpb25hcnljb3VudHJ5aW5mby5EaWN0aW9uYXJ5Q291bnRyeUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExhbmd1YWdlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNCAoUmVsZWFzZSA2LjYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHN1cHBvcnRlZCBsYW5ndWFnZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RMYW5ndWFnZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xhbmd1YWdlJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TGFuZ3VhZ2VzT3B0aW9ucyksIGxhbmd1YWdlbGlzdC5MYW5ndWFnZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExhbmd1YWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTQgKFJlbGVhc2UgNi42KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxhbmd1YWdlIGJ5IGl0cyByZXNwZWN0aXZlIElELjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L2xhbmd1YWdlL3tsYW5ndWFnZUlkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZExhbmd1YWdlT3B0aW9ucyksIGxhbmd1YWdlaW5mby5MYW5ndWFnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IExvY2F0aW9uIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBhdmFpbGFibGUgbG9jYXRpb25zIGZvciB0aGUgY2VydGFpbiBzdGF0ZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvbG9jYXRpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RMb2NhdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeWxvY2F0aW9ubGlzdC5EaWN0aW9uYXJ5TG9jYXRpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTZWNyZXQgUXVlc3Rpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjIwIChSZWxlYXNlIDcuNCk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBzZWNyZXQgcXVlc3Rpb25zIGZvciBhIHNwZWNpZmljIGxhbmd1YWdlLjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5saXN0U2VjcmV0UXVlc3Rpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zZWNyZXQtcXVlc3Rpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RTZWNyZXRRdWVzdGlvbnNPcHRpb25zKSwgZGljdGlvbmFyeXNlY3JldHF1ZXN0aW9ubGlzdC5EaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBTZWNyZXQgUXVlc3Rpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yMCAoUmVsZWFzZSA3LjQpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYSBwYXJ0aWN1bGFyIHNlY3JldCBxdWVzdGlvbiBpbiBzcGVjaWZpYyBsYW5ndWFnZSBieSBxdWVzdGlvbiBJRC48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFNlY3JldFF1ZXN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zZWNyZXQtcXVlc3Rpb24vcXVlc3Rpb25JZCcsIG9wdGlvbnMsIGV4cG9ydHMubG9hZFNlY3JldFF1ZXN0aW9uT3B0aW9ucyksIHNlY3JldHF1ZXN0aW9uaW5mby5TZWNyZXRRdWVzdGlvbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFNoaXBwaW5nIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xNiAoUmVsZWFzZSA3LjEpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZGV2aWNlIHNoaXBwaW5nIG9wdGlvbnMgd2l0aCB0aGVpciBwcmljZXMsIGFjY29yZGluZyB0byBicmFuZCwgdGllciwgbnVtYmVyIG9mIG9yZGVyZWQgZGV2aWNlcy48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubGlzdFNoaXBwaW5nT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc2hpcHBpbmctb3B0aW9ucycsIG9wdGlvbnMsIGV4cG9ydHMubGlzdFNoaXBwaW5nT3B0aW9uc09wdGlvbnMpLCBkaWN0aW9uYXJ5c2hpcHBpbmdvcHRpb25zLkRpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN0YXRlIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIHRoZSBzdGF0ZXMgZm9yIGEgY2VydGFpbiBjb3VudHJ5LjwvcD5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5sb2FkbGlzdFN0YXRlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2RpY3Rpb25hcnkvc3RhdGUnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRsaXN0U3RhdGVzT3B0aW9ucyksIGRpY3Rpb25hcnlzdGF0ZWxpc3QuRGljdGlvbmFyeVN0YXRlTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIHRoZSByZXF1aXJlZCBzdGF0ZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFN0YXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS9zdGF0ZS97c3RhdGVJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRTdGF0ZU9wdGlvbnMpLCBkaWN0aW9uYXJ5c3RhdGVpbmZvLkRpY3Rpb25hcnlTdGF0ZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFRpbWV6b25lIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgYWxsIGF2YWlsYWJsZSB0aW1lem9uZXMuPC9wPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmxpc3RUaW1lem9uZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9kaWN0aW9uYXJ5L3RpbWV6b25lJywgb3B0aW9ucywgZXhwb3J0cy5saXN0VGltZXpvbmVzT3B0aW9ucyksIGRpY3Rpb25hcnl0aW1lem9uZWxpc3QuRGljdGlvbmFyeVRpbWV6b25lTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgVGltZXpvbmVcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMCAoUmVsZWFzZSA2LjIpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGluZm9ybWF0aW9uIG9uIGEgY2VydGFpbiB0aW1lem9uZS48L3A+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUubG9hZFRpbWV6b25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvZGljdGlvbmFyeS90aW1lem9uZS97dGltZXpvbmVJZH0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRUaW1lem9uZU9wdGlvbnMpLCBkaWN0aW9uYXJ5dGltZXpvbmVpbmZvLkRpY3Rpb25hcnlUaW1lem9uZUluZm8pO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnk7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdENvdW50cmllcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0Q291bnRyaWVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImxvZ2luQWxsb3dlZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm51bWJlclNlbGxpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZENvdW50cnkgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZENvdW50cnlPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY291bnRyeUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RMYW5ndWFnZXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdExhbmd1YWdlc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkTGFuZ3VhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZExhbmd1YWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImxhbmd1YWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdExvY2F0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0TG9jYXRpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm9yZGVyQnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RMb2NhdGlvbnNPcmRlckJ5XCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiTnBhXCIsXG4gICAgICAgICAgICBcIkNpdHlcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdGF0ZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ3aXRoTnh4XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RTZWNyZXRRdWVzdGlvbnMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdFNlY3JldFF1ZXN0aW9uc09wdGlvbnMgPSBbXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU2VjcmV0UXVlc3Rpb24gb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFNlY3JldFF1ZXN0aW9uT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInF1ZXN0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFNoaXBwaW5nT3B0aW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0U2hpcHBpbmdPcHRpb25zT3B0aW9ucyA9IFtdO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRsaXN0U3RhdGVzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRsaXN0U3RhdGVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvdW50cnlJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwid2l0aFBob25lTnVtYmVyc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkU3RhdGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFN0YXRlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXRlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdFRpbWV6b25lcyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0VGltZXpvbmVzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkVGltZXpvbmUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZFRpbWV6b25lT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInRpbWV6b25lSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0TG9jYXRpb25zT3JkZXJCeSkge1xuICAgIElMaXN0TG9jYXRpb25zT3JkZXJCeVtJTGlzdExvY2F0aW9uc09yZGVyQnlbXCJOcGFcIl0gPSAnTnBhJ10gPSBcIk5wYVwiO1xuICAgIElMaXN0TG9jYXRpb25zT3JkZXJCeVtJTGlzdExvY2F0aW9uc09yZGVyQnlbXCJDaXR5XCJdID0gJ0NpdHknXSA9IFwiQ2l0eVwiO1xufSkoZXhwb3J0cy5JTGlzdExvY2F0aW9uc09yZGVyQnkgfHwgKGV4cG9ydHMuSUxpc3RMb2NhdGlvbnNPcmRlckJ5ID0ge30pKTtcbnZhciBJTGlzdExvY2F0aW9uc09yZGVyQnkgPSBleHBvcnRzLklMaXN0TG9jYXRpb25zT3JkZXJCeTtcblxuXG4vKioqLyB9LFxuLyogNTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeWNvdW50cnlpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQ291bnRyeUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudHJ5TGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb3VudHJ5TGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENvdW50cnlMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeWNvdW50cnlpbmZvLkRpY3Rpb25hcnlDb3VudHJ5SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ291bnRyeUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdDb3VudHJ5TGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ291bnRyeUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkNvdW50cnlMaXN0ID0gQ291bnRyeUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDU3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpY3Rpb25hcnlDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlDb3VudHJ5SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5Q291bnRyeUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5Q291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGluZ0NvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VtZXJnZW5jeUNhbGxpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpc29Db2RlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdudW1iZXJTZWxsaW5nJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbG9naW5BbGxvd2VkJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlDb3VudHJ5SW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlDb3VudHJ5SW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeUNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5Q291bnRyeUluZm8gPSBEaWN0aW9uYXJ5Q291bnRyeUluZm87XG5cblxuLyoqKi8gfSxcbi8qIDU4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxhbmd1YWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIExhbmd1YWdlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExhbmd1YWdlTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYW5ndWFnZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMYW5ndWFnZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogbGFuZ3VhZ2VpbmZvLkxhbmd1YWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTGFuZ3VhZ2VMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGFuZ3VhZ2VMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBMYW5ndWFnZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkxhbmd1YWdlTGlzdCA9IExhbmd1YWdlTGlzdDtcblxuXG4vKioqLyB9LFxuLyogNTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbG9jYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRGljdGlvbmFyeUxvY2F0aW9uTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlMb2NhdGlvbkxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeUxvY2F0aW9uTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlMb2NhdGlvbkxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBsb2NhdGlvbmluZm8uTG9jYXRpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeUxvY2F0aW9uTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlMb2NhdGlvbkxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlMb2NhdGlvbkxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlMb2NhdGlvbkxpc3QgPSBEaWN0aW9uYXJ5TG9jYXRpb25MaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA2MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBMb2NhdGlvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhdGlvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9jYXRpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTG9jYXRpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnYXJlYUNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NpdHknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25wYScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbnh4JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0ZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExvY2F0aW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0xvY2F0aW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYXRpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Mb2NhdGlvbkluZm8gPSBMb2NhdGlvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDYxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHNlY3JldHF1ZXN0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBzZWNyZXRxdWVzdGlvbmluZm8uU2VjcmV0UXVlc3Rpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3BhZ2luZycsIENsYXNzOiBwYWdpbmdpbmZvLlBhZ2luZ0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U2VjcmV0UXVlc3Rpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVNlY3JldFF1ZXN0aW9uTGlzdCA9IERpY3Rpb25hcnlTZWNyZXRRdWVzdGlvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDYyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFNlY3JldFF1ZXN0aW9uSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlY3JldFF1ZXN0aW9uSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZWNyZXRRdWVzdGlvbkluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTZWNyZXRRdWVzdGlvbkluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3F1ZXN0aW9uVHlwZScsIENsYXNzOiBudWxsIC8qIG51bWJlciAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbGFuZ3VhZ2VJZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVlc3Rpb25UZXh0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzaG93SW5TaWduVXAnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2VjcmV0UXVlc3Rpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2VjcmV0UXVlc3Rpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTZWNyZXRRdWVzdGlvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNlY3JldFF1ZXN0aW9uSW5mbyA9IFNlY3JldFF1ZXN0aW9uSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgc2hpcHBpbmdtZXRob2RpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG52YXIgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncXVhbnRpdHknLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByaWNlJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXRob2QnLCBDbGFzczogc2hpcHBpbmdtZXRob2RpbmZvLlNoaXBwaW5nTWV0aG9kSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVNoaXBwaW5nT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMnO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTaGlwcGluZ09wdGlvbnMgPSBEaWN0aW9uYXJ5U2hpcHBpbmdPcHRpb25zO1xuXG5cbi8qKiovIH0sXG4vKiA2NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBTaGlwcGluZ01ldGhvZEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaGlwcGluZ01ldGhvZEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hpcHBpbmdNZXRob2RJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2hpcHBpbmdNZXRob2RJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgU2hpcHBpbmdNZXRob2RJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU2hpcHBpbmdNZXRob2RJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTaGlwcGluZ01ldGhvZEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlNoaXBwaW5nTWV0aG9kSW5mbyA9IFNoaXBwaW5nTWV0aG9kSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeXN0YXRlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlTdGF0ZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5U3RhdGVMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlTdGF0ZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5U3RhdGVMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeXN0YXRlaW5mby5EaWN0aW9uYXJ5U3RhdGVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5U3RhdGVMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVN0YXRlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVN0YXRlTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVN0YXRlTGlzdCA9IERpY3Rpb25hcnlTdGF0ZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDY2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHN0YXRlY291bnRyeWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBEaWN0aW9uYXJ5U3RhdGVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGljdGlvbmFyeVN0YXRlSW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U3RhdGVJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRGljdGlvbmFyeVN0YXRlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjb3VudHJ5JywgQ2xhc3M6IHN0YXRlY291bnRyeWluZm8uU3RhdGVDb3VudHJ5SW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaXNvQ29kZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIERpY3Rpb25hcnlTdGF0ZUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEaWN0aW9uYXJ5U3RhdGVJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBEaWN0aW9uYXJ5U3RhdGVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5EaWN0aW9uYXJ5U3RhdGVJbmZvID0gRGljdGlvbmFyeVN0YXRlSW5mbztcblxuXG4vKioqLyB9LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgU3RhdGVDb3VudHJ5SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YXRlQ291bnRyeUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGVDb3VudHJ5SW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFN0YXRlQ291bnRyeUluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFN0YXRlQ291bnRyeUluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTdGF0ZUNvdW50cnlJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZUNvdW50cnlJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5TdGF0ZUNvdW50cnlJbmZvID0gU3RhdGVDb3VudHJ5SW5mbztcblxuXG4vKioqLyB9LFxuLyogNjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGljdGlvbmFyeXRpbWV6b25laW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERpY3Rpb25hcnlUaW1lem9uZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlUaW1lem9uZUxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZGljdGlvbmFyeXRpbWV6b25laW5mby5EaWN0aW9uYXJ5VGltZXpvbmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRGljdGlvbmFyeVRpbWV6b25lTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRGljdGlvbmFyeVRpbWV6b25lTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRGljdGlvbmFyeVRpbWV6b25lTGlzdCA9IERpY3Rpb25hcnlUaW1lem9uZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDY5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIERpY3Rpb25hcnlUaW1lem9uZUluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpY3Rpb25hcnlUaW1lem9uZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2Rlc2NyaXB0aW9uJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGljdGlvbmFyeVRpbWV6b25lSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RpY3Rpb25hcnlUaW1lem9uZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlUaW1lem9uZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlUaW1lem9uZUluZm8gPSBEaWN0aW9uYXJ5VGltZXpvbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA3MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZXh0ZW5zaW9ubGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGV4dGVuc2lvbnBob25lbnVtYmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xudmFyIGV4dGVuc2lvbmdyYW50bGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xudmFyIGRlcGFydG1lbnRtZW1iZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG52YXIgRXh0ZW5zaW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZW5zaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjA8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBleHRlbnNpb25zIGNyZWF0ZWQgZm9yIGEgcGFydGljdWxhciBhY2NvdW50LiBBbGwgdHlwZXMgb2YgZXh0ZW5zaW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxpc3RFeHRlbnNpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24nLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25zT3B0aW9ucyksIGV4dGVuc2lvbmxpc3QuRXh0ZW5zaW9uTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEluZm9cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4wPC9wPlxuICAgICAqIDxwPlJldHVybnMgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgYSBwYXJ0aWN1bGFyIGV4dGVuc2lvbiBvZiBhbiBhY2NvdW50LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubG9hZEV4dGVuc2lvbkluZm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkRXh0ZW5zaW9uSW5mb09wdGlvbnMpLCBleHRlbnNpb25pbmZvLkV4dGVuc2lvbkluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQaG9uZSBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgYnkgYSBwYXJ0aWN1bGFyIGV4dGVuc2lvbiwgYW5kIGNhbiBiZSBmaWx0ZXJlZCBieSB0aGUgcGhvbmUgbnVtYmVyIHR5cGUuIFRoZSByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIGFsbCBudW1iZXJzIHdoaWNoIGFyZSBkaXJlY3RseSBtYXBwZWQgdG8gYSBnaXZlbiBleHRlbnNpb24gcGx1cyB0aGUgZmVhdHVyZXMgYW5kIGFsc28gY29tcGFueS1sZXZlbCBudW1iZXJzXG4gICAgICogICAgIHdoaWNoIG1heSBiZSB1c2VkIHdoZW4gcGVyZm9ybWluZyBkaWZmZXJlbnQgb3BlcmF0aW9ucyBvbiBiZWhhbGYgb2YgdGhpcyBleHRlbnNpb24uPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9waG9uZS1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNPcHRpb25zKSwgZXh0ZW5zaW9ucGhvbmVudW1iZXJzLkV4dGVuc2lvblBob25lTnVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEdyYW50IExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBsaXN0IG9mIGV4dGVuc2lvbiBncmFudHMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRXh0ZW5zaW9uLnByb3RvdHlwZS5saXN0RXh0ZW5zaW9uR3JhbnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9ncmFudCcsIG9wdGlvbnMsIGV4cG9ydHMubGlzdEV4dGVuc2lvbkdyYW50c09wdGlvbnMpLCBleHRlbnNpb25ncmFudGxpc3QuRXh0ZW5zaW9uR3JhbnRMaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBFeHRlbnNpb24gUHJvZmlsZSBJbWFnZVxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGV4dGVuc2lvbiBwcm9maWxlIGltYWdlLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2UnLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25Qcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRXh0ZW5zaW9uIFByb2ZpbGUgSW1hZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIHRoZSBleHRlbnNpb24gcHJvZmlsZSBpbWFnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5IaWdoPC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+VXBkYXRlcyB0aGUgZXh0ZW5zaW9uIHByb2ZpbGUgaW1hZ2UuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGlnaDwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLnVwZGF0ZUV4dGVuc2lvblByb2ZpbGVJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BVVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJvZmlsZS1pbWFnZScsIG9wdGlvbnMsIGV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbiBQcm9maWxlIEltYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgc2NhbGVkIHByb2ZpbGUgaW1hZ2Ugb2YgYW4gZXh0ZW5zaW9uLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3Byb2ZpbGUtaW1hZ2Uve3NjYWxlU2l6ZX0nLCBvcHRpb25zLCBleHBvcnRzLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2VPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRGVwYXJ0bWVudCBNZW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEV4dGVuc2lvbi5wcm90b3R5cGUubGlzdERlcGFydG1lbnRNZW1iZXJzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9kZXBhcnRtZW50L3tkZXBhcnRtZW50SWR9L21lbWJlcnMnLCBvcHRpb25zLCBleHBvcnRzLmxpc3REZXBhcnRtZW50TWVtYmVyc09wdGlvbnMpLCBkZXBhcnRtZW50bWVtYmVycy5EZXBhcnRtZW50TWVtYmVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkV4dGVuc2lvbiA9IEV4dGVuc2lvbjtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsaXN0RXh0ZW5zaW9ucyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInBlclBhZ2VcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN0YXR1c1wiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbnNTdGF0dXNcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJFbmFibGVkXCIsXG4gICAgICAgICAgICBcIkRpc2FibGVkXCIsXG4gICAgICAgICAgICBcIk5vdEFjdGl2YXRlZFwiLFxuICAgICAgICAgICAgXCJVbmFzc2lnbmVkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvbnNUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiVXNlclwiLFxuICAgICAgICAgICAgXCJGYXhVc2VyXCIsXG4gICAgICAgICAgICBcIlZpcnR1YWxVc2VyXCIsXG4gICAgICAgICAgICBcIkRpZ2l0YWxVc2VyXCIsXG4gICAgICAgICAgICBcIkRlcGFydG1lbnRcIixcbiAgICAgICAgICAgIFwiQW5ub3VuY2VtZW50XCIsXG4gICAgICAgICAgICBcIlZvaWNlbWFpbFwiLFxuICAgICAgICAgICAgXCJTaGFyZWRMaW5lc0dyb3VwXCIsXG4gICAgICAgICAgICBcIlBhZ2luZ09ubHlHcm91cFwiLFxuICAgICAgICAgICAgXCJJdnJNZW51XCIsXG4gICAgICAgICAgICBcIkFwcGxpY2F0aW9uRXh0ZW5zaW9uXCIsXG4gICAgICAgICAgICBcIlBhcmtMb2NhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uSW5mbyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uSW5mb09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvblBob25lTnVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInVzYWdlVHlwZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIk1haW5Db21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkFkZGl0aW9uYWxDb21wYW55TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRGlyZWN0TnVtYmVyXCIsXG4gICAgICAgICAgICBcIkNvbXBhbnlGYXhOdW1iZXJcIixcbiAgICAgICAgICAgIFwiRm9yd2FyZGVkTnVtYmVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGVyUGFnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RFeHRlbnNpb25HcmFudHMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubGlzdEV4dGVuc2lvbkdyYW50c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEV4dGVuc2lvblByb2ZpbGVJbWFnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5sb2FkRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBjcmVhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVFeHRlbnNpb25Qcm9maWxlSW1hZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlRXh0ZW5zaW9uUHJvZmlsZUltYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkRXh0ZW5zaW9uU2NhbGVkUHJvZmlsZUltYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRFeHRlbnNpb25TY2FsZWRQcm9maWxlSW1hZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic2NhbGVTaXplXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3REZXBhcnRtZW50TWVtYmVycyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5saXN0RGVwYXJ0bWVudE1lbWJlcnNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkZXBhcnRtZW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uc1N0YXR1cykge1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJFbmFibGVkXCJdID0gJ0VuYWJsZWQnXSA9IFwiRW5hYmxlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJEaXNhYmxlZFwiXSA9ICdEaXNhYmxlZCddID0gXCJEaXNhYmxlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJOb3RBY3RpdmF0ZWRcIl0gPSAnTm90QWN0aXZhdGVkJ10gPSBcIk5vdEFjdGl2YXRlZFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1N0YXR1c1tJTGlzdEV4dGVuc2lvbnNTdGF0dXNbXCJVbmFzc2lnbmVkXCJdID0gJ1VuYXNzaWduZWQnXSA9IFwiVW5hc3NpZ25lZFwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNTdGF0dXMgfHwgKGV4cG9ydHMuSUxpc3RFeHRlbnNpb25zU3RhdHVzID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvbnNTdGF0dXMgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1N0YXR1cztcbihmdW5jdGlvbiAoSUxpc3RFeHRlbnNpb25zVHlwZSkge1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJBbm5vdW5jZW1lbnRcIl0gPSAnQW5ub3VuY2VtZW50J10gPSBcIkFubm91bmNlbWVudFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiU2hhcmVkTGluZXNHcm91cFwiXSA9ICdTaGFyZWRMaW5lc0dyb3VwJ10gPSBcIlNoYXJlZExpbmVzR3JvdXBcIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJQYWdpbmdPbmx5R3JvdXBcIl0gPSAnUGFnaW5nT25seUdyb3VwJ10gPSBcIlBhZ2luZ09ubHlHcm91cFwiO1xuICAgIElMaXN0RXh0ZW5zaW9uc1R5cGVbSUxpc3RFeHRlbnNpb25zVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgSUxpc3RFeHRlbnNpb25zVHlwZVtJTGlzdEV4dGVuc2lvbnNUeXBlW1wiQXBwbGljYXRpb25FeHRlbnNpb25cIl0gPSAnQXBwbGljYXRpb25FeHRlbnNpb24nXSA9IFwiQXBwbGljYXRpb25FeHRlbnNpb25cIjtcbiAgICBJTGlzdEV4dGVuc2lvbnNUeXBlW0lMaXN0RXh0ZW5zaW9uc1R5cGVbXCJQYXJrTG9jYXRpb25cIl0gPSAnUGFya0xvY2F0aW9uJ10gPSBcIlBhcmtMb2NhdGlvblwiO1xufSkoZXhwb3J0cy5JTGlzdEV4dGVuc2lvbnNUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGUgPSB7fSkpO1xudmFyIElMaXN0RXh0ZW5zaW9uc1R5cGUgPSBleHBvcnRzLklMaXN0RXh0ZW5zaW9uc1R5cGU7XG4oZnVuY3Rpb24gKElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlKSB7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJNYWluQ29tcGFueU51bWJlclwiXSA9ICdNYWluQ29tcGFueU51bWJlciddID0gXCJNYWluQ29tcGFueU51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIl0gPSAnQWRkaXRpb25hbENvbXBhbnlOdW1iZXInXSA9IFwiQWRkaXRpb25hbENvbXBhbnlOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkNvbXBhbnlOdW1iZXJcIl0gPSAnQ29tcGFueU51bWJlciddID0gXCJDb21wYW55TnVtYmVyXCI7XG4gICAgSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGVbXCJEaXJlY3ROdW1iZXJcIl0gPSAnRGlyZWN0TnVtYmVyJ10gPSBcIkRpcmVjdE51bWJlclwiO1xuICAgIElMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW0lMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlW1wiQ29tcGFueUZheE51bWJlclwiXSA9ICdDb21wYW55RmF4TnVtYmVyJ10gPSBcIkNvbXBhbnlGYXhOdW1iZXJcIjtcbiAgICBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZVtcIkZvcndhcmRlZE51bWJlclwiXSA9ICdGb3J3YXJkZWROdW1iZXInXSA9IFwiRm9yd2FyZGVkTnVtYmVyXCI7XG59KShleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0RXh0ZW5zaW9uUGhvbmVOdW1iZXJzVXNhZ2VUeXBlID0ge30pKTtcbnZhciBJTGlzdEV4dGVuc2lvblBob25lTnVtYmVyc1VzYWdlVHlwZSA9IGV4cG9ydHMuSUxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnNVc2FnZVR5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDcxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25MaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVuc2lvbkxpc3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25MaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZXh0ZW5zaW9uaW5mby5FeHRlbnNpb25JbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uTGlzdCA9IEV4dGVuc2lvbkxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDcyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHBob25lbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIEV4dGVuc2lvblBob25lTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvblBob25lTnVtYmVycywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25QaG9uZU51bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFeHRlbnNpb25QaG9uZU51bWJlcnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBwaG9uZW51bWJlcmluZm8uUGhvbmVOdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBFeHRlbnNpb25QaG9uZU51bWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdFeHRlbnNpb25QaG9uZU51bWJlcnMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvblBob25lTnVtYmVycztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uUGhvbmVOdW1iZXJzID0gRXh0ZW5zaW9uUGhvbmVOdW1iZXJzO1xuXG5cbi8qKiovIH0sXG4vKiA3MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBncmFudGluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBFeHRlbnNpb25HcmFudExpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25HcmFudExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uR3JhbnRMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRXh0ZW5zaW9uR3JhbnRMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZ3JhbnRpbmZvLkdyYW50SW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uR3JhbnRMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uR3JhbnRMaXN0JztcbiAgICB9O1xuICAgIHJldHVybiBFeHRlbnNpb25HcmFudExpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkdyYW50TGlzdCA9IEV4dGVuc2lvbkdyYW50TGlzdDtcblxuXG4vKioqLyB9LFxuLyogNzQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZXh0ZW5zaW9uaW5mb2dyYW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xudmFyIEdyYW50SW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyYW50SW5mbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcmFudEluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHcmFudEluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogZXh0ZW5zaW9uaW5mb2dyYW50cy5FeHRlbnNpb25JbmZvR3JhbnRzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsUGlja3VwJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbE1vbml0b3JpbmcnLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgR3JhbnRJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnR3JhbnRJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBHcmFudEluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkdyYW50SW5mbyA9IEdyYW50SW5mbztcblxuXG4vKioqLyB9LFxuLyogNzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRXh0ZW5zaW9uSW5mb0dyYW50cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVuc2lvbkluZm9HcmFudHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSW5mb0dyYW50cygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkluZm9HcmFudHMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXh0ZW5zaW9uTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0eXBlJywgQ2xhc3M6IEV4dGVuc2lvbkluZm9HcmFudHNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50cy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0V4dGVuc2lvbkluZm9HcmFudHMnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkluZm9HcmFudHM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHMgPSBFeHRlbnNpb25JbmZvR3JhbnRzO1xuKGZ1bmN0aW9uIChFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSkge1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVXNlclwiXSA9ICdVc2VyJ10gPSBcIlVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkZheFVzZXJcIl0gPSAnRmF4IFVzZXInXSA9IFwiRmF4VXNlclwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiVmlydHVhbFVzZXJcIl0gPSAnVmlydHVhbFVzZXInXSA9IFwiVmlydHVhbFVzZXJcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJEZXBhcnRtZW50XCJdID0gJ0RlcGFydG1lbnQnXSA9IFwiRGVwYXJ0bWVudFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiQW5ub3VuY2VtZW50XCJdID0gJ0Fubm91bmNlbWVudCddID0gXCJBbm5vdW5jZW1lbnRcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIlZvaWNlbWFpbFwiXSA9ICdWb2ljZW1haWwnXSA9IFwiVm9pY2VtYWlsXCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJTaGFyZWRMaW5lc0dyb3VwXCJdID0gJ1NoYXJlZExpbmVzR3JvdXAnXSA9IFwiU2hhcmVkTGluZXNHcm91cFwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiUGFnaW5nT25seVwiXSA9ICdQYWdpbmdPbmx5J10gPSBcIlBhZ2luZ09ubHlcIjtcbiAgICBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtFeHRlbnNpb25JbmZvR3JhbnRzVHlwZVtcIkl2ck1lbnVcIl0gPSAnSXZyTWVudSddID0gXCJJdnJNZW51XCI7XG4gICAgRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIEV4dGVuc2lvbkluZm9HcmFudHNUeXBlW0V4dGVuc2lvbkluZm9HcmFudHNUeXBlW1wiUGFya0xvY2F0aW9uXCJdID0gJ1BhcmsgTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlIHx8IChleHBvcnRzLkV4dGVuc2lvbkluZm9HcmFudHNUeXBlID0ge30pKTtcbnZhciBFeHRlbnNpb25JbmZvR3JhbnRzVHlwZSA9IGV4cG9ydHMuRXh0ZW5zaW9uSW5mb0dyYW50c1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDc2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGV4dGVuc2lvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG5hdmlnYXRpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgcGFnaW5naW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIERlcGFydG1lbnRNZW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVwYXJ0bWVudE1lbWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVwYXJ0bWVudE1lbWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEZXBhcnRtZW50TWVtYmVycy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGV4dGVuc2lvbmluZm8uRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRGVwYXJ0bWVudE1lbWJlcnMucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEZXBhcnRtZW50TWVtYmVycyc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVwYXJ0bWVudE1lbWJlcnM7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkRlcGFydG1lbnRNZW1iZXJzID0gRGVwYXJ0bWVudE1lbWJlcnM7XG5cblxuLyoqKi8gfSxcbi8qIDc3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBtZXNzYWdlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xudmFyIG1lc3NhZ2VsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG52YXIgbWVzc2FnZXN5bmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcbnZhciBNZXNzYWdlcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFBhZ2VyIE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzIGEgcGFnZXIgbWVzc2FnZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkludGVybmFsTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgaW50cmEtY29tcGFueSB0ZXh0IG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkTWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUuc2VuZEludGVybmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2NvbXBhbnktcGFnZXInLCBvcHRpb25zLCBleHBvcnRzLnNlbmRJbnRlcm5hbE1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIEZheCBNZXNzYWdlXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMjwvcD5cbiAgICAgKiA8cD5DcmVhdGVzIGFuZCBzZW5kcy9yZXNlbmRzIG5ldyBmYXggbWVzc2FnZS4gUmVzZW5kIGNhbiBiZSBkb25lIGlmIHNlbmRpbmcgZmFpbGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RmF4ZXM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgZmF4ZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRGYXhNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZmF4Jywgb3B0aW9ucywgZXhwb3J0cy5zZW5kRmF4TWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgU01TIE1lc3NhZ2VcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPkNyZWF0ZXMgYW5kIHNlbmRzIG5ldyBTTVMgbWVzc2FnZS4gU2VuZGluZyBTTVMgbWVzc2FnZXMgc2ltdWx0YW5lb3VzbHkgdG8gZGlmZmVyZW50IHJlY2lwaWVudHMgaXMgbGltaXRlZCB1cCB0byA1MCByZXF1ZXN0cyBwZXIgbWludXRlOyByZWxldmFudCBmb3IgYWxsIGNsaWVudCBhcHBsaWNhdGlvbnMuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5TTVM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5TZW5kaW5nIGFuZCByZWNlaXZpbmcgU01TICh0ZXh0KSBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnNlbmRTTVMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQT1NUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9zbXMnLCBvcHRpb25zLCBleHBvcnRzLnNlbmRTTVNPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBtZXNzYWdlcyBmcm9tIGFuIGV4dGVuc2lvbiBtYWlsYm94LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBNZXNzYWdlcy5wcm90b3R5cGUubGlzdE1lc3NhZ2VzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TWVzc2FnZXNPcHRpb25zKSwgbWVzc2FnZWxpc3QuTWVzc2FnZUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgaW5kaXZpZHVhbCBtZXNzYWdlIHJlY29yZChzKSBieSB0aGUgZ2l2ZW4gbWVzc2FnZSBJRChzKS4gVGhlIGxlbmd0aCBvZiBpbmJvdW5kIG1lc3NhZ2VzIGlzIHVubGltaXRlZC4gQmF0Y2ggcmVxdWVzdCBpcyBzdXBwb3J0ZWQsIHNlZSBCYXRjaCBSZXF1ZXN0cyBmb3IgZGV0YWlscy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxvYWRNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTWVzc2FnZU9wdGlvbnMpLCBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTWVzc2FnZShzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+VXBkYXRlcyBtZXNzYWdlKHMpIGJ5IElEKHMpLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZCwgc2VlIEJhdGNoIFJlcXVlc3RzIGZvciBkZXRhaWxzLiBDdXJyZW50bHksIG9ubHkgdGhlIG1lc3NhZ2UgcmVhZCBzdGF0dXMgdXBkYXRpbmcgaXMgc3VwcG9ydGVkLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnVwZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L21lc3NhZ2Utc3RvcmUve21lc3NhZ2VJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZU1lc3NhZ2VPcHRpb25zKSwgbWVzc2FnZWluZm8uTWVzc2FnZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIE1lc3NhZ2UocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5EZWxldGVzIG1lc3NhZ2UocykgYnkgdGhlIGdpdmVuIG1lc3NhZ2UgSUQocykuIFRoZSBmaXJzdCBjYWxsIG9mIHRoaXMgbWV0aG9kIHRyYW5zZmVycyB0aGUgbWVzc2FnZSB0byB0aGUgJ0RlbGV0ZScgc3RhdHVzLiBUaGUgc2Vjb25kIGNhbGwgdHJhbnNmZXJzIHRoZSBkZWxldGVkIG1lc3NhZ2UgdG8gdGhlICdQdXJnZWQnIHN0YXR1cy4gSWYgaXQgaXMgcmVxdWlyZWQgdG8gbWFrZSB0aGUgbWVzc2FnZSAnUHVyZ2VkJyBpbW1lZGlhdGVseVxuICAgICAqICAgICAoZnJvbSB0aGUgZmlyc3QgY2FsbCksIHRoZW4gc2V0IHRoZSBxdWVyeSBwYXJhbWV0ZXIgcHVyZ2UgdG8gJ1RydWUnLiBCYXRjaCByZXF1ZXN0IGlzIHN1cHBvcnRlZC48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgbWVzc2FnZXM8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIE1lc3NhZ2VzLnByb3RvdHlwZS5kZWxldGVNZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9tZXNzYWdlLXN0b3JlL3ttZXNzYWdlSWR9Jywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVNZXNzYWdlT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1lc3NhZ2UgQXR0YWNobWVudFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjQgKFJlbGVhc2UgNS4xMyk8L3A+XG4gICAgICogPHA+UmV0dXJucyBwYXJ0aWN1bGFyIG1lc3NhZ2UgYXR0YWNobWVudCBkYXRhIGFzIGEgbWVkaWEgc3RyZWFtLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZE1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIG1lc3NhZ2VzPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLmxvYWRNZXNzYWdlQXR0YWNobWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zdG9yZS97bWVzc2FnZUlkfS9jb250ZW50L3thdHRhY2htZW50SWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkTWVzc2FnZUF0dGFjaG1lbnRPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgTWVzc2FnZSBTeW5jXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNCAoUmVsZWFzZSA1LjEzKTwvcD5cbiAgICAgKiA8cD5Qcm92aWRlcyBmYWNpbGl0aWVzIHRvIHN5bmNocm9uaXplIG1haWxib3ggY29udGVudCBzdG9yZWQgZXh0ZXJuYWxseSB3aXRoIHNlcnZlciBzdGF0ZS48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRNZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBtZXNzYWdlczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgTWVzc2FnZXMucHJvdG90eXBlLnN5bmNNZXNzYWdlcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vbWVzc2FnZS1zeW5jJywgb3B0aW9ucywgZXhwb3J0cy5zeW5jTWVzc2FnZXNPcHRpb25zKSwgbWVzc2FnZXN5bmMuTWVzc2FnZVN5bmMpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZEludGVybmFsTWVzc2FnZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kSW50ZXJuYWxNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVwYWdlcm1lc3NhZ2VyZXF1ZXN0LkNyZWF0ZVBhZ2VyTWVzc2FnZVJlcXVlc3RcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZEZheE1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuc2VuZEZheE1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwibm90ZXNcIjogXCJcIixcbiAgICAgICAgXCJwYXJhbVR5cGVcIjogXCJwYXRoXCIsXG4gICAgICAgIFwiZGVmYXVsdFZhbHVlXCI6IFwiflwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiYWxsb3dNdWx0aXBsZVwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJub3Rlc1wiOiBcIlwiLFxuICAgICAgICBcInBhcmFtVHlwZVwiOiBcInBhdGhcIixcbiAgICAgICAgXCJkZWZhdWx0VmFsdWVcIjogXCJ+XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJhbGxvd011bHRpcGxlXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICAgICAgXCJpblwiOiBcImhlYWRlclwiLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICBcImluXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwiY29uc3VtZXNcIjogW1xuICAgICAgICAgICAgXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PUJvdW5kYXJ5XzFfMTQ0MTM5MDFfMTM2MTg3MTA4MDg4OFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi0tQm91bmRhcnlfMV8xNDQxMzkwMV8xMzYxODcxMDgwODg4XFxuQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXFxuXFxue1xcbiAgXFxcInRvXFxcIjpbe1xcXCJwaG9uZU51bWJlclxcXCI6XFxcIjE4MDA1NjMwMDAzXFxcIn1dLFxcbiAgXFxcImZheFJlc29sdXRpb25cXFwiOlxcXCJIaWdoXFxcIixcXG4gIFxcXCJzZW5kVGltZVxcXCI6XFxcIjIwMTMtMDItMjZUMDk6MzE6MjAuODgyWlxcXCJcXG59XFxuXFxuLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODhcXG5Db250ZW50LVR5cGU6IHRleHQvcGxhaW5cXG5cXG5IZWxsbywgV29ybGQhXFxuXFxuLS1Cb3VuZGFyeV8xXzE0NDEzOTAxXzEzNjE4NzEwODA4ODgtLVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc2VuZFNNUyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5zZW5kU01TT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVzbXNtZXNzYWdlLkNyZWF0ZVNNU01lc3NhZ2VcIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdE1lc3NhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RNZXNzYWdlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhdmFpbGFiaWxpdHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkFsaXZlXCIsXG4gICAgICAgICAgICBcIkRlbGV0ZWRcIixcbiAgICAgICAgICAgIFwiUHVyZ2VkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY29udmVyc2F0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVGcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJkYXRlVG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpcmVjdGlvblwiLFxuICAgICAgICBcInR5cGVcIjogXCJJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiSW5ib3VuZFwiLFxuICAgICAgICAgICAgXCJPdXRib3VuZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRpc3RpbmN0Q29udmVyc2F0aW9uc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZheFwiLFxuICAgICAgICAgICAgXCJTTVNcIixcbiAgICAgICAgICAgIFwiVm9pY2VNYWlsXCIsXG4gICAgICAgICAgICBcIlBhZ2VyXCIsXG4gICAgICAgICAgICBcIlRleHRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyZWFkU3RhdHVzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklMaXN0TWVzc2FnZXNSZWFkU3RhdHVzXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiUmVhZFwiLFxuICAgICAgICAgICAgXCJVbnJlYWRcIlxuICAgICAgICBdLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwaG9uZU51bWJlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxvYWRNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRNZXNzYWdlT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIm1lc3NhZ2VJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVNZXNzYWdlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZU1lc3NhZ2VPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZUlkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInVwZGF0ZW1lc3NhZ2VyZXF1ZXN0LlVwZGF0ZU1lc3NhZ2VSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZU1lc3NhZ2Ugb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlTWVzc2FnZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwdXJnZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNvbnZlcnNhdGlvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZE1lc3NhZ2VBdHRhY2htZW50IG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRNZXNzYWdlQXR0YWNobWVudE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhdHRhY2htZW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJtZXNzYWdlSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3Igc3luY01lc3NhZ2VzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnN5bmNNZXNzYWdlc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjb252ZXJzYXRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGF0ZUZyb21cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImRhdGVUb1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlyZWN0aW9uXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNEaXJlY3Rpb25cIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImNvbGxlY3Rpb25Gb3JtYXRcIjogXCJtdWx0aVwiLFxuICAgICAgICBcImFsbG93RW1wdHlWYWx1ZVwiOiB0cnVlLFxuICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJJbmJvdW5kXCIsXG4gICAgICAgICAgICBcIk91dGJvdW5kXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZGlzdGluY3RDb252ZXJzYXRpb25zXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwibWVzc2FnZVR5cGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlXCIsXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb2xsZWN0aW9uRm9ybWF0XCI6IFwibXVsdGlcIixcbiAgICAgICAgXCJhbGxvd0VtcHR5VmFsdWVcIjogdHJ1ZSxcbiAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiRmF4XCIsXG4gICAgICAgICAgICBcIlNNU1wiLFxuICAgICAgICAgICAgXCJWb2ljZU1haWxcIixcbiAgICAgICAgICAgIFwiUGFnZXJcIixcbiAgICAgICAgICAgIFwiVGV4dFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInJlY29yZENvdW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzeW5jVG9rZW5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInN5bmNUeXBlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIklTeW5jTWVzc2FnZXNTeW5jVHlwZVwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY29sbGVjdGlvbkZvcm1hdFwiOiBcIm11bHRpXCIsXG4gICAgICAgIFwiYWxsb3dFbXB0eVZhbHVlXCI6IHRydWUsXG4gICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcIkZTeW5jXCIsXG4gICAgICAgICAgICBcIklTeW5jXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2VcbiAgICB9XG5dO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5KSB7XG4gICAgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W1wiQWxpdmVcIl0gPSAnQWxpdmUnXSA9IFwiQWxpdmVcIjtcbiAgICBJTGlzdE1lc3NhZ2VzQXZhaWxhYmlsaXR5W0lMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbXCJEZWxldGVkXCJdID0gJ0RlbGV0ZWQnXSA9IFwiRGVsZXRlZFwiO1xuICAgIElMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHlbSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eVtcIlB1cmdlZFwiXSA9ICdQdXJnZWQnXSA9IFwiUHVyZ2VkXCI7XG59KShleHBvcnRzLklMaXN0TWVzc2FnZXNBdmFpbGFiaWxpdHkgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eSA9IGV4cG9ydHMuSUxpc3RNZXNzYWdlc0F2YWlsYWJpbGl0eTtcbihmdW5jdGlvbiAoSUxpc3RNZXNzYWdlc0RpcmVjdGlvbikge1xuICAgIElMaXN0TWVzc2FnZXNEaXJlY3Rpb25bSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSUxpc3RNZXNzYWdlc0RpcmVjdGlvbltJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJTGlzdE1lc3NhZ2VzRGlyZWN0aW9uID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGUpIHtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBJTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGVbSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlIHx8IChleHBvcnRzLklMaXN0TWVzc2FnZXNNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgSUxpc3RNZXNzYWdlc01lc3NhZ2VUeXBlID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzKSB7XG4gICAgSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXNbXCJSZWFkXCJdID0gJ1JlYWQnXSA9IFwiUmVhZFwiO1xuICAgIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW0lMaXN0TWVzc2FnZXNSZWFkU3RhdHVzW1wiVW5yZWFkXCJdID0gJ1VucmVhZCddID0gXCJVbnJlYWRcIjtcbn0pKGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgfHwgKGV4cG9ydHMuSUxpc3RNZXNzYWdlc1JlYWRTdGF0dXMgPSB7fSkpO1xudmFyIElMaXN0TWVzc2FnZXNSZWFkU3RhdHVzID0gZXhwb3J0cy5JTGlzdE1lc3NhZ2VzUmVhZFN0YXR1cztcbihmdW5jdGlvbiAoSVN5bmNNZXNzYWdlc0RpcmVjdGlvbikge1xuICAgIElTeW5jTWVzc2FnZXNEaXJlY3Rpb25bSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltcIkluYm91bmRcIl0gPSAnSW5ib3VuZCddID0gXCJJbmJvdW5kXCI7XG4gICAgSVN5bmNNZXNzYWdlc0RpcmVjdGlvbltJU3luY01lc3NhZ2VzRGlyZWN0aW9uW1wiT3V0Ym91bmRcIl0gPSAnT3V0Ym91bmQnXSA9IFwiT3V0Ym91bmRcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc0RpcmVjdGlvbiB8fCAoZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzRGlyZWN0aW9uID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGUpIHtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiRmF4XCJdID0gJ0ZheCddID0gXCJGYXhcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiU01TXCJdID0gJ1NNUyddID0gXCJTTVNcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVm9pY2VNYWlsXCJdID0gJ1ZvaWNlTWFpbCddID0gXCJWb2ljZU1haWxcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiUGFnZXJcIl0gPSAnUGFnZXInXSA9IFwiUGFnZXJcIjtcbiAgICBJU3luY01lc3NhZ2VzTWVzc2FnZVR5cGVbSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlW1wiVGV4dFwiXSA9ICdUZXh0J10gPSBcIlRleHRcIjtcbn0pKGV4cG9ydHMuSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlIHx8IChleHBvcnRzLklTeW5jTWVzc2FnZXNNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgSVN5bmNNZXNzYWdlc01lc3NhZ2VUeXBlID0gZXhwb3J0cy5JU3luY01lc3NhZ2VzTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKElTeW5jTWVzc2FnZXNTeW5jVHlwZSkge1xuICAgIElTeW5jTWVzc2FnZXNTeW5jVHlwZVtJU3luY01lc3NhZ2VzU3luY1R5cGVbXCJGU3luY1wiXSA9ICdGU3luYyddID0gXCJGU3luY1wiO1xuICAgIElTeW5jTWVzc2FnZXNTeW5jVHlwZVtJU3luY01lc3NhZ2VzU3luY1R5cGVbXCJJU3luY1wiXSA9ICdJU3luYyddID0gXCJJU3luY1wiO1xufSkoZXhwb3J0cy5JU3luY01lc3NhZ2VzU3luY1R5cGUgfHwgKGV4cG9ydHMuSVN5bmNNZXNzYWdlc1N5bmNUeXBlID0ge30pKTtcbnZhciBJU3luY01lc3NhZ2VzU3luY1R5cGUgPSBleHBvcnRzLklTeW5jTWVzc2FnZXNTeW5jVHlwZTtcblxuXG4vKioqLyB9LFxuLyogNzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWF0dGFjaG1lbnRpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG52YXIgbWVzc2FnZXN0b3JlY2FsbGVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xudmFyIE1lc3NhZ2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdhdHRhY2htZW50cycsIENsYXNzOiBtZXNzYWdlYXR0YWNobWVudGluZm8uTWVzc2FnZUF0dGFjaG1lbnRJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2F2YWlsYWJpbGl0eScsIENsYXNzOiBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udmVyc2F0aW9uSWQnLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NyZWF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZGVsaXZlcnlFcnJvckNvZGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RpcmVjdGlvbicsIENsYXNzOiBNZXNzYWdlSW5mb0RpcmVjdGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4UGFnZUNvdW50JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmYXhSZXNvbHV0aW9uJywgQ2xhc3M6IE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbiwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZnJvbScsIENsYXNzOiBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhc3RNb2RpZmllZFRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ21lc3NhZ2VTdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwZ1RvRGVwYXJ0bWVudCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByaW9yaXR5JywgQ2xhc3M6IE1lc3NhZ2VJbmZvUHJpb3JpdHksIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlYWRTdGF0dXMnLCBDbGFzczogTWVzc2FnZUluZm9SZWFkU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzbXNEZWxpdmVyeVRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Ntc1NlbmRpbmdBdHRlbXB0c0NvdW50JywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdWJqZWN0JywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd0bycsIENsYXNzOiBtZXNzYWdlc3RvcmVjYWxsZXJpbmZvLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNZXNzYWdlSW5mb1R5cGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ZtVHJhbnNjcmlwdGlvblN0YXR1cycsIENsYXNzOiBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTWVzc2FnZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5NZXNzYWdlSW5mbyA9IE1lc3NhZ2VJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSkge1xuICAgIE1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W01lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5W1wiQWxpdmVcIl0gPSAnQWxpdmUnXSA9IFwiQWxpdmVcIjtcbiAgICBNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtNZXNzYWdlSW5mb0F2YWlsYWJpbGl0eVtcIkRlbGV0ZWRcIl0gPSAnRGVsZXRlZCddID0gXCJEZWxldGVkXCI7XG4gICAgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbTWVzc2FnZUluZm9BdmFpbGFiaWxpdHlbXCJQdXJnZWRcIl0gPSAnUHVyZ2VkJ10gPSBcIlB1cmdlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb0F2YWlsYWJpbGl0eSA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9BdmFpbGFiaWxpdHkgPSBleHBvcnRzLk1lc3NhZ2VJbmZvQXZhaWxhYmlsaXR5O1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb0RpcmVjdGlvbikge1xuICAgIE1lc3NhZ2VJbmZvRGlyZWN0aW9uW01lc3NhZ2VJbmZvRGlyZWN0aW9uW1wiSW5ib3VuZFwiXSA9ICdJbmJvdW5kJ10gPSBcIkluYm91bmRcIjtcbiAgICBNZXNzYWdlSW5mb0RpcmVjdGlvbltNZXNzYWdlSW5mb0RpcmVjdGlvbltcIk91dGJvdW5kXCJdID0gJ091dGJvdW5kJ10gPSBcIk91dGJvdW5kXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvRGlyZWN0aW9uID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0RpcmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZUluZm9EaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbikge1xuICAgIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bXCJIaWdoXCJdID0gJ0hpZ2gnXSA9IFwiSGlnaFwiO1xuICAgIE1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbltNZXNzYWdlSW5mb0ZheFJlc29sdXRpb25bXCJMb3dcIl0gPSAnTG93J10gPSBcIkxvd1wiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9GYXhSZXNvbHV0aW9uID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb0ZheFJlc29sdXRpb24gPSBleHBvcnRzLk1lc3NhZ2VJbmZvRmF4UmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzKSB7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlF1ZXVlZFwiXSA9ICdRdWV1ZWQnXSA9IFwiUXVldWVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJlZFwiXSA9ICdEZWxpdmVyZWQnXSA9IFwiRGVsaXZlcmVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIkRlbGl2ZXJ5RmFpbGVkXCJdID0gJ0RlbGl2ZXJ5RmFpbGVkJ10gPSBcIkRlbGl2ZXJ5RmFpbGVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbmRpbmdGYWlsZWRcIl0gPSAnU2VuZGluZ0ZhaWxlZCddID0gXCJTZW5kaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1c1tcIlJlY2VpdmVkXCJdID0gJ1JlY2VpdmVkJ10gPSBcIlJlY2VpdmVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb01lc3NhZ2VTdGF0dXMgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvTWVzc2FnZVN0YXR1cyA9IGV4cG9ydHMuTWVzc2FnZUluZm9NZXNzYWdlU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1ByaW9yaXR5KSB7XG4gICAgTWVzc2FnZUluZm9Qcmlvcml0eVtNZXNzYWdlSW5mb1ByaW9yaXR5W1wiTm9ybWFsXCJdID0gJ05vcm1hbCddID0gXCJOb3JtYWxcIjtcbiAgICBNZXNzYWdlSW5mb1ByaW9yaXR5W01lc3NhZ2VJbmZvUHJpb3JpdHlbXCJIaWdoXCJdID0gJ0hpZ2gnXSA9IFwiSGlnaFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1ByaW9yaXR5IHx8IChleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHkgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvUHJpb3JpdHkgPSBleHBvcnRzLk1lc3NhZ2VJbmZvUHJpb3JpdHk7XG4oZnVuY3Rpb24gKE1lc3NhZ2VJbmZvUmVhZFN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvUmVhZFN0YXR1c1tNZXNzYWdlSW5mb1JlYWRTdGF0dXNbXCJSZWFkXCJdID0gJ1JlYWQnXSA9IFwiUmVhZFwiO1xuICAgIE1lc3NhZ2VJbmZvUmVhZFN0YXR1c1tNZXNzYWdlSW5mb1JlYWRTdGF0dXNbXCJVbnJlYWRcIl0gPSAnVW5yZWFkJ10gPSBcIlVucmVhZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1JlYWRTdGF0dXMgfHwgKGV4cG9ydHMuTWVzc2FnZUluZm9SZWFkU3RhdHVzID0ge30pKTtcbnZhciBNZXNzYWdlSW5mb1JlYWRTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvUmVhZFN0YXR1cztcbihmdW5jdGlvbiAoTWVzc2FnZUluZm9UeXBlKSB7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIkZheFwiXSA9ICdGYXgnXSA9IFwiRmF4XCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlNNU1wiXSA9ICdTTVMnXSA9IFwiU01TXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlZvaWNlTWFpbFwiXSA9ICdWb2ljZU1haWwnXSA9IFwiVm9pY2VNYWlsXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlBhZ2VyXCJdID0gJ1BhZ2VyJ10gPSBcIlBhZ2VyXCI7XG4gICAgTWVzc2FnZUluZm9UeXBlW01lc3NhZ2VJbmZvVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG59KShleHBvcnRzLk1lc3NhZ2VJbmZvVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VJbmZvVHlwZSA9IGV4cG9ydHMuTWVzc2FnZUluZm9UeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cykge1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiTm90QXZhaWxhYmxlXCJdID0gJ05vdEF2YWlsYWJsZSddID0gXCJOb3RBdmFpbGFibGVcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJUaW1lZE91dFwiXSA9ICdUaW1lZE91dCddID0gXCJUaW1lZE91dFwiO1xuICAgIE1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW01lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzW1wiQ29tcGxldGVkXCJdID0gJ0NvbXBsZXRlZCddID0gXCJDb21wbGV0ZWRcIjtcbiAgICBNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tNZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1c1tcIkNvbXBsZXRlZFBhcnRpYWxseVwiXSA9ICdDb21wbGV0ZWRQYXJ0aWFsbHknXSA9IFwiQ29tcGxldGVkUGFydGlhbGx5XCI7XG4gICAgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXNbXCJGYWlsZWRcIl0gPSAnRmFpbGVkJ10gPSBcIkZhaWxlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlSW5mb1ZtVHJhbnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZUluZm9WbVRyYW5zY3JpcHRpb25TdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VJbmZvVm1UcmFuc2NyaXB0aW9uU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA3OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNZXNzYWdlQXR0YWNobWVudEluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQXR0YWNobWVudEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUF0dGFjaG1lbnRJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3R5cGUnLCBDbGFzczogTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZSwgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY29udGVudFR5cGUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ZtRHVyYXRpb24nLCBDbGFzczogbnVsbCAvKiBudW1iZXIgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlQXR0YWNobWVudEluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VBdHRhY2htZW50SW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZUF0dGFjaG1lbnRJbmZvID0gTWVzc2FnZUF0dGFjaG1lbnRJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlKSB7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiQXVkaW9SZWNvcmRpbmdcIl0gPSAnQXVkaW9SZWNvcmRpbmcnXSA9IFwiQXVkaW9SZWNvcmRpbmdcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJBdWRpb1RyYW5zY3JpcHRpb25cIl0gPSAnQXVkaW9UcmFuc2NyaXB0aW9uJ10gPSBcIkF1ZGlvVHJhbnNjcmlwdGlvblwiO1xuICAgIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtcIlRleHRcIl0gPSAnVGV4dCddID0gXCJUZXh0XCI7XG4gICAgTWVzc2FnZUF0dGFjaG1lbnRJbmZvVHlwZVtNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW1wiU291cmNlRG9jdW1lbnRcIl0gPSAnU291cmNlRG9jdW1lbnQnXSA9IFwiU291cmNlRG9jdW1lbnRcIjtcbiAgICBNZXNzYWdlQXR0YWNobWVudEluZm9UeXBlW01lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGVbXCJSZW5kZXJlZERvY3VtZW50XCJdID0gJ1JlbmRlcmVkRG9jdW1lbnQnXSA9IFwiUmVuZGVyZWREb2N1bWVudFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlQXR0YWNobWVudEluZm9UeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgPSB7fSkpO1xudmFyIE1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGUgPSBleHBvcnRzLk1lc3NhZ2VBdHRhY2htZW50SW5mb1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDgwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VTdG9yZUNhbGxlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdsb2NhdGlvbicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbWVzc2FnZVN0YXR1cycsIENsYXNzOiBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZmF4RXJyb3JDb2RlJywgQ2xhc3M6IE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3Bob25lTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VTdG9yZUNhbGxlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VTdG9yZUNhbGxlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm8gPSBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cykge1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiUXVldWVkXCJdID0gJ1F1ZXVlZCddID0gXCJRdWV1ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbnRcIl0gPSAnU2VudCddID0gXCJTZW50XCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJEZWxpdmVyZWRcIl0gPSAnRGVsaXZlcmVkJ10gPSBcIkRlbGl2ZXJlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW01lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzW1wiRGVsaXZlcnlGYWlsZWRcIl0gPSAnRGVsaXZlcnlGYWlsZWQnXSA9IFwiRGVsaXZlcnlGYWlsZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tNZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1c1tcIlNlbmRpbmdGYWlsZWRcIl0gPSAnU2VuZGluZ0ZhaWxlZCddID0gXCJTZW5kaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXNbXCJSZWNlaXZlZFwiXSA9ICdSZWNlaXZlZCddID0gXCJSZWNlaXZlZFwiO1xufSkoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyB8fCAoZXhwb3J0cy5NZXNzYWdlU3RvcmVDYWxsZXJJbmZvTWVzc2FnZVN0YXR1cyA9IHt9KSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb01lc3NhZ2VTdGF0dXMgPSBleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9NZXNzYWdlU3RhdHVzO1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlKSB7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVW5kZWZpbmVkXCJdID0gJ1VuZGVmaW5lZCddID0gXCJVbmRlZmluZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJOb0ZheFNlbmRQZXJtaXNzaW9uXCJdID0gJ05vRmF4U2VuZFBlcm1pc3Npb24nXSA9IFwiTm9GYXhTZW5kUGVybWlzc2lvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vSW50ZXJuYXRpb25hbFBlcm1pc3Npb25cIl0gPSAnTm9JbnRlcm5hdGlvbmFsUGVybWlzc2lvbiddID0gXCJOb0ludGVybmF0aW9uYWxQZXJtaXNzaW9uXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiTm9GYXhNYWNoaW5lXCJdID0gJ05vRmF4TWFjaGluZSddID0gXCJOb0ZheE1hY2hpbmVcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJPdXRnb2luZ0NhbGxFcnJvclwiXSA9ICdPdXRnb2luZ0NhbGxFcnJvciddID0gXCJPdXRnb2luZ0NhbGxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlJlbmRlcmluZ0ZhaWxlZFwiXSA9ICdSZW5kZXJpbmdGYWlsZWQnXSA9IFwiUmVuZGVyaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiVG9vTWFueVBhZ2VzXCJdID0gJ1Rvb01hbnlQYWdlcyddID0gXCJUb29NYW55UGFnZXNcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJSZXR1cm5Ub0RCUXVldWVcIl0gPSAnUmV0dXJuVG9EQlF1ZXVlJ10gPSBcIlJldHVyblRvREJRdWV1ZVwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIk5vQ2FsbFRpbWVcIl0gPSAnTm9DYWxsVGltZSddID0gXCJOb0NhbGxUaW1lXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiV3JvbmdOdW1iZXJcIl0gPSAnV3JvbmdOdW1iZXInXSA9IFwiV3JvbmdOdW1iZXJcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJQcm9oaWJpdGVkTnVtYmVyXCJdID0gJ1Byb2hpYml0ZWROdW1iZXInXSA9IFwiUHJvaGliaXRlZE51bWJlclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSAnSW50ZXJuYWxFcnJvciddID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiRmF4U2VuZGluZ1Byb2hpYml0ZWRcIl0gPSAnRmF4U2VuZGluZ1Byb2hpYml0ZWQnXSA9IFwiRmF4U2VuZGluZ1Byb2hpYml0ZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJUaGVQaG9uZUlzQmxhY2tsaXN0ZWRcIl0gPSAnVGhlUGhvbmVJc0JsYWNrbGlzdGVkJ10gPSBcIlRoZVBob25lSXNCbGFja2xpc3RlZFwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlVzZXJOb3RGb3VuZFwiXSA9ICdVc2VyTm90Rm91bmQnXSA9IFwiVXNlck5vdEZvdW5kXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiQ29udmVydEVycm9yXCJdID0gJ0NvbnZlcnRFcnJvciddID0gXCJDb252ZXJ0RXJyb3JcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJEQkdlbmVyYWxFcnJvclwiXSA9ICdEQkdlbmVyYWxFcnJvciddID0gXCJEQkdlbmVyYWxFcnJvclwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIlNreXBlQmlsbGluZ0ZhaWxlZFwiXSA9ICdTa3lwZUJpbGxpbmdGYWlsZWQnXSA9IFwiU2t5cGVCaWxsaW5nRmFpbGVkXCI7XG4gICAgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW1wiQWNjb3VudFN1c3BlbmRlZFwiXSA9ICdBY2NvdW50U3VzcGVuZGVkJ10gPSBcIkFjY291bnRTdXNwZW5kZWRcIjtcbiAgICBNZXNzYWdlU3RvcmVDYWxsZXJJbmZvRmF4RXJyb3JDb2RlW01lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbXCJQcm9oaWJpdGVkRGVzdGluYXRpb25cIl0gPSAnUHJvaGliaXRlZERlc3RpbmF0aW9uJ10gPSBcIlByb2hpYml0ZWREZXN0aW5hdGlvblwiO1xuICAgIE1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGVbTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZVtcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG59KShleHBvcnRzLk1lc3NhZ2VTdG9yZUNhbGxlckluZm9GYXhFcnJvckNvZGUgfHwgKGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZSA9IGV4cG9ydHMuTWVzc2FnZVN0b3JlQ2FsbGVySW5mb0ZheEVycm9yQ29kZTtcblxuXG4vKioqLyB9LFxuLyogODEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbWVzc2FnZWluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciBuYXZpZ2F0aW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHBhZ2luZ2luZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbnZhciBNZXNzYWdlTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VMaXN0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTWVzc2FnZUxpc3QucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVjb3JkcycsIENsYXNzOiBtZXNzYWdlaW5mby5NZXNzYWdlSW5mbywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ25hdmlnYXRpb24nLCBDbGFzczogbmF2aWdhdGlvbmluZm8uTmF2aWdhdGlvbkluZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZUxpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNZXNzYWdlTGlzdCc7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUxpc3Q7XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VMaXN0ID0gTWVzc2FnZUxpc3Q7XG5cblxuLyoqKi8gfSxcbi8qIDgyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1lc3NhZ2VpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG52YXIgbWVzc2FnZXNzeW5jaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xudmFyIE1lc3NhZ2VTeW5jID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVzc2FnZVN5bmMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVN5bmMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNZXNzYWdlU3luYy5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IG1lc3NhZ2VpbmZvLk1lc3NhZ2VJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY0luZm8nLCBDbGFzczogbWVzc2FnZXNzeW5jaW5mby5NZXNzYWdlc1N5bmNJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNZXNzYWdlU3luYy5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VTeW5jJztcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlU3luYztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTWVzc2FnZVN5bmMgPSBNZXNzYWdlU3luYztcblxuXG4vKioqLyB9LFxuLyogODMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgTWVzc2FnZXNTeW5jSW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2VzU3luY0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZXNTeW5jSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1lc3NhZ2VzU3luY0luZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3luY1R5cGUnLCBDbGFzczogTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzeW5jVG9rZW4nLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3N5bmNUaW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTWVzc2FnZXNTeW5jSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ01lc3NhZ2VzU3luY0luZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VzU3luY0luZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1lc3NhZ2VzU3luY0luZm8gPSBNZXNzYWdlc1N5bmNJbmZvO1xuKGZ1bmN0aW9uIChNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGUpIHtcbiAgICBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW1wiRlN5bmNcIl0gPSAnRlN5bmMnXSA9IFwiRlN5bmNcIjtcbiAgICBNZXNzYWdlc1N5bmNJbmZvU3luY1R5cGVbTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlW1wiSVN5bmNcIl0gPSAnSVN5bmMnXSA9IFwiSVN5bmNcIjtcbn0pKGV4cG9ydHMuTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VzU3luY0luZm9TeW5jVHlwZSA9IHt9KSk7XG52YXIgTWVzc2FnZXNTeW5jSW5mb1N5bmNUeXBlID0gZXhwb3J0cy5NZXNzYWdlc1N5bmNJbmZvU3luY1R5cGU7XG5cblxuLyoqKi8gfSxcbi8qIDg0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcbnZhciBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+Q3JlYXRlcyBhIG5ldyBzdWJzY3JpcHRpb24uIFRvIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBBUE5TIHRyYW5zcG9ydCB0eXBlIHlvdSBoYXZlIHRvIHNwZWNpZnkgZW5kcG9pbnRfaWQgYXR0cmlidXRlIGluIGdldCB0b2tlbiByZXF1ZXN0IGF0IGF1dGhvcml6YXRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL3N1YnNjcmlwdGlvbicsIG9wdGlvbnMsIGV4cG9ydHMuY3JlYXRlT3B0aW9ucyksIGdldHN1YnNjcmlwdGlvbmluZm9yZXNwb25zZS5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IFN1YnNjcmlwdGlvblxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjYgKFJlbGVhc2UgNS4xNSk8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgcmVxdWVzdGVkIHN1YnNjcmlwdGlvbi48L3A+XG4gICAgICogPGg0PlVzYWdlIFBsYW4gR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9zdWJzY3JpcHRpb24ve3N1YnNjcmlwdGlvbklkfScsIG9wdGlvbnMsIGV4cG9ydHMubG9hZE9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmV3IFN1YnNjcmlwdGlvbiAvIE1vZGlmeSBFdmVudCBGaWx0ZXJzXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuNiAoUmVsZWFzZSA1LjE1KTwvcD5cbiAgICAgKiA8cD5XaXRoIGVtcHR5IHJlcXVlc3QgYm9keSAtIHJlbmV3cyB0aGUgZXhpc3RlbnQgc3Vic2NyaXB0aW9uLiBJZiBldmVudCBmaWx0ZXJzIHNwZWNpZmllZCAtIG1vZGlmaWVzIHRoZSBldmVudCBmaWx0ZXJzIGZvciB0aGUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uLiBUaGUgY2xpZW50IGFwcGxpY2F0aW9uIGNhbiBleHRlbmQgb3IgbmFycm93IHRoZSBldmVudHMgZm9yIHdoaWNoIGl0IHJlY2VpdmVzIG5vdGlmaWNhdGlvbnMgaW4gdGhlIGZyYW1lXG4gICAgICogICAgIG9mIG9uZSBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUFVUJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLnVwZGF0ZU9wdGlvbnMpLCBnZXRzdWJzY3JpcHRpb25pbmZvcmVzcG9uc2UuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbCBTdWJzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD5DYW5jZWxzIHRoZSBleGlzdGVudCBzdWJzY3JpcHRpb24uPC9wPlxuICAgICAqIDxoND5Vc2FnZSBQbGFuIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbkFQSS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnREVMRVRFJywgJy9yZXN0YXBpL3YxLjAvc3Vic2NyaXB0aW9uL3tzdWJzY3JpcHRpb25JZH0nLCBvcHRpb25zLCBleHBvcnRzLnJlbW92ZU9wdGlvbnMpLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25BUEkgPSBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uQVBJO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGNyZWF0ZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVzdWJzY3JpcHRpb25yZXF1ZXN0LkNyZWF0ZVN1YnNjcmlwdGlvblJlcXVlc3RcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBsb2FkIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxvYWRPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwic3Vic2NyaXB0aW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdXBkYXRlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kaWZ5c3Vic2NyaXB0aW9ucmVxdWVzdC5Nb2RpZnlTdWJzY3JpcHRpb25SZXF1ZXN0XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgcmVtb3ZlIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnJlbW92ZU9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpcHRpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogODUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgbm90aWZpY2F0aW9uZGVsaXZlcnltb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XG52YXIgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdldmVudEZpbHRlcnMnLCBDbGFzczogbnVsbCAvKiBzdHJpbmdbXSAqLywgaXNBcnJheTogdHJ1ZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHBpcmF0aW9uVGltZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZXhwaXJlc0luJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjcmVhdGlvblRpbWUnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RlbGl2ZXJ5TW9kZScsIENsYXNzOiBub3RpZmljYXRpb25kZWxpdmVyeW1vZGUuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2UnO1xuICAgIH07XG4gICAgcmV0dXJuIEdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZTtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlID0gR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlO1xuKGZ1bmN0aW9uIChHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXMpIHtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW1wiQWN0aXZlXCJdID0gJ0FjdGl2ZSddID0gXCJBY3RpdmVcIjtcbiAgICBHZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXNbR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzW1wiU3VzcGVuZGVkXCJdID0gJ1N1c3BlbmRlZCddID0gXCJTdXNwZW5kZWRcIjtcbn0pKGV4cG9ydHMuR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzIHx8IChleHBvcnRzLkdldFN1YnNjcmlwdGlvbkluZm9SZXNwb25zZVN0YXR1cyA9IHt9KSk7XG52YXIgR2V0U3Vic2NyaXB0aW9uSW5mb1Jlc3BvbnNlU3RhdHVzID0gZXhwb3J0cy5HZXRTdWJzY3JpcHRpb25JbmZvUmVzcG9uc2VTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDg2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGUucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHJhbnNwb3J0VHlwZScsIENsYXNzOiBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2VuY3J5cHRpb24nLCBDbGFzczogbnVsbCAvKiBib29sZWFuICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FkZHJlc3MnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnc3Vic2NyaWJlcktleScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbkFsZ29yaXRobScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnZW5jcnlwdGlvbktleScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncmVnaXN0cmF0aW9uSWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2NlcnRpZmljYXRlTmFtZScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZSc7XG4gICAgfTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25EZWxpdmVyeU1vZGUgPSBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGU7XG4oZnVuY3Rpb24gKE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUpIHtcbiAgICBOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlW05vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbXCJQdWJOdWJcIl0gPSAnUHViTnViJ10gPSBcIlB1Yk51YlwiO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIkFQTlNcIl0gPSAnQVBOUyddID0gXCJBUE5TXCI7XG4gICAgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtOb3RpZmljYXRpb25EZWxpdmVyeU1vZGVUcmFuc3BvcnRUeXBlWydQdWJOdWIvQVBOUy9Wb0lQJ10gPSAnUHViTnViL0FQTlMvVm9JUCddID0gJ1B1Yk51Yi9BUE5TL1ZvSVAnO1xuICAgIE5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGVbTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZVtcIldlYkhvb2tcIl0gPSAnV2ViSG9vayddID0gXCJXZWJIb29rXCI7XG59KShleHBvcnRzLk5vdGlmaWNhdGlvbkRlbGl2ZXJ5TW9kZVRyYW5zcG9ydFR5cGUgfHwgKGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSA9IHt9KSk7XG52YXIgTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uRGVsaXZlcnlNb2RlVHJhbnNwb3J0VHlwZTtcblxuXG4vKioqLyB9LFxuLyogODcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHByZXNlbmNlaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xudmFyIG1vbml0b3JlZGV4dGVuc2lvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcbnZhciBQcmVzZW5jZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByZXNlbmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEV4dGVuc2lvbihzKSBQcmVzZW5jZSBTdGF0dXMgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4yPC9wPlxuICAgICAqIDxwPlJldHVybnMgcHJlc2VuY2Ugc3RhdHVzIG9mIGFuIGV4dGVuc2lvbiBvciBzZXZlcmFsIGV4dGVuc2lvbnMgYnkgdGhlaXIgSUQocykuIEJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLCBzZWUgQmF0Y2ggUmVxdWVzdHMgZm9yIGRldGFpbHMuVGhlIHByZXNlbmNlU3RhdHVzIGlzIHJldHVybmVkIGFzIE9mZmxpbmUgKHRoZSBwYXJhbWV0ZXJzIHRlbGVwaG9ueVN0YXR1cywgbWVzc2FnZSwgdXNlclN0YXR1cyBhbmQgZG5kU3RhdHVzIGFyZSBub3RcbiAgICAgKiAgICAgcmV0dXJuZWQgYXQgYWxsKSBmb3IgdGhlIGZvbGxvd2luZyBleHRlbnNpb24gdHlwZXM6IERlcGFydG1lbnQvQW5ub3VuY2VtZW50IE9ubHkvVGFrZSBNZXNzYWdlcyBPbmx5IChWb2ljZW1haWwpL0ZheCBVc2VyL1BhZ2luZyBPbmx5IEdyb3VwL1NoYXJlZCBMaW5lcyBHcm91cC9JVlIgTWVudS9BcHBsaWNhdGlvbiBFeHRlbnNpb24vUGFyayBMb2NhdGlvbi5JZiB0aGUgdXNlciByZXF1ZXN0cyBoaXMvaGVyIG93biBwcmVzZW5jZSBzdGF0dXMsXG4gICAgICogICAgIHRoZSByZXNwb25zZSBjb250YWlucyBhY3R1YWwgcHJlc2VuY2Ugc3RhdHVzIGV2ZW4gaWYgdGhlIHN0YXR1cyBwdWJsaWNhdGlvbiBpcyB0dXJuZWQgb2ZmLkJhdGNoIHJlcXVlc3QgaXMgc3VwcG9ydGVkLiBGb3IgYmF0Y2ggcmVxdWVzdHMgdGhlIG51bWJlciBvZiBleHRlbnNpb25zIGluIG9uZSByZXF1ZXN0IGlzIGxpbWl0ZWQgdG8gMzAuIElmIG1vcmUgZXh0ZW5zaW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QsIHRoZVxuICAgICAqICAgICBlcnJvciBjb2RlIDQwMCBCYWQgUmVxdWVzdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBsb2dpY2FsIGVycm9yIGNvZGUgSW52YWxpZE11bHRpcGFydFJlcXVlc3QgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2UgJ0V4dGVuc2lvbiBQcmVzZW5jZSBJbmZvIG11bHRpcGFydCByZXF1ZXN0IGlzIGxpbWl0ZWQgdG8gMzAgZXh0ZW5zaW9ucycuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkUHJlc2VuY2U8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5HZXR0aW5nIHVzZXIgcHJlc2VuY2UgaW5mb3JtYXRpb248L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIFByZXNlbmNlLnByb3RvdHlwZS5nZXRQcmVzZW5jZVN0YXR1cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcHJlc2VuY2UnLCBvcHRpb25zLCBleHBvcnRzLmdldFByZXNlbmNlU3RhdHVzT3B0aW9ucyksIHByZXNlbmNlaW5mby5QcmVzZW5jZUluZm8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IE1vbml0b3JlZCBFeHRlbnNpb25zXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz5TaW5jZSAxLjAuMTMgKFJlbGVhc2UgNi41KTwvcD5cbiAgICAgKiA8cD5SZXR1cm5zIGxpc3Qgb2YgbGluZXMgLSBleHRlbnNpb25zIHdoaWNoIHByZXNlbmNlIHN0YXR1cyBjYW4gYmUgaW5kaWNhdGVkIGFuZCBtb25pdG9yZWQgb24gQkxGLWVuYWJsZWQgKEJ1c3kgTGFtcCBGaWVsZCkgZGV2aWNlcy48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRQcmVzZW5jZTwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPkdldHRpbmcgdXNlciBwcmVzZW5jZSBpbmZvcm1hdGlvbjwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnR0VUJywgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC97YWNjb3VudElkfS9leHRlbnNpb24ve2V4dGVuc2lvbklkfS9wcmVzZW5jZS9saW5lJywgb3B0aW9ucywgZXhwb3J0cy5saXN0TW9uaXRvcmVkRXh0ZW5zaW9uc09wdGlvbnMpLCBtb25pdG9yZWRleHRlbnNpb25zLk1vbml0b3JlZEV4dGVuc2lvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZXNlbmNlO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLlByZXNlbmNlID0gUHJlc2VuY2U7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgZ2V0UHJlc2VuY2VTdGF0dXMgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZ2V0UHJlc2VuY2VTdGF0dXNPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGxpc3RNb25pdG9yZWRFeHRlbnNpb25zIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RNb25pdG9yZWRFeHRlbnNpb25zT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogODggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgcHJlc2VuY2VleHRlbnNpb25pbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG52YXIgUHJlc2VuY2VJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlc2VuY2VJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZXNlbmNlSW5mbygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFByZXNlbmNlSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2FsbG93U2VlTXlQcmVzZW5jZScsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2RuZFN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9EbmRTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbicsIENsYXNzOiBwcmVzZW5jZWV4dGVuc2lvbmluZm8uUHJlc2VuY2VFeHRlbnNpb25JbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdtZXNzYWdlJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaWNrVXBDYWxsc09uSG9sZCcsIENsYXNzOiBudWxsIC8qIGJvb2xlYW4gKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3ByZXNlbmNlU3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyaW5nT25Nb25pdG9yZWRDYWxsJywgQ2xhc3M6IG51bGwgLyogYm9vbGVhbiAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndGVsZXBob255U3RhdHVzJywgQ2xhc3M6IFByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXNlclN0YXR1cycsIENsYXNzOiBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUHJlc2VuY2VJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUHJlc2VuY2VJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZUluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLlByZXNlbmNlSW5mbyA9IFByZXNlbmNlSW5mbztcbihmdW5jdGlvbiAoUHJlc2VuY2VJbmZvRG5kU3RhdHVzKSB7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIlRha2VBbGxDYWxsc1wiXSA9ICdUYWtlQWxsQ2FsbHMnXSA9IFwiVGFrZUFsbENhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIkRvTm90QWNjZXB0QW55Q2FsbHNcIl0gPSAnRG9Ob3RBY2NlcHRBbnlDYWxscyddID0gXCJEb05vdEFjY2VwdEFueUNhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIkRvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzXCJdID0gJ0RvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzJ10gPSBcIkRvTm90QWNjZXB0RGVwYXJ0bWVudENhbGxzXCI7XG4gICAgUHJlc2VuY2VJbmZvRG5kU3RhdHVzW1ByZXNlbmNlSW5mb0RuZFN0YXR1c1tcIlRha2VEZXBhcnRtZW50Q2FsbHNPbmx5XCJdID0gJ1Rha2VEZXBhcnRtZW50Q2FsbHNPbmx5J10gPSBcIlRha2VEZXBhcnRtZW50Q2FsbHNPbmx5XCI7XG59KShleHBvcnRzLlByZXNlbmNlSW5mb0RuZFN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9EbmRTdGF0dXMgPSB7fSkpO1xudmFyIFByZXNlbmNlSW5mb0RuZFN0YXR1cyA9IGV4cG9ydHMuUHJlc2VuY2VJbmZvRG5kU3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cykge1xuICAgIFByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1ByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzW1wiT2ZmbGluZVwiXSA9ICdPZmZsaW5lJ10gPSBcIk9mZmxpbmVcIjtcbiAgICBQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tQcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXNbXCJBdmFpbGFibGVcIl0gPSAnQXZhaWxhYmxlJ10gPSBcIkF2YWlsYWJsZVwiO1xufSkoZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9QcmVzZW5jZVN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvUHJlc2VuY2VTdGF0dXMgPSBleHBvcnRzLlByZXNlbmNlSW5mb1ByZXNlbmNlU3RhdHVzO1xuKGZ1bmN0aW9uIChQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiTm9DYWxsXCJdID0gJ05vQ2FsbCddID0gXCJOb0NhbGxcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiQ2FsbENvbm5lY3RlZFwiXSA9ICdDYWxsQ29ubmVjdGVkJ10gPSBcIkNhbGxDb25uZWN0ZWRcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiUmluZ2luZ1wiXSA9ICdSaW5naW5nJ10gPSBcIlJpbmdpbmdcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiT25Ib2xkXCJdID0gJ09uSG9sZCddID0gXCJPbkhvbGRcIjtcbiAgICBQcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXNbUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzW1wiUGFya2VkQ2FsbFwiXSA9ICdQYXJrZWRDYWxsJ10gPSBcIlBhcmtlZENhbGxcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzIHx8IChleHBvcnRzLlByZXNlbmNlSW5mb1RlbGVwaG9ueVN0YXR1cyA9IHt9KSk7XG52YXIgUHJlc2VuY2VJbmZvVGVsZXBob255U3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9UZWxlcGhvbnlTdGF0dXM7XG4oZnVuY3Rpb24gKFByZXNlbmNlSW5mb1VzZXJTdGF0dXMpIHtcbiAgICBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1ByZXNlbmNlSW5mb1VzZXJTdGF0dXNbXCJPZmZsaW5lXCJdID0gJ09mZmxpbmUnXSA9IFwiT2ZmbGluZVwiO1xuICAgIFByZXNlbmNlSW5mb1VzZXJTdGF0dXNbUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUHJlc2VuY2VJbmZvVXNlclN0YXR1c1tQcmVzZW5jZUluZm9Vc2VyU3RhdHVzW1wiQXZhaWxhYmxlXCJdID0gJ0F2YWlsYWJsZSddID0gXCJBdmFpbGFibGVcIjtcbn0pKGV4cG9ydHMuUHJlc2VuY2VJbmZvVXNlclN0YXR1cyB8fCAoZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzID0ge30pKTtcbnZhciBQcmVzZW5jZUluZm9Vc2VyU3RhdHVzID0gZXhwb3J0cy5QcmVzZW5jZUluZm9Vc2VyU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA4OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQcmVzZW5jZUV4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVzZW5jZUV4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgUHJlc2VuY2VFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFByZXNlbmNlRXh0ZW5zaW9uSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1ByZXNlbmNlRXh0ZW5zaW9uSW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VFeHRlbnNpb25JbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5QcmVzZW5jZUV4dGVuc2lvbkluZm8gPSBQcmVzZW5jZUV4dGVuc2lvbkluZm87XG5cblxuLyoqKi8gfSxcbi8qIDkwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGxpbmVpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgTW9uaXRvcmVkRXh0ZW5zaW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbml0b3JlZEV4dGVuc2lvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcmVkRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE1vbml0b3JlZEV4dGVuc2lvbnMucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGxpbmVpbmZvLkxpbmVJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBNb25pdG9yZWRFeHRlbnNpb25zLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9uaXRvcmVkRXh0ZW5zaW9ucyc7XG4gICAgfTtcbiAgICByZXR1cm4gTW9uaXRvcmVkRXh0ZW5zaW9ucztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuTW9uaXRvcmVkRXh0ZW5zaW9ucyA9IE1vbml0b3JlZEV4dGVuc2lvbnM7XG5cblxuLyoqKi8gfSxcbi8qIDkxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIG1vbml0b3JlZGxpbmVzZXh0ZW5zaW9uaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xudmFyIExpbmVJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZUluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZUluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdpZCcsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndXJpJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdleHRlbnNpb24nLCBDbGFzczogbW9uaXRvcmVkbGluZXNleHRlbnNpb25pbmZvLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIExpbmVJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTGluZUluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmVJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5MaW5lSW5mbyA9IExpbmVJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiA5MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2V4dGVuc2lvbk51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAndHlwZScsIENsYXNzOiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbyA9IE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mbztcbihmdW5jdGlvbiAoTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSkge1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlVzZXJcIl0gPSAnVXNlciddID0gXCJVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRmF4VXNlclwiXSA9ICdGYXhVc2VyJ10gPSBcIkZheFVzZXJcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJWaXJ0dWFsVXNlclwiXSA9ICdWaXJ0dWFsVXNlciddID0gXCJWaXJ0dWFsVXNlclwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIkRpZ2l0YWxVc2VyXCJdID0gJ0RpZ2l0YWxVc2VyJ10gPSBcIkRpZ2l0YWxVc2VyXCI7XG4gICAgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW1wiRGVwYXJ0bWVudFwiXSA9ICdEZXBhcnRtZW50J10gPSBcIkRlcGFydG1lbnRcIjtcbiAgICBNb25pdG9yZWRMaW5lc0V4dGVuc2lvbkluZm9UeXBlW01vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiXSA9ICdBcHBsaWNhdGlvbkV4dGVuc2lvbiddID0gXCJBcHBsaWNhdGlvbkV4dGVuc2lvblwiO1xuICAgIE1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGVbTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZVtcIlBhcmtMb2NhdGlvblwiXSA9ICdQYXJrTG9jYXRpb24nXSA9IFwiUGFya0xvY2F0aW9uXCI7XG59KShleHBvcnRzLk1vbml0b3JlZExpbmVzRXh0ZW5zaW9uSW5mb1R5cGUgfHwgKGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSA9IHt9KSk7XG52YXIgTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZSA9IGV4cG9ydHMuTW9uaXRvcmVkTGluZXNFeHRlbnNpb25JbmZvVHlwZTtcblxuXG4vKioqLyB9LFxuLyogOTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHJpbmdvdXRzdGF0dXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcbnZhciBSaW5nT3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSaW5nT3V0KCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBSaW5nT3V0IENhbGxcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPk1ha2VzIGEgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUubWFrZVJpbmdPdXRDYWxsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0aGlzLnBhcnNlT3B0aW9ucygnUE9TVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vcmluZ291dCcsIG9wdGlvbnMsIGV4cG9ydHMubWFrZVJpbmdPdXRDYWxsT3B0aW9ucyksIHJpbmdvdXRzdGF0dXMuUmluZ091dFN0YXR1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU3RhdHVzIG9mIFJpbmdPdXQgQ2FsbFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjcgKFJlbGVhc2UgNS4xNik8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgc3RhdHVzIG9mIGEgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUuZ2V0UmluZ091dENhbGxTdGF0dXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQve3JpbmdvdXRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmdldFJpbmdPdXRDYWxsU3RhdHVzT3B0aW9ucyksIHJpbmdvdXRzdGF0dXMuUmluZ091dFN0YXR1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgUmluZ091dCBDYWxsXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+Q2FuY2VscyB0aGUgMi1sZWcgUmluZ091dCBjYWxsLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmluZ091dDwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlBlcmZvcm1pbmcgdHdvLWxlZ2dlZCByaW5nLW91dCBwaG9uZSBjYWxsczwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+SGVhdnk8L3A+XG4gICAgICovXG4gICAgUmluZ091dC5wcm90b3R5cGUuY2FuY2VsUmluZ091dENhbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L3JpbmdvdXQve3JpbmdvdXRJZH0nLCBvcHRpb25zLCBleHBvcnRzLmNhbmNlbFJpbmdPdXRDYWxsT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpbmdPdXQ7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuUmluZ091dCA9IFJpbmdPdXQ7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbWFrZVJpbmdPdXRDYWxsIG9wZXJhdGlvblxuICovXG5leHBvcnRzLm1ha2VSaW5nT3V0Q2FsbE9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJib2R5XCIsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibWFrZXJpbmdvdXRyZXF1ZXN0Lk1ha2VSaW5nT3V0UmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBnZXRSaW5nT3V0Q2FsbFN0YXR1cyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5nZXRSaW5nT3V0Q2FsbFN0YXR1c09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJyaW5nb3V0SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY2FuY2VsUmluZ091dENhbGwgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuY2FuY2VsUmluZ091dENhbGxPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwicmluZ291dElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuXG5cbi8qKiovIH0sXG4vKiA5NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciByaW5nb3V0c3RhdHVzaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xudmFyIFJpbmdPdXRTdGF0dXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSaW5nT3V0U3RhdHVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpbmdPdXRTdGF0dXMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSaW5nT3V0U3RhdHVzLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdzdGF0dXMnLCBDbGFzczogcmluZ291dHN0YXR1c2luZm8uUmluZ091dFN0YXR1c0luZm8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSaW5nT3V0U3RhdHVzLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUmluZ091dFN0YXR1cyc7XG4gICAgfTtcbiAgICByZXR1cm4gUmluZ091dFN0YXR1cztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmluZ091dFN0YXR1cyA9IFJpbmdPdXRTdGF0dXM7XG5cblxuLyoqKi8gfSxcbi8qIDk1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmluZ091dFN0YXR1c0luZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmluZ091dFN0YXR1c0luZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSaW5nT3V0U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnY2FsbGVyU3RhdHVzJywgQ2xhc3M6IFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdjYWxsZWVTdGF0dXMnLCBDbGFzczogUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMsIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBSaW5nT3V0U3RhdHVzSW5mby5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1JpbmdPdXRTdGF0dXNJbmZvJztcbiAgICB9O1xuICAgIHJldHVybiBSaW5nT3V0U3RhdHVzSW5mbztcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuUmluZ091dFN0YXR1c0luZm8gPSBSaW5nT3V0U3RhdHVzSW5mbztcbihmdW5jdGlvbiAoUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzKSB7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkludmFsaWRcIl0gPSAnSW52YWxpZCddID0gXCJJbnZhbGlkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkluUHJvZ3Jlc3NcIl0gPSAnSW5Qcm9ncmVzcyddID0gXCJJblByb2dyZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkJ1c3lcIl0gPSAnQnVzeSddID0gXCJCdXN5XCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIlJlamVjdGVkXCJdID0gJ1JlamVjdGVkJ10gPSBcIlJlamVjdGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkdlbmVyaWNFcnJvclwiXSA9ICdHZW5lcmljRXJyb3InXSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiXSA9ICdJbnRlcm5hdGlvbmFsRGlzYWJsZWQnXSA9IFwiSW50ZXJuYXRpb25hbERpc2FibGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIkRlc3RpbmF0aW9uQmxvY2tlZFwiXSA9ICdEZXN0aW5hdGlvbkJsb2NrZWQnXSA9IFwiRGVzdGluYXRpb25CbG9ja2VkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1c1tcIk5vU3VjaFVzZXJcIl0gPSAnTm9TdWNoVXNlciddID0gXCJOb1N1Y2hVc2VyXCI7XG59KShleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxTdGF0dXMgPSB7fSkpO1xudmFyIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbFN0YXR1cyA9IGV4cG9ydHMuUmluZ091dFN0YXR1c0luZm9DYWxsU3RhdHVzO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlclN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsZXJTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVyU3RhdHVzO1xuKGZ1bmN0aW9uIChSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cykge1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiSW52YWxpZFwiXSA9ICdJbnZhbGlkJ10gPSBcIkludmFsaWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIlN1Y2Nlc3NcIl0gPSAnU3VjY2VzcyddID0gXCJTdWNjZXNzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJblByb2dyZXNzXCJdID0gJ0luUHJvZ3Jlc3MnXSA9IFwiSW5Qcm9ncmVzc1wiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiQnVzeVwiXSA9ICdCdXN5J10gPSBcIkJ1c3lcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vQW5zd2VyXCJdID0gJ05vQW5zd2VyJ10gPSBcIk5vQW5zd2VyXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJSZWplY3RlZFwiXSA9ICdSZWplY3RlZCddID0gXCJSZWplY3RlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiR2VuZXJpY0Vycm9yXCJdID0gJ0dlbmVyaWNFcnJvciddID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIkZpbmlzaGVkXCJdID0gJ0ZpbmlzaGVkJ10gPSBcIkZpbmlzaGVkXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJJbnRlcm5hdGlvbmFsRGlzYWJsZWRcIl0gPSAnSW50ZXJuYXRpb25hbERpc2FibGVkJ10gPSBcIkludGVybmF0aW9uYWxEaXNhYmxlZFwiO1xuICAgIFJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1JpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzW1wiRGVzdGluYXRpb25CbG9ja2VkXCJdID0gJ0Rlc3RpbmF0aW9uQmxvY2tlZCddID0gXCJEZXN0aW5hdGlvbkJsb2NrZWRcIjtcbiAgICBSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tSaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1c1tcIk5vdEVub3VnaEZ1bmRzXCJdID0gJ05vdEVub3VnaEZ1bmRzJ10gPSBcIk5vdEVub3VnaEZ1bmRzXCI7XG4gICAgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXNbXCJOb1N1Y2hVc2VyXCJdID0gJ05vU3VjaFVzZXInXSA9IFwiTm9TdWNoVXNlclwiO1xufSkoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyB8fCAoZXhwb3J0cy5SaW5nT3V0U3RhdHVzSW5mb0NhbGxlZVN0YXR1cyA9IHt9KSk7XG52YXIgUmluZ091dFN0YXR1c0luZm9DYWxsZWVTdGF0dXMgPSBleHBvcnRzLlJpbmdPdXRTdGF0dXNJbmZvQ2FsbGVlU3RhdHVzO1xuXG5cbi8qKiovIH0sXG4vKiA5NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgZXh0ZW5zaW9uZm9yd2FyZGluZ251bWJlcmxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcbnZhciBmb3J3YXJkaW5nbnVtYmVyaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xudmFyIEZvcndhcmRpbmdOdW1iZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9yd2FyZGluZ051bWJlcnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9yd2FyZGluZ051bWJlcnMoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRXh0ZW5zaW9uIEZvcndhcmRpbmcgTnVtYmVyIExpc3RcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC43IChSZWxlYXNlIDUuMTYpPC9wPlxuICAgICAqIDxwPlJldHVybnMgdGhlIGxpc3Qgb2YgZXh0ZW5zaW9uIHBob25lIG51bWJlcnMgdXNlZCBmb3IgY2FsbCBmb3J3YXJkaW5nIGFuZCBjYWxsIGZsaXAuIFRoZSByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIGFsbCB0aGUgZXh0ZW5zaW9uIHBob25lIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBmb3IgY2FsbCBmb3J3YXJkaW5nIGFuZCBjYWxsIGZsaXAuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5SZWFkQWNjb3VudHM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIHVzZXIgYWNjb3VudCBpbmZvIChpbmNsdWRpbmcgbmFtZSwgYnVzaW5lc3MgbmFtZSwgYWRkcmVzcyBhbmQgcGhvbmUgbnVtYmVyL2FjY291bnQgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TGlnaHQ8L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0dFVCcsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vZm9yd2FyZGluZy1udW1iZXInLCBvcHRpb25zLCBleHBvcnRzLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyc09wdGlvbnMpLCBleHRlbnNpb25mb3J3YXJkaW5nbnVtYmVybGlzdC5FeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgRm9yd2FyZGluZyBOdW1iZXJcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPlNpbmNlIDEuMC4xMiAoUmVsZWFzZSA2LjQpPC9wPlxuICAgICAqIDxwPkFkZHMgYSBuZXcgZm9yd2FyZGluZyBudW1iZXIgdG8gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QuPC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIHVzZXIgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIsIGFzc2lnbmVkIHBob25lIG51bWJlcnMsIGRldmljZXMgYW5kIG90aGVyIGV4dGVuc2lvbiBzZXR0aW5ncyk8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBGb3J3YXJkaW5nTnVtYmVycy5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBGb3J3YXJkaW5nIE51bWJlciBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI0IChSZWxlYXNlIDguMCk8L3A+XG4gICAgICogPHA+VXBkYXRlcyBhbiBleGlzdGVudCBmb3J3YXJkaW5nIG51bWJlciBmcm9tIHRoZSBmb3J3YXJkaW5nIG51bWJlciBsaXN0LjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyL3tmb3J3YXJkaW5nTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIGZvcndhcmRpbmdudW1iZXJpbmZvLkZvcndhcmRpbmdOdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBGb3J3YXJkaW5nIE51bWJlciBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI0IChSZWxlYXNlIDguMCk8L3A+XG4gICAgICogPHA+RGVsZXRlcyBhIGZvcndhcmRpbmcgbnVtYmVyIGZyb20gdGhlIGZvcndhcmRpbmcgbnVtYmVyIGxpc3QgYnkgaXRzIElELjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyB1c2VyIGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyLCBhc3NpZ25lZCBwaG9uZSBudW1iZXJzLCBkZXZpY2VzIGFuZCBvdGhlciBleHRlbnNpb24gc2V0dGluZ3MpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgRm9yd2FyZGluZ051bWJlcnMucHJvdG90eXBlLmRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdERUxFVEUnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2ZvcndhcmRpbmctbnVtYmVyL3tmb3J3YXJkaW5nTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5kZWxldGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyksIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcndhcmRpbmdOdW1iZXJzO1xufShjbGllbnQuQ2xpZW50KSk7XG5leHBvcnRzLkZvcndhcmRpbmdOdW1iZXJzID0gRm9yd2FyZGluZ051bWJlcnM7XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJwZXJQYWdlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgY3JlYXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5jcmVhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJvZHlcIixcbiAgICAgICAgXCJpblwiOiBcImJvZHlcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJjcmVhdGVmb3J3YXJkaW5nbnVtYmVycmVxdWVzdC5DcmVhdGVGb3J3YXJkaW5nTnVtYmVyUmVxdWVzdFwiXG4gICAgfVxuXTtcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciB1cGRhdGVFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyIG9wZXJhdGlvblxuICovXG5leHBvcnRzLnVwZGF0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZm9yd2FyZGluZ051bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYm9keVwiLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcInVwZGF0ZWZvcndhcmRpbmdudW1iZXJyZXF1ZXN0LlVwZGF0ZUZvcndhcmRpbmdOdW1iZXJSZXF1ZXN0XCJcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIGRlbGV0ZUV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMuZGVsZXRlRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmb3J3YXJkaW5nTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG5cblxuLyoqKi8gfSxcbi8qIDk3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGZvcndhcmRpbmdudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0eU1hcHBpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3JlY29yZHMnLCBDbGFzczogZm9yd2FyZGluZ251bWJlcmluZm8uRm9yd2FyZGluZ051bWJlckluZm8sIGlzQXJyYXk6IHRydWUsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGFnaW5nJywgQ2xhc3M6IHBhZ2luZ2luZm8uUGFnaW5nSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0LnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRXh0ZW5zaW9uRm9yd2FyZGluZ051bWJlckxpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0O1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5FeHRlbnNpb25Gb3J3YXJkaW5nTnVtYmVyTGlzdCA9IEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJMaXN0O1xuXG5cbi8qKiovIH0sXG4vKiA5OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9leHRlcm5hbHMuZC50c1wiIC8+XG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG1vZGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBGb3J3YXJkaW5nTnVtYmVySW5mbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcndhcmRpbmdOdW1iZXJJbmZvLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcndhcmRpbmdOdW1iZXJJbmZvKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRm9yd2FyZGluZ051bWJlckluZm8ucHJvdG90eXBlLmdldFByb3BlcnR5TWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnaWQnLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ3VyaScsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAncGhvbmVOdW1iZXInLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2xhYmVsJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmZWF0dXJlcycsIENsYXNzOiBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdmbGlwTnVtYmVyJywgQ2xhc3M6IG51bGwgLyogbnVtYmVyICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgRm9yd2FyZGluZ051bWJlckluZm8ucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdGb3J3YXJkaW5nTnVtYmVySW5mbyc7XG4gICAgfTtcbiAgICByZXR1cm4gRm9yd2FyZGluZ051bWJlckluZm87XG59KG1vZGVsLk1vZGVsKSk7XG5leHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvID0gRm9yd2FyZGluZ051bWJlckluZm87XG4oZnVuY3Rpb24gKEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMpIHtcbiAgICBGb3J3YXJkaW5nTnVtYmVySW5mb0ZlYXR1cmVzW0ZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbXCJDYWxsRmxpcFwiXSA9ICdDYWxsRmxpcCddID0gXCJDYWxsRmxpcFwiO1xuICAgIEZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXNbRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlc1tcIkNhbGxGb3J3YXJkaW5nXCJdID0gJ0NhbGxGb3J3YXJkaW5nJ10gPSBcIkNhbGxGb3J3YXJkaW5nXCI7XG59KShleHBvcnRzLkZvcndhcmRpbmdOdW1iZXJJbmZvRmVhdHVyZXMgfHwgKGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyA9IHt9KSk7XG52YXIgRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcyA9IGV4cG9ydHMuRm9yd2FyZGluZ051bWJlckluZm9GZWF0dXJlcztcblxuXG4vKioqLyB9LFxuLyogOTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGJsb2NrZWRudW1iZXJpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xudmFyIGJsb2NrZWRudW1iZXJzbGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcbnZhciBCbG9ja2VkTnVtYmVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrZWROdW1iZXJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJzKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIEJsb2NrZWQgTnVtYmVyXG4gICAgICpcbiAgICAgKiA8cCBzdHlsZT0nZm9udC1zdHlsZTppdGFsaWM7Jz48L3A+XG4gICAgICogPHA+PC9wPlxuICAgICAqIDxoND5SZXF1aXJlZCBQZXJtaXNzaW9uczwvaDQ+XG4gICAgICogPHRhYmxlIGNsYXNzPSdmdWxsd2lkdGgnPlxuICAgICAqICAgICA8dGhlYWQ+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRoPlBlcm1pc3Npb248L3RoPlxuICAgICAqICAgICAgICAgICAgIDx0aD5EZXNjcmlwdGlvbjwvdGg+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3RoZWFkPlxuICAgICAqICAgICA8dGJvZHk+XG4gICAgICogICAgICAgICA8dHI+XG4gICAgICogICAgICAgICAgICAgPHRkIGNsYXNzPSdjb2RlJz5FZGl0RXh0ZW5zaW9uczwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgYW5kIHVwZGF0aW5nIG15IGV4dGVuc2lvbiBpbmZvIChpbmNsdWRlcyBleHRlbnNpb24gbmFtZSwgbnVtYmVyLCBlbWFpbCBhbmQgcGhvbmUgbnVtYmVyKTwvdGQ+XG4gICAgICogICAgICAgICA8L3RyPlxuICAgICAqICAgICA8L3Rib2R5PlxuICAgICAqIDwvdGFibGU+XG4gICAgICogPGg0PkFQSSBHcm91cDwvaDQ+XG4gICAgICogPHA+TWVkaXVtPC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5ibG9ja051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ1BPU1QnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5ibG9ja051bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQmxvY2tlZCBOdW1iZXIgTGlzdFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+U2luY2UgMS4wLjI8L3A+XG4gICAgICogPHA+UmV0dXJucyB0aGUgbGlzdCBvZiBwaG9uZSBudW1iZXJzIHdoaWNoIGFyZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgdG8gYmxvY2sgaW5ib3VuZCBjYWxscyBhbmQgU01TIG1lc3NhZ2VzLjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+UmVhZEFjY291bnRzPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyB1c2VyIGFjY291bnQgaW5mbyAoaW5jbHVkaW5nIG5hbWUsIGJ1c2luZXNzIG5hbWUsIGFkZHJlc3MgYW5kIHBob25lIG51bWJlci9hY2NvdW50IG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPkxpZ2h0PC9wPlxuICAgICAqL1xuICAgIEJsb2NrZWROdW1iZXJzLnByb3RvdHlwZS5saXN0QmxvY2tlZE51bWJlcnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyJywgb3B0aW9ucywgZXhwb3J0cy5saXN0QmxvY2tlZE51bWJlcnNPcHRpb25zKSwgYmxvY2tlZG51bWJlcnNsaXN0LkJsb2NrZWROdW1iZXJzTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPlJlYWRBY2NvdW50czwvdGQ+XG4gICAgICogICAgICAgICAgICAgPHRkPlZpZXdpbmcgdXNlciBhY2NvdW50IGluZm8gKGluY2x1ZGluZyBuYW1lLCBidXNpbmVzcyBuYW1lLCBhZGRyZXNzIGFuZCBwaG9uZSBudW1iZXIvYWNjb3VudCBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5MaWdodDwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUubG9hZEJsb2NrZWROdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdHRVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy5sb2FkQmxvY2tlZE51bWJlck9wdGlvbnMpLCBibG9ja2VkbnVtYmVyaW5mby5CbG9ja2VkTnVtYmVySW5mbyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgQmxvY2tlZCBOdW1iZXIocykgYnkgSURcbiAgICAgKlxuICAgICAqIDxwIHN0eWxlPSdmb250LXN0eWxlOml0YWxpYzsnPjwvcD5cbiAgICAgKiA8cD48L3A+XG4gICAgICogPGg0PlJlcXVpcmVkIFBlcm1pc3Npb25zPC9oND5cbiAgICAgKiA8dGFibGUgY2xhc3M9J2Z1bGx3aWR0aCc+XG4gICAgICogICAgIDx0aGVhZD5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGg+UGVybWlzc2lvbjwvdGg+XG4gICAgICogICAgICAgICAgICAgPHRoPkRlc2NyaXB0aW9uPC90aD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGhlYWQ+XG4gICAgICogICAgIDx0Ym9keT5cbiAgICAgKiAgICAgICAgIDx0cj5cbiAgICAgKiAgICAgICAgICAgICA8dGQgY2xhc3M9J2NvZGUnPkVkaXRFeHRlbnNpb25zPC90ZD5cbiAgICAgKiAgICAgICAgICAgICA8dGQ+Vmlld2luZyBhbmQgdXBkYXRpbmcgbXkgZXh0ZW5zaW9uIGluZm8gKGluY2x1ZGVzIGV4dGVuc2lvbiBuYW1lLCBudW1iZXIsIGVtYWlsIGFuZCBwaG9uZSBudW1iZXIpPC90ZD5cbiAgICAgKiAgICAgICAgIDwvdHI+XG4gICAgICogICAgIDwvdGJvZHk+XG4gICAgICogPC90YWJsZT5cbiAgICAgKiA8aDQ+QVBJIEdyb3VwPC9oND5cbiAgICAgKiA8cD5NZWRpdW08L3A+XG4gICAgICovXG4gICAgQmxvY2tlZE51bWJlcnMucHJvdG90eXBlLnVwZGF0ZUJsb2NrZWROdW1iZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHRoaXMucGFyc2VPcHRpb25zKCdQVVQnLCAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L3thY2NvdW50SWR9L2V4dGVuc2lvbi97ZXh0ZW5zaW9uSWR9L2Jsb2NrZWQtbnVtYmVyL3tibG9ja2VkTnVtYmVySWR9Jywgb3B0aW9ucywgZXhwb3J0cy51cGRhdGVCbG9ja2VkTnVtYmVyT3B0aW9ucyksIGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBCbG9ja2VkIE51bWJlcihzKSBieSBJRFxuICAgICAqXG4gICAgICogPHAgc3R5bGU9J2ZvbnQtc3R5bGU6aXRhbGljOyc+PC9wPlxuICAgICAqIDxwPjwvcD5cbiAgICAgKiA8aDQ+UmVxdWlyZWQgUGVybWlzc2lvbnM8L2g0PlxuICAgICAqIDx0YWJsZSBjbGFzcz0nZnVsbHdpZHRoJz5cbiAgICAgKiAgICAgPHRoZWFkPlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0aD5QZXJtaXNzaW9uPC90aD5cbiAgICAgKiAgICAgICAgICAgICA8dGg+RGVzY3JpcHRpb248L3RoPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90aGVhZD5cbiAgICAgKiAgICAgPHRib2R5PlxuICAgICAqICAgICAgICAgPHRyPlxuICAgICAqICAgICAgICAgICAgIDx0ZCBjbGFzcz0nY29kZSc+RWRpdEV4dGVuc2lvbnM8L3RkPlxuICAgICAqICAgICAgICAgICAgIDx0ZD5WaWV3aW5nIGFuZCB1cGRhdGluZyBteSBleHRlbnNpb24gaW5mbyAoaW5jbHVkZXMgZXh0ZW5zaW9uIG5hbWUsIG51bWJlciwgZW1haWwgYW5kIHBob25lIG51bWJlcik8L3RkPlxuICAgICAqICAgICAgICAgPC90cj5cbiAgICAgKiAgICAgPC90Ym9keT5cbiAgICAgKiA8L3RhYmxlPlxuICAgICAqIDxoND5BUEkgR3JvdXA8L2g0PlxuICAgICAqIDxwPk1lZGl1bTwvcD5cbiAgICAgKi9cbiAgICBCbG9ja2VkTnVtYmVycy5wcm90b3R5cGUudW5ibG9ja051bWJlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQodGhpcy5wYXJzZU9wdGlvbnMoJ0RFTEVURScsICcvcmVzdGFwaS92MS4wL2FjY291bnQve2FjY291bnRJZH0vZXh0ZW5zaW9uL3tleHRlbnNpb25JZH0vYmxvY2tlZC1udW1iZXIve2Jsb2NrZWROdW1iZXJJZH0nLCBvcHRpb25zLCBleHBvcnRzLnVuYmxvY2tOdW1iZXJPcHRpb25zKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tlZE51bWJlcnM7XG59KGNsaWVudC5DbGllbnQpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlcnMgPSBCbG9ja2VkTnVtYmVycztcbi8qKlxuICogRGVmaW5pdGlvbiBvZiBvcHRpb25zIGZvciBibG9ja051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy5ibG9ja051bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbGlzdEJsb2NrZWROdW1iZXJzIG9wZXJhdGlvblxuICovXG5leHBvcnRzLmxpc3RCbG9ja2VkTnVtYmVyc09wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgbG9hZEJsb2NrZWROdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMubG9hZEJsb2NrZWROdW1iZXJPcHRpb25zID0gW1xuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJleHRlbnNpb25JZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZE51bWJlcklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICB9XG5dO1xuLyoqXG4gKiBEZWZpbml0aW9uIG9mIG9wdGlvbnMgZm9yIHVwZGF0ZUJsb2NrZWROdW1iZXIgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydHMudXBkYXRlQmxvY2tlZE51bWJlck9wdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhY2NvdW50SWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImV4dGVuc2lvbklkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcImluXCI6IFwicGF0aFwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIn5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBcIm5hbWVcIjogXCJibG9ja2VkTnVtYmVySWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgIH1cbl07XG4vKipcbiAqIERlZmluaXRpb24gb2Ygb3B0aW9ucyBmb3IgdW5ibG9ja051bWJlciBvcGVyYXRpb25cbiAqL1xuZXhwb3J0cy51bmJsb2NrTnVtYmVyT3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFjY291bnRJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImRlZmF1bHRcIjogXCJ+XCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiZXh0ZW5zaW9uSWRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgIFwiaW5cIjogXCJwYXRoXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IFwiflwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImJsb2NrZWROdW1iZXJJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJpblwiOiBcInBhdGhcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlXG4gICAgfVxuXTtcblxuXG4vKioqLyB9LFxuLyogMTAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2V4dGVybmFscy5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbW9kZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIEJsb2NrZWROdW1iZXJJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tlZE51bWJlckluZm8oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCbG9ja2VkTnVtYmVySW5mby5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICd1cmknLCBDbGFzczogbnVsbCAvKiBzdHJpbmcgKi8sIGlzQXJyYXk6IGZhbHNlLCBpc1JlcXVpcmVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBwcm9wZXJ0eTogJ2lkJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICduYW1lJywgQ2xhc3M6IG51bGwgLyogc3RyaW5nICovLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwaG9uZU51bWJlcicsIENsYXNzOiBudWxsIC8qIHN0cmluZyAqLywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IGZhbHNlIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJsb2NrZWROdW1iZXJJbmZvLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQmxvY2tlZE51bWJlckluZm8nO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJJbmZvO1xufShtb2RlbC5Nb2RlbCkpO1xuZXhwb3J0cy5CbG9ja2VkTnVtYmVySW5mbyA9IEJsb2NrZWROdW1iZXJJbmZvO1xuXG5cbi8qKiovIH0sXG4vKiAxMDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vZXh0ZXJuYWxzLmQudHNcIiAvPlxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBtb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgYmxvY2tlZG51bWJlcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG52YXIgbmF2aWdhdGlvbmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBwYWdpbmdpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgQmxvY2tlZE51bWJlcnNMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tlZE51bWJlcnNMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrZWROdW1iZXJzTGlzdCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJsb2NrZWROdW1iZXJzTGlzdC5wcm90b3R5cGUuZ2V0UHJvcGVydHlNYXBwaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdyZWNvcmRzJywgQ2xhc3M6IGJsb2NrZWRudW1iZXJpbmZvLkJsb2NrZWROdW1iZXJJbmZvLCBpc0FycmF5OiB0cnVlLCBpc1JlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHByb3BlcnR5OiAnbmF2aWdhdGlvbicsIENsYXNzOiBuYXZpZ2F0aW9uaW5mby5OYXZpZ2F0aW9uSW5mbywgaXNBcnJheTogZmFsc2UsIGlzUmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHJvcGVydHk6ICdwYWdpbmcnLCBDbGFzczogcGFnaW5naW5mby5QYWdpbmdJbmZvLCBpc0FycmF5OiBmYWxzZSwgaXNSZXF1aXJlZDogdHJ1ZSB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBCbG9ja2VkTnVtYmVyc0xpc3QucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCbG9ja2VkTnVtYmVyc0xpc3QnO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrZWROdW1iZXJzTGlzdDtcbn0obW9kZWwuTW9kZWwpKTtcbmV4cG9ydHMuQmxvY2tlZE51bWJlcnNMaXN0ID0gQmxvY2tlZE51bWJlcnNMaXN0O1xuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpbmdjZW50cmFsLWNsaWVudC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC1jbGllbnQvYnVpbGQvcmluZ2NlbnRyYWwtY2xpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgU3ltYm9sTWFwIGZyb20gJy4vc3ltYm9sLW1hcCc7XG5pbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudC1lbWl0dGVyJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAnc3RvcmUnLFxuICAnbWFwcGVyJyxcbiAgJ3ByZWZpeCcsXG4gICdhY3Rpb25zJyxcbiAgJ2VtaXR0ZXInLFxuXSk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBkZXNjcmlwdGlvbiBEZWZhdWx0IHJlZHVjZXIgaWYgbW9kdWxlIGRvZXMgbm90IGhhcyBpdHMgb3duIHJlZHVjZXIuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRSZWR1Y2VyKHN0YXRlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4ge307XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBkZXNjcmlwdGlvbiBEZWZhdWx0IHBhcmVudCBzdGF0ZSB0byBtb2R1bGUgc3RhdGUgbWFwcGVyLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0TWFwcGVyKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZWZhdWx0XG4gKiBAZGVzY3JpcHRpb24gQmFzZSBtb2R1bGUgY2xhc3MuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyLFxuICAgIHN0YXRlTWFwcGVyID0gZGVmYXVsdE1hcHBlcixcbiAgICBwcmVmaXgsXG4gICAgYWN0aW9ucyxcbiAgfSkge1xuICAgIC8vIEV4dGVuZGluZyBFdmVudEVtaXR0ZXIgYnJlYWtzIHNvbWUgbWVjaGFuaWMsIHNvIHdlIHdpcmUgZW1pdHRlciB1cCBsaWtlIHRoaXMgaW5zdGVhZC5cbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLm1hcHBlcl0gPSBzdGF0ZU1hcHBlcjtcbiAgICB0aGlzW3N5bWJvbHMucHJlZml4XSA9IHByZWZpeDtcbiAgICB0aGlzW3N5bWJvbHMuYWN0aW9uc10gPSBhY3Rpb25zICYmIHByZWZpeEFjdGlvbnMoYWN0aW9ucywgcHJlZml4KTtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcigoc3RvcmUpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5zdG9yZV0gPSBzdG9yZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vbihldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5vZmYoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbil9IGhhbmRsZXJcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmVtaXR0ZXJdLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uYXJnc30gYXJnc1xuICAgKi9cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzW3N5bWJvbHMuZW1pdHRlcl0ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpc1tzeW1ib2xzLm1hcHBlcl0odGhpc1tzeW1ib2xzLnN0b3JlXS5nZXRTdGF0ZSgpKTtcbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlZHVjZXI7XG4gIH1cbiAgZ2V0IHN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMuc3RvcmVdO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5wcmVmaXhdO1xuICB9XG4gIGdldCBhY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzW3N5bWJvbHMuYWN0aW9uc107XG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3JjLW1vZHVsZS5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4vZW51bSc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gSGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyBhIHN5bWJvbCBtYXBwaW5nXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bWJvbE1hcCBleHRlbmRzIEVudW0ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0ge307XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBkZWZpbml0aW9uW2tleV0gPSBTeW1ib2woKTtcbiAgICB9KTtcbiAgICBzdXBlcihkZWZpbml0aW9uKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL3N5bWJvbC1tYXAuanNcbiAqKi8iLCJjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuY29uc3QgREVGSU5JVElPTiA9IFN5bWJvbCgpO1xuY29uc3QgVkFMVUVTID0gU3ltYm9sKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudW0ge1xuICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uKSB7XG4gICAgdGhpc1tERUZJTklUSU9OXSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pO1xuICAgIHRoaXNbVkFMVUVTXSA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0RFRklOSVRJT05dW2tleV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1tWQUxVRVNdLmFkZCh0aGlzW0RFRklOSVRJT05dW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgaGFzVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpc1tWQUxVRVNdLmhhcyh2YWx1ZSk7XG4gIH1cbn1cblxuLypcbiAqIC8vd2l0aCBQcm94eSBzdXBwb3J0XG4gKmNvbnN0IGVudW1IYW5kbGVyID0ge1xuICogIGdldCh0YXJnZXQsIGtleSkge1xuICogICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICogIH0sXG4gKiAgc2V0KCkge1xuICogICAgcmV0dXJuO1xuICogIH1cbiAqfTtcbiAqRW51bSA9IGNsYXNzIEVudW0gZXh0ZW5kcyBQcm94eSB7XG4gKiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbikge1xuICogICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbiksIGVudW1IYW5kbGVyKTtcbiAqICB9XG4gKn1cbiAqL1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvZW51bS5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4vZW51bSc7XG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQGNsYXNzXG4gKiBAZGVzY3JpcHRpb24gaGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyByZWR1eCBhY3Rpb24gZGVmaW5pdGlvbiBtYXBzXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3Rpb25NYXAgZXh0ZW5kcyBFbnVtIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhY3Rpb25zIC0gbGlzdCBvZiBhY3Rpb24gc3RyaW5nc1xuICAgKiBAZXh0ZW5kcyBFbnVtXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhY3Rpb25zID0gW10sIHByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgZGVmaW5pdGlvblthY3Rpb25dID0gcHJlZml4ICE9PSAnJyA/IGAke3ByZWZpeH0tJHthY3Rpb259YCA6IGFjdGlvbjtcbiAgICB9KTtcbiAgICBzdXBlcihkZWZpbml0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uIGhlbHBlciBmdW5jdGlvbiB0byByZXR1cm4gYSBwcmVmaXhlZCBhY3Rpb24gZGVmaW5pdGlvbiBtYXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhBY3Rpb25zKGFjdGlvbnMsIHByZWZpeCkge1xuICBpZiAoIXByZWZpeCB8fCBwcmVmaXggPT09ICcnKSByZXR1cm4gYWN0aW9ucztcbiAgY29uc3QgZGVmaW5pdGlvbiA9IHt9O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBpbiBhY3Rpb25zKSB7XG4gICAgaWYgKGFjdGlvbnM6Omhhc093blByb3BlcnR5KGFjdGlvbikpIHtcbiAgICAgIGRlZmluaXRpb25bYWN0aW9uXSA9IGAke3ByZWZpeH0tJHthY3Rpb259YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBFbnVtKGRlZmluaXRpb24pO1xufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvcmVkdXgtaGVscGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ldmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvYXNzaWduJylcbiAgLCBub3JtYWxpemVPcHRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMnKVxuICAsIGlzQ2FsbGFibGUgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9pcy1jYWxsYWJsZScpXG4gICwgY29udGFpbnMgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMnKVxuXG4gICwgZDtcblxuZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMikgfHwgKHR5cGVvZiBkc2NyICE9PSAnc3RyaW5nJykpIHtcblx0XHRvcHRpb25zID0gdmFsdWU7XG5cdFx0dmFsdWUgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHRcdHcgPSBjb250YWlucy5jYWxsKGRzY3IsICd3Jyk7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmIChnZXQgPT0gbnVsbCkge1xuXHRcdGdldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoc2V0ID09IG51bGwpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzQ2FsbGFibGUoc2V0KSkge1xuXHRcdG9wdGlvbnMgPSBzZXQ7XG5cdFx0c2V0ID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChkc2NyID09IG51bGwpIHtcblx0XHRjID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ2MnKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCAnZScpO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKClcblx0PyBPYmplY3QuYXNzaWduXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiAncmF6JyB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogJ2R3YScgfSwgeyB0cnp5OiAndHJ6eScgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09ICdyYXpkd2F0cnp5Jztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9hc3NpZ24vaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgID0gcmVxdWlyZSgnLi4va2V5cycpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLi92YWxpZC12YWx1ZScpXG5cbiAgLCBtYXggPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzdCwgc3JjLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGwgPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkgeyBkZXN0W2tleV0gPSBzcmNba2V5XTsgfSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvYXNzaWduL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IE9iamVjdC5rZXlzXG5cdDogcmVxdWlyZSgnLi9zaGltJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdE9iamVjdC5rZXlzKCdwcmltaXRpdmUnKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHRyZXR1cm4ga2V5cyhvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IE9iamVjdChvYmplY3QpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtZXh0L29iamVjdC9rZXlzL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucy8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyA9PSBudWxsKSByZXR1cm47XG5cdFx0cHJvY2VzcyhPYmplY3Qob3B0aW9ucyksIHJlc3VsdCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBEZXByZWNhdGVkXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9vYmplY3QvaXMtY2FsbGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKCcuL3NoaW0nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0ciA9ICdyYXpkd2F0cnp5JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoKHN0ci5jb250YWlucygnZHdhJykgPT09IHRydWUpICYmIChzdHIuY29udGFpbnMoJ2ZvbycpID09PSBmYWxzZSkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaXMtaW1wbGVtZW50ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgeyBBY3Rpb25NYXAsIHByZWZpeEFjdGlvbnMgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ3JlZHVjZXInLFxuXSk7XG5cbmZ1bmN0aW9uIGdldFNldHRpbmdzUmVkdWNlcihwcmVmaXgpIHtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB7fTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIHRoaXNbc3ltYm9scy5yZWR1Y2VyXSA9IHtcbiAgICAgIGJhc2U6IGdldFNldHRpbmdzUmVkdWNlcih0aGlzLnByZWZpeCksXG4gICAgfTtcbiAgfVxuICByZWdpc3RlclJlZHVjZXIobmFtZSwgcmVkdWNlcikge1xuICAgIHRoaXNbc3ltYm9scy5yZWR1Y2VyXVtuYW1lXSA9IHJlZHVjZXI7XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVSZWR1Y2Vycyh0aGlzW3N5bWJvbHMucmVkdWNlcl0pO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3NldHRpbmdzL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IGV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gZXhwb3J0cy5jcmVhdGVTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9jcmVhdGVTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVTdG9yZSk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzID0gcmVxdWlyZSgnLi9jb21iaW5lUmVkdWNlcnMnKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tYmluZVJlZHVjZXJzKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2JpbmRBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5kQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vYXBwbHlNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5TWlkZGxld2FyZSk7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gX2NyZWF0ZVN0b3JlMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IF9jb21iaW5lUmVkdWNlcnMyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gX2JpbmRBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBfYXBwbHlNaWRkbGV3YXJlMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbXBvc2UgPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IGV4cG9ydHMuQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbaW5pdGlhbFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBHZXRzIHRoZSBgW1tQcm90b3R5cGVdXWAgb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGBbW1Byb3RvdHlwZV1dYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG90eXBlKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGUoT2JqZWN0KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNIb3N0T2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL19pc0hvc3RPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N5bWJvbC1vYnNlcnZhYmxlL3BvbnlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAnaW5pdGlhbFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgc2FuaXR5RXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNhbml0eShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNhbml0eUVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNhbml0eUVycm9yKSB7XG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgUmNNb2R1bGUgZnJvbSAnLi4vLi4vbGliL3JjLW1vZHVsZSc7XG5pbXBvcnQgYnJhbmRBY3Rpb25zIGZyb20gJy4vYnJhbmQtYWN0aW9ucyc7XG5pbXBvcnQgZ2V0UmVkdWNlciBmcm9tICcuL2JyYW5kLXJlZHVjZXInO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5cbmNvbnN0IHN5bWJvbHMgPSBuZXcgU3ltYm9sTWFwKFtcbiAgJ2luaXRpYWxTdGF0ZScsXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJhbmQgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICBzdGF0ZU1hcHBlciA9IChzdGF0ZSkgPT4gc3RhdGUuYnJhbmQsXG4gICAgcHJlZml4LFxuICAgIGlkLFxuICAgIG5hbWUsXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICByZWdpc3RlclN0b3JlSGFuZGxlcixcbiAgICAgIHN0YXRlTWFwcGVyLFxuICAgICAgcHJlZml4LFxuICAgICAgYWN0aW9uczogYnJhbmRBY3Rpb25zLFxuICAgIH0pO1xuICAgIHRoaXNbc3ltYm9scy5pbml0aWFsU3RhdGVdID0ge1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgIH07XG4gIH1cbiAgZ2V0IHJlZHVjZXIoKSB7XG4gICAgcmV0dXJuIGdldFJlZHVjZXIodGhpc1tzeW1ib2xzLmluaXRpYWxTdGF0ZV0sIHRoaXMucHJlZml4KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaWQ7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubmFtZTtcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnc2V0QnJhbmQnLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2JyYW5kL2JyYW5kLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgYnJhbmRBY3Rpb25zIGZyb20gJy4vYnJhbmQtYWN0aW9ucyc7XG5pbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UmVkdWNlcihpbml0aWFsU3RhdGUsIHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyhicmFuZEFjdGlvbnMsIHByZWZpeCk7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcblxuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgY2FzZSBhY3Rpb25zLnNldEJyYW5kOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBuYW1lOiBhY3Rpb24ucGF5bG9hZC5uYW1lLFxuICAgICAgICAgIGlkOiBhY3Rpb24ucGF5bG9hZC5pZCxcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9icmFuZC9icmFuZC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgbG9naW5TdGF0dXMgZnJvbSAnLi9sb2dpbi1zdGF0dXMnO1xuaW1wb3J0IGF1dGhBY3Rpb25zIGZyb20gJy4vYXV0aC1hY3Rpb25zJztcbmltcG9ydCBnZXRBdXRoUmVkdWNlciBmcm9tICcuL2F1dGgtcmVkdWNlcic7XG5pbXBvcnQgeyBhdXRoRXZlbnRzLCBhdXRoRXZlbnRUeXBlcyB9IGZyb20gJy4vYXV0aC1ldmVudHMnO1xuaW1wb3J0IHsgZW1pdCB9IGZyb20gJy4uLy4uL2xpYi91dGlscyc7XG5cblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAncGxhdGZvcm0nLFxuICAnZW1pdHRlcicsXG4gICdiZWZvcmVMb2dvdXRIYW5kbGVycycsXG5dKTtcblxuY29uc3QgRU5VTVMgPSBuZXcgRW51bSh7XG4gIGxvZ2luU3RhdHVzLFxufSk7XG5cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBkZXNjcmlwdGlvbiBBdXRoZW50aWNhdGlvbiBtb2R1bGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0aCBleHRlbmRzIFJjTW9kdWxlIHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBhY3Rpb25zOiBhdXRoQWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBwbGF0Zm9ybSxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcbiAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdID0gbmV3IFNldCgpO1xuXG4gICAgLy8gbG9hZCBpbmZvIG9uIGxvZ2luXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpblN1Y2Nlc3MsXG4gICAgICB9KTtcbiAgICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXRlLnN0YXR1cyk7XG4gICAgfSk7XG4gICAgLy8gbG9naW5FcnJvclxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpbkVycm9yLCBlcnJvciA9PiB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmxvZ2luRXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gdW5sb2FkIGluZm8gb24gbG9nb3V0XG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ291dFN1Y2Nlc3MsICgpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9nb3V0U3VjY2VzcyxcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcy5lbWl0KGF1dGhFdmVudHMudXNlckluZm9DbGVhcmVkKTtcbiAgICB9KTtcblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dvdXRFcnJvciwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dvdXRFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5yZWZyZXNoRXJyb3IsIGVycm9yID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMucmVmcmVzaEVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gbG9hZCBpbmZvIGlmIGFscmVhZHkgbG9nZ2VkIGluXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlZEluID0gYXdhaXQgcGxhdGZvcm0ubG9nZ2VkSW4oKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuaW5pdCxcbiAgICAgICAgc3RhdHVzOiBsb2dnZWRJbiA/IGxvZ2luU3RhdHVzLmxvZ2dlZEluIDogbG9naW5TdGF0dXMubm90TG9nZ2VkSW4sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChhdXRoRXZlbnRUeXBlcy5hdXRoRXZlbnRUeXBlcywgdGhpcy5zdGF0ZS5zdGF0dXMpO1xuICAgIH0pKCk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0QXV0aFJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBMb2dpbiBmdW5jdGlvbiB1c2luZyB1c2VybmFtZSBhbmQgcGFzc3dvcmRcbiAgICovXG4gIGFzeW5jIGxvZ2luKHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBleHRlbnNpb24sIHJlbWVtYmVyIH0pIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5sb2dpbixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgdXNlcm5hbWUsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIHJlbWVtYmVyLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KGF1dGhFdmVudFR5cGVzLmxvZ2luU3RhdHVzQ2hhbmdlZCwgYXV0aEV2ZW50cy5sb2dnaW5nSW4pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2luKHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBleHRlbnNpb24sXG4gICAgICByZW1lbWJlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGRlc2NyaXB0aW9uIGdldCBPQXV0aCBwYWdlIHVybFxuICAgKi9cbiAgbG9naW5VcmwoeyByZWRpcmVjdFVyaSwgc3RhdGUsIGJyYW5kSWQsIGRpc3BsYXksIHByb21wdCB9KSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9naW5Vcmwoe1xuICAgICAgcmVkaXJlY3RVcmksXG4gICAgICBzdGF0ZSxcbiAgICAgIGJyYW5kSWQsXG4gICAgICBkaXNwbGF5LFxuICAgICAgcHJvbXB0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHBhcnNlTG9naW5VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ucGFyc2VMb2dpblJlZGlyZWN0VXJsKHVybCk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhc3luY1xuICAgKiBAZGVzY3JpcHRpb24gQXV0aG9yaXplIHVzaW5nIE9BYXV0aCBjb2RlXG4gICAqL1xuICBhc3luYyBhdXRob3JpemUoeyBjb2RlLCByZWRpcmVjdFVyaSB9KSB7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMubG9naW4sXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlZGlyZWN0VXJpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KGF1dGhFdmVudFR5cGVzLmxvZ2luU3RhdHVzQ2hhbmdlZCwgYXV0aEV2ZW50cy5sb2dnaW5nSW4pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dLmxvZ2luKHtcbiAgICAgIGNvZGUsXG4gICAgICByZWRpcmVjdFVyaSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQGFzeW5jXG4gICAqIEBkZXNjcmlwdGlvbiBMb2cgdGhlIHVzZXIgb3V0XG4gICAqL1xuICBhc3luYyBsb2dvdXQoKSB7XG4gICAgLy8gZGVhbCB3aXRoIHJlbW92aW5nIHN1YnNjcmlwdGlvbnNcblxuICAgIHRoaXM6OmVtaXQoYXV0aEV2ZW50VHlwZXMubG9naW5TdGF0dXNDaGFuZ2VkLCBhdXRoRXZlbnRzLmxvZ2dpbmdPdXQpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gWy4uLnRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc11dO1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gd3JhcHMgd2l0aCBhc3luYyBzbyBldmVuIG5vcm1hbCBmdW5jdGlvbnMgY2FuIGJlIGF3YWl0ZWRcbiAgICAgICAgLy8gVE9ETyBjYW5jZWwgbG9nb3V0IGlmIGhhbmRsZXIgcmVzb2x2ZXMgdG8gZmFsc2VcbiAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IGhhbmRsZXIoKSkoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIGVtaXQgZXJyb3JcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV0ubG9nb3V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG4gIGFkZEJlZm9yZUxvZ291dEhhbmRsZXIoaGFuZGxlcikge1xuICAgIHRoaXNbc3ltYm9scy5iZWZvcmVMb2dvdXRIYW5kbGVyc10uYWRkKGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzW3N5bWJvbHMuYmVmb3JlTG9nb3V0SGFuZGxlcnNdLnJlbW92ZShoYW5kbGVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVtb3ZlQmVmb3JlTG9nb3V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgdGhpc1tzeW1ib2xzLmJlZm9yZUxvZ291dEhhbmRsZXJzXS5yZW1vdmUoaGFuZGxlcik7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnN0YXR1cztcbiAgfVxuXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIGF1dGhFdmVudHM7XG4gIH1cblxuICBnZXQgZXZlbnRUeXBlcygpIHtcbiAgICByZXR1cm4gYXV0aEV2ZW50VHlwZXM7XG4gIH1cblxuICBnZXQgZW51bXMoKSB7XG4gICAgcmV0dXJuIEVOVU1TO1xuICB9XG5cbiAgYXN5bmMgaXNMb2dnZWRJbigpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXS5sb2dnZWRJbigpO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvaW5kZXguanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9mcm9tID0gcmVxdWlyZShcIi4uL2NvcmUtanMvYXJyYXkvZnJvbVwiKTtcblxudmFyIF9mcm9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zyb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKVxuICAsIGdldEl0ZXJGbiAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEM7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XHJcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcclxuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9XG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpcztcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKChvdXRlckZuIHx8IEdlbmVyYXRvcikucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gbmV3IEF3YWl0QXJndW1lbnQoYXJnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBBd2FpdEFyZ3VtZW50KGFyZykge1xuICAgIHRoaXMuYXJnID0gYXJnO1xuICB9XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvcHJvbWlzZVwiKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3Byb21pc2UyLmRlZmF1bHQucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwKFwibmV4dFwiKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5Qcm9taXNlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNsYXNzb2YgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNldFByb3RvICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldFxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAxODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4gKiogbW9kdWxlIGlkID0gMTg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5cbmNvbnN0IGRlZmluaXRpb24gPSB7XG4gIHBlbmRpbmc6ICdQRU5ESU5HJywgLy8gYWZ0ZXIgaW5pdCwgYmVmb3JlIHN0YXR1cyBmcm9tIHBsYXRmb3JtIGlzIGRldGVybWluZWRcbiAgbm90TG9nZ2VkSW46ICdOT1RfTE9HR0VEX0lOJyxcbiAgbG9nZ2luZ0luOiAnTE9HR0lOR19JTicsXG4gIGxvZ2dlZEluOiAnTE9HR0VEX0lOJyxcbiAgbG9nZ2luZ091dDogJ0xPR0dJTkdfT1VUJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBFbnVtKGRlZmluaXRpb24pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9hdXRoL2xvZ2luLXN0YXR1cy5qc1xuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ2xvZ2luJyxcbiAgJ2xvZ2luU3VjY2VzcycsXG4gICdsb2dpbkVycm9yJyxcbiAgJ2xvZ291dCcsXG4gICdsb2dvdXRTdWNjZXNzJyxcbiAgJ2xvZ291dEVycm9yJyxcbiAgJ3JlZnJlc2gnLFxuICAncmVmcmVzaFN1Y2Nlc3MnLFxuICAncmVmcmVzaEVycm9yJyxcbiAgJ2luaXQnLFxuXSwgJ2F1dGgnKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvYXV0aC9hdXRoLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBwcmVmaXhBY3Rpb25zIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5pbXBvcnQgYXV0aEFjdGlvbnMgZnJvbSAnLi9hdXRoLWFjdGlvbnMnO1xuaW1wb3J0IGxvZ2luU3RhdHVzIGZyb20gJy4vbG9naW4tc3RhdHVzJztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBzdGF0dXM6IGxvZ2luU3RhdHVzLnBlbmRpbmcsXG4gIGF1dGhFcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEF1dGhSZWR1Y2VyKHByZWZpeCkge1xuICBjb25zdCBhY3Rpb25zID0gcHJlZml4QWN0aW9ucyhhdXRoQWN0aW9ucywgcHJlZml4KTtcbiAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICAgIGlmICghYWN0aW9uKSByZXR1cm4gc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICBjYXNlIGFjdGlvbnMuaW5pdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7IHN0YXR1czogYWN0aW9uLnN0YXR1cyB9KTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ2luOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbG9naW5TdGF0dXMubG9nZ2luZ0luLFxuICAgICAgICAgIGF1dGhFcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ2luU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IGxvZ2luU3RhdHVzLmxvZ2dlZEluLFxuICAgICAgICAgIGF1dGhFcnJvcjogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ291dFN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBsb2dpblN0YXR1cy5ub3RMb2dnZWRJbixcbiAgICAgICAgICBhdXRoRXJyb3I6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5sb2dpbkVycm9yOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiBsb2dpblN0YXR1cy5ub3RMb2dnZWRJbixcbiAgICAgICAgICBhdXRoRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBhY3Rpb25zLmxvZ291dEVycm9yOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogbG9naW5TdGF0dXMubG9nZ2VkSW4sXG4gICAgICAgICAgYXV0aEVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL2F1dGgvYXV0aC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vLi4vbGliL2VudW0nO1xuaW1wb3J0IGxvZ2luU3RhdHVzIGZyb20gJy4vbG9naW4tc3RhdHVzJztcblxuY29uc3QgZXZlbnREZWZpbml0aW9ucyA9IHtcbiAgLi4ubG9naW5TdGF0dXMsXG59O1xuXG5leHBvcnQgY29uc3QgYXV0aEV2ZW50cyA9IG5ldyBFbnVtKGV2ZW50RGVmaW5pdGlvbnMpO1xuXG5jb25zdCBldmVudFR5cGVEZWZpbml0aW9ucyA9IHtcbiAgbG9naW5TdGF0dXNDaGFuZ2VkOiAnTE9HSU5fU1RBVFVTX0NIQU5HRUQnLFxufTtcblxuZXhwb3J0IGNvbnN0IGF1dGhFdmVudFR5cGVzID0gbmV3IEVudW0oZXZlbnRUeXBlRGVmaW5pdGlvbnMpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy9hdXRoL2F1dGgtZXZlbnRzLmpzXG4gKiovIiwiZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3REYXRhKG1vZGVsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1vZGVsKSkge1xuICAgIHJldHVybiBtb2RlbC5tYXAoaXRlbSA9PiBleHRyYWN0RGF0YShpdGVtKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtb2RlbCkge1xuICAgICAgaWYgKGtleVswXSAhPT0gJ18nICYmIG1vZGVsLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gZXh0cmFjdERhdGEobW9kZWxba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBtb2RlbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTGlzdChmbikge1xuICBsZXQgZmV0Y2hlZFBhZ2VzID0gMDtcbiAgbGV0IHRvdGFsUGFnZXMgPSAxO1xuICBsZXQgbGlzdCA9IFtdO1xuICB3aGlsZSAoZmV0Y2hlZFBhZ2VzIDwgdG90YWxQYWdlcykge1xuICAgIGZldGNoZWRQYWdlcysrO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmbih7XG4gICAgICBwYWdlOiBmZXRjaGVkUGFnZXMsXG4gICAgfSk7XG4gICAgdG90YWxQYWdlcyA9IGRhdGEucGFnaW5nLnRvdGFsUGFnZXM7XG4gICAgbGlzdCA9IGxpc3QuY29uY2F0KGRhdGEucmVjb3Jkcyk7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBkZXNjcmlwdGlvbiBIZWxwZXIgZnVuY3Rpb24gdG8gZW1pdCBldmVudFR5cGVkIGV2ZW50cyBhbmQgdGhlIGV2ZW50IGl0c2VsZlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1pdChldmVudFR5cGUsIGV2ZW50LCAuLi5wYXlsb2Fkcykge1xuICB0aGlzLmVtaXQoZXZlbnQsIC4uLnBheWxvYWRzKTtcbiAgdGhpcy5lbWl0KGV2ZW50VHlwZSwgZXZlbnQsIC4uLnBheWxvYWRzKTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcCh0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHQpO1xuICB9KTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi91dGlscy5qc1xuICoqLyIsImltcG9ydCBSY01vZHVsZSBmcm9tICcuLi8uLi9saWIvcmMtbW9kdWxlJztcbmltcG9ydCBTeW1ib2xNYXAgZnJvbSAnLi4vLi4vbGliL3N5bWJvbC1tYXAnO1xuaW1wb3J0IHN1YnNjcmlwdGlvbkFjdGlvbnMgZnJvbSAnLi9zdWJzY3JpcHRpb24tYWN0aW9ucyc7XG5pbXBvcnQgZ2V0U3Vic2NyaXB0aW9uUmVkdWNlciBmcm9tICcuL3N1YnNjcmlwdGlvbi1yZWR1Y2VyJztcbmltcG9ydCB7IHN1YnNjcmlwdGlvbkV2ZW50cywgc3Vic2NyaXB0aW9uRXZlbnRUeXBlcyB9IGZyb20gJy4vc3Vic2NyaXB0aW9uLWV2ZW50cyc7XG5pbXBvcnQgc3Vic2NyaXB0aW9uU3RhdHVzIGZyb20gJy4vc3Vic2NyaXB0aW9uLXN0YXR1cyc7XG5pbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgeyBlbWl0IH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAnYXV0aCcsXG4gICdzZGsnLFxuICAncGxhdGZvcm0nLFxuICAnc3Vic2NyaXB0aW9uJyxcbiAgJ2ZpbHRlckNhY2hlJyxcbl0pO1xuXG5cbmNvbnN0IGZpbHRlclJlZ2V4ID0ge1xuICBtZXNzYWdlOiAvbWVzc2FnZS1zdG9yZSQvLFxuICBwcmVzZW5jZTogL3ByZXNlbmNlKFxcP2RldGFpbGVkVGVsZXBob255U3RhdGU9dHJ1ZSk/JC8sXG4gIHRlbGVwaG9ueTogL3ByZXNlbmNlXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJC8sXG4gIGxpbmU6IC9wcmVzZW5jZVxcL2xpbmUkLyxcbiAgbGluZVByZXNlbmNlOiAvcHJlc2VuY2VcXC9saW5lXFwvcHJlc2VuY2UoXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlKT8kLyxcbiAgbGluZVRlbGVwaG9ueTogL3ByZXNlbmNlXFwvbGluZVxcL3ByZXNlbmNlXFw/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJC8sXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIG1lc3NhZ2VzIGRlbGl2ZXJlZCBieSB0aGUgc3Vic2NyaXB0b25cbiAqL1xuZnVuY3Rpb24gbWVzc2FnZUhhbmRsZXIobWVzc2FnZSkge1xuICAvLyBkZXRlcm1pbmUgd2hpY2ggZXZlbnRzIHRoZSBtZXNzYWdlIGZhbGxzIHVuZGVyXG4gIGNvbnN0IGV2ZW50cyA9IFtdO1xuICBpZiAoZmlsdGVyUmVnZXgubWVzc2FnZS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSB7XG4gICAgZXZlbnRzLnB1c2goJ21lc3NhZ2UnKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXJSZWdleC5saW5lLnRlc3QobWVzc2FnZS5ldmVudCkpIHtcbiAgICBldmVudHMucHVzaCgnbGluZScpO1xuICB9IGVsc2UgaWYgKGZpbHRlclJlZ2V4LmxpbmVQcmVzZW5jZS50ZXN0KG1lc3NhZ2UuZXZlbnQpKSB7XG4gICAgZXZlbnRzLnB1c2goJ2xpbmVQcmVzZW5jZScpO1xuICAgIGlmIChmaWx0ZXJSZWdleC5saW5lVGVsZXBob255LnRlc3QobWVzc2FnZS5ldmVudCkpIGV2ZW50cy5wdXNoKCdsaW5lVGVsZXBob255Jyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyUmVnZXgucHJlc2VuY2UudGVzdChtZXNzYWdlLmV2ZW50KSkge1xuICAgIGV2ZW50cy5wdXNoKCdwcmVzZW5jZScpO1xuICAgIGlmIChmaWx0ZXJSZWdleC50ZWxlcGhvbnkudGVzdChtZXNzYWdlLmV2ZW50KSkgZXZlbnRzLnB1c2goJ3RlbGVwaG9ueScpO1xuICB9XG4gIC8vIGRpc3BhdGNoIHRoZSBtZXNzYWdlIGluIHJlZHV4IG1hbm5lclxuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMubm90aWZpY2F0aW9uLFxuICAgIGV2ZW50VHlwZXM6IGV2ZW50cyxcbiAgICBwYXlsb2FkOiBtZXNzYWdlLFxuICB9KTtcbiAgLy8gZW1pdCB0aGUgbWVzc2FnZXMgYXMgZXZlbnRzXG4gIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMubm90aWZpY2F0aW9uLCBzdWJzY3JpcHRpb25FdmVudHNbZXZlbnRdLCBtZXNzYWdlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbml0KCkge1xuICBjb25zdCBwbGF0Zm9ybSA9IHRoaXNbc3ltYm9scy5wbGF0Zm9ybV07XG4gIHRoaXNbc3ltYm9scy5zdWJzY3JpcHRpb25dID0gdGhpc1tzeW1ib2xzLnNka10uY3JlYXRlU3Vic2NyaXB0aW9uKCk7XG4gIGNvbnN0IG93bmVySWQgPSBwbGF0Zm9ybS5hdXRoKCkuZGF0YSgpLm93bmVyX2lkO1xuICBsZXQgY2FjaGVLZXkgPSBudWxsO1xuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjYWNoZUtleSA9IGAke3RoaXMucHJlZml4fS1zdWItJHtvd25lcklkfWA7XG4gICAgY29uc3QgY2FjaGVkU3Vic2NyaXB0aW9uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYmFzZS5zZXRTdWJzY3JpcHRpb24oSlNPTi5wYXJzZShjYWNoZWRTdWJzY3JpcHRpb24pKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgdGhpcy5iYXNlLnNldEV2ZW50RmlsdGVycyh0aGlzLmZpbHRlcnMpO1xuXG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLm5vdGlmaWNhdGlvbiwgbWVzc2FnZSA9PiB7XG4gICAgdGhpczo6bWVzc2FnZUhhbmRsZXIobWVzc2FnZSk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5yZW1vdmVTdWNjZXNzLCAoKSA9PiB7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMubm90U3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogbnVsbCxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICB9KTtcbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMucmVtb3ZlRXJyb3IsICgpID0+IHtcbiAgICAvLyBUT0RPXG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5yZW5ld1N1Y2Nlc3MsICgpID0+IHtcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLmJhc2Uuc3Vic2NyaXB0aW9uKCkpKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkU3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMuc3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5iYXNlLnN1YnNjcmlwdGlvbigpLFxuICAgIH0pO1xuICAgIGlmIChvbGRTdGF0dXMgIT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuYmFzZS5vbih0aGlzLmJhc2UuZXZlbnRzLnJlbmV3RXJyb3IsIGVycm9yID0+IHtcbiAgICAvLyBUT0RPIGhhbmRsZSA0MjlcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVTdGF0dXMsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cy5ub3RTdWJzY3JpYmVkLFxuICAgICAgc3Vic2NyaXB0aW9uOiBudWxsLFxuICAgIH0pO1xuICAgIHRoaXM6OmVtaXQoc3Vic2NyaXB0aW9uRXZlbnRUeXBlcy5zdGF0dXNDaGFuZ2VkLCB0aGlzLnN0YXR1cyk7XG4gICAgdGhpcy5iYXNlLnJlc2V0KCkuc2V0RXZlbnRGaWx0ZXJzKHRoaXMuZmlsdGVycykucmVnaXN0ZXIoKS5jYXRjaChlID0+IHsgfSk7XG4gIH0pO1xuICB0aGlzLmJhc2Uub24odGhpcy5iYXNlLmV2ZW50cy5zdWJzY3JpYmVTdWNjZXNzLCAoKSA9PiB7XG4gICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShjYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5iYXNlLnN1YnNjcmlwdGlvbigpKSk7XG4gICAgfVxuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZVN0YXR1cyxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uU3RhdHVzLnN1YnNjcmliZWQsXG4gICAgICBzdWJzY3JpcHRpb246IHRoaXMuYmFzZS5zdWJzY3JpcHRpb24oKSxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMuc3RhdHVzQ2hhbmdlZCwgdGhpcy5zdGF0dXMpO1xuICB9KTtcbiAgdGhpcy5iYXNlLm9uKHRoaXMuYmFzZS5ldmVudHMuc3Vic2NyaWJlRXJyb3IsIGVycm9yID0+IHtcbiAgICAvLyBUT0RPXG4gICAgLy8gaGFuZGxlIDQyOVxuICAgIC8vIGhhbmRsZSBzdWJzY3JpcHRpb24gbGltaXRcbiAgfSk7XG5cbiAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICB0aGlzLmJhc2UucmVnaXN0ZXIoKS5jYXRjaCgoKSA9PiB7IC8qIGRvIG5vdGhpbmcgKi8gfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Vic2NyaXB0aW9uIGV4dGVuZHMgUmNNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJlZ2lzdGVyU3RvcmVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZWdpc3RlclN0b3JlSGFuZGxlcihzdG9yZSA9PiB7XG4gICAgICAgICAgLy8gc2V0IHN0b3JlIHRvIHNlbGYgZmlyc3RcbiAgICAgICAgICBoYW5kbGVyKHN0b3JlKTtcblxuICAgICAgICAgIC8vIHVwZGF0ZSBzdG9yZSB3aXRoIGNhY2hlZEZpbHRlcnNcbiAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVGaWx0ZXJzLFxuICAgICAgICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpc1tzeW1ib2xzLmZpbHRlckNhY2hlXSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFjdGlvbnM6IHN1YnNjcmlwdGlvbkFjdGlvbnMsXG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhdXRoLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBzZGssXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpc1tzeW1ib2xzLmF1dGhdID0gYXV0aDtcbiAgICB0aGlzW3N5bWJvbHMucGxhdGZvcm1dID0gcGxhdGZvcm07XG4gICAgdGhpc1tzeW1ib2xzLnNka10gPSBzZGs7XG4gICAgdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl0gPSBudWxsO1xuXG4gICAgLy8gY2FjaGVzIGZpbHRlcnMgYmVmb3JlIHJlZHV4IHN0b3JlIGlzIGNyZWF0ZWRcbiAgICB0aGlzW3N5bWJvbHMuZmlsdGVyQ2FjaGVdID0gW107XG5cbiAgICBhdXRoLm9uKGF1dGguZXZlbnRzLmxvZ2dlZEluLCAoKSA9PiB7XG4gICAgICB0aGlzOjppbml0KCk7XG4gICAgfSk7XG5cbiAgICBhdXRoLm9uKGF1dGguZXZlbnRzLmxvZ2dlZE91dCwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYmFzZSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBwbGF0Zm9ybS5vbihwbGF0Zm9ybS5ldmVudHMubG9naW5TdWNjZXNzLCAoKSA9PiB7XG4gICAgLy8gICB0aGlzOjppbml0KCk7XG4gICAgLy8gfSk7XG4gICAgLy8gcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ291dFN1Y2Nlc3MsIGFzeW5jICgpID0+IHtcbiAgICAvLyAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAvLyAgICAgYXdhaXQgdGhpcy5yZXNldCgpO1xuICAgIC8vICAgfVxuICAgIC8vICAgdGhpc1tzeW1ib2xzLnN1YnNjcmlwdGlvbl0gPSBudWxsO1xuICAgIC8vIH0pO1xuXG4gICAgYXV0aC5hZGRCZWZvcmVMb2dvdXRIYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVzZXQoKTtcbiAgICB9KTtcblxuICAgIC8vIChhc3luYyAoKSA9PiB7XG4gICAgLy8gICBpZiAoYXdhaXQgcGxhdGZvcm0ubG9nZ2VkSW4oKSkge1xuICAgIC8vICAgICB0aGlzOjppbml0KCk7XG4gICAgLy8gICB9XG4gICAgLy8gfSkoKTtcbiAgfVxuXG4gIGdldCByZWR1Y2VyKCkge1xuICAgIHJldHVybiBnZXRTdWJzY3JpcHRpb25SZWR1Y2VyKHRoaXMucHJlZml4KTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG5cbiAgZ2V0IGZpbHRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gfHwgdGhpcy5zdGF0ZS5maWx0ZXJzO1xuICB9XG5cbiAgZ2V0IGJhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXNbc3ltYm9scy5zdWJzY3JpcHRpb25dO1xuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uRXZlbnRzO1xuICB9XG5cbiAgZ2V0IGV2ZW50VHlwZXMoKSB7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbkV2ZW50VHlwZXM7XG4gIH1cblxuICBzdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAvLyBUT0RPIG5vcm1hbGl6ZWQgZXJyb3JcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkV2ZW50czo6RW51bS5oYXNWYWx1ZShldmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXZlbnQgaXMgbm90IHJlY29nbml6ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJzLmluZGV4T2YoZXZlbnQpID09PSAtMSkge1xuICAgICAgY29uc3QgbmV3RmlsdGVycyA9IHRoaXMuZmlsdGVycy5zbGljZSgpO1xuICAgICAgbmV3RmlsdGVycy5wdXNoKGV2ZW50KTtcbiAgICAgIGlmICh0aGlzLmJhc2UpIHtcbiAgICAgICAgdGhpcy5iYXNlLnNldEV2ZW50RmlsdGVycyhuZXdGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcnMsXG4gICAgICAgICAgZmlsdGVyczogbmV3RmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFzZS5yZWdpc3RlcigpLmNhdGNoKCgpID0+IHsgLyogZG8gbm90aGluZyAqLyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbc3ltYm9scy5maWx0ZXJDYWNoZV0gPSBuZXdGaWx0ZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVuc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgLy8gVE9ETyBub3JtYWxpemVkIGVycm9yXG4gICAgaWYgKCFzdWJzY3JpcHRpb25FdmVudHM6OkVudW0uaGFzVmFsdWUoZXZlbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V2ZW50IGlzIG5vdCByZWNvZ25pemVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGlkeCA9IHRoaXMuZmlsdGVycy5pbmRleE9mKGV2ZW50KTtcbiAgICBpZiAodGhpcy5maWx0ZXJzLmluZGV4T2YoZXZlbnQpID4gLTEpIHtcbiAgICAgIGNvbnN0IG5ld0ZpbHRlcnMgPSB0aGlzLmZpbHRlcnMuc2xpY2UoKTtcbiAgICAgIG5ld0ZpbHRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICBpZiAodGhpcy5iYXNlKSB7XG4gICAgICAgIHRoaXMuYmFzZS5zZXRFdmVudEZpbHRlcnMobmV3RmlsdGVycyk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy51cGRhdGVGaWx0ZXJzLFxuICAgICAgICAgIGZpbHRlcnM6IG5ld0ZpbHRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3RmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJhc2UucmVnaXN0ZXIoKS5jYXRjaCgoKSA9PiB7IC8qIGRvIG5vdGhpbmcgKi8gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5iYXNlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3N5bWJvbHMuZmlsdGVyQ2FjaGVdID0gbmV3RmlsdGVycztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyByZXNldCgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuYmFzZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IHN1YnNjcmlwdGlvblN0YXR1cy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5iYXNlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IHRoaXMuYmFzZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICB0aGlzW3N5bWJvbHMuc3Vic2NyaXB0aW9uXSA9IG51bGw7XG4gICAgY29uc3Qgb2xkU3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudXBkYXRlU3RhdHVzLFxuICAgICAgc3RhdHVzOiBzdWJzY3JpcHRpb25TdGF0dXMubm90U3Vic2NyaWJlZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogbnVsbCxcbiAgICB9KTtcbiAgICBpZiAob2xkU3RhdHVzICE9PSB0aGlzLnN0YXR1cykge1xuICAgICAgdGhpczo6ZW1pdChzdWJzY3JpcHRpb25FdmVudFR5cGVzLnN0YXR1c0NoYW5nZWQsIHRoaXMuc3RhdHVzKTtcbiAgICB9XG4gIH1cblxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9pbmRleC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpXG4gICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gICd1cGRhdGVGaWx0ZXJzJyxcbiAgJ25vdGlmaWNhdGlvbicsXG5cbiAgJ3VwZGF0ZVN0YXR1cycsXG5cbl0sICdzdWJzY3JpcHRpb24nKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHN1YnNjcmlwdGlvbkFjdGlvbnMgZnJvbSAnLi9zdWJzY3JpcHRpb24tYWN0aW9ucyc7XG5pbXBvcnQgeyBzdWJzY3JpcHRpb25FdmVudHMgfSBmcm9tICcuL3N1YnNjcmlwdGlvbi1ldmVudHMnO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGNhY2hlS2V5OiBudWxsLFxuICBmaWx0ZXJzOiBbXSxcbiAgc3RhdHVzOiBzdWJzY3JpcHRpb25FdmVudHMucGVuZGluZyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvblJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKHN1YnNjcmlwdGlvbkFjdGlvbnMsIHByZWZpeCk7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbiAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgYWN0aW9ucy51cGRhdGVTdGF0dXM6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXR1czogYWN0aW9uLnN0YXR1cyxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogYWN0aW9ucy5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBhY3Rpb25zLnVwZGF0ZUZpbHRlcnM6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcnM6IGFjdGlvbi5maWx0ZXJzLnNsaWNlKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vLi4vbGliL2VudW0nO1xuaW1wb3J0IHN1YnNjcmlwdGlvblN0YXR1cyBmcm9tICcuL3N1YnNjcmlwdGlvbi1zdGF0dXMnO1xuXG5cbmNvbnN0IGV2ZW50RGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L21lc3NhZ2Utc3RvcmUnLFxuICBwcmVzZW5jZTogJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlJyxcbiAgdGVsZXBob255OiAnL3Jlc3RhcGkvdjEuMC9hY2NvdW50L34vZXh0ZW5zaW9uL34vcHJlc2VuY2U/ZGV0YWlsZWRUZWxlcGhvbnlTdGF0ZT10cnVlJyxcbiAgbGluZTogJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlL2xpbmUnLFxuICBsaW5lUHJlc2VuY2U6XG4gICAgJy9yZXN0YXBpL3YxLjAvYWNjb3VudC9+L2V4dGVuc2lvbi9+L3ByZXNlbmNlL2xpbmUvcHJlc2VuY2UnLFxuICBsaW5lVGVsZXBob255OlxuICAgICcvcmVzdGFwaS92MS4wL2FjY291bnQvfi9leHRlbnNpb24vfi9wcmVzZW5jZS9saW5lL3ByZXNlbmNlP2RldGFpbGVkVGVsZXBob255U3RhdGU9dHJ1ZScsXG4gIC4uLnN1YnNjcmlwdGlvblN0YXR1cyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdWJzY3JpcHRpb25FdmVudHMgPSBuZXcgRW51bShldmVudERlZmluaXRpb24pO1xuXG5jb25zdCBldmVudFR5cGVEZWZpbml0aW9uID0ge1xuICBub3RpZmljYXRpb246ICdOT1RJRklDQVRJT04nLFxuICBzdGF0dXNDaGFuZ2VkOiAnU1RBVFVTX0NIQU5HRUQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN1YnNjcmlwdGlvbkV2ZW50VHlwZXMgPSBuZXcgRW51bShldmVudFR5cGVEZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi1ldmVudHMuanNcbiAqKi8iLCJpbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5cbmNvbnN0IGRlZmluaXRpb24gPSB7XG4gIHBlbmRpbmc6ICdQRU5ESU5HJyxcbiAgc3Vic2NyaWJlZDogJ1NVQlNDUklCRUQnLFxuICBub3RTdWJzY3JpYmVkOiAnTk9UX1NVQlNDUklCRUQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3N1YnNjcmlwdGlvbi9zdWJzY3JpcHRpb24tc3RhdHVzLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgeyBleHRyYWN0RGF0YSwgZmV0Y2hMaXN0LCBlbWl0IH0gZnJvbSAnLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB1c2VyQWN0aW9ucyBmcm9tICcuL3VzZXItYWN0aW9ucyc7XG5pbXBvcnQgZ2V0VXNlclJlZHVjZXIgZnJvbSAnLi91c2VyLXJlZHVjZXInO1xuaW1wb3J0IHsgdXNlckV2ZW50cywgdXNlckV2ZW50VHlwZXMgfSBmcm9tICcuL3VzZXItZXZlbnRzJztcblxuY29uc3Qgc3ltYm9scyA9IG5ldyBTeW1ib2xNYXAoW1xuICAnYXBpJyxcbiAgJ3BsYXRmb3JtJyxcbiAgJ3NldHRpbmdzJyxcbl0pO1xuXG4vLyBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4vLyAgIHRlc3Q6IHRydWUsXG4vLyB9O1xuXG4vLyBmdW5jdGlvbiBnZXRVc2VyU2V0dGluZ3NSZWR1Y2VyKHByZWZpeCkge1xuLy8gICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbi8vICAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4vLyAgICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbi8vICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4vLyAgICAgICBkZWZhdWx0OlxuLy8gICAgICAgICByZXR1cm4gc3RhdGU7XG4vLyAgICAgfVxuLy8gICB9O1xuLy8gfVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFUeXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsb2FkRnVuY3Rpb24gLSBhc3luYyBsb2FkZXIgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBkZXNjcmlwdGlvbiBHZW5lcmljIGRhdGEgbG9hZGluZyBsb2dpYyB3aXRoIGV2ZW50c1xuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkRGF0YShkYXRhVHlwZSwgbG9hZEZ1bmN0aW9uKSB7XG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9uc1tgbG9hZCR7ZGF0YVR5cGV9YF0sXG4gIH0pO1xuICB0aGlzLmVtaXQodXNlckV2ZW50c1tgbG9hZCR7ZGF0YVR5cGV9YF0pO1xuICB0cnkge1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzOjpsb2FkRnVuY3Rpb24oKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9uc1tgbG9hZCR7ZGF0YVR5cGV9U3VjY2Vzc2BdLFxuICAgICAgcGF5bG9hZCxcbiAgICB9KTtcbiAgICB0aGlzOjplbWl0KHVzZXJFdmVudFR5cGVzLnVzZXJJbmZvQ2hhbmdlZCwgdXNlckV2ZW50c1tgbG9hZCR7ZGF0YVR5cGV9U3VjY2Vzc2BdKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9uc1tgbG9hZCR7ZGF0YVR5cGV9RmFpbGVkYF0sXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KHVzZXJFdmVudHNbYGxvYWQke2RhdGFUeXBlfUZhaWxlZGBdKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxuICogQGRlc2NyaXB0aW9uIEZldGNoIGFjY291bnQgaW5mbyBhbmQgZXh0cmFjdCB0aGUgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0QWNjb3VudEluZm8oKSB7XG4gIHJldHVybiBleHRyYWN0RGF0YShhd2FpdCB0aGlzW3N5bWJvbHMuYXBpXS5hY2NvdW50KCkubG9hZEFjY291bnQoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkQWNjb3VudEluZm8oKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnQWNjb3VudEluZm8nLCBleHRyYWN0QWNjb3VudEluZm8pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RXh0ZW5zaW9uSW5mbygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXNbc3ltYm9scy5hcGldLmV4dGVuc2lvbigpLmxvYWRFeHRlbnNpb25JbmZvKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEV4dGVuc2lvbkluZm8oKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnRXh0ZW5zaW9uSW5mbycsIGV4dHJhY3RFeHRlbnNpb25JbmZvKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdERpYWxpbmdQbGFucygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXM6OmZldGNoTGlzdChvcHRpb25zID0+IChcbiAgICB0aGlzW3N5bWJvbHMuYXBpXS5hY2NvdW50KCkubGlzdERpYWxpbmdQbGFucyhvcHRpb25zKVxuICApKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRGlhbGluZ1BsYW5zKCkge1xuICByZXR1cm4gYXdhaXQgdGhpczo6bG9hZERhdGEoJ0RpYWxpbmdQbGFucycsIGV4dHJhY3REaWFsaW5nUGxhbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0UGhvbmVOdW1iZXJzKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmV4dGVuc2lvbigpLmxpc3RFeHRlbnNpb25QaG9uZU51bWJlcnMob3B0aW9ucylcbiAgKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFBob25lTnVtYmVycygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdQaG9uZU51bWJlcnMnLCBleHRyYWN0UGhvbmVOdW1iZXJzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEZvcndhcmRpbmdOdW1iZXJzKCkge1xuICByZXR1cm4gZXh0cmFjdERhdGEoYXdhaXQgdGhpczo6ZmV0Y2hMaXN0KG9wdGlvbnMgPT4gKFxuICAgIHRoaXNbc3ltYm9scy5hcGldLmZvcndhcmRpbmdOdW1iZXJzKCkubGlzdEV4dGVuc2lvbkZvcndhcmRpbmdOdW1iZXJzKG9wdGlvbnMpXG4gICkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRGb3J3YXJkaW5nTnVtYmVycygpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXM6OmxvYWREYXRhKCdGb3J3YXJkaW5nTnVtYmVycycsIGV4dHJhY3RGb3J3YXJkaW5nTnVtYmVycyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RCbG9ja2VkTnVtYmVycygpIHtcbiAgcmV0dXJuIGV4dHJhY3REYXRhKGF3YWl0IHRoaXM6OmZldGNoTGlzdChvcHRpb25zID0+IChcbiAgICB0aGlzW3N5bWJvbHMuYXBpXS5ibG9ja2VkTnVtYmVycygpLmxpc3RCbG9ja2VkTnVtYmVycyhvcHRpb25zKVxuICApKSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkQmxvY2tlZE51bWJlcnMoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzOjpsb2FkRGF0YSgnQmxvY2tlZE51bWJlcnMnLCBleHRyYWN0QmxvY2tlZE51bWJlcnMpO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZEluZm8oKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpczo6bG9hZEFjY291bnRJbmZvKCksXG4gICAgICB0aGlzOjpsb2FkRXh0ZW5zaW9uSW5mbygpLFxuICAgICAgdGhpczo6bG9hZERpYWxpbmdQbGFucygpLFxuICAgICAgdGhpczo6bG9hZFBob25lTnVtYmVycygpLFxuICAgICAgdGhpczo6bG9hZEZvcndhcmRpbmdOdW1iZXJzKCksXG4gICAgICB0aGlzOjpsb2FkQmxvY2tlZE51bWJlcnMoKSxcbiAgICBdKTtcbiAgICAvLyB0aGlzLmVtaXQodXNlckV2ZW50cy51c2VySW5mb0xvYWRlZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPIHNlbmQgZXJyb3Igb3V0XG4gICAgY29uc29sZS5sb2coZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgVXNlclxuICogQGV4dGVuZHMgUmNNb2R1bGVcbiAqIEBkZWZhdWx0XG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZXIgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWN0aW9uczogdXNlckFjdGlvbnMsXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYXBpLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBzZXR0aW5ncyxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzW3N5bWJvbHMuYXBpXSA9IGFwaTtcbiAgICB0aGlzW3N5bWJvbHMucGxhdGZvcm1dID0gcGxhdGZvcm07XG4gICAgdGhpc1tzeW1ib2xzLnNldHRpbmdzXSA9IHNldHRpbmdzO1xuXG4gICAgLy8gc2V0dGluZ3MucmVnaXN0ZXJSZWR1Y2VyKCd1c2VyJywgZ2V0VXNlclNldHRpbmdzUmVkdWNlcigpKTtcblxuICAgIC8vIGxvYWQgaW5mbyBvbiBsb2dpblxuICAgIHBsYXRmb3JtLm9uKHBsYXRmb3JtLmV2ZW50cy5sb2dpblN1Y2Nlc3MsICgpID0+IHtcbiAgICAgIHRoaXM6OmxvYWRJbmZvKCk7XG4gICAgfSk7XG4gICAgLy8gdW5sb2FkIGluZm8gb24gbG9nb3V0XG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ291dFN1Y2Nlc3MsICgpID0+IHtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2xlYXJVc2VySW5mbyxcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcy5lbWl0KHVzZXJFdmVudHMudXNlckluZm9DbGVhcmVkKTtcbiAgICB9KTtcblxuXG4gICAgLy8gbG9hZCBpbmZvIGlmIGFscmVhZHkgbG9nZ2VkIGluXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhd2FpdCBwbGF0Zm9ybS5sb2dnZWRJbigpKSB7XG4gICAgICAgIGF3YWl0IHRoaXM6OmxvYWRJbmZvKCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8qKlxuICAgICAqIFRPRE86XG4gICAgICogICAxLiBEaWFsaW5nIFBsYW4gQ2hlY2tpbmdcbiAgICAgKi9cbiAgfVxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0VXNlclJlZHVjZXIodGhpcy5wcmVmaXgpO1xuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gdXNlckV2ZW50cztcbiAgfVxuXG4gIGdldCBldmVudFR5cGVzKCkge1xuICAgIHJldHVybiB1c2VyRXZlbnRUeXBlcztcbiAgfVxuXG4gIGdldCBkaXJlY3ROdW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBob25lTnVtYmVycy5maWx0ZXIobiA9PiBuLnVzYWdlVHlwZSA9PT0gJ0RpcmVjdE51bWJlcicpO1xuICB9XG5cbiAgZ2V0IG1haW5Db21wYW55TnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBob25lTnVtYmVycy5maW5kKG4gPT4gbi51c2FnZVR5cGUgPT09ICdNYWluQ29tcGFueU51bWJlcicpO1xuICB9XG5cbiAgZ2V0IGRpYWxpbmdQbGFucygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaWFsaW5nUGxhbnM7XG4gIH1cblxuICBnZXQgZXh0ZW5zaW9uTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmV4dGVuc2lvbkluZm8uZXh0ZW5zaW9uTnVtYmVyO1xuICB9XG5cbiAgZ2V0IHNtc051bWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGhvbmVOdW1iZXJzLmZpbHRlcihuID0+IG4uZmVhdHVyZXMuaW5kZXhPZignU21zU2VuZGVyJykgPiAtMSk7XG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy91c2VyL2luZGV4LmpzXG4gKiovIiwiaW1wb3J0IHsgQWN0aW9uTWFwIH0gZnJvbSAnLi4vLi4vbGliL3JlZHV4LWhlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBY3Rpb25NYXAoW1xuICAnY2xlYXJVc2VySW5mbycsXG5cbiAgJ2xvYWRBY2NvdW50SW5mbycsXG4gICdsb2FkQWNjb3VudEluZm9TdWNjZXNzJyxcbiAgJ2xvYWRBY2NvdW50SW5mb0ZhaWxlZCcsXG5cbiAgJ2xvYWRFeHRlbnNpb25JbmZvJyxcbiAgJ2xvYWRFeHRlbnNpb25JbmZvU3VjY2VzcycsXG4gICdsb2FkRXh0ZW5zaW9uSW5mb0ZhaWxlZCcsXG5cbiAgJ2xvYWREaWFsaW5nUGxhbnMnLFxuICAnbG9hZERpYWxpbmdQbGFuc1N1Y2Nlc3MnLFxuICAnbG9hZERpYWxpbmdQbGFuc0ZhaWxlZCcsXG5cbiAgJ2xvYWRQaG9uZU51bWJlcnMnLFxuICAnbG9hZFBob25lTnVtYmVyc1N1Y2Nlc3MnLFxuICAnbG9hZFBob25lTnVtYmVyc0ZhaWxlZCcsXG5cbiAgJ2xvYWRGb3J3YXJkaW5nTnVtYmVycycsXG4gICdsb2FkRm9yd2FyZGluZ051bWJlcnNTdWNjZXNzJyxcbiAgJ2xvYWRGb3J3YXJkaW5nTnVtYmVyc0ZhaWxlZCcsXG5cbiAgJ2xvYWRCbG9ja2VkTnVtYmVycycsXG4gICdsb2FkQmxvY2tlZE51bWJlcnNTdWNjZXNzJyxcbiAgJ2xvYWRCbG9ja2VkTnVtYmVyc0ZhaWxlZCcsXG5cbl0sICd1c2VyJyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvdXNlci1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHVzZXJBY3Rpb25zIGZyb20gJy4vdXNlci1hY3Rpb25zJztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBhY2NvdW50SW5mbzogbnVsbCxcbiAgYWNjb3VudEluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgYWNjb3VudEluZm9FcnJvcjogbnVsbCxcblxuICBleHRlbnNpb25JbmZvOiBudWxsLFxuICBleHRlbnNpb25JbmZvTG9hZGluZzogZmFsc2UsXG4gIGV4dGVuc2lvbkluZm9FcnJvcjogbnVsbCxcblxuICBkaWFsaW5nUGxhbnM6IFtdLFxuICBkaWFsaW5nUGxhbnNMb2FkaW5nOiBmYWxzZSxcbiAgZGlhbGluZ1BsYW5zRXJyb3I6IG51bGwsXG5cbiAgcGhvbmVOdW1iZXJzOiBbXSxcbiAgcGhvbmVOdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gIHBob25lTnVtYmVyc0Vycm9yOiBudWxsLFxuXG4gIGZvcndhcmRpbmdOdW1iZXJzOiBbXSxcbiAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgZm9yd2FyZGluZ051bWJlcnNFcnJvcjogbnVsbCxcblxuICBibG9ja2VkTnVtYmVyczogW10sXG4gIGJsb2NrZWROdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gIGJsb2NrZWROdW1iZXJzRXJyb3I6IG51bGwsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVc2VyUmVkdWNlcihwcmVmaXgpIHtcbiAgY29uc3QgYWN0aW9ucyA9IHByZWZpeEFjdGlvbnModXNlckFjdGlvbnMsIHByZWZpeCk7XG4gIHJldHVybiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKTtcbiAgICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuICAgICAgLy8gYWNjb3VudCBpbmZvXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZEFjY291bnRJbmZvOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50SW5mb0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkQWNjb3VudEluZm9TdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhY2NvdW50SW5mbzogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgICBhY2NvdW50SW5mb0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjb3VudEluZm9FcnJvcjogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRBY2NvdW50SW5mb0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYWNjb3VudEluZm9Mb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGFjY291bnRJbmZvRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBleHRlbnNpb24gaW5mb1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRFeHRlbnNpb25JbmZvOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleHRlbnNpb25JbmZvTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRFeHRlbnNpb25JbmZvU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXh0ZW5zaW9uSW5mbzogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgICBleHRlbnNpb25JbmZvTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb25JbmZvRXJyb3I6IG51bGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkRXh0ZW5zaW9uSW5mb0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZXh0ZW5zaW9uSW5mb0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXh0ZW5zaW9uSW5mb0Vycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgLy8gZGlhbGluZyBwbGFuc1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWREaWFsaW5nUGxhbnM6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkRGlhbGluZ1BsYW5zU3VjY2VzczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlhbGluZ1BsYW5zTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBkaWFsaW5nUGxhbnM6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICBjYXNlIGFjdGlvbi5sb2FkRGlhbGluZ1BsYW5zRmFpbGVkOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaWFsaW5nUGxhbnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRpYWxpbmdQbGFuc0Vycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuXG4gICAgICAvLyBwaG9uZSBudW1iZXJzXG4gICAgICBjYXNlIGFjdGlvbnMubG9hZFBob25lTnVtYmVyczpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGhvbmVOdW1iZXJzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRQaG9uZU51bWJlcnNTdWNjZXNzOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwaG9uZU51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHBob25lTnVtYmVyczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWRQaG9uZU51bWJlcnNGYWlsZWQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBob25lTnVtYmVyc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJzRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBmb3J3YXJkaW5nIG51bWJlcnNcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkRm9yd2FyZGluZ051bWJlcnM6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRGb3J3YXJkaW5nTnVtYmVyc1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBmb3J3YXJkaW5nTnVtYmVyczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWRGb3J3YXJkaW5nTnVtYmVyc0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yd2FyZGluZ051bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcndhcmRpbmdOdW1iZXJzRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICAvLyBibG9ja2VkIG51bWJlcnNcbiAgICAgIGNhc2UgYWN0aW9ucy5sb2FkQmxvY2tlZE51bWJlcnM6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgY2FzZSBhY3Rpb25zLmxvYWRCbG9ja2VkTnVtYmVyc1N1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBibG9ja2VkTnVtYmVyczogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgYWN0aW9uLmxvYWRCbG9ja2VkTnVtYmVyc0ZhaWxlZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmxvY2tlZE51bWJlcnNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrZWROdW1iZXJzRXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuXG4gICAgICBjYXNlIGFjdGlvbi5jbGVhclVzZXJJbmZvOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBpbml0aWFsU3RhdGUsXG4gICAgICAgICk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3VzZXIvdXNlci1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vLi4vbGliL2VudW0nO1xuXG5jb25zdCBldmVudERlZmluaXRpb25zID0ge1xuICB1c2VySW5mb0xvYWRlZDogJ1VTRVJfSU5GT19MT0FERUQnLFxuICB1c2VySW5mb0NsZWFyZWQ6ICdVU0VSX0lORk9fQ0xFQVJFRCcsXG5cbiAgbG9hZEFjY291bnRJbmZvOiAnTE9BRF9BQ0NPVU5UX0lORk8nLFxuICBsb2FkQWNjb3VudEluZm9TdWNjZXNzOiAnTE9BRF9BQ0NPVU5UX0lORk9fU1VDQ0VTUycsXG4gIGxvYWRBY2NvdW50SW5mb0ZhaWxlZDogJ0xPQURfQUNDT1VOVF9JTkZPX0ZBSUxFRCcsXG5cbiAgbG9hZEV4dGVuc2lvbkluZm86ICdMT0FEX0VYVEVOU0lPTl9JTkZPJyxcbiAgbG9hZEV4dGVuc2lvbkluZm9TdWNjZXNzOiAnTE9BRF9FWFRFTlNJT05fSU5GT19TVUNDRVNTJyxcbiAgbG9hZEV4dGVuc2lvbkluZm9GYWlsZWQ6ICdMT0FEX0VYVEVOU0lPTl9JTkZPX0ZBSUxFRCcsXG5cbiAgbG9hZERpYWxpbmdQbGFuczogJ0xPQURfRElBTElOR19QTEFOUycsXG4gIGxvYWREaWFsaW5nUGxhbnNTdWNjZXNzOiAnTE9BRF9ESUFMSU5HX1BMQU5TX1NVQ0NFU1MnLFxuICBsb2FkRGlhbGluZ1BsYW5zRmFpbGVkOiAnTE9BRF9ESUFMSU5HX1BMQU5TX0ZBSUxFRCcsXG5cbiAgbG9hZFBob25lTnVtYmVyczogJ0xPQURfUEhPTkVfTlVNQkVSUycsXG4gIGxvYWRQaG9uZU51bWJlcnNTdWNjZXNzOiAnTE9BRF9QSE9ORV9OVU1CRVJTX1NVQ0NFU1MnLFxuICBsb2FkUGhvbmVOdW1iZXJzRmFpbGVkOiAnTE9BRF9QSE9ORV9OVU1CRVJTX0ZBSUxFRCcsXG5cbiAgbG9hZEZvcndhcmRpbmdOdW1iZXJzOiAnTE9BRF9GT1JXQVJESU5HX05VTUJFUlMnLFxuICBsb2FkRm9yd2FyZGluZ051bWJlcnNTdWNjZXNzOiAnTE9BRF9GT1JXQVJESU5HX05VTUJFUlNfU1VDQ0VTUycsXG4gIGxvYWRGb3J3YXJkaW5nTnVtYmVyc0ZhaWxlZDogJ0xPQURfRk9SV0FSRElOR19OVU1CRVJTX0ZBSUxFRCcsXG5cbiAgbG9hZEJsb2NrZWROdW1iZXJzOiAnTE9BRF9CTE9DS0VEX05VTUJFUlMnLFxuICBsb2FkQmxvY2tlZE51bWJlcnNTdWNjZXNzOiAnTE9BRF9CTE9DS0VEX05VTUJFUlNfU1VDQ0VTUycsXG4gIGxvYWRCbG9ja2VkTnVtYmVyc0ZhaWxlZDogJ0xPQURfQkxPQ0tFRF9OVU1CRVJTX0ZBSUxFRCcsXG59O1xuXG5leHBvcnQgY29uc3QgdXNlckV2ZW50cyA9IG5ldyBFbnVtKGV2ZW50RGVmaW5pdGlvbnMpO1xuXG5jb25zdCBldmVudFR5cGVEZWZpbml0aW9ucyA9IHtcbiAgdXNlckluZm9DaGFuZ2VkOiAnVVNFUl9JTkZPX0NIQU5HRUQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHVzZXJFdmVudFR5cGVzID0gbmV3IEVudW0oZXZlbnRUeXBlRGVmaW5pdGlvbnMpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy91c2VyL3VzZXItZXZlbnRzLmpzXG4gKiovIiwiaW1wb3J0IFJjTW9kdWxlIGZyb20gJy4uLy4uL2xpYi9yYy1tb2R1bGUnO1xuaW1wb3J0IFN5bWJvbE1hcCBmcm9tICcuLi8uLi9saWIvc3ltYm9sLW1hcCc7XG5pbXBvcnQgRW51bSBmcm9tICcuLi8uLi9saWIvZW51bSc7XG5pbXBvcnQgd2VicGhvbmVBY3Rpb25zIGZyb20gJy4vd2VicGhvbmUtYWN0aW9ucyc7XG5pbXBvcnQgY2FsbEFjdGlvbnMgZnJvbSAnLi9jYWxsLWFjdGlvbnMnO1xuaW1wb3J0IGdldFJlZHVjZXIgZnJvbSAnLi93ZWJwaG9uZS1yZWR1Y2VyJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJ2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IFJpbmdDZW50cmFsV2VicGhvbmUgZnJvbSAncmluZ2NlbnRyYWwtd2ViLXBob25lJztcbmltcG9ydCB3ZWJwaG9uZVN0YXR1cyBmcm9tICcuLi8uLi9lbnVtcy93ZWJwaG9uZS1zdGF0dXMnO1xuaW1wb3J0IGNhbGxTdGF0dXMgZnJvbSAnLi4vLi4vZW51bXMvY2FsbC1zdGF0dXMnO1xuXG5jb25zdCBzeW1ib2xzID0gbmV3IFN5bWJvbE1hcChbXG4gICdhcGknLFxuICAncGxhdGZvcm0nLFxuICAnZW1pdHRlcicsXG4gICdzZXR0aW5ncycsXG4gICdwaG9uZUluc3RhbmNlJyxcbl0pO1xuXG5jb25zdCBFTlVNUyA9IG5ldyBFbnVtKHtcbiAgd2VicGhvbmVTdGF0dXMsXG4gIGNhbGxTdGF0dXMsXG59KTtcblxuYXN5bmMgZnVuY3Rpb24gaW5pdFBob25lSW5zdGFuY2UoKSB7XG4gIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzW3N5bWJvbHMucGxhdGZvcm1dXG4gICAgLnBvc3QoJy9jbGllbnQtaW5mby9zaXAtcHJvdmlzaW9uJywge1xuICAgICAgc2lwSW5mbzogW3sgdHJhbnNwb3J0OiAnV1NTJyB9XSxcbiAgICB9KVxuICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKTtcbiAgcmV0dXJuIG5ldyBSaW5nQ2VudHJhbFdlYnBob25lKGluZm8sIHtcbiAgICBsb2dMZXZlbDogMCxcbiAgICBhdWRpb0hlbHBlcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICB9LFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVjb3JkKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uc3RvcFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuc3RvcFJlY29yZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5zdGFydFJlY29yZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMucmVjb3JkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtdXRlKGZsYWcgPSB0cnVlKSB7XG4gIGlmICghZmxhZykge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24udW5tdXRlKCk7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICAgIG9wZXJhdGlvbjoge1xuICAgICAgICB0eXBlOiBjYWxsQWN0aW9ucy51bm11dGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ubXV0ZSgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMubXV0ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaG9sZChmbGFnID0gdHJ1ZSkge1xuICBpZiAoIWZsYWcpIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnVuaG9sZCgpO1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMudW5ob2xkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLmhvbGQoKTtcbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgICAgb3BlcmF0aW9uOiB7XG4gICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmhvbGQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcmsoKSB7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24ucGFyaygpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLnBhcmssXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZmVyKG51bWJlcikge1xuICB0aGlzLmNoZWNrU2Vzc2lvbigpO1xuICBhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uLnRyYW5zZmVyKG51bWJlcik7XG4gIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsT3BlcmF0aW9uLFxuICAgIG9wZXJhdGlvbjoge1xuICAgICAgdHlwZTogY2FsbEFjdGlvbnMudHJhbnNmZXIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZsaXAobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZmxpcChudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmZsaXAsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGR0bWYobnVtYmVyKSB7XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIGF3YWl0IHRoaXMuY3VycmVudFNlc3Npb24uZHRtZihudW1iZXIpO1xuICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbE9wZXJhdGlvbixcbiAgICBvcGVyYXRpb246IHtcbiAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmR0bWYsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9wZXJhdGlvbnMobmFtZSwgLi4uYXJncykge1xuICBjb25zdCBhY3Rpb25zID0geyByZWNvcmQsIG11dGUsIGhvbGQsIHBhcmssIHRyYW5zZmVyLCBmbGlwLCBkdG1mIH07XG4gIHRoaXMuY2hlY2tTZXNzaW9uKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgYWN0aW9uc1tuYW1lXS5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxPcGVyYXRpb24sXG4gICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgdHlwZTogY2FsbEFjdGlvbnMuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBuZWVkZWQ/XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VicGhvbmUgZXh0ZW5kcyBSY01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWN0aW9uczogd2VicGhvbmVBY3Rpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwaSxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgc2V0dGluZ3MsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpc1tzeW1ib2xzLmFwaV0gPSBhcGk7XG4gICAgdGhpc1tzeW1ib2xzLnBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIHRoaXNbc3ltYm9scy5lbWl0dGVyXSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgdGhpc1tzeW1ib2xzLnNldHRpbmdzXSA9IHNldHRpbmdzO1xuXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdW50aWwgc2V0dGluZyBtb2R1bGUgY29tcGxldGVkXG4gICAgLy8gc2V0dGluZ3MucmVnaXN0ZXJSZWR1Y2VyKCd3ZWJwaG9uZScsIGdldFdlYnBob25lUmVkdWNlcigpKVxuXG4gICAgcGxhdGZvcm0ub24ocGxhdGZvcm0uZXZlbnRzLmxvZ2luU3VjY2VzcywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpc1tzeW1ib2xzLnBob25lSW5zdGFuY2VdID0gYXdhaXQgdGhpczo6aW5pdFBob25lSW5zdGFuY2UoKTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3JlZ2lzdGVyZWQnLCAoKSA9PiB7XG4gICAgICAgIC8vIHNpcCB3aWxsIGZpcmUgbXVsdGlwbGUgcmVnaXN0ZXJlZCBldmVudHMsIG9ubHkgZGlzcGF0Y2ggb25lIHJlZ2lzdGVyIGFjdGlvbiB0byBzdGF0ZS5cbiAgICAgICAgLy8gVE9ETzogaXMgdGhpcyBpc1JlZ2lzdGVyZWQgc3RhdGUgbmVlZGVkIHRvIGJlIHN0b3JlIGFzIGluc3RhbmNlIHZhcmlhYmxlXG4gICAgICAgIC8vICAgICAgIG9yIGp1c3QgY2hlY2sgc3RvcmUgc3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyU3VjY2VzcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVnaXN0ZXJlZCA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaXNSZWdpc3RlcmVkKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQub24oJ3VucmVnaXN0ZXJlZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50LmlzUmVnaXN0ZXJlZCgpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMudW5yZWdpc3RlcixcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IGNhbGxBY3Rpb25zLmNsZWFyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdyZWdpc3RyYXRpb25GYWlsZWQnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnJlZ2lzdGVyRXJyb3IsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50Lm9uKCdpbnZpdGUnLCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5saXN0ZW5TZXNzaW9uRXZlbnRzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlc3Npb24pO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBzZXNzaW9uLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogc2Vzc2lvbi5sb2NhbElkZW50aXR5LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcmVkdWNlcigpIHtcbiAgICByZXR1cm4gZ2V0UmVkdWNlcih0aGlzLnByZWZpeCk7XG4gIH1cblxuICBnZXQgZW51bXMoKSB7XG4gICAgcmV0dXJuIEVOVU1TO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwaG9uZSBjYWxsLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGluIHJlZ2lzdGVyU3VjY2VzcyBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9OdW1iZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tTnVtYmVyXVxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufVxuICAgKi9cbiAgYXN5bmMgY2FsbCh7IHRvTnVtYmVyLCBmcm9tTnVtYmVyLCBtZWRpYSB9KSB7XG4gICAgLy8gQ2hlY2sgc3RhdHVzXG4gICAgaWYgKCF0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0pIHtcbiAgICAgIHRocm93IEVycm9yKCdub3QgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICB0b051bWJlcixcbiAgICAgICAgZnJvbU51bWJlcixcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IHRoaXNbc3ltYm9scy5waG9uZUluc3RhbmNlXS51c2VyQWdlbnQuaW52aXRlKHRvTnVtYmVyLCB7XG4gICAgICBtZWRpYToge1xuICAgICAgICByZW5kZXI6IG1lZGlhLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlblNlc3Npb25FdmVudHMoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFcnJvcixcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGEgcGhvbmUgY2FsbCwgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGNhbGwgaXMgaW5jb21pbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lZGlhLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JpbmdjZW50cmFsL3JpbmdjZW50cmFsLXdlYi1waG9uZSNhY2NlcHRpbmctaW5jb21pbmctY2FsbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgYWNjZXB0KG1lZGlhKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi5hY2NlcHQobWVkaWEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBieWUoKSB7XG4gICAgdGhpcy5jaGVja1Nlc3Npb24oKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2Vzc2lvbi50ZXJtaW5hdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ET1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVjb3JkKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ3JlY29yZCcsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgbXV0ZShmbGFnKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICdtdXRlJywgZmxhZyk7XG4gIH1cblxuICBhc3luYyBob2xkKGZsYWcpIHtcbiAgICBvcGVyYXRpb25zLmNhbGwodGhpcywgJ2hvbGQnLCBmbGFnKTtcbiAgfVxuXG4gIGFzeW5jIHBhcmsoZmxhZykge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAncGFyaycsIGZsYWcpO1xuICB9XG5cbiAgYXN5bmMgdHJhbnNmZXIobnVtYmVyKSB7XG4gICAgb3BlcmF0aW9ucy5jYWxsKHRoaXMsICd0cmFuc2ZlcicsIG51bWJlcik7XG4gIH1cblxuICBhc3luYyBmbGlwKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnZmxpcCcsIG51bWJlcik7XG4gIH1cblxuICBhc3luYyBkdG1mKG51bWJlcikge1xuICAgIG9wZXJhdGlvbnMuY2FsbCh0aGlzLCAnZHRtZicsIG51bWJlcik7XG4gIH1cblxuICBsb2FkUmluZ0F1ZGlvKHsgaW5jb21pbmcsIG91dGdvaW5nIH0pIHtcbiAgICB0aGlzW3N5bWJvbHMucGhvbmVJbnN0YW5jZV0udXNlckFnZW50LmF1ZGlvSGVscGVyLmxvYWRBdWRpbyh7XG4gICAgICBpbmNvbWluZyxcbiAgICAgIG91dGdvaW5nLFxuICAgIH0pXG4gIH1cblxuICBjaGVja1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLnNlc3Npb25FcnJvcixcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgbGlzdGVuIHNlc3Npb24gZXZlbnRzXG4gICAqL1xuICBsaXN0ZW5TZXNzaW9uRXZlbnRzKCkge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2FjY2VwdGVkJywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAvLyBhY2NlcHRlZCBldmVudCBmb3Igb3V0Ym91bmQgY2FsbCB3aWxsIHJldHVybmUgYSBpbmNvbWluZ1Jlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSkge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFjdGlvbnMuY2FsbENvbm5lY3QsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IHJlc3BvbnNlLnRvLFxuICAgICAgICAgICAgbG9jYWxJZGVudGl0eTogcmVzcG9uc2UuZnJvbSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIC8vIGFjY2VwdGVkIGV2ZW50IGZvciBpbmJvdW5kIGNhbGwgd2lsbCBvbmx5IGNvbnRhaW4gYSByb3cgc2lwIGRhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsQWNjZXB0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbGwgc2l0dWF0aW9uIGFib3V0IGNhbGwgdGVybWluYXRlZCBleGNlcHQgJ2NhbGwgY2FuY2VsJ1xuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ3Rlcm1pbmF0ZWQnLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5hY3Rpb25zLmNhbGxFbmQsXG4gICAgICAgIGVycm9yOiBjYXVzZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgfSk7XG4gICAgLy8gd2hlbiB3ZSBjYWxsIG91dCBhbmQgY2FuY2VsIHRoZSBwaG9uZSBjYWxsXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbi5vbignY2FuY2VsJywgKHJlc3BvbnNlLCBjYXVzZSkgPT4ge1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgICBlcnJvcjogY2F1c2UsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgIH0pO1xuICAgIC8vIHNob3VsZCBub3QgbmVlZFxuICAgIHRoaXMuY3VycmVudFNlc3Npb24ub24oJ2J5ZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IHRoaXMuYWN0aW9ucy5jYWxsRW5kLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRTZXNzaW9uID0gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbW9kdWxlcy93ZWJwaG9uZS9pbmRleC5qc1xuICoqLyIsImltcG9ydCB7IEFjdGlvbk1hcCB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWN0aW9uTWFwKFtcbiAgJ3JlZ2lzdGVyJyxcbiAgJ3JlZ2lzdGVyU3VjY2VzcycsXG4gICdyZWdpc3RlckVycm9yJyxcbiAgJ3VucmVnaXN0ZXInLFxuXG4gIC8vIG91dGJvdW5kIGNhbGxcbiAgJ2NhbGwnLFxuICAnY2FsbENvbm5lY3QnLFxuICAvLyBpbmJvdW5kIGNhbGxcbiAgJ2NhbGxBY2NlcHQnLFxuICAnY2FsbEluY29taW5nJyxcblxuICAnY2FsbEVuZCcsXG4gICdjYWxsRXJyb3InLFxuICAnY2FsbE9wZXJhdGlvbicsXG4gIC8vIG5vIGFjdGl2ZSBzZXNzaW9uXG4gICdzZXNzaW9uRXJyb3InLFxuXSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tb2R1bGVzL3dlYnBob25lL3dlYnBob25lLWFjdGlvbnMuanNcbiAqKi8iLCJpbXBvcnQgeyBBY3Rpb25NYXAgfSBmcm9tICcuLi8uLi9saWIvcmVkdXgtaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFjdGlvbk1hcChbXG4gIC8vIG9wZXJhdGlvbmFsIGVycm9yXG4gICdlcnJvcicsXG4gIC8vIHVucmVnaXN0ZXIsIGNsZWFyIG9wZXJhdGlvbmFsIHN0YXRlXG4gICdjbGVhcicsXG4gIC8vIG9wZXJhdGlvblxuICAnZmxpcCcsXG4gICdyZWNvcmQnLFxuICAnc3RvcFJlY29yZCcsXG4gICdob2xkJyxcbiAgJ3VuaG9sZCcsXG4gICdtdXRlJyxcbiAgJ3VubXV0ZScsXG4gICdwYXJrJyxcbiAgJ3RyYW5zZmVyJyxcbiAgJ2ZvcndhcmQnLFxuICAnZHRtZicsXG5dKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1hY3Rpb25zLmpzXG4gKiovIiwiaW1wb3J0IHsgcHJlZml4QWN0aW9ucyB9IGZyb20gJy4uLy4uL2xpYi9yZWR1eC1oZWxwZXInO1xuaW1wb3J0IHdlYnBob25lQWN0aW9ucyBmcm9tICcuL3dlYnBob25lLWFjdGlvbnMnO1xuaW1wb3J0IHdlYnBob25lU3RhdHVzIGZyb20gJy4uLy4uL2VudW1zL3dlYnBob25lLXN0YXR1cyc7XG5cbmltcG9ydCBjYWxsUmVkdWNlciBmcm9tICcuL2NhbGwtcmVkdWNlcic7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgc3RhdHVzOiB3ZWJwaG9uZVN0YXR1cy5wcmVSZWdpc3RlcixcbiAgLy8gYXNzaWduIGZyb20gVUlcbiAgdG9OdW1iZXI6ICcnLFxuICBmcm9tTnVtYmVyOiAnJyxcbiAgLy8gc2lwIGluZm8gcmV0dXJuIGZyb20gc2lwIHNlcnZlclxuICByZW1vdGVJZGVudGl0eTogbnVsbCxcbiAgbG9jYWxJZGVudGl0eTogbnVsbCxcbiAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcigpLFxuICBlcnJvcjogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZHVjZXIocHJlZml4KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBwcmVmaXhBY3Rpb25zKHdlYnBob25lQWN0aW9ucywgcHJlZml4KTtcblxuICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgaWYgKCFhY3Rpb24pIHJldHVybiBzdGF0ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgIGNhc2UgYWN0aW9ucy5yZWdpc3RlclN1Y2Nlc3M6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLnJlZ2lzdGVyRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMudW5yZWdpc3RlcjpcbiAgICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0aW5nLFxuICAgICAgICAgIHRvTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC50b051bWJlcixcbiAgICAgICAgICBmcm9tTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5mcm9tTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5jYWxsSW5jb21pbmc6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbEluY29taW5nLFxuICAgICAgICAgIHJlbW90ZUlkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5yZW1vdGVJZGVudGl0eSxcbiAgICAgICAgICBsb2NhbElkZW50aXR5OiBhY3Rpb24ucGF5bG9hZC5sb2NhbElkZW50aXR5LFxuICAgICAgICB9KTtcbiAgICAgIC8vIFRPRE86IHVwZGF0ZSBmcm9tTnVtYmVyLCB0b051bWJlclxuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxDb25uZWN0OlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxDb25uZWN0ZWQsXG4gICAgICAgICAgcmVtb3RlSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLnJlbW90ZUlkZW50aXR5LFxuICAgICAgICAgIGxvY2FsSWRlbnRpdHk6IGFjdGlvbi5wYXlsb2FkLmxvY2FsSWRlbnRpdHksXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBhY3Rpb25zLmNhbGxBY2NlcHQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMuY2FsbENvbm5lY3RlZCxcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVuZDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwge1xuICAgICAgICAgIHN0YXR1czogd2VicGhvbmVTdGF0dXMucmVnaXN0ZXJTdWNjZXNzZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbEVycm9yOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICBzdGF0dXM6IHdlYnBob25lU3RhdHVzLmNhbGxGYWlsZWQsXG4gICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIGFjdGlvbnMuY2FsbE9wZXJhdGlvbjpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgICAgb3BlcmF0aW9uOiBjYWxsUmVkdWNlcihzdGF0ZS5vcGVyYXRpb24sIGFjdGlvbi5vcGVyYXRpb24pLFxuICAgICAgICB9KTtcbiAgICAgIGNhc2UgYWN0aW9ucy5zZXNzaW9uRXJyb3I6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIHtcbiAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvd2VicGhvbmUtcmVkdWNlci5qc1xuICoqLyIsImltcG9ydCBFbnVtIGZyb20gJy4uL2xpYi9lbnVtJztcblxuY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgLy8gRm9yIHJlZ2lzdGVyaW5nXG4gIHByZVJlZ2lzdGVyOiAnUFJFX1JFR0lTVEVSJyxcbiAgcmVnaXN0ZXJTdWNjZXNzZWQ6ICdSRUdJU1RFUl9TVUNDRVNTRUQnLFxuICByZWdpc3RlckZhaWxlZDogJ1JFR0lTVEVSX0ZBSUxFRCcsXG4gIC8vIEZvciBjYWxsb3V0IGFuZCBhY3RpdmUgY2FsbFxuICBjYWxsQ29ubmVjdGluZzogJ0NBTExfQ09OTkVDVElORycsXG4gIGNhbGxDb25uZWN0ZWQ6ICdDQUxMX0NPTk5FQ1RFRCcsXG4gIGNhbGxGYWlsZWQ6ICdDQUxMX0ZBSUxFRCcsXG4gIC8vIEZvciBpbmNvbWluZyBjYWxsXG4gIGNhbGxJbmNvbWluZzogJ0NBTExfSU5DT01JTkcnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IEVudW0oZGVmaW5pdGlvbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9lbnVtcy93ZWJwaG9uZS1zdGF0dXMuanNcbiAqKi8iLCJpbXBvcnQgY2FsbEFjdGlvbnMgZnJvbSAnLi9jYWxsLWFjdGlvbnMnO1xuaW1wb3J0IGNhbGxTdGF0dXMgZnJvbSAnLi4vLi4vZW51bXMvY2FsbC1zdGF0dXMnO1xuXG5mdW5jdGlvbiBjb250YWluKGFyciwgZWxlKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZihlbGUpID4gLTE7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGVsZSkge1xuICBpZiAoY29udGFpbihhcnIsIGVsZSkpIHtcbiAgICBhcnIuc3BsaWNlKGFyci5pbmRleE9mKGVsZSksIDEpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgLy8gb3BlcmF0aW9ucyB3aGljaCBpcyBlbmFibGVcbiAgc3RhdHVzOiBbXSxcbiAgLy8gc29tZSBvcGVyYXRpb25zIHdpbGwgZGlzYWJsZSBhbm90aGVyLCBzdWNoIGFzICdob2xkJ1xuICBkaXNhYmxlZDogW10sXG4gIC8vIHNvbWUgb3BlcmF0aW9ucyBoYXZlIGluZm9tYXRpb24gbmVlZCB0byBiZSBzdG9yZWRcbiAgdHJhbnNmZXJUYWdldDogbnVsbCxcbiAgZmxpcFRhcmdldDogbnVsbCxcbiAgZHRtZk51bWJlcjogbnVsbCxcbiAgLy8gb3BlcmF0aW9uIGVycm9yXG4gIGVycm9yOiBudWxsLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUpO1xuICBpZiAoIWFjdGlvbikgcmV0dXJuIHN0YXRlO1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICBjYXNlIGNhbGxBY3Rpb25zLmVycm9yOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIGVycm9yOiBhY3Rpb24uZXJyb3IsXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmNsZWFyOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy5yZWNvcmQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5yZWNvcmRpbmcpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuc3RvcFJlY29yZDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHJlbW92ZShzdGF0ZS5zdGF0dXMsIGNhbGxTdGF0dXMucmVjb3JkaW5nKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMubXV0ZTpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLm11dGVkKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLm11dGVkKSxcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMudW5tdXRlOlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICAgIHN0YXR1czogcmVtb3ZlKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5tdXRlZCksXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiBjb250YWluKHN0YXRlLnN0YXR1cywgY2FsbFN0YXR1cy5ob2xkaW5nKSA/XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgOlxuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzLmNvbmNhdChjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogWydwYXJrJywgJ3JlY29yZCddLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy51bmhvbGQ6XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgc3RhdHVzOiByZW1vdmUoc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmhvbGRpbmcpLFxuICAgICAgICBkaXNhYmxlZDogW10sXG4gICAgICB9KTtcbiAgICBjYXNlIGNhbGxBY3Rpb25zLnBhcms6XG4gICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWxsX3BhcmtpbmdcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnBhcmtlcikgP1xuICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhdHVzIDpcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZXIpLFxuICAgICAgfSk7XG4gICAgY2FzZSBjYWxsQWN0aW9ucy50cmFuc2ZlcjpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLnRyYW5zZmVyZWQpID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMudHJhbnNmZXJlZCksXG4gICAgICAgIHRyYW5zZmVyVGFnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZmxpcDpcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IGNvbnRhaW4oc3RhdGUuc3RhdHVzLCBjYWxsU3RhdHVzLmZsaXApID9cbiAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA6XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMuY29uY2F0KGNhbGxTdGF0dXMuZmxpcCksXG4gICAgICAgIGZsaXBUYXJnZXQ6IGFjdGlvbi5wYXlsb2FkLm51bWJlcixcbiAgICAgIH0pO1xuICAgIGNhc2UgY2FsbEFjdGlvbnMuZHRtZjpcbiAgICAgIC8vIFRPRE86IGNsYXJpZnkgcGFyayBhY3Rpb25cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgICBzdGF0dXM6IHN0YXRlLnN0YXR1cy5jb25jYXQoY2FsbFN0YXR1cy5wYXJrZWQpLFxuICAgICAgICBkdG1mTnVtYmVyOiBhY3Rpb24ucGF5bG9hZC5udW1iZXIsXG4gICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL21vZHVsZXMvd2VicGhvbmUvY2FsbC1yZWR1Y2VyLmpzXG4gKiovIiwiaW1wb3J0IEVudW0gZnJvbSAnLi4vbGliL2VudW0nO1xuXG5jb25zdCBkZWZpbml0aW9uID0ge1xuICBmbGlwOiAnRkxJUEVEJyxcbiAgcmVjb3JkaW5nOiAnUkVDT1JESU5HJyxcbiAgaG9sZGluZzogJ0hPTERJTkcnLFxuICBtdXRlZDogJ01VVEVEJyxcbiAgcGFya2VkOiAnUEFSS0VEJyxcbiAgdHJhbnNmZXJlZDogJ1RSQU5TRkVSRUQnLFxuICBmb3J3YXJkZWQ6ICdGT1dBUkRFRCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRW51bShkZWZpbml0aW9uKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2VudW1zL2NhbGwtc3RhdHVzLmpzXG4gKiovIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ3NpcC5qcyddLCBmdW5jdGlvbihTSVApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KFNJUCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NpcC5qcycpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzOyAvL0VTNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuUmluZ0NlbnRyYWwgPSByb290LlJpbmdDZW50cmFsIHx8IHt9O1xuICAgICAgICByb290LlJpbmdDZW50cmFsLldlYlBob25lID0gZmFjdG9yeShyb290LlNJUCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTSVApIHtcblxuICAgIHZhciBtZXNzYWdlcyA9IHtcbiAgICAgICAgcGFyazoge3JlcWlkOiAxLCBjb21tYW5kOiAnY2FsbHBhcmsnfSxcbiAgICAgICAgc3RhcnRSZWNvcmQ6IHtyZXFpZDogMiwgY29tbWFuZDogJ3N0YXJ0Y2FsbHJlY29yZCd9LFxuICAgICAgICBzdG9wUmVjb3JkOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdzdG9wY2FsbHJlY29yZCd9LFxuICAgICAgICBmbGlwOiB7cmVxaWQ6IDMsIGNvbW1hbmQ6ICdjYWxsZmxpcCcsIHRhcmdldDogJyd9LFxuICAgICAgICBtb25pdG9yOiB7cmVxaWQ6IDQsIGNvbW1hbmQ6ICdtb25pdG9yJ30sXG4gICAgICAgIGJhcmdlOiB7cmVxaWQ6IDUsIGNvbW1hbmQ6ICdiYXJnZSd9LFxuICAgICAgICB3aGlzcGVyOiB7cmVxaWQ6IDYsIGNvbW1hbmQ6ICd3aGlzcGVyJ30sXG4gICAgICAgIHRha2VvdmVyOiB7cmVxaWQ6IDcsIGNvbW1hbmQ6ICd0YWtlb3Zlcid9XG4gICAgfTtcblxuICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSAxMDAwMDtcblxuICAgIGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsYXkobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICAgICAgICBzcmMgPSBzcmMgfHwge307XG4gICAgICAgIGRzdCA9IGRzdCB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvSGVscGVyKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9lbmFibGVkID0gISFvcHRpb25zLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMubG9hZEF1ZGlvKG9wdGlvbnMpO1xuXG4gICAgfVxuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl9wbGF5U291bmQgPSBmdW5jdGlvbih1cmwsIHZhbCwgdm9sdW1lKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8ICF1cmwpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fYXVkaW9bdXJsXSkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLmxvb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0udm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0ucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0ucGxheSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb1t1cmxdLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUubG9hZEF1ZGlvID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbmNvbWluZyA9IG9wdGlvbnMuaW5jb21pbmc7XG4gICAgICAgIHRoaXMuX291dGdvaW5nID0gb3B0aW9ucy5vdXRnb2luZztcbiAgICAgICAgdGhpcy5fYXVkaW8gPSB7fTtcbiAgICB9XG5cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24odm9sdW1lKSB7XG4gICAgICAgIGlmICh2b2x1bWUgPCAwKSB7IHZvbHVtZSA9IDA7IH1cbiAgICAgICAgaWYgKHZvbHVtZSA+IDEpIHsgdm9sdW1lID0gMTsgfVxuICAgICAgICB0aGlzLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgZm9yICh2YXIgdXJsIGluIHRoaXMuX2F1ZGlvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXVkaW8uaGFzT3duUHJvcGVydHkodXJsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvW3VybF0udm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlJbmNvbWluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX2luY29taW5nLCB2YWwsICh0aGlzLnZvbHVtZSB8fCAwLjUpKTtcbiAgICB9O1xuXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnBsYXlPdXRnb2luZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheVNvdW5kKHRoaXMuX291dGdvaW5nLCB2YWwsICh0aGlzLnZvbHVtZSB8fCAxKSk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZ0RhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnV1aWRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFwcEtleV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwTmFtZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXBwVmVyc2lvbl1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXVkaW9IZWxwZXJdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9uU2Vzc2lvbl0gZmlyZWQgZWFjaCB0aW1lIFVzZXJBZ2VudCBzdGFydHMgd29ya2luZyB3aXRoIHNlc3Npb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJQaG9uZShyZWdEYXRhLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmVnRGF0YSA9IHJlZ0RhdGEgfHwge307XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuc2lwSW5mbyA9IHJlZ0RhdGEuc2lwSW5mb1swXSB8fCByZWdEYXRhLnNpcEluZm87XG4gICAgICAgIHRoaXMuc2lwRmxhZ3MgPSByZWdEYXRhLnNpcEZsYWdzO1xuXG4gICAgICAgIHZhciBpZCA9IG9wdGlvbnMudXVpZCB8fCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncmMtd2ViUGhvbmUtdXVpZCcpIHx8IHV1aWQoKTsgLy9UT0RPIE1ha2UgY29uZmlndXJhYmxlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyYy13ZWJQaG9uZS11dWlkJywgaWQpO1xuXG4gICAgICAgIHRoaXMuZW5kcG9pbnRIZWFkZXIgPSAnUC1yYy1lbmRwb2ludC1pZDogJyArIGlkO1xuXG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0ge1xuICAgICAgICAgICAgdXJpOiAnc2lwOicgKyB0aGlzLnNpcEluZm8udXNlcm5hbWUgKyAnQCcgKyB0aGlzLnNpcEluZm8uZG9tYWluLFxuICAgICAgICAgICAgd3NTZXJ2ZXJzOiB0aGlzLnNpcEluZm8ub3V0Ym91bmRQcm94eSAmJiB0aGlzLnNpcEluZm8udHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgPyB0aGlzLnNpcEluZm8udHJhbnNwb3J0LnRvTG93ZXJDYXNlKCkgKyAnOi8vJyArIHRoaXMuc2lwSW5mby5vdXRib3VuZFByb3h5XG4gICAgICAgICAgICAgICAgOiB0aGlzLnNpcEluZm8ud3NTZXJ2ZXJzLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvblVzZXI6IHRoaXMuc2lwSW5mby5hdXRob3JpemF0aW9uSWQsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5zaXBJbmZvLnBhc3N3b3JkLFxuICAgICAgICAgICAgdHJhY2VTaXA6IHRydWUsXG4gICAgICAgICAgICBzdHVuU2VydmVyczogdGhpcy5zaXBJbmZvLnN0dW5TZXJ2ZXJzIHx8IFsnc3R1bjo3NC4xMjUuMTk0LjEyNzoxOTMwMiddLCAvL0ZJWE1FIEhhcmRjb2RlZD9cbiAgICAgICAgICAgIHR1cm5TZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGxvZzoge1xuICAgICAgICAgICAgICAgIGxldmVsOiBvcHRpb25zLmxvZ0xldmVsIHx8IDEgLy9GSVhNRSBMT0cgTEVWRUwgM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5zaXBJbmZvLmRvbWFpbixcbiAgICAgICAgICAgIGF1dG9zdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIHJlZ2lzdGVyOiB0cnVlLFxuICAgICAgICAgICAgaWNlR2F0aGVyaW5nVGltZW91dDogdGhpcy5zaXBJbmZvLmljZUdhdGhlcmluZ1RpbWVvdXQgfHwgMzAwMFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYXBwS2V5ID0gb3B0aW9ucy5hcHBLZXk7XG4gICAgICAgIHRoaXMuYXBwTmFtZSA9IG9wdGlvbnMuYXBwTmFtZTtcbiAgICAgICAgdGhpcy5hcHBWZXJzaW9uID0gb3B0aW9ucy5hcHBWZXJzaW9uO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudEhlYWRlciA9ICdSQy1Vc2VyLUFnZW50OiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5hcHBOYW1lID8gKG9wdGlvbnMuYXBwTmFtZSArIChvcHRpb25zLmFwcFZlcnNpb24gPyAnLycgKyBvcHRpb25zLmFwcFZlcnNpb24gOiAnJykpICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUkNXRUJQSE9ORS8nICsgV2ViUGhvbmUudmVyc2lvbjtcblxuICAgICAgICB0aGlzLmNsaWVudElkSGVhZGVyID0gJ0NsaWVudC1pZDonICsgb3B0aW9ucy5hcHBLZXk7XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBuZXcgU0lQLlVBKGNvbmZpZ3VyYXRpb24pLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQWdlbnRIZWFkZXIsXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRJZEhlYWRlclxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5lbmRwb2ludEhlYWRlciA9IHRoaXMuZW5kcG9pbnRIZWFkZXI7XG4gICAgICAgIHRoaXMudXNlckFnZW50LnVzZXJBZ2VudEhlYWRlciA9IHRoaXMudXNlckFnZW50SGVhZGVyO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudC5jbGllbnRJZEhlYWRlciA9IHRoaXMuY2xpZW50SWRIZWFkZXI7XG4gICAgICAgIHRoaXMudXNlckFnZW50LnNpcEluZm8gPSB0aGlzLnNpcEluZm87XG5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQuX19pbnZpdGUgPSB0aGlzLnVzZXJBZ2VudC5pbnZpdGU7XG4gICAgICAgIHRoaXMudXNlckFnZW50Lmludml0ZSA9IGludml0ZTtcblxuICAgICAgICB0aGlzLnVzZXJBZ2VudC5vbignaW52aXRlJywgZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy51c2VyQWdlbnQuYXVkaW9IZWxwZXIucGxheUluY29taW5nKHRydWUpO1xuICAgICAgICAgICAgcGF0Y2hTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50LmF1ZGlvSGVscGVyID0gbmV3IEF1ZGlvSGVscGVyKG9wdGlvbnMuYXVkaW9IZWxwZXIpO1xuXG4gICAgICAgIHRoaXMudXNlckFnZW50Lm9uU2Vzc2lvbiA9IG9wdGlvbnMub25TZXNzaW9uIHx8IG51bGw7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIFdlYlBob25lLnZlcnNpb24gPSAnMC4zLjEnO1xuICAgIFdlYlBob25lLnV1aWQgPSB1dWlkO1xuICAgIFdlYlBob25lLmRlbGF5ID0gZGVsYXk7XG4gICAgV2ViUGhvbmUuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICBmdW5jdGlvbiBwYXRjaFNlc3Npb24oc2Vzc2lvbikge1xuXG4gICAgICAgIGlmIChzZXNzaW9uLl9fcGF0Y2hlZCkgcmV0dXJuIHNlc3Npb247XG5cbiAgICAgICAgc2Vzc2lvbi5fX3BhdGNoZWQgPSB0cnVlO1xuXG4gICAgICAgIHNlc3Npb24uX19zZW5kUmVxdWVzdCA9IHNlc3Npb24uc2VuZFJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24uX19yZWNlaXZlUmVxdWVzdCA9IHNlc3Npb24ucmVjZWl2ZVJlcXVlc3Q7XG4gICAgICAgIHNlc3Npb24uX19yZWNlaXZlSW52aXRlUmVzcG9uc2UgPSBzZXNzaW9uLnJlY2VpdmVJbnZpdGVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5fX3JlY2VpdmVSZXNwb25zZSA9IHNlc3Npb24ucmVjZWl2ZVJlc3BvbnNlO1xuICAgICAgICBzZXNzaW9uLl9fYWNjZXB0ID0gc2Vzc2lvbi5hY2NlcHQ7XG4gICAgICAgIHNlc3Npb24uX19ob2xkID0gc2Vzc2lvbi5ob2xkO1xuICAgICAgICBzZXNzaW9uLl9fdW5ob2xkID0gc2Vzc2lvbi51bmhvbGQ7XG4gICAgICAgIHNlc3Npb24uX19kdG1mID0gc2Vzc2lvbi5kdG1mO1xuXG4gICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QgPSBzZW5kUmVxdWVzdDtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdCA9IHJlY2VpdmVSZXF1ZXN0O1xuICAgICAgICBzZXNzaW9uLnJlY2VpdmVJbnZpdGVSZXNwb25zZSA9IHJlY2VpdmVJbnZpdGVSZXNwb25zZTtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVzcG9uc2UgPSByZWNlaXZlUmVzcG9uc2U7XG4gICAgICAgIHNlc3Npb24uYWNjZXB0ID0gYWNjZXB0O1xuICAgICAgICBzZXNzaW9uLmhvbGQgPSBob2xkO1xuICAgICAgICBzZXNzaW9uLnVuaG9sZCA9IHVuaG9sZDtcbiAgICAgICAgc2Vzc2lvbi5kdG1mID0gZHRtZjtcblxuICAgICAgICBzZXNzaW9uLmJsaW5kVHJhbnNmZXIgPSBibGluZFRyYW5zZmVyO1xuICAgICAgICBzZXNzaW9uLnRyYW5zZmVyID0gdHJhbnNmZXI7XG4gICAgICAgIHNlc3Npb24ucGFyayA9IHBhcms7XG4gICAgICAgIHNlc3Npb24uZm9yd2FyZCA9IGZvcndhcmQ7XG4gICAgICAgIHNlc3Npb24uc3RhcnRSZWNvcmQgPSBzdGFydFJlY29yZDtcbiAgICAgICAgc2Vzc2lvbi5zdG9wUmVjb3JkID0gc3RvcFJlY29yZDtcbiAgICAgICAgc2Vzc2lvbi5mbGlwID0gZmxpcDtcblxuICAgICAgICBzZXNzaW9uLm9uKCdyZXBsYWNlZCcsIHBhdGNoU2Vzc2lvbik7XG4gICAgICAgIC8vIHNlc3Npb24ub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuXG4gICAgICAgIC8vIEF1ZGlvXG4gICAgICAgIHNlc3Npb24ub24oJ2FjY2VwdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdyZWplY3RlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbignYnllJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCd0ZXJtaW5hdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm9uKCdjYW5jZWwnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ub24oJ2ZhaWxlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgc2Vzc2lvbi5vbigncmVwbGFjZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLm9uKCdpY2VDb25uZWN0aW9uQ29tcGxldGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5vbignaWNlQ29ubmVjdGlvbkZhaWxlZCcsIHN0b3BQbGF5aW5nKTtcblxuICAgICAgICBmdW5jdGlvbiBzdG9wUGxheWluZygpIHtcbiAgICAgICAgICAgIHNlc3Npb24udWEuYXVkaW9IZWxwZXIucGxheU91dGdvaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNlc3Npb24udWEuYXVkaW9IZWxwZXIucGxheUluY29taW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2FjY2VwdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcigncmVqZWN0ZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdieWUnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCd0ZXJtaW5hdGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignY2FuY2VsJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignZmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcigncmVwbGFjZWQnLCBzdG9wUGxheWluZyk7XG4gICAgICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5yZW1vdmVMaXN0ZW5lcignaWNlQ29ubmVjdGlvbkNvbXBsZXRlZCcsIHN0b3BQbGF5aW5nKTtcbiAgICAgICAgICAgIHNlc3Npb24ubWVkaWFIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCdpY2VDb25uZWN0aW9uRmFpbGVkJywgc3RvcFBsYXlpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlc3Npb24udWEub25TZXNzaW9uKSBzZXNzaW9uLnVhLm9uU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgICAgICByZXR1cm4gc2Vzc2lvbjtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbW1hbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZW5kUmVjZWl2ZShzZXNzaW9uLCBjb21tYW5kLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgZXh0ZW5kKGNvbW1hbmQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBjc2VxID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuSU5GTywge1xuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogY29tbWFuZFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24udWEudXNlckFnZW50SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVhLmVuZHBvaW50SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnVhLmNsaWVudElkSGVhZGVyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzZXEgPSByZXNwb25zZS5jc2VxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uSW5mbyA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuY3NlcSA9PT0gY3NlcSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcmVxdWVzdCAmJiByZXF1ZXN0LmJvZHkgfHwgJ3t9JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iajtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnJlc3BvbnNlICYmIG9iai5yZXNwb25zZS5jb21tYW5kID09PSBjb21tYW5kLmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmoucmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNwb25zZS5yZXN1bHQuY29kZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG9iai5yZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Qob2JqLnJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfSU5GTycsIG9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7IC8vRklYTUUgV2hhdCB0byByZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dDogbm8gcmVwbHknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignUkNfU0lQX0lORk8nLCBvbkluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ub24oJ1JDX1NJUF9JTkZPJywgb25JbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBJTkZPIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzOiAnICsgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgKyAnICh3YWl0aW5nIGZvciAyMDApJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KHR5cGUsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZSA9PSBTSVAuQy5QUkFDSykge1xuICAgICAgICAgICAgdHlwZSA9IFNJUC5DLkFDSztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX3NlbmRSZXF1ZXN0KHR5cGUsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBlYWNoIHRpbWUgYSBwcm92aXNpb25hbCAoMTAwLTE5OSkgcmVzcG9uc2UgaXMgcmVjZWl2ZWQuXG4gICAgICogRWFybHkgbWVkaWEgaXMgc3VwcG9ydGVkIGJ5IFNJUC5qcyBsaWJyYXJ5XG4gICAgICogQnV0IGluIGNhc2UgaXQgaXMgc2VudCB3aXRob3V0IDEwMHJlbCBzdXBwb3J0IHdlIHBsYXkgaXQgbWFudWFsbHlcbiAgICAgKiBTVEFUVVNfRUFSTFlfTUVESUEgPT09IDExLCBpdCB3aWxsIGJlIHNldCBieSBTSVAuanMgaWYgMTAwcmVsIGlzIHN1cHBvcnRlZFxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDcyMzg4XG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7ZnVuY2l0b259IGNiXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGF0Y2gxMDByZWwoc2Vzc2lvbiwgcmVzcG9uc2UsIGNiKSB7XG5cbiAgICAgICAgLy9FYXJseSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgU0lQLmpzIGxpYnJhcnlcbiAgICAgICAgLy9CdXQgaW4gY2FzZSBpdCBpcyBzZW50IHdpdGhvdXQgMTAwcmVsIHN1cHBvcnQgd2UgcGxheSBpdCBtYW51YWxseVxuICAgICAgICAvL1NUQVRVU19FQVJMWV9NRURJQSA9PT0gMTEsIGl0IHdpbGwgYmUgc2V0IGJ5IFNJUC5qcyBpZiAxMDByZWwgaXMgc3VwcG9ydGVkXG4gICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfRUFSTFlfTUVESUEgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDE4MyAmJiB0eXBlb2YocmVzcG9uc2UuYm9keSkgPT09ICdzdHJpbmcnICYmIHJlc3BvbnNlLmJvZHkuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmhhc0hlYWRlcigncmVxdWlyZScpKSByZXNwb25zZS5zZXRIZWFkZXIoJ3JlcXVpcmUnLCAnMTAwcmVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2IuY2FsbChzZXNzaW9uLCByZXNwb25zZSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNlaXZlSW52aXRlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHBhdGNoMTAwcmVsKHRoaXMsIHJlc3BvbnNlLCB0aGlzLl9fcmVjZWl2ZUludml0ZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHBhdGNoMTAwcmVsKHRoaXMsIHJlc3BvbnNlLCB0aGlzLl9fcmVjZWl2ZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UmVjb3JkKHNlc3Npb24sIGZsYWcpIHtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9ICEhZmxhZ1xuICAgICAgICAgICAgPyBtZXNzYWdlcy5zdGFydFJlY29yZFxuICAgICAgICAgICAgOiBtZXNzYWdlcy5zdG9wUmVjb3JkO1xuXG4gICAgICAgIGlmICgoc2Vzc2lvbi5fX29uUmVjb3JkICYmICFmbGFnKSB8fCAoIXNlc3Npb24uX19vblJlY29yZCAmJiBmbGFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRSZWNlaXZlKHNlc3Npb24sIG1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLl9fb25SZWNvcmQgPSAhIWZsYWc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0SG9sZChzZXNzaW9uLCBmbGFnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQ6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZDogcmVqZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLl9faG9sZChvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5fX3VuaG9sZChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuVUF9XG4gICAgICogQHBhcmFtIG51bWJlclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybiB7U0lQLlNlc3Npb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52aXRlKG51bWJlciwgb3B0aW9ucykge1xuXG4gICAgICAgIHZhciB1YSA9IHRoaXM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG5cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCh1YS51c2VyQWdlbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHVhLmVuZHBvaW50SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCh1YS5jbGllbnRJZEhlYWRlcik7XG5cbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnUC1Bc3NlcnRlZC1JZGVudGl0eTogc2lwOicgKyAob3B0aW9ucy5mcm9tTnVtYmVyIHx8IHVhLnNpcEluZm8udXNlcm5hbWUpICsgJ0AnICsgdWEuc2lwSW5mby5kb21haW4pOyAvL0ZJWE1FIFBob25lIE51bWJlclxuXG4gICAgICAgIC8vRklYTUUgQmFja2VuZCBzaG91bGQga25vdyBpdCBhbHJlYWR5XG4gICAgICAgIGlmIChvcHRpb25zLmhvbWVDb3VudHJ5SWQpIHsgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnUC1yYy1jb3VudHJ5LWlkOiAnICsgb3B0aW9ucy5ob21lQ291bnRyeUlkKTsgfVxuXG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSBvcHRpb25zLm1lZGlhIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzID0gb3B0aW9ucy5tZWRpYS5jb25zdHJhaW50cyB8fCB7YXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZX07XG5cbiAgICAgICAgb3B0aW9ucy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge29wdGlvbmFsOiBbe0R0bHNTcnRwS2V5QWdyZWVtZW50OiAndHJ1ZSd9XX07XG5cbiAgICAgICAgdWEuYXVkaW9IZWxwZXIucGxheU91dGdvaW5nKHRydWUpO1xuXG4gICAgICAgIHJldHVybiBwYXRjaFNlc3Npb24odWEuX19pbnZpdGUobnVtYmVyLCBvcHRpb25zKSk7XG5cbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjZWl2ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgU0lQLkMuSU5GTzpcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ1JDX1NJUF9JTkZPJywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgLy9TSVAuanMgZG9lcyBub3Qgc3VwcG9ydCBhcHBsaWNhdGlvbi9qc29uIGNvbnRlbnQgdHlwZSwgc28gd2UgbW9ua2V5IG92ZXJyaWRlIGl0cyBiZWhhdmlvdXIgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQgfHwgc2Vzc2lvbi5zdGF0dXMgPT09IFNJUC5TZXNzaW9uLkMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvL1JlZnJlc2ggaW52aXRlIHNob3VsZCBub3QgYmUgcmVqZWN0ZWQgd2l0aCA0ODhcbiAgICAgICAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0YXR1cyA9PT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNhbGxfaWQgJiYgc2Vzc2lvbi5kaWFsb2cgJiYgc2Vzc2lvbi5kaWFsb2cuaWQgJiYgcmVxdWVzdC5jYWxsX2lkID09IHNlc3Npb24uZGlhbG9nLmlkLmNhbGxfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogY2hlY2sgdGhhdCBTRFAgZGlkIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLmxvZygncmUtSU5WSVRFIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxTRFAgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5wZWVyQ29ubmVjdGlvbi5sb2NhbERlc2NyaXB0aW9uLnNkcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsLCBbJ0NvbnRhY3Q6ICcgKyBzZXNzaW9uLmNvbnRhY3RdLCBsb2NhbFNEUCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5zZXRJbnZpdGUyeHhUaW1lcihyZXF1ZXN0LCBsb2NhbFNEUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5zZXRBQ0tUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2Vsc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIDQ4OCBieSBTSVAuanNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvL1dlIG5lZWQgdG8gYW5hbGl6ZSBOT1RJRlkgbWVzc2FnZXMgc29tZXRpbWVzLCBzbyB3ZSBmaXJlIGFuIGV2ZW50XG4gICAgICAgICAgICBjYXNlIFNJUC5DLk5PVElGWTpcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmVtaXQoJ1JDX1NJUF9OT1RJRlknLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vzc2lvbi5fX3JlY2VpdmVSZXF1ZXN0LmFwcGx5KHNlc3Npb24sIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjY2VwdChvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuXG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS51c2VyQWdlbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuZW5kcG9pbnRIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKHNlc3Npb24udWEuY2xpZW50SWRIZWFkZXIpO1xuXG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSBvcHRpb25zLm1lZGlhIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm1lZGlhLmNvbnN0cmFpbnRzID0gb3B0aW9ucy5tZWRpYS5jb25zdHJhaW50cyB8fCB7YXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZX07XG5cbiAgICAgICAgb3B0aW9ucy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge29wdGlvbmFsOiBbe0R0bHNTcnRwS2V5QWdyZWVtZW50OiAndHJ1ZSd9XX07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkFuc3dlcmVkKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignZmFpbGVkJywgb25GYWlsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignYWNjZXB0ZWQnLCBvbkFuc3dlcmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9UT0RPIE1vcmUgZXZlbnRzP1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdhY2NlcHRlZCcsIG9uQW5zd2VyZWQpO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdmYWlsZWQnLCBvbkZhaWwpO1xuXG4gICAgICAgICAgICBzZXNzaW9uLl9fYWNjZXB0KG9wdGlvbnMpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHRtZlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZHRtZihkdG1mLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG4gICAgICAgIGR1cmF0aW9uID0gcGFyc2VJbnQoZHVyYXRpb24pIHx8IDEwMDA7XG4gICAgICAgIHZhciBwZWVyID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIucGVlckNvbm5lY3Rpb247XG4gICAgICAgIHZhciBzdHJlYW0gPSBzZXNzaW9uLmdldExvY2FsU3RyZWFtcygpWzBdO1xuICAgICAgICB2YXIgZHRtZlNlbmRlciA9IHBlZXIuY3JlYXRlRFRNRlNlbmRlcihzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSk7XG4gICAgICAgIGlmIChkdG1mU2VuZGVyICE9PSB1bmRlZmluZWQgJiYgZHRtZlNlbmRlci5jYW5JbnNlcnREVE1GKSB7XG4gICAgICAgICAgICByZXR1cm4gZHRtZlNlbmRlci5pbnNlcnREVE1GKGR0bWYsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbmQgRFRNRiBmYWlsZWQ6ICcgKyAoIWR0bWZTZW5kZXIgPyAnbm8gc2VuZGVyJyA6ICghZHRtZlNlbmRlci5jYW5JbnNlcnREVE1GID8gJ2NhblxcJ3QgaW5zZXJ0IERUTUYnIDogJ1Vua25vd24nKSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBob2xkKCkge1xuICAgICAgICByZXR1cm4gc2V0SG9sZCh0aGlzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5ob2xkKCkge1xuICAgICAgICByZXR1cm4gc2V0SG9sZCh0aGlzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJsaW5kVHJhbnNmZXIodGFyZ2V0LCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgICAgIHZhciBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvL0JsaW5kIFRyYW5zZmVyIGlzIHRha2VuIGZyb20gU0lQLmpzIHNvdXJjZVxuXG4gICAgICAgICAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3Ioc2Vzc2lvbi5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3JtYWxpemVUYXJnZXQgYWxsb3dzIGluc3RhbmNlcyBvZiBTSVAuVVJJIHRvIHBhc3MgdGhyb3VnaCB1bmFsdGVyZWQsXG4gICAgICAgICAgICAvLyBzbyB0cnkgdG8gbWFrZSBvbmUgYWhlYWQgb2YgdGltZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBTSVAuR3JhbW1hci5wYXJzZSh0YXJnZXQsICdSZWZlcl9UbycpLnVyaSB8fCB0YXJnZXQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIuZGVidWcoXCIucmVmZXIoKSBjYW5ub3QgcGFyc2UgUmVmZXJfVG8gZnJvbVwiLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLmRlYnVnKFwiLi4uZmFsbGluZyB0aHJvdWdoIHRvIG5vcm1hbGl6ZVRhcmdldCgpXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0YXJnZXQgdmFsaWRpdHlcbiAgICAgICAgICAgIHRhcmdldCA9IHNlc3Npb24udWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OiAnICsgb3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHNlc3Npb24uY29udGFjdCk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcgKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVmZXItVG86ICcgKyB0YXJnZXQpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS51c2VyQWdlbnRIZWFkZXIpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goc2Vzc2lvbi51YS5lbmRwb2ludEhlYWRlcik7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChzZXNzaW9uLnVhLmNsaWVudElkSGVhZGVyKTtcblxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5SRUZFUiwge1xuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSAyMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsSWQgPSByZXNwb25zZS5jYWxsX2lkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Ob3RpZnkgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY2FsbF9pZCA9PT0gY2FsbElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcmVxdWVzdCAmJiByZXF1ZXN0LmJvZHkgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAvMVswLTldezJ9Ly50ZXN0KGJvZHkpOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLzJbMC05XXsyfS8udGVzdChib2R5KTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdSQ19TSVBfTk9USUZZJywgb25Ob3RpZnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dDogbm8gcmVwbHknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVMaXN0ZW5lcignUkNfU0lQX05PVElGWScsIG9uTm90aWZ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlc3BvbnNlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLm9uKCdSQ19TSVBfTk9USUZZJywgb25Ob3RpZnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlzOiAnICsgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgKyAnICh3YWl0aW5nIGZvciAyMDIpJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zlcih0YXJnZXQsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIChzZXNzaW9uLmlzT25Ib2xkKCkgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiBzZXNzaW9uLmhvbGQoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVsYXkoMzAwKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmJsaW5kVHJhbnNmZXIodGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2NlcHRPcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt0cmFuc2Zlck9wdGlvbnNdXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3J3YXJkKHRhcmdldCwgYWNjZXB0T3B0aW9ucywgdHJhbnNmZXJPcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIGludGVydmFsID0gbnVsbCxcbiAgICAgICAgICAgIHNlc3Npb24gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBzZXNzaW9uLmFjY2VwdChhY2NlcHRPcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5tdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZXNzaW9uLnRyYW5zZmVyKHRhcmdldCwgdHJhbnNmZXJPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNzAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQHRoaXMge1NJUC5TZXNzaW9ufVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRSZWNvcmQoKSB7XG4gICAgICAgIHJldHVybiBzZXRSZWNvcmQodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9wUmVjb3JkKCkge1xuICAgICAgICByZXR1cm4gc2V0UmVjb3JkKHRoaXMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtTSVAuU2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gc2VuZFJlY2VpdmUodGhpcywgbWVzc2FnZXMuZmxpcCwge3RhcmdldDogdGFyZ2V0fSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7U0lQLlNlc3Npb259XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJrKCkge1xuICAgICAgICByZXR1cm4gc2VuZFJlY2VpdmUodGhpcywgbWVzc2FnZXMucGFyayk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICByZXR1cm4gV2ViUGhvbmU7XG5cbn0pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yaW5nY2VudHJhbC13ZWItcGhvbmUvc3JjL3JpbmdjZW50cmFsLXdlYi1waG9uZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vU0lQJykocmVxdWlyZSgnLi9lbnZpcm9ubWVudCcpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG5hbWUgU0lQXG4gKiBAbmFtZXNwYWNlXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuXG52YXIgcGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciBTSVAgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICB2ZXJzaW9uOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gcGtnLnZlcnNpb247IH1cbiAgfSxcbiAgbmFtZToge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHBrZy50aXRsZTsgfVxuICB9XG59KTtcblxucmVxdWlyZSgnLi9VdGlscycpKFNJUCwgZW52aXJvbm1lbnQpO1xuU0lQLkxvZ2dlckZhY3RvcnkgPSByZXF1aXJlKCcuL0xvZ2dlckZhY3RvcnknKShlbnZpcm9ubWVudC5jb25zb2xlKTtcblNJUC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpKGVudmlyb25tZW50LmNvbnNvbGUpO1xuU0lQLkMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpKFNJUC5uYW1lLCBTSVAudmVyc2lvbik7XG5TSVAuRXhjZXB0aW9ucyA9IHJlcXVpcmUoJy4vRXhjZXB0aW9ucycpO1xuU0lQLlRpbWVycyA9IHJlcXVpcmUoJy4vVGltZXJzJykoZW52aXJvbm1lbnQudGltZXJzKTtcblNJUC5UcmFuc3BvcnQgPSBlbnZpcm9ubWVudC5UcmFuc3BvcnQoU0lQLCBlbnZpcm9ubWVudC5XZWJTb2NrZXQpO1xucmVxdWlyZSgnLi9QYXJzZXInKShTSVApO1xucmVxdWlyZSgnLi9TSVBNZXNzYWdlJykoU0lQKTtcbnJlcXVpcmUoJy4vVVJJJykoU0lQKTtcbnJlcXVpcmUoJy4vTmFtZUFkZHJIZWFkZXInKShTSVApO1xucmVxdWlyZSgnLi9UcmFuc2FjdGlvbnMnKShTSVApO1xucmVxdWlyZSgnLi9EaWFsb2dzJykoU0lQKTtcbnJlcXVpcmUoJy4vUmVxdWVzdFNlbmRlcicpKFNJUCk7XG5yZXF1aXJlKCcuL1JlZ2lzdGVyQ29udGV4dCcpKFNJUCk7XG5TSVAuTWVkaWFIYW5kbGVyID0gcmVxdWlyZSgnLi9NZWRpYUhhbmRsZXInKShTSVAuRXZlbnRFbWl0dGVyKTtcbnJlcXVpcmUoJy4vQ2xpZW50Q29udGV4dCcpKFNJUCk7XG5yZXF1aXJlKCcuL1NlcnZlckNvbnRleHQnKShTSVApO1xucmVxdWlyZSgnLi9TZXNzaW9uJykoU0lQLCBlbnZpcm9ubWVudCk7XG5yZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpKFNJUCk7XG5TSVAuV2ViUlRDID0gcmVxdWlyZSgnLi9XZWJSVEMnKShTSVAsIGVudmlyb25tZW50KTtcbnJlcXVpcmUoJy4vVUEnKShTSVAsIGVudmlyb25tZW50KTtcblNJUC5IYWNrcyA9IHJlcXVpcmUoJy4vSGFja3MnKShTSVApO1xucmVxdWlyZSgnLi9TYW5pdHlDaGVjaycpKFNJUCk7XG5TSVAuRGlnZXN0QXV0aGVudGljYXRpb24gPSByZXF1aXJlKCcuL0RpZ2VzdEF1dGhlbnRpY2F0aW9uJykoU0lQLlV0aWxzKTtcblNJUC5HcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyJykoU0lQKTtcblxucmV0dXJuIFNJUDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1NJUC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiX2FyZ3NcIjogW1xuXHRcdFtcblx0XHRcdFwic2lwLmpzQDAuNy41XCIsXG5cdFx0XHRcIi9Vc2Vycy9ob3dhcmQuemhhbmcvU2l0ZXMvcmluZ2NlbnRyYWwtanMtaW50ZWdyYXRpb24tY29tbW9ucy9ub2RlX21vZHVsZXMvcmluZ2NlbnRyYWwtd2ViLXBob25lXCJcblx0XHRdXG5cdF0sXG5cdFwiX2Zyb21cIjogXCJzaXAuanNAMC43LjVcIixcblx0XCJfaWRcIjogXCJzaXAuanNAMC43LjVcIixcblx0XCJfaW5DYWNoZVwiOiB0cnVlLFxuXHRcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuXHRcIl9sb2NhdGlvblwiOiBcIi9zaXAuanNcIixcblx0XCJfbm9kZVZlcnNpb25cIjogXCI0LjQuM1wiLFxuXHRcIl9ucG1PcGVyYXRpb25hbEludGVybmFsXCI6IHtcblx0XHRcImhvc3RcIjogXCJwYWNrYWdlcy0xMi13ZXN0LmludGVybmFsLm5wbWpzLmNvbVwiLFxuXHRcdFwidG1wXCI6IFwidG1wL3NpcC5qcy0wLjcuNS50Z3pfMTQ2MTU5NDQxODY5MF8wLjU4Mzk5MzMxMjQzNzA4NzNcIlxuXHR9LFxuXHRcIl9ucG1Vc2VyXCI6IHtcblx0XHRcImVtYWlsXCI6IFwiMTIxMmp0cmFjZXVyQGdtYWlsLmNvbVwiLFxuXHRcdFwibmFtZVwiOiBcImpvc2VwaGZyYXppZXJcIlxuXHR9LFxuXHRcIl9ucG1WZXJzaW9uXCI6IFwiMi4xNS4xXCIsXG5cdFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcblx0XCJfcmVxdWVzdGVkXCI6IHtcblx0XHRcIm5hbWVcIjogXCJzaXAuanNcIixcblx0XHRcInJhd1wiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcdFwicmF3U3BlY1wiOiBcIjAuNy41XCIsXG5cdFx0XCJzY29wZVwiOiBudWxsLFxuXHRcdFwic3BlY1wiOiBcIjAuNy41XCIsXG5cdFx0XCJ0eXBlXCI6IFwidmVyc2lvblwiXG5cdH0sXG5cdFwiX3JlcXVpcmVkQnlcIjogW1xuXHRcdFwiL3JpbmdjZW50cmFsLXdlYi1waG9uZVwiXG5cdF0sXG5cdFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc2lwLmpzLy0vc2lwLmpzLTAuNy41LnRnelwiLFxuXHRcIl9zaGFzdW1cIjogXCI4NmFjZTcwNTE1OTRmOTFiNDU1MWJkYjgxMjBhMTZjNDQ5NjJkM2EyXCIsXG5cdFwiX3Nocmlua3dyYXBcIjogbnVsbCxcblx0XCJfc3BlY1wiOiBcInNpcC5qc0AwLjcuNVwiLFxuXHRcIl93aGVyZVwiOiBcIi9Vc2Vycy9ob3dhcmQuemhhbmcvU2l0ZXMvcmluZ2NlbnRyYWwtanMtaW50ZWdyYXRpb24tY29tbW9ucy9ub2RlX21vZHVsZXMvcmluZ2NlbnRyYWwtd2ViLXBob25lXCIsXG5cdFwiYXV0aG9yXCI6IHtcblx0XHRcImVtYWlsXCI6IFwiZGV2ZWxvcGVyQG9uc2lwLmNvbVwiLFxuXHRcdFwibmFtZVwiOiBcIk9uU0lQXCIsXG5cdFx0XCJ1cmxcIjogXCJodHRwOi8vc2lwanMuY29tL2F1dGhvcnMvXCJcblx0fSxcblx0XCJicm93c2VyXCI6IHtcblx0XHRcIi4vc3JjL2Vudmlyb25tZW50LmpzXCI6IFwiLi9zcmMvZW52aXJvbm1lbnRfYnJvd3Nlci5qc1wiXG5cdH0sXG5cdFwiYnVnc1wiOiB7XG5cdFx0XCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vb25zaXAvU0lQLmpzL2lzc3Vlc1wiXG5cdH0sXG5cdFwiY29udHJpYnV0b3JzXCI6IFtcblx0XHR7XG5cdFx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMvYmxvYi9tYXN0ZXIvVEhBTktTLm1kXCJcblx0XHR9XG5cdF0sXG5cdFwiZGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcInByb21pc2N1b3VzXCI6IFwiXjAuNi4wXCIsXG5cdFx0XCJ3c1wiOiBcIl4wLjYuNFwiXG5cdH0sXG5cdFwiZGVzY3JpcHRpb25cIjogXCJBIHNpbXBsZSwgaW50dWl0aXZlLCBhbmQgcG93ZXJmdWwgSmF2YVNjcmlwdCBzaWduYWxpbmcgbGlicmFyeVwiLFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJiZWVmeVwiOiBcIl4yLjEuNVwiLFxuXHRcdFwiYnJvd3NlcmlmeVwiOiBcIl40LjEuOFwiLFxuXHRcdFwiZ3J1bnRcIjogXCJ+MC40LjBcIixcblx0XHRcImdydW50LWJyb3dzZXJpZnlcIjogXCJeNC4wLjFcIixcblx0XHRcImdydW50LWNsaVwiOiBcIn4wLjEuNlwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1jb3B5XCI6IFwiXjAuNS4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLWphc21pbmVcIjogXCJeMC45LjJcIixcblx0XHRcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwiPjAuNS4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIn4wLjIuMFwiLFxuXHRcdFwiZ3J1bnQtcGVnXCI6IFwifjEuMy4xXCIsXG5cdFx0XCJncnVudC10cmltdHJhaWxpbmdzcGFjZXNcIjogXCJeMC40LjBcIixcblx0XHRcInBlZ2pzXCI6IFwiXjAuOC4wXCJcblx0fSxcblx0XCJkaXJlY3Rvcmllc1wiOiB7fSxcblx0XCJkaXN0XCI6IHtcblx0XHRcInNoYXN1bVwiOiBcIjg2YWNlNzA1MTU5NGY5MWI0NTUxYmRiODEyMGExNmM0NDk2MmQzYTJcIixcblx0XHRcInRhcmJhbGxcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zaXAuanMvLS9zaXAuanMtMC43LjUudGd6XCJcblx0fSxcblx0XCJlbmdpbmVzXCI6IHtcblx0XHRcIm5vZGVcIjogXCI+PTAuOFwiXG5cdH0sXG5cdFwiZ2l0SGVhZFwiOiBcImJhZTQ0YmQwMzU5ZjRkNzBkZWQzMDlhMzIzNjFmMDRhMDRlNzhkNmVcIixcblx0XCJob21lcGFnZVwiOiBcImh0dHA6Ly9zaXBqcy5jb21cIixcblx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XCJzaXBcIixcblx0XHRcIndlYnNvY2tldFwiLFxuXHRcdFwid2VicnRjXCIsXG5cdFx0XCJsaWJyYXJ5XCIsXG5cdFx0XCJqYXZhc2NyaXB0XCJcblx0XSxcblx0XCJsaWNlbnNlXCI6IFwiTUlUXCIsXG5cdFwibWFpblwiOiBcInNyYy9pbmRleC5qc1wiLFxuXHRcIm1haW50YWluZXJzXCI6IFtcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiZXJpYy5ncmVlbkBvbnNpcC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImVncmVlbl9vbnNpcFwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiamFtZXNAb25zaXAuY29tXCIsXG5cdFx0XHRcIm5hbWVcIjogXCJqYW1lcy1jcmlzY3VvbG9cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJlbWFpbFwiOiBcIjEyMTJqdHJhY2V1ckBnbWFpbC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImpvc2VwaGZyYXppZXJcIlxuXHRcdH1cblx0XSxcblx0XCJuYW1lXCI6IFwic2lwLmpzXCIsXG5cdFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwicHJvbWlzY3VvdXNcIjogXCJeMC42LjBcIlxuXHR9LFxuXHRcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vb25zaXAvU0lQLmpzLmdpdFwiXG5cdH0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJidWlsZFwiOiBcImdydW50IGJ1aWxkXCIsXG5cdFx0XCJwcmVwdWJsaXNoXCI6IFwiY2Qgc3JjL0dyYW1tYXIgJiYgbWtkaXIgLXAgZGlzdCAmJiBwZWdqcyAtLWV4dHJhLW9wdGlvbnMtZmlsZSBwZWcuanNvbiBzcmMvR3JhbW1hci5wZWdqcyBkaXN0L0dyYW1tYXIuanNcIixcblx0XHRcInJlcGxcIjogXCJiZWVmeSB0ZXN0L3JlcGwuanMgLS1vcGVuXCIsXG5cdFx0XCJ0ZXN0XCI6IFwiZ3J1bnQgdHJhdmlzIC0tdmVyYm9zZVwiXG5cdH0sXG5cdFwidGl0bGVcIjogXCJTSVAuanNcIixcblx0XCJ2ZXJzaW9uXCI6IFwiMC43LjVcIlxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvcGFja2FnZS5qc29uXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcbnZhciBVdGlscztcblxuVXRpbHM9IHtcblxuICBQcm9taXNlOiBlbnZpcm9ubWVudC5Qcm9taXNlLFxuXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlciAoKSB7XG4gICAgdmFyIGRlZmVycmVkID0ge307XG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBVdGlscy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfSxcblxuICBwcm9taXNpZnk6IGZ1bmN0aW9uIHByb21pc2lmeSAob2JqZWN0LCBtZXRob2ROYW1lLCBjYWxsYmFja3NGaXJzdCkge1xuICAgIHZhciBvbGRNZXRob2QgPSBvYmplY3RbbWV0aG9kTmFtZV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2lmaWVkTWV0aG9kIChhcmcsIG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFV0aWxzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgb2xkQXJncyA9IFthcmcsIHJlc29sdmUsIHJlamVjdF07XG4gICAgICAgIGlmIChjYWxsYmFja3NGaXJzdCkge1xuICAgICAgICAgIG9sZEFyZ3MgPSBbcmVzb2x2ZSwgcmVqZWN0LCBhcmddO1xuICAgICAgICB9XG4gICAgICAgIG9sZE1ldGhvZC5hcHBseShvYmplY3QsIG9sZEFyZ3MpO1xuICAgICAgfSkudGhlbihvblN1Y2Nlc3MsIG9uRmFpbHVyZSk7XG4gICAgfTtcbiAgfSxcblxuICBhdWdtZW50OiBmdW5jdGlvbiAob2JqZWN0LCBjb25zdHJ1Y3RvciwgYXJncywgb3ZlcnJpZGUpIHtcbiAgICB2YXIgaWR4LCBwcm90bztcblxuICAgIC8vIEFkZCBwdWJsaWMgcHJvcGVydGllcyBmcm9tIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlIG9udG8gb2JqZWN0XG4gICAgcHJvdG8gPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgZm9yIChpZHggaW4gcHJvdG8pIHtcbiAgICAgIGlmIChvdmVycmlkZSB8fCBvYmplY3RbaWR4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdFtpZHhdID0gcHJvdG9baWR4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIG9iamVjdCBhcyB0aG91Z2ggaXQgd2VyZSBqdXN0IGNyZWF0ZWQgYnkgY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3Rvci5hcHBseShvYmplY3QsIGFyZ3MpO1xuICB9LFxuXG4gIG9wdGlvbnNPdmVycmlkZTogZnVuY3Rpb24gKG9wdGlvbnMsIHdpbm5lciwgbG9zZXIsIGlzRGVwcmVjYXRlZCwgbG9nZ2VyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaXNEZXByZWNhdGVkICYmIG9wdGlvbnNbbG9zZXJdKSB7XG4gICAgICBsb2dnZXIud2Fybihsb3NlciArICcgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnICsgd2lubmVyICsgJyBpbnN0ZWFkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbd2lubmVyXSAmJiBvcHRpb25zW2xvc2VyXSkge1xuICAgICAgbG9nZ2VyLndhcm4od2lubmVyICsgJyBvdmVycmlkaW5nICcgKyBsb3Nlcik7XG4gICAgfVxuXG4gICAgb3B0aW9uc1t3aW5uZXJdID0gb3B0aW9uc1t3aW5uZXJdIHx8IG9wdGlvbnNbbG9zZXJdIHx8IGRlZmF1bHRWYWx1ZTtcbiAgfSxcblxuICBzdHJfdXRmOF9sZW5ndGg6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKS5yZXBsYWNlKC8lW0EtRlxcZF17Mn0vZywgJ1UnKS5sZW5ndGg7XG4gIH0sXG5cbiAgZ2VuZXJhdGVGYWtlU0RQOiBmdW5jdGlvbihib2R5KSB7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gYm9keS5pbmRleE9mKCdvPScpO1xuICAgIHZhciBlbmQgPSBib2R5LmluZGV4T2YoJ1xcclxcbicsIHN0YXJ0KTtcblxuICAgIHJldHVybiAndj0wXFxyXFxuJyArIGJvZHkuc2xpY2Uoc3RhcnQsIGVuZCkgKyAnXFxyXFxucz0tXFxyXFxudD0wIDBcXHJcXG5jPUlOIElQNCAwLjAuMC4wJztcbiAgfSxcblxuICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihmbikge1xuICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBpc0RlY2ltYWw6IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG51bSkgJiYgKHBhcnNlRmxvYXQobnVtKSA9PT0gcGFyc2VJbnQobnVtLDEwKSk7XG4gIH0sXG5cbiAgY3JlYXRlUmFuZG9tVG9rZW46IGZ1bmN0aW9uKHNpemUsIGJhc2UpIHtcbiAgICB2YXIgaSwgcixcbiAgICAgIHRva2VuID0gJyc7XG5cbiAgICBiYXNlID0gYmFzZSB8fCAzMjtcblxuICAgIGZvciggaT0wOyBpIDwgc2l6ZTsgaSsrICkge1xuICAgICAgciA9IE1hdGgucmFuZG9tKCkgKiBiYXNlfDA7XG4gICAgICB0b2tlbiArPSByLnRvU3RyaW5nKGJhc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfSxcblxuICBuZXdUYWc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oU0lQLlVBLkMuVEFHX0xFTkdUSCk7XG4gIH0sXG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3VzZXJzLzEwOTUzOC9icm9vZmFcbiAgbmV3VVVJRDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIFVVSUQgPSAgJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBVVUlEO1xuICB9LFxuXG4gIGhvc3RUeXBlOiBmdW5jdGlvbihob3N0KSB7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3QgPSBTSVAuR3JhbW1hci5wYXJzZShob3N0LCdob3N0Jyk7XG4gICAgICBpZiAoaG9zdCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QuaG9zdF90eXBlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBOb3JtYWxpemUgU0lQIFVSSS5cbiAgKiBOT1RFOiBJdCBkb2VzIG5vdCBhbGxvdyBhIFNJUCBVUkkgd2l0aG91dCB1c2VybmFtZS5cbiAgKiBBY2NlcHRzICdzaXAnLCAnc2lwcycgYW5kICd0ZWwnIFVSSXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvICdzaXAnLlxuICAqIERldGVjdHMgdGhlIGRvbWFpbiBwYXJ0IChpZiBnaXZlbikgYW5kIHByb3Blcmx5IGhleC1lc2NhcGVzIHRoZSB1c2VyIHBvcnRpb24uXG4gICogSWYgdGhlIHVzZXIgcG9ydGlvbiBoYXMgb25seSAndGVsJyBudW1iZXIgc3ltYm9scyB0aGUgdXNlciBwb3J0aW9uIGlzIGNsZWFuIG9mICd0ZWwnIHZpc3VhbCBzZXBhcmF0b3JzLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICAqIEBwYXJhbSB7U3RyaW5nfSBbZG9tYWluXVxuICAqL1xuICBub3JtYWxpemVUYXJnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgZG9tYWluKSB7XG4gICAgdmFyIHVyaSwgdGFyZ2V0X2FycmF5LCB0YXJnZXRfdXNlciwgdGFyZ2V0X2RvbWFpbjtcblxuICAgIC8vIElmIG5vIHRhcmdldCBpcyBnaXZlbiB0aGVuIHJhaXNlIGFuIGVycm9yLlxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgLy8gSWYgYSBTSVAuVVJJIGluc3RhbmNlIGlzIGdpdmVuIHRoZW4gcmV0dXJuIGl0LlxuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU0lQLlVSSSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcblxuICAgIC8vIElmIGEgc3RyaW5nIGlzIGdpdmVuIHNwbGl0IGl0IGJ5ICdAJzpcbiAgICAvLyAtIExhc3QgZnJhZ21lbnQgaXMgdGhlIGRlc2lyZWQgZG9tYWluLlxuICAgIC8vIC0gT3RoZXJ3aXNlIGFwcGVuZCB0aGUgZ2l2ZW4gZG9tYWluIGFyZ3VtZW50LlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhcmdldF9hcnJheSA9IHRhcmdldC5zcGxpdCgnQCcpO1xuXG4gICAgICBzd2l0Y2godGFyZ2V0X2FycmF5Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXQ7XG4gICAgICAgICAgdGFyZ2V0X2RvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRhcmdldF91c2VyID0gdGFyZ2V0X2FycmF5WzBdO1xuICAgICAgICAgIHRhcmdldF9kb21haW4gPSB0YXJnZXRfYXJyYXlbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfYXJyYXkuc2xpY2UoMCwgdGFyZ2V0X2FycmF5Lmxlbmd0aC0xKS5qb2luKCdAJyk7XG4gICAgICAgICAgdGFyZ2V0X2RvbWFpbiA9IHRhcmdldF9hcnJheVt0YXJnZXRfYXJyYXkubGVuZ3RoLTFdO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIFVSSSBzY2hlbWUgKGlmIHByZXNlbnQpLlxuICAgICAgdGFyZ2V0X3VzZXIgPSB0YXJnZXRfdXNlci5yZXBsYWNlKC9eKHNpcHM/fHRlbCk6L2ksICcnKTtcblxuICAgICAgLy8gUmVtb3ZlICd0ZWwnIHZpc3VhbCBzZXBhcmF0b3JzIGlmIHRoZSB1c2VyIHBvcnRpb24ganVzdCBjb250YWlucyAndGVsJyBudW1iZXIgc3ltYm9scy5cbiAgICAgIGlmICgvXltcXC1cXC5cXChcXCldKlxcKz9bMC05XFwtXFwuXFwoXFwpXSskLy50ZXN0KHRhcmdldF91c2VyKSkge1xuICAgICAgICB0YXJnZXRfdXNlciA9IHRhcmdldF91c2VyLnJlcGxhY2UoL1tcXC1cXC5cXChcXCldL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgdGhlIGNvbXBsZXRlIFNJUCBVUkkuXG4gICAgICB0YXJnZXQgPSBTSVAuQy5TSVAgKyAnOicgKyBTSVAuVXRpbHMuZXNjYXBlVXNlcih0YXJnZXRfdXNlcikgKyAnQCcgKyB0YXJnZXRfZG9tYWluO1xuXG4gICAgICAvLyBGaW5hbGx5IHBhcnNlIHRoZSByZXN1bHRpbmcgVVJJLlxuICAgICAgaWYgKHVyaSA9IFNJUC5VUkkucGFyc2UodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEhleC1lc2NhcGUgYSBTSVAgVVJJIHVzZXIuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICAqL1xuICBlc2NhcGVVc2VyOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgLy8gRG9uJ3QgaGV4LWVzY2FwZSAnOicgKCUzQSksICcrJyAoJTJCKSwgJz8nICglM0ZcIiksICcvJyAoJTJGKS5cbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1c2VyKSkucmVwbGFjZSgvJTNBL2lnLCAnOicpLnJlcGxhY2UoLyUyQi9pZywgJysnKS5yZXBsYWNlKC8lM0YvaWcsICc/JykucmVwbGFjZSgvJTJGL2lnLCAnLycpO1xuICB9LFxuXG4gIGhlYWRlcml6ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGV4Y2VwdGlvbnMgPSB7XG4gICAgICAnQ2FsbC1JZCc6ICdDYWxsLUlEJyxcbiAgICAgICdDc2VxJzogJ0NTZXEnLFxuICAgICAgJ01pbi1TZSc6ICdNaW4tU0UnLFxuICAgICAgJ1JhY2snOiAnUkFjaycsXG4gICAgICAnUnNlcSc6ICdSU2VxJyxcbiAgICAgICdXd3ctQXV0aGVudGljYXRlJzogJ1dXVy1BdXRoZW50aWNhdGUnXG4gICAgICB9LFxuICAgICAgbmFtZSA9IHN0cmluZy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18vZywnLScpLnNwbGl0KCctJyksXG4gICAgICBobmFtZSA9ICcnLFxuICAgICAgcGFydHMgPSBuYW1lLmxlbmd0aCwgcGFydDtcblxuICAgIGZvciAocGFydCA9IDA7IHBhcnQgPCBwYXJ0czsgcGFydCsrKSB7XG4gICAgICBpZiAocGFydCAhPT0gMCkge1xuICAgICAgICBobmFtZSArPSctJztcbiAgICAgIH1cbiAgICAgIGhuYW1lICs9IG5hbWVbcGFydF0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbmFtZVtwYXJ0XS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChleGNlcHRpb25zW2huYW1lXSkge1xuICAgICAgaG5hbWUgPSBleGNlcHRpb25zW2huYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGhuYW1lO1xuICB9LFxuXG4gIHNpcEVycm9yQ2F1c2U6IGZ1bmN0aW9uKHN0YXR1c19jb2RlKSB7XG4gICAgdmFyIGNhdXNlO1xuXG4gICAgZm9yIChjYXVzZSBpbiBTSVAuQy5TSVBfRVJST1JfQ0FVU0VTKSB7XG4gICAgICBpZiAoU0lQLkMuU0lQX0VSUk9SX0NBVVNFU1tjYXVzZV0uaW5kZXhPZihzdGF0dXNfY29kZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5jYXVzZXNbY2F1c2VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTSVAuQy5jYXVzZXMuU0lQX0ZBSUxVUkVfQ09ERTtcbiAgfSxcblxuICBnZXRSZWFzb25QaHJhc2U6IGZ1bmN0aW9uIGdldFJlYXNvblBocmFzZSAoY29kZSwgc3BlY2lmaWMpIHtcbiAgICByZXR1cm4gc3BlY2lmaWMgfHwgU0lQLkMuUkVBU09OX1BIUkFTRVtjb2RlXSB8fCAnJztcbiAgfSxcblxuICBnZXRSZWFzb25IZWFkZXJWYWx1ZTogZnVuY3Rpb24gZ2V0UmVhc29uSGVhZGVyVmFsdWUgKGNvZGUsIHJlYXNvbikge1xuICAgIHJlYXNvbiA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UoY29kZSwgcmVhc29uKTtcbiAgICByZXR1cm4gJ1NJUCA7Y2F1c2U9JyArIGNvZGUgKyAnIDt0ZXh0PVwiJyArIHJlYXNvbiArICdcIic7XG4gIH0sXG5cbiAgZ2V0Q2FuY2VsUmVhc29uOiBmdW5jdGlvbiBnZXRDYW5jZWxSZWFzb24gKGNvZGUsIHJlYXNvbikge1xuICAgIGlmIChjb2RlICYmIGNvZGUgPCAyMDAgfHwgY29kZSA+IDY5OSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNfY29kZTogJyArIGNvZGUpO1xuICAgIH0gZWxzZSBpZiAoY29kZSkge1xuICAgICAgcmV0dXJuIFNJUC5VdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZShjb2RlLCByZWFzb24pO1xuICAgIH1cbiAgfSxcblxuICBidWlsZFN0YXR1c0xpbmU6IGZ1bmN0aW9uIGJ1aWxkU3RhdHVzTGluZSAoY29kZSwgcmVhc29uKSB7XG4gICAgY29kZSA9IGNvZGUgfHwgbnVsbDtcbiAgICByZWFzb24gPSByZWFzb24gfHwgbnVsbDtcblxuICAgIC8vIFZhbGlkYXRlIGNvZGUgYW5kIHJlYXNvbiB2YWx1ZXNcbiAgICBpZiAoIWNvZGUgfHwgKGNvZGUgPCAxMDAgfHwgY29kZSA+IDY5OSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzX2NvZGU6ICcrIGNvZGUpO1xuICAgIH0gZWxzZSBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24gIT09ICdzdHJpbmcnICYmICEocmVhc29uIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCByZWFzb25fcGhyYXNlOiAnKyByZWFzb24pO1xuICAgIH1cblxuICAgIHJlYXNvbiA9IFV0aWxzLmdldFJlYXNvblBocmFzZShjb2RlLCByZWFzb24pO1xuXG4gICAgcmV0dXJuICdTSVAvMi4wICcgKyBjb2RlICsgJyAnICsgcmVhc29uICsgJ1xcclxcbic7XG4gIH0sXG5cbiAgLyoqXG4gICogR2VuZXJhdGUgYSByYW5kb20gVGVzdC1OZXQgSVAgKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU3MzUpXG4gICogQHByaXZhdGVcbiAgKi9cbiAgZ2V0UmFuZG9tVGVzdE5ldElQOiBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBnZXRPY3RldChmcm9tLHRvKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKih0by1mcm9tKzEpK2Zyb20pO1xuICAgIH1cbiAgICByZXR1cm4gJzE5Mi4wLjIuJyArIGdldE9jdGV0KDEsIDI1NCk7XG4gIH0sXG5cbiAgLy8gTUQ1IChNZXNzYWdlLURpZ2VzdCBBbGdvcml0aG0pIGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvXG4gIGNhbGN1bGF0ZU1ENTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgZnVuY3Rpb24gUm90YXRlTGVmdChsVmFsdWUsIGlTaGlmdEJpdHMpIHtcbiAgICAgIHJldHVybiAobFZhbHVlPDxpU2hpZnRCaXRzKSB8IChsVmFsdWU+Pj4oMzItaVNoaWZ0Qml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFkZFVuc2lnbmVkKGxYLGxZKSB7XG4gICAgICB2YXIgbFg0LGxZNCxsWDgsbFk4LGxSZXN1bHQ7XG4gICAgICBsWDggPSAobFggJiAweDgwMDAwMDAwKTtcbiAgICAgIGxZOCA9IChsWSAmIDB4ODAwMDAwMDApO1xuICAgICAgbFg0ID0gKGxYICYgMHg0MDAwMDAwMCk7XG4gICAgICBsWTQgPSAobFkgJiAweDQwMDAwMDAwKTtcbiAgICAgIGxSZXN1bHQgPSAobFggJiAweDNGRkZGRkZGKSsobFkgJiAweDNGRkZGRkZGKTtcbiAgICAgIGlmIChsWDQgJiBsWTQpIHtcbiAgICAgICAgcmV0dXJuIChsUmVzdWx0IF4gMHg4MDAwMDAwMCBeIGxYOCBeIGxZOCk7XG4gICAgICB9XG4gICAgICBpZiAobFg0IHwgbFk0KSB7XG4gICAgICAgIGlmIChsUmVzdWx0ICYgMHg0MDAwMDAwMCkge1xuICAgICAgICAgIHJldHVybiAobFJlc3VsdCBeIDB4QzAwMDAwMDAgXiBsWDggXiBsWTgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAobFJlc3VsdCBeIDB4NDAwMDAwMDAgXiBsWDggXiBsWTgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKGxSZXN1bHQgXiBsWDggXiBsWTgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEYoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBHKHgseSx6KSB7XG4gICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSCh4LHkseikge1xuICAgICAgcmV0dXJuICh4IF4geSBeIHopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEkoeCx5LHopIHtcbiAgICAgIHJldHVybiAoeSBeICh4IHwgKH56KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZGKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoRihiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR0coYSxiLGMsZCx4LHMsYWMpIHtcbiAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChHKGIsIGMsIGQpLCB4KSwgYWMpKTtcbiAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBISChhLGIsYyxkLHgscyxhYykge1xuICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEgoYiwgYywgZCksIHgpLCBhYykpO1xuICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIElJKGEsYixjLGQseCxzLGFjKSB7XG4gICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSShiLCBjLCBkKSwgeCksIGFjKSk7XG4gICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udmVydFRvV29yZEFycmF5KHN0cmluZykge1xuICAgICAgdmFyIGxXb3JkQ291bnQ7XG4gICAgICB2YXIgbE1lc3NhZ2VMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxOdW1iZXJPZldvcmRzX3RlbXAxPWxNZXNzYWdlTGVuZ3RoICsgODtcbiAgICAgIHZhciBsTnVtYmVyT2ZXb3Jkc190ZW1wMj0obE51bWJlck9mV29yZHNfdGVtcDEtKGxOdW1iZXJPZldvcmRzX3RlbXAxICUgNjQpKS82NDtcbiAgICAgIHZhciBsTnVtYmVyT2ZXb3JkcyA9IChsTnVtYmVyT2ZXb3Jkc190ZW1wMisxKSoxNjtcbiAgICAgIHZhciBsV29yZEFycmF5PUFycmF5KGxOdW1iZXJPZldvcmRzLTEpO1xuICAgICAgdmFyIGxCeXRlUG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGxCeXRlQ291bnQgPSAwO1xuICAgICAgd2hpbGUgKCBsQnl0ZUNvdW50IDwgbE1lc3NhZ2VMZW5ndGggKSB7XG4gICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudC0obEJ5dGVDb3VudCAlIDQpKS80O1xuICAgICAgICBsQnl0ZVBvc2l0aW9uID0gKGxCeXRlQ291bnQgJSA0KSo4O1xuICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID0gKGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoc3RyaW5nLmNoYXJDb2RlQXQobEJ5dGVDb3VudCk8PGxCeXRlUG9zaXRpb24pKTtcbiAgICAgICAgbEJ5dGVDb3VudCsrO1xuICAgICAgfVxuICAgICAgbFdvcmRDb3VudCA9IChsQnl0ZUNvdW50LShsQnl0ZUNvdW50ICUgNCkpLzQ7XG4gICAgICBsQnl0ZVBvc2l0aW9uID0gKGxCeXRlQ291bnQgJSA0KSo4O1xuICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSA9IGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoMHg4MDw8bEJ5dGVQb3NpdGlvbik7XG4gICAgICBsV29yZEFycmF5W2xOdW1iZXJPZldvcmRzLTJdID0gbE1lc3NhZ2VMZW5ndGg8PDM7XG4gICAgICBsV29yZEFycmF5W2xOdW1iZXJPZldvcmRzLTFdID0gbE1lc3NhZ2VMZW5ndGg+Pj4yOTtcbiAgICAgIHJldHVybiBsV29yZEFycmF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdvcmRUb0hleChsVmFsdWUpIHtcbiAgICAgIHZhciBXb3JkVG9IZXhWYWx1ZT1cIlwiLFdvcmRUb0hleFZhbHVlX3RlbXA9XCJcIixsQnl0ZSxsQ291bnQ7XG4gICAgICBmb3IgKGxDb3VudCA9IDA7bENvdW50PD0zO2xDb3VudCsrKSB7XG4gICAgICAgIGxCeXRlID0gKGxWYWx1ZT4+PihsQ291bnQqOCkpICYgMjU1O1xuICAgICAgICBXb3JkVG9IZXhWYWx1ZV90ZW1wID0gXCIwXCIgKyBsQnl0ZS50b1N0cmluZygxNik7XG4gICAgICAgIFdvcmRUb0hleFZhbHVlID0gV29yZFRvSGV4VmFsdWUgKyBXb3JkVG9IZXhWYWx1ZV90ZW1wLnN1YnN0cihXb3JkVG9IZXhWYWx1ZV90ZW1wLmxlbmd0aC0yLDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFdvcmRUb0hleFZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFV0ZjhFbmNvZGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxyXFxuL2csXCJcXG5cIik7XG4gICAgICB2YXIgdXRmdGV4dCA9IFwiXCI7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgc3RyaW5nLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG5cbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZigoYyA+IDEyNykgJiYgKGMgPCAyMDQ4KSkge1xuICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiA2KSB8IDE5Mik7XG4gICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gMTIpIHwgMjI0KTtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjID4+IDYpICYgNjMpIHwgMTI4KTtcbiAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRmdGV4dDtcbiAgICB9XG5cbiAgICB2YXIgeD1bXTtcbiAgICB2YXIgayxBQSxCQixDQyxERCxhLGIsYyxkO1xuICAgIHZhciBTMTE9NywgUzEyPTEyLCBTMTM9MTcsIFMxND0yMjtcbiAgICB2YXIgUzIxPTUsIFMyMj05ICwgUzIzPTE0LCBTMjQ9MjA7XG4gICAgdmFyIFMzMT00LCBTMzI9MTEsIFMzMz0xNiwgUzM0PTIzO1xuICAgIHZhciBTNDE9NiwgUzQyPTEwLCBTNDM9MTUsIFM0ND0yMTtcblxuICAgIHN0cmluZyA9IFV0ZjhFbmNvZGUoc3RyaW5nKTtcblxuICAgIHggPSBDb252ZXJ0VG9Xb3JkQXJyYXkoc3RyaW5nKTtcblxuICAgIGEgPSAweDY3NDUyMzAxOyBiID0gMHhFRkNEQUI4OTsgYyA9IDB4OThCQURDRkU7IGQgPSAweDEwMzI1NDc2O1xuXG4gICAgZm9yIChrPTA7azx4Lmxlbmd0aDtrKz0xNikge1xuICAgICAgQUE9YTsgQkI9YjsgQ0M9YzsgREQ9ZDtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srMF0sIFMxMSwweEQ3NkFBNDc4KTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srMV0sIFMxMiwweEU4QzdCNzU2KTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srMl0sIFMxMywweDI0MjA3MERCKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srM10sIFMxNCwweEMxQkRDRUVFKTtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srNF0sIFMxMSwweEY1N0MwRkFGKTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srNV0sIFMxMiwweDQ3ODdDNjJBKTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srNl0sIFMxMywweEE4MzA0NjEzKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srN10sIFMxNCwweEZENDY5NTAxKTtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srOF0sIFMxMSwweDY5ODA5OEQ4KTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srOV0sIFMxMiwweDhCNDRGN0FGKTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srMTBdLFMxMywweEZGRkY1QkIxKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srMTFdLFMxNCwweDg5NUNEN0JFKTtcbiAgICAgIGE9RkYoYSxiLGMsZCx4W2srMTJdLFMxMSwweDZCOTAxMTIyKTtcbiAgICAgIGQ9RkYoZCxhLGIsYyx4W2srMTNdLFMxMiwweEZEOTg3MTkzKTtcbiAgICAgIGM9RkYoYyxkLGEsYix4W2srMTRdLFMxMywweEE2Nzk0MzhFKTtcbiAgICAgIGI9RkYoYixjLGQsYSx4W2srMTVdLFMxNCwweDQ5QjQwODIxKTtcbiAgICAgIGE9R0coYSxiLGMsZCx4W2srMV0sIFMyMSwweEY2MUUyNTYyKTtcbiAgICAgIGQ9R0coZCxhLGIsYyx4W2srNl0sIFMyMiwweEMwNDBCMzQwKTtcbiAgICAgIGM9R0coYyxkLGEsYix4W2srMTFdLFMyMywweDI2NUU1QTUxKTtcbiAgICAgIGI9R0coYixjLGQsYSx4W2srMF0sIFMyNCwweEU5QjZDN0FBKTtcbiAgICAgIGE9R0coYSxiLGMsZCx4W2srNV0sIFMyMSwweEQ2MkYxMDVEKTtcbiAgICAgIGQ9R0coZCxhLGIsYyx4W2srMTBdLFMyMiwweDI0NDE0NTMpO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbaysxNV0sUzIzLDB4RDhBMUU2ODEpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbays0XSwgUzI0LDB4RTdEM0ZCQzgpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbays5XSwgUzIxLDB4MjFFMUNERTYpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbaysxNF0sUzIyLDB4QzMzNzA3RDYpO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbayszXSwgUzIzLDB4RjRENTBEODcpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbays4XSwgUzI0LDB4NDU1QTE0RUQpO1xuICAgICAgYT1HRyhhLGIsYyxkLHhbaysxM10sUzIxLDB4QTlFM0U5MDUpO1xuICAgICAgZD1HRyhkLGEsYixjLHhbaysyXSwgUzIyLDB4RkNFRkEzRjgpO1xuICAgICAgYz1HRyhjLGQsYSxiLHhbays3XSwgUzIzLDB4Njc2RjAyRDkpO1xuICAgICAgYj1HRyhiLGMsZCxhLHhbaysxMl0sUzI0LDB4OEQyQTRDOEEpO1xuICAgICAgYT1ISChhLGIsYyxkLHhbays1XSwgUzMxLDB4RkZGQTM5NDIpO1xuICAgICAgZD1ISChkLGEsYixjLHhbays4XSwgUzMyLDB4ODc3MUY2ODEpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbaysxMV0sUzMzLDB4NkQ5RDYxMjIpO1xuICAgICAgYj1ISChiLGMsZCxhLHhbaysxNF0sUzM0LDB4RkRFNTM4MEMpO1xuICAgICAgYT1ISChhLGIsYyxkLHhbaysxXSwgUzMxLDB4QTRCRUVBNDQpO1xuICAgICAgZD1ISChkLGEsYixjLHhbays0XSwgUzMyLDB4NEJERUNGQTkpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbays3XSwgUzMzLDB4RjZCQjRCNjApO1xuICAgICAgYj1ISChiLGMsZCxhLHhbaysxMF0sUzM0LDB4QkVCRkJDNzApO1xuICAgICAgYT1ISChhLGIsYyxkLHhbaysxM10sUzMxLDB4Mjg5QjdFQzYpO1xuICAgICAgZD1ISChkLGEsYixjLHhbayswXSwgUzMyLDB4RUFBMTI3RkEpO1xuICAgICAgYz1ISChjLGQsYSxiLHhbayszXSwgUzMzLDB4RDRFRjMwODUpO1xuICAgICAgYj1ISChiLGMsZCxhLHhbays2XSwgUzM0LDB4NDg4MUQwNSk7XG4gICAgICBhPUhIKGEsYixjLGQseFtrKzldLCBTMzEsMHhEOUQ0RDAzOSk7XG4gICAgICBkPUhIKGQsYSxiLGMseFtrKzEyXSxTMzIsMHhFNkRCOTlFNSk7XG4gICAgICBjPUhIKGMsZCxhLGIseFtrKzE1XSxTMzMsMHgxRkEyN0NGOCk7XG4gICAgICBiPUhIKGIsYyxkLGEseFtrKzJdLCBTMzQsMHhDNEFDNTY2NSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzBdLCBTNDEsMHhGNDI5MjI0NCk7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzddLCBTNDIsMHg0MzJBRkY5Nyk7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzE0XSxTNDMsMHhBQjk0MjNBNyk7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzVdLCBTNDQsMHhGQzkzQTAzOSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzEyXSxTNDEsMHg2NTVCNTlDMyk7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzNdLCBTNDIsMHg4RjBDQ0M5Mik7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzEwXSxTNDMsMHhGRkVGRjQ3RCk7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzFdLCBTNDQsMHg4NTg0NUREMSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzhdLCBTNDEsMHg2RkE4N0U0Rik7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzE1XSxTNDIsMHhGRTJDRTZFMCk7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzZdLCBTNDMsMHhBMzAxNDMxNCk7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzEzXSxTNDQsMHg0RTA4MTFBMSk7XG4gICAgICBhPUlJKGEsYixjLGQseFtrKzRdLCBTNDEsMHhGNzUzN0U4Mik7XG4gICAgICBkPUlJKGQsYSxiLGMseFtrKzExXSxTNDIsMHhCRDNBRjIzNSk7XG4gICAgICBjPUlJKGMsZCxhLGIseFtrKzJdLCBTNDMsMHgyQUQ3RDJCQik7XG4gICAgICBiPUlJKGIsYyxkLGEseFtrKzldLCBTNDQsMHhFQjg2RDM5MSk7XG4gICAgICBhPUFkZFVuc2lnbmVkKGEsQUEpO1xuICAgICAgYj1BZGRVbnNpZ25lZChiLEJCKTtcbiAgICAgIGM9QWRkVW5zaWduZWQoYyxDQyk7XG4gICAgICBkPUFkZFVuc2lnbmVkKGQsREQpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wID0gV29yZFRvSGV4KGEpK1dvcmRUb0hleChiKStXb3JkVG9IZXgoYykrV29yZFRvSGV4KGQpO1xuXG4gICAgcmV0dXJuIHRlbXAudG9Mb3dlckNhc2UoKTtcbiAgfVxufTtcblxuU0lQLlV0aWxzID0gVXRpbHM7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGV2ZWxzID0ge1xuICAnZXJyb3InOiAwLFxuICAnd2Fybic6IDEsXG4gICdsb2cnOiAyLFxuICAnZGVidWcnOiAzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zb2xlKSB7XG5cbnZhciBMb2dnZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9nZ2VyLFxuICAgIGxldmVsID0gMixcbiAgICBidWlsdGluRW5hYmxlZCA9IHRydWUsXG4gICAgY29ubmVjdG9yID0gbnVsbDtcblxuICAgIHRoaXMubG9nZ2VycyA9IHt9O1xuXG4gICAgbG9nZ2VyID0gdGhpcy5nZXRMb2dnZXIoJ3NpcC5sb2dnZXJmYWN0b3J5Jyk7XG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgYnVpbHRpbkVuYWJsZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGJ1aWx0aW5FbmFibGVkOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGJ1aWx0aW5FbmFibGVkID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdpbnZhbGlkIFwiYnVpbHRpbkVuYWJsZWRcIiBwYXJhbWV0ZXIgdmFsdWU6ICcrIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGV2ZWw6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7cmV0dXJuIGxldmVsOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PTMpIHtcbiAgICAgICAgICBsZXZlbCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMykge1xuICAgICAgICAgIGxldmVsID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChsZXZlbHMuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgbGV2ZWwgPSBsZXZlbHNbdmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignaW52YWxpZCBcImxldmVsXCIgcGFyYW1ldGVyIHZhbHVlOiAnKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbm5lY3Rvcjoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtyZXR1cm4gY29ubmVjdG9yOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25uZWN0b3IgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbm5lY3RvciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcignaW52YWxpZCBcImNvbm5lY3RvclwiIHBhcmFtZXRlciB2YWx1ZTogJysgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Mb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKHRhcmdldCwgY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcHJlZml4ID0gW25ldyBEYXRlKCksIGNhdGVnb3J5XTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHByZWZpeC5wdXNoKGxhYmVsKTtcbiAgICB9XG4gICAgY29udGVudCA9IHByZWZpeC5jb25jYXQoY29udGVudCkuam9pbignIHwgJyk7XG4gIH1cbiAgdGFyZ2V0LmNhbGwoY29uc29sZSwgY29udGVudCk7XG59O1xuXG5mdW5jdGlvbiBMb2dnZXIgKGxvZ2dlciwgY2F0ZWdvcnksIGxhYmVsKSB7XG4gIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB0aGlzLmNhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuT2JqZWN0LmtleXMobGV2ZWxzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXROYW1lKSB7XG4gIExvZ2dlci5wcm90b3R5cGVbdGFyZ2V0TmFtZV0gPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHRoaXMubG9nZ2VyW3RhcmdldE5hbWVdKHRoaXMuY2F0ZWdvcnksIHRoaXMubGFiZWwsIGNvbnRlbnQpO1xuICB9O1xuXG4gIExvZ2dlckZhY3RvcnkucHJvdG90eXBlW3RhcmdldE5hbWVdID0gZnVuY3Rpb24gKGNhdGVnb3J5LCBsYWJlbCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmxldmVsID49IGxldmVsc1t0YXJnZXROYW1lXSkge1xuICAgICAgaWYgKHRoaXMuYnVpbHRpbkVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5wcmludChjb25zb2xlW3RhcmdldE5hbWVdLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IodGFyZ2V0TmFtZSwgY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcblxuTG9nZ2VyRmFjdG9yeS5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oY2F0ZWdvcnksIGxhYmVsKSB7XG4gIHZhciBsb2dnZXI7XG5cbiAgaWYgKGxhYmVsICYmIHRoaXMubGV2ZWwgPT09IDMpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLCBjYXRlZ29yeSwgbGFiZWwpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV0pIHtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJzW2NhdGVnb3J5XTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIgPSBuZXcgTG9nZ2VyKHRoaXMsIGNhdGVnb3J5KTtcbiAgICB0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldID0gbG9nZ2VyO1xuICAgIHJldHVybiBsb2dnZXI7XG4gIH1cbn07XG5cbnJldHVybiBMb2dnZXJGYWN0b3J5O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvTG9nZ2VyRmFjdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgTm9kZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uc29sZSkge1xuXG4vLyBEb24ndCB1c2UgYG5ldyBTSVAuRXZlbnRFbWl0dGVyKClgIGZvciBpbmhlcml0aW5nLlxuLy8gVXNlIE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3RveXBlKTtcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlciAoKSB7XG4gIE5vZGVFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZUV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogRXZlbnRFbWl0dGVyLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHdhcm5pbmcgPSAnJztcbiAgd2FybmluZyArPSAnU0lQLkV2ZW50RW1pdHRlciNvZmYgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIFNJUC5qcyB2ZXJzaW9ucy5cXG4nO1xuICB3YXJuaW5nICs9ICdQbGVhc2UgdXNlIHJlbW92ZUxpc3RlbmVyIG9yIHJlbW92ZUFsbExpc3RlbmVycyBpbnN0ZWFkLlxcbic7XG4gIHdhcm5pbmcgKz0gJ1NlZSBoZXJlIGZvciBtb3JlIGRldGFpbHM6XFxuJztcbiAgd2FybmluZyArPSAnaHR0cDovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19lbWl0dGVyX3JlbW92ZWxpc3RlbmVyX2V2ZW50X2xpc3RlbmVyJztcbiAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG5yZXR1cm4gRXZlbnRFbWl0dGVyO1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9FdmVudEVtaXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2V2ZW50cy9ldmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBDb25zdGFudHNcbiAqL1xuXG4vKipcbiAqIFNJUCBDb25zdGFudHMuXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbikge1xucmV0dXJuIHtcbiAgVVNFUl9BR0VOVDogbmFtZSArJy8nKyB2ZXJzaW9uLFxuXG4gIC8vIFNJUCBzY2hlbWVcbiAgU0lQOiAgJ3NpcCcsXG4gIFNJUFM6ICdzaXBzJyxcblxuICAvLyBFbmQgYW5kIEZhaWx1cmUgY2F1c2VzXG4gIGNhdXNlczoge1xuICAgIC8vIEdlbmVyaWMgZXJyb3IgY2F1c2VzXG4gICAgQ09OTkVDVElPTl9FUlJPUjogICAgICAgICAnQ29ubmVjdGlvbiBFcnJvcicsXG4gICAgUkVRVUVTVF9USU1FT1VUOiAgICAgICAgICAnUmVxdWVzdCBUaW1lb3V0JyxcbiAgICBTSVBfRkFJTFVSRV9DT0RFOiAgICAgICAgICdTSVAgRmFpbHVyZSBDb2RlJyxcbiAgICBJTlRFUk5BTF9FUlJPUjogICAgICAgICAgICdJbnRlcm5hbCBFcnJvcicsXG5cbiAgICAvLyBTSVAgZXJyb3IgY2F1c2VzXG4gICAgQlVTWTogICAgICAgICAgICAgICAgICAgICAnQnVzeScsXG4gICAgUkVKRUNURUQ6ICAgICAgICAgICAgICAgICAnUmVqZWN0ZWQnLFxuICAgIFJFRElSRUNURUQ6ICAgICAgICAgICAgICAgJ1JlZGlyZWN0ZWQnLFxuICAgIFVOQVZBSUxBQkxFOiAgICAgICAgICAgICAgJ1VuYXZhaWxhYmxlJyxcbiAgICBOT1RfRk9VTkQ6ICAgICAgICAgICAgICAgICdOb3QgRm91bmQnLFxuICAgIEFERFJFU1NfSU5DT01QTEVURTogICAgICAgJ0FkZHJlc3MgSW5jb21wbGV0ZScsXG4gICAgSU5DT01QQVRJQkxFX1NEUDogICAgICAgICAnSW5jb21wYXRpYmxlIFNEUCcsXG4gICAgQVVUSEVOVElDQVRJT05fRVJST1I6ICAgICAnQXV0aGVudGljYXRpb24gRXJyb3InLFxuICAgIERJQUxPR19FUlJPUjogICAgICAgICAgICAgJ0RpYWxvZyBFcnJvcicsXG5cbiAgICAvLyBTZXNzaW9uIGVycm9yIGNhdXNlc1xuICAgIFdFQlJUQ19OT1RfU1VQUE9SVEVEOiAgICAgJ1dlYlJUQyBOb3QgU3VwcG9ydGVkJyxcbiAgICBXRUJSVENfRVJST1I6ICAgICAgICAgICAgICdXZWJSVEMgRXJyb3InLFxuICAgIENBTkNFTEVEOiAgICAgICAgICAgICAgICAgJ0NhbmNlbGVkJyxcbiAgICBOT19BTlNXRVI6ICAgICAgICAgICAgICAgICdObyBBbnN3ZXInLFxuICAgIEVYUElSRVM6ICAgICAgICAgICAgICAgICAgJ0V4cGlyZXMnLFxuICAgIE5PX0FDSzogICAgICAgICAgICAgICAgICAgJ05vIEFDSycsXG4gICAgTk9fUFJBQ0s6ICAgICAgICAgICAgICAgICAnTm8gUFJBQ0snLFxuICAgIFVTRVJfREVOSUVEX01FRElBX0FDQ0VTUzogJ1VzZXIgRGVuaWVkIE1lZGlhIEFjY2VzcycsXG4gICAgQkFEX01FRElBX0RFU0NSSVBUSU9OOiAgICAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJyxcbiAgICBSVFBfVElNRU9VVDogICAgICAgICAgICAgICdSVFAgVGltZW91dCdcbiAgfSxcblxuICBzdXBwb3J0ZWQ6IHtcbiAgICBVTlNVUFBPUlRFRDogICAgICAgICdub25lJyxcbiAgICBTVVBQT1JURUQ6ICAgICAgICAgICdzdXBwb3J0ZWQnLFxuICAgIFJFUVVJUkVEOiAgICAgICAgICAgJ3JlcXVpcmVkJ1xuICB9LFxuXG4gIFNJUF9FUlJPUl9DQVVTRVM6IHtcbiAgICBSRURJUkVDVEVEOiBbMzAwLDMwMSwzMDIsMzA1LDM4MF0sXG4gICAgQlVTWTogWzQ4Niw2MDBdLFxuICAgIFJFSkVDVEVEOiBbNDAzLDYwM10sXG4gICAgTk9UX0ZPVU5EOiBbNDA0LDYwNF0sXG4gICAgVU5BVkFJTEFCTEU6IFs0ODAsNDEwLDQwOCw0MzBdLFxuICAgIEFERFJFU1NfSU5DT01QTEVURTogWzQ4NF0sXG4gICAgSU5DT01QQVRJQkxFX1NEUDogWzQ4OCw2MDZdLFxuICAgIEFVVEhFTlRJQ0FUSU9OX0VSUk9SOls0MDEsNDA3XVxuICB9LFxuXG4gIC8vIFNJUCBNZXRob2RzXG4gIEFDSzogICAgICAgICdBQ0snLFxuICBCWUU6ICAgICAgICAnQllFJyxcbiAgQ0FOQ0VMOiAgICAgJ0NBTkNFTCcsXG4gIElORk86ICAgICAgICdJTkZPJyxcbiAgSU5WSVRFOiAgICAgJ0lOVklURScsXG4gIE1FU1NBR0U6ICAgICdNRVNTQUdFJyxcbiAgTk9USUZZOiAgICAgJ05PVElGWScsXG4gIE9QVElPTlM6ICAgICdPUFRJT05TJyxcbiAgUkVHSVNURVI6ICAgJ1JFR0lTVEVSJyxcbiAgVVBEQVRFOiAgICAgJ1VQREFURScsXG4gIFNVQlNDUklCRTogICdTVUJTQ1JJQkUnLFxuICBSRUZFUjogICAgICAnUkVGRVInLFxuICBQUkFDSzogICAgICAnUFJBQ0snLFxuXG4gIC8qIFNJUCBSZXNwb25zZSBSZWFzb25zXG4gICAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVyc1xuICAgKiBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdmVyc2F0aWNhL092ZXJTSVAvYmxvYi9tYXN0ZXIvbGliL292ZXJzaXAvc2lwL2NvbnN0YW50cy5yYiNMN1xuICAgKi9cbiAgUkVBU09OX1BIUkFTRToge1xuICAgIDEwMDogJ1RyeWluZycsXG4gICAgMTgwOiAnUmluZ2luZycsXG4gICAgMTgxOiAnQ2FsbCBJcyBCZWluZyBGb3J3YXJkZWQnLFxuICAgIDE4MjogJ1F1ZXVlZCcsXG4gICAgMTgzOiAnU2Vzc2lvbiBQcm9ncmVzcycsXG4gICAgMTk5OiAnRWFybHkgRGlhbG9nIFRlcm1pbmF0ZWQnLCAgLy8gZHJhZnQtaWV0Zi1zaXBjb3JlLTE5OVxuICAgIDIwMDogJ09LJyxcbiAgICAyMDI6ICdBY2NlcHRlZCcsICAvLyBSRkMgMzI2NVxuICAgIDIwNDogJ05vIE5vdGlmaWNhdGlvbicsICAvL1JGQyA1ODM5XG4gICAgMzAwOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxOiAnTW92ZWQgUGVybWFuZW50bHknLFxuICAgIDMwMjogJ01vdmVkIFRlbXBvcmFyaWx5JyxcbiAgICAzMDU6ICdVc2UgUHJveHknLFxuICAgIDM4MDogJ0FsdGVybmF0aXZlIFNlcnZpY2UnLFxuICAgIDQwMDogJ0JhZCBSZXF1ZXN0JyxcbiAgICA0MDE6ICdVbmF1dGhvcml6ZWQnLFxuICAgIDQwMjogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMzogJ0ZvcmJpZGRlbicsXG4gICAgNDA0OiAnTm90IEZvdW5kJyxcbiAgICA0MDU6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgIDQwNjogJ05vdCBBY2NlcHRhYmxlJyxcbiAgICA0MDc6ICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG4gICAgNDA4OiAnUmVxdWVzdCBUaW1lb3V0JyxcbiAgICA0MTA6ICdHb25lJyxcbiAgICA0MTI6ICdDb25kaXRpb25hbCBSZXF1ZXN0IEZhaWxlZCcsICAvLyBSRkMgMzkwM1xuICAgIDQxMzogJ1JlcXVlc3QgRW50aXR5IFRvbyBMYXJnZScsXG4gICAgNDE0OiAnUmVxdWVzdC1VUkkgVG9vIExvbmcnLFxuICAgIDQxNTogJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnLFxuICAgIDQxNjogJ1Vuc3VwcG9ydGVkIFVSSSBTY2hlbWUnLFxuICAgIDQxNzogJ1Vua25vd24gUmVzb3VyY2UtUHJpb3JpdHknLCAgLy8gUkZDIDQ0MTJcbiAgICA0MjA6ICdCYWQgRXh0ZW5zaW9uJyxcbiAgICA0MjE6ICdFeHRlbnNpb24gUmVxdWlyZWQnLFxuICAgIDQyMjogJ1Nlc3Npb24gSW50ZXJ2YWwgVG9vIFNtYWxsJywgIC8vIFJGQyA0MDI4XG4gICAgNDIzOiAnSW50ZXJ2YWwgVG9vIEJyaWVmJyxcbiAgICA0Mjg6ICdVc2UgSWRlbnRpdHkgSGVhZGVyJywgIC8vIFJGQyA0NDc0XG4gICAgNDI5OiAnUHJvdmlkZSBSZWZlcnJlciBJZGVudGl0eScsICAvLyBSRkMgMzg5MlxuICAgIDQzMDogJ0Zsb3cgRmFpbGVkJywgIC8vIFJGQyA1NjI2XG4gICAgNDMzOiAnQW5vbnltaXR5IERpc2FsbG93ZWQnLCAgLy8gUkZDIDUwNzlcbiAgICA0MzY6ICdCYWQgSWRlbnRpdHktSW5mbycsICAvLyBSRkMgNDQ3NFxuICAgIDQzNzogJ1Vuc3VwcG9ydGVkIENlcnRpZmljYXRlJywgIC8vIFJGQyA0NzQ0XG4gICAgNDM4OiAnSW52YWxpZCBJZGVudGl0eSBIZWFkZXInLCAgLy8gUkZDIDQ3NDRcbiAgICA0Mzk6ICdGaXJzdCBIb3AgTGFja3MgT3V0Ym91bmQgU3VwcG9ydCcsICAvLyBSRkMgNTYyNlxuICAgIDQ0MDogJ01heC1CcmVhZHRoIEV4Y2VlZGVkJywgIC8vIFJGQyA1MzkzXG4gICAgNDY5OiAnQmFkIEluZm8gUGFja2FnZScsICAvLyBkcmFmdC1pZXRmLXNpcGNvcmUtaW5mby1ldmVudHNcbiAgICA0NzA6ICdDb25zZW50IE5lZWRlZCcsICAvLyBSRkMgNTM2MFxuICAgIDQ3ODogJ1VucmVzb2x2YWJsZSBEZXN0aW5hdGlvbicsICAvLyBDdXN0b20gY29kZSBjb3BpZWQgZnJvbSBLYW1haWxpby5cbiAgICA0ODA6ICdUZW1wb3JhcmlseSBVbmF2YWlsYWJsZScsXG4gICAgNDgxOiAnQ2FsbC9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdCcsXG4gICAgNDgyOiAnTG9vcCBEZXRlY3RlZCcsXG4gICAgNDgzOiAnVG9vIE1hbnkgSG9wcycsXG4gICAgNDg0OiAnQWRkcmVzcyBJbmNvbXBsZXRlJyxcbiAgICA0ODU6ICdBbWJpZ3VvdXMnLFxuICAgIDQ4NjogJ0J1c3kgSGVyZScsXG4gICAgNDg3OiAnUmVxdWVzdCBUZXJtaW5hdGVkJyxcbiAgICA0ODg6ICdOb3QgQWNjZXB0YWJsZSBIZXJlJyxcbiAgICA0ODk6ICdCYWQgRXZlbnQnLCAgLy8gUkZDIDMyNjVcbiAgICA0OTE6ICdSZXF1ZXN0IFBlbmRpbmcnLFxuICAgIDQ5MzogJ1VuZGVjaXBoZXJhYmxlJyxcbiAgICA0OTQ6ICdTZWN1cml0eSBBZ3JlZW1lbnQgUmVxdWlyZWQnLCAgLy8gUkZDIDMzMjlcbiAgICA1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG4gICAgNTAyOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuICAgIDUwNDogJ1NlcnZlciBUaW1lLW91dCcsXG4gICAgNTA1OiAnVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICA1MTM6ICdNZXNzYWdlIFRvbyBMYXJnZScsXG4gICAgNTgwOiAnUHJlY29uZGl0aW9uIEZhaWx1cmUnLCAgLy8gUkZDIDMzMTJcbiAgICA2MDA6ICdCdXN5IEV2ZXJ5d2hlcmUnLFxuICAgIDYwMzogJ0RlY2xpbmUnLFxuICAgIDYwNDogJ0RvZXMgTm90IEV4aXN0IEFueXdoZXJlJyxcbiAgICA2MDY6ICdOb3QgQWNjZXB0YWJsZSdcbiAgfSxcblxuICAvKiBTSVAgT3B0aW9uIFRhZ3NcbiAgICogRE9DOiBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3NpcC1wYXJhbWV0ZXJzL3NpcC1wYXJhbWV0ZXJzLnhodG1sI3NpcC1wYXJhbWV0ZXJzLTRcbiAgICovXG4gIE9QVElPTl9UQUdTOiB7XG4gICAgJzEwMHJlbCc6ICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzI2MlxuICAgIDE5OTogICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDYyMjhcbiAgICBhbnN3ZXJtb2RlOiAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1MzczXG4gICAgJ2Vhcmx5LXNlc3Npb24nOiAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzk1OVxuICAgIGV2ZW50bGlzdDogICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQ2NjJcbiAgICBleHBsaWNpdHN1YjogICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQy1pZXRmLXNpcGNvcmUtcmVmZXItZXhwbGljaXQtc3Vic2NyaXB0aW9uLTAzXG4gICAgJ2Zyb20tY2hhbmdlJzogICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDkxNlxuICAgICdnZW9sb2NhdGlvbi1odHRwJzogICAgICAgICB0cnVlLCAgLy8gUkZDIDY0NDJcbiAgICAnZ2VvbG9jYXRpb24tc2lwJzogICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA2NDQyXG4gICAgZ2luOiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNjE0MFxuICAgIGdydXU6ICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDU2MjdcbiAgICBoaXN0aW5mbzogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA3MDQ0XG4gICAgaWNlOiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNTc2OFxuICAgIGpvaW46ICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDM5MTFcbiAgICAnbXVsdGlwbGUtcmVmZXInOiAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1MzY4XG4gICAgbm9yZWZlcnN1YjogICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDQ4OFxuICAgIG5vc3ViOiAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDLWlldGYtc2lwY29yZS1yZWZlci1leHBsaWNpdC1zdWJzY3JpcHRpb24tMDNcbiAgICBvdXRib3VuZDogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyA1NjI2XG4gICAgcGF0aDogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzMyN1xuICAgIHBvbGljeTogICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDY3OTRcbiAgICBwcmVjb25kaXRpb246ICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzEyXG4gICAgcHJlZjogICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgMzg0MFxuICAgIHByaXZhY3k6ICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDMzMjNcbiAgICAncmVjaXBpZW50LWxpc3QtaW52aXRlJzogICAgdHJ1ZSwgIC8vIFJGQyA1MzY2XG4gICAgJ3JlY2lwaWVudC1saXN0LW1lc3NhZ2UnOiAgIHRydWUsICAvLyBSRkMgNTM2NVxuICAgICdyZWNpcGllbnQtbGlzdC1zdWJzY3JpYmUnOiB0cnVlLCAgLy8gUkZDIDUzNjdcbiAgICByZXBsYWNlczogICAgICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzODkxXG4gICAgJ3Jlc291cmNlLXByaW9yaXR5JzogICAgICAgIHRydWUsICAvLyBSRkMgNDQxMlxuICAgICdzZHAtYW5hdCc6ICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQwOTJcbiAgICAnc2VjLWFncmVlJzogICAgICAgICAgICAgICAgdHJ1ZSwgIC8vIFJGQyAzMzI5XG4gICAgdGRpYWxvZzogICAgICAgICAgICAgICAgICAgIHRydWUsICAvLyBSRkMgNDUzOFxuICAgIHRpbWVyOiAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgLy8gUkZDIDQwMjhcbiAgICB1dWk6ICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAgIC8vIFJGQyA3NDMzXG4gIH1cbn07XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9Db25zdGFudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4Y2VwdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNJUCBFeGNlcHRpb25zLlxuICogQGF1Z21lbnRzIFNJUFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ29uZmlndXJhdGlvbkVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24ocGFyYW1ldGVyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb2RlID0gMTtcbiAgICAgIHRoaXMubmFtZSA9ICdDT05GSUdVUkFUSU9OX0VSUk9SJztcbiAgICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5tZXNzYWdlID0gKCF0aGlzLnZhbHVlKT8gJ01pc3NpbmcgcGFyYW1ldGVyOiAnKyB0aGlzLnBhcmFtZXRlciA6ICdJbnZhbGlkIHZhbHVlICcrIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpICsnIGZvciBwYXJhbWV0ZXIgXCInKyB0aGlzLnBhcmFtZXRlciArJ1wiJztcbiAgICB9O1xuICAgIGV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KCkpLFxuXG4gIEludmFsaWRTdGF0ZUVycm9yOiAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZXhjZXB0aW9uID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICB0aGlzLmNvZGUgPSAyO1xuICAgICAgdGhpcy5uYW1lID0gJ0lOVkFMSURfU1RBVEVfRVJST1InO1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAnSW52YWxpZCBzdGF0dXM6ICcgKyBzdGF0dXM7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKSxcblxuICBOb3RTdXBwb3J0ZWRFcnJvcjogKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuY29kZSA9IDM7XG4gICAgICB0aGlzLm5hbWUgPSAnTk9UX1NVUFBPUlRFRF9FUlJPUic7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH07XG4gICAgZXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH0oKSksXG5cbiAgR2V0RGVzY3JpcHRpb25FcnJvcjogKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuY29kZSA9IDQ7XG4gICAgICB0aGlzLm5hbWUgPSAnR0VUX0RFU0NSSVBUSU9OX0VSUk9SJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfTtcbiAgICBleGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbjtcbiAgfSgpKVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRXhjZXB0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFRJTUVSU1xuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICovXG52YXJcbiAgVDEgPSA1MDAsXG4gIFQyID0gNDAwMCxcbiAgVDQgPSA1MDAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGltZXJzKSB7XG4gIHZhciBUaW1lcnMgPSB7XG4gICAgVDE6IFQxLFxuICAgIFQyOiBUMixcbiAgICBUNDogVDQsXG4gICAgVElNRVJfQjogNjQgKiBUMSxcbiAgICBUSU1FUl9EOiAwICAqIFQxLFxuICAgIFRJTUVSX0Y6IDY0ICogVDEsXG4gICAgVElNRVJfSDogNjQgKiBUMSxcbiAgICBUSU1FUl9JOiAwICAqIFQxLFxuICAgIFRJTUVSX0o6IDAgICogVDEsXG4gICAgVElNRVJfSzogMCAgKiBUNCxcbiAgICBUSU1FUl9MOiA2NCAqIFQxLFxuICAgIFRJTUVSX006IDY0ICogVDEsXG4gICAgVElNRVJfTjogNjQgKiBUMSxcbiAgICBQUk9WSVNJT05BTF9SRVNQT05TRV9JTlRFUlZBTDogNjAwMDAgIC8vIFNlZSBSRkMgMzI2MSBTZWN0aW9uIDEzLjMuMS4xXG4gIH07XG5cbiAgWydzZXRUaW1lb3V0JywgJ2NsZWFyVGltZW91dCcsICdzZXRJbnRlcnZhbCcsICdjbGVhckludGVydmFsJ11cbiAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBjYW4ndCBqdXN0IHVzZSB0aW1lcnNbbmFtZV0uYmluZCh0aW1lcnMpIHNpbmNlIGl0IGJ5cGFzc2VzIGphc21pbmUnc1xuICAgIC8vIGNsb2NrLW1vY2tpbmdcbiAgICBUaW1lcnNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGltZXJzW25hbWVdLmFwcGx5KHRpbWVycywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gVGltZXJzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVGltZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgTWVzc2FnZSBQYXJzZXJcbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgYW5kIHBhcnNlIGV2ZXJ5IGhlYWRlciBvZiBhIFNJUCBtZXNzYWdlLlxuICogQGF1Z21lbnRzIFNJUFxuICogQG5hbWVzcGFjZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBQYXJzZXI7XG5cbmZ1bmN0aW9uIGdldEhlYWRlcihkYXRhLCBoZWFkZXJTdGFydCkge1xuICB2YXJcbiAgICAvLyAnc3RhcnQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgc3RhcnQgPSBoZWFkZXJTdGFydCxcbiAgICAvLyAnZW5kJyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIGVuZCA9IDAsXG4gICAgLy8gJ3BhcnRpYWwgZW5kJyBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyLlxuICAgIHBhcnRpYWxFbmQgPSAwO1xuXG4gIC8vRW5kIG9mIG1lc3NhZ2UuXG4gIGlmIChkYXRhLnN1YnN0cmluZyhzdGFydCwgc3RhcnQgKyAyKS5tYXRjaCgvKF5cXHJcXG4pLykpIHtcbiAgICByZXR1cm4gLTI7XG4gIH1cblxuICB3aGlsZShlbmQgPT09IDApIHtcbiAgICAvLyBQYXJ0aWFsIEVuZCBvZiBIZWFkZXIuXG4gICAgcGFydGlhbEVuZCA9IGRhdGEuaW5kZXhPZignXFxyXFxuJywgc3RhcnQpO1xuXG4gICAgLy8gJ2luZGV4T2YnIHJldHVybnMgLTEgaWYgdGhlIHZhbHVlIHRvIGJlIGZvdW5kIG5ldmVyIG9jY3Vycy5cbiAgICBpZiAocGFydGlhbEVuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsRW5kO1xuICAgIH1cblxuICAgIGlmKCFkYXRhLnN1YnN0cmluZyhwYXJ0aWFsRW5kICsgMiwgcGFydGlhbEVuZCArIDQpLm1hdGNoKC8oXlxcclxcbikvKSAmJiBkYXRhLmNoYXJBdChwYXJ0aWFsRW5kICsgMikubWF0Y2goLyheXFxzKykvKSkge1xuICAgICAgLy8gTm90IHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2UuIENvbnRpbnVlIGZyb20gdGhlIG5leHQgcG9zaXRpb24uXG4gICAgICBzdGFydCA9IHBhcnRpYWxFbmQgKyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBwYXJ0aWFsRW5kO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKG1lc3NhZ2UsIGRhdGEsIGhlYWRlclN0YXJ0LCBoZWFkZXJFbmQpIHtcbiAgdmFyIGhlYWRlciwgaWR4LCBsZW5ndGgsIHBhcnNlZCxcbiAgICBoY29sb25JbmRleCA9IGRhdGEuaW5kZXhPZignOicsIGhlYWRlclN0YXJ0KSxcbiAgICBoZWFkZXJOYW1lID0gZGF0YS5zdWJzdHJpbmcoaGVhZGVyU3RhcnQsIGhjb2xvbkluZGV4KS50cmltKCksXG4gICAgaGVhZGVyVmFsdWUgPSBkYXRhLnN1YnN0cmluZyhoY29sb25JbmRleCArIDEsIGhlYWRlckVuZCkudHJpbSgpO1xuXG4gIC8vIElmIGhlYWRlci1maWVsZCBpcyB3ZWxsLWtub3duLCBwYXJzZSBpdC5cbiAgc3dpdGNoKGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3ZpYSc6XG4gICAgY2FzZSAndic6XG4gICAgICBtZXNzYWdlLmFkZEhlYWRlcigndmlhJywgaGVhZGVyVmFsdWUpO1xuICAgICAgaWYobWVzc2FnZS5nZXRIZWFkZXJzKCd2aWEnKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignVmlhJyk7XG4gICAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICAgIG1lc3NhZ2UudmlhID0gcGFyc2VkO1xuICAgICAgICAgIG1lc3NhZ2UudmlhX2JyYW5jaCA9IHBhcnNlZC5icmFuY2g7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmcm9tJzpcbiAgICBjYXNlICdmJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdmcm9tJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcignZnJvbScpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UuZnJvbSA9IHBhcnNlZDtcbiAgICAgICAgbWVzc2FnZS5mcm9tX3RhZyA9IHBhcnNlZC5nZXRQYXJhbSgndGFnJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0byc6XG4gICAgY2FzZSAndCc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcigndG8nLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd0bycpO1xuICAgICAgaWYocGFyc2VkKSB7XG4gICAgICAgIG1lc3NhZ2UudG8gPSBwYXJzZWQ7XG4gICAgICAgIG1lc3NhZ2UudG9fdGFnID0gcGFyc2VkLmdldFBhcmFtKCd0YWcnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY29yZC1yb3V0ZSc6XG4gICAgICBwYXJzZWQgPSBTSVAuR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgJ1JlY29yZF9Sb3V0ZScpO1xuXG4gICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBwYXJzZWQubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHBhcnNlZFtpZHhdO1xuICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcigncmVjb3JkLXJvdXRlJywgaGVhZGVyVmFsdWUuc3Vic3RyaW5nKGhlYWRlci5wb3NpdGlvbiwgaGVhZGVyLm9mZnNldCkpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlcnNbJ1JlY29yZC1Sb3V0ZSddW21lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJykubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NhbGwtaWQnOlxuICAgIGNhc2UgJ2knOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NhbGwtaWQnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjYWxsLWlkJyk7XG4gICAgICBpZihwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5jYWxsX2lkID0gaGVhZGVyVmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb250YWN0JzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKGhlYWRlclZhbHVlLCAnQ29udGFjdCcpO1xuXG4gICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBwYXJzZWQubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGhlYWRlciA9IHBhcnNlZFtpZHhdO1xuICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcignY29udGFjdCcsIGhlYWRlclZhbHVlLnN1YnN0cmluZyhoZWFkZXIucG9zaXRpb24sIGhlYWRlci5vZmZzZXQpKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzWydDb250YWN0J11bbWVzc2FnZS5nZXRIZWFkZXJzKCdjb250YWN0JykubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnQtbGVuZ3RoJzpcbiAgICBjYXNlICdsJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb250ZW50LXR5cGUnOlxuICAgIGNhc2UgJ2MnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY3NlcSc6XG4gICAgICBtZXNzYWdlLnNldEhlYWRlcignY3NlcScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ2NzZXEnKTtcbiAgICAgIGlmKHBhcnNlZCkge1xuICAgICAgICBtZXNzYWdlLmNzZXEgPSBwYXJzZWQudmFsdWU7XG4gICAgICB9XG4gICAgICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICAgICAgbWVzc2FnZS5tZXRob2QgPSBwYXJzZWQubWV0aG9kO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWF4LWZvcndhcmRzJzpcbiAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKCdtYXgtZm9yd2FyZHMnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdtYXgtZm9yd2FyZHMnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3d3dy1hdXRoZW50aWNhdGUnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3d3dy1hdXRoZW50aWNhdGUnLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcm94eS1hdXRoZW50aWNhdGUnOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3Byb3h5LWF1dGhlbnRpY2F0ZScsIGhlYWRlclZhbHVlKTtcbiAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoJ3Byb3h5LWF1dGhlbnRpY2F0ZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVmZXItdG8nOlxuICAgIGNhc2UgJ3InOlxuICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoJ3JlZmVyLXRvJywgaGVhZGVyVmFsdWUpO1xuICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcigncmVmZXItdG8nKTtcbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgbWVzc2FnZS5yZWZlcl90byA9IHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBEbyBub3QgcGFyc2UgdGhpcyBoZWFkZXIuXG4gICAgICBtZXNzYWdlLnNldEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICBwYXJzZWQgPSAwO1xuICB9XG5cbiAgaWYgKHBhcnNlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiAnZXJyb3IgcGFyc2luZyBoZWFkZXIgXCInKyBoZWFkZXJOYW1lICsnXCInXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKiogUGFyc2UgU0lQIE1lc3NhZ2VcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgU0lQIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nZ2VyIG9iamVjdC5cbiAqIEByZXR1cm5zIHtTSVAuSW5jb21pbmdSZXF1ZXN0fFNJUC5JbmNvbWluZ1Jlc3BvbnNlfHVuZGVmaW5lZH1cbiAqL1xuUGFyc2VyID0ge307XG5QYXJzZXIucGFyc2VNZXNzYWdlID0gZnVuY3Rpb24oZGF0YSwgdWEpIHtcbiAgdmFyIG1lc3NhZ2UsIGZpcnN0TGluZSwgY29udGVudExlbmd0aCwgYm9keVN0YXJ0LCBwYXJzZWQsXG4gICAgaGVhZGVyU3RhcnQgPSAwLFxuICAgIGhlYWRlckVuZCA9IGRhdGEuaW5kZXhPZignXFxyXFxuJyksXG4gICAgbG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAucGFyc2VyJyk7XG5cbiAgaWYoaGVhZGVyRW5kID09PSAtMSkge1xuICAgIGxvZ2dlci53YXJuKCdubyBDUkxGIGZvdW5kLCBub3QgYSBTSVAgbWVzc2FnZSwgZGlzY2FyZGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUGFyc2UgZmlyc3QgbGluZS4gQ2hlY2sgaWYgaXQgaXMgYSBSZXF1ZXN0IG9yIGEgUmVwbHkuXG4gIGZpcnN0TGluZSA9IGRhdGEuc3Vic3RyaW5nKDAsIGhlYWRlckVuZCk7XG4gIHBhcnNlZCA9IFNJUC5HcmFtbWFyLnBhcnNlKGZpcnN0TGluZSwgJ1JlcXVlc3RfUmVzcG9uc2UnKTtcblxuICBpZihwYXJzZWQgPT09IC0xKSB7XG4gICAgbG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgZmlyc3QgbGluZSBvZiBTSVAgbWVzc2FnZTogXCInICsgZmlyc3RMaW5lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYoIXBhcnNlZC5zdGF0dXNfY29kZSkge1xuICAgIG1lc3NhZ2UgPSBuZXcgU0lQLkluY29taW5nUmVxdWVzdCh1YSk7XG4gICAgbWVzc2FnZS5tZXRob2QgPSBwYXJzZWQubWV0aG9kO1xuICAgIG1lc3NhZ2UucnVyaSA9IHBhcnNlZC51cmk7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IG5ldyBTSVAuSW5jb21pbmdSZXNwb25zZSh1YSk7XG4gICAgbWVzc2FnZS5zdGF0dXNfY29kZSA9IHBhcnNlZC5zdGF0dXNfY29kZTtcbiAgICBtZXNzYWdlLnJlYXNvbl9waHJhc2UgPSBwYXJzZWQucmVhc29uX3BocmFzZTtcbiAgfVxuXG4gIG1lc3NhZ2UuZGF0YSA9IGRhdGE7XG4gIGhlYWRlclN0YXJ0ID0gaGVhZGVyRW5kICsgMjtcblxuICAvKiBMb29wIG92ZXIgZXZlcnkgbGluZSBpbiBkYXRhLiBEZXRlY3QgdGhlIGVuZCBvZiBlYWNoIGhlYWRlciBhbmQgcGFyc2VcbiAgKiBpdCBvciBzaW1wbHkgYWRkIHRvIHRoZSBoZWFkZXJzIGNvbGxlY3Rpb24uXG4gICovXG4gIHdoaWxlKHRydWUpIHtcbiAgICBoZWFkZXJFbmQgPSBnZXRIZWFkZXIoZGF0YSwgaGVhZGVyU3RhcnQpO1xuXG4gICAgLy8gVGhlIFNJUCBtZXNzYWdlIGhhcyBub3JtYWxseSBmaW5pc2hlZC5cbiAgICBpZihoZWFkZXJFbmQgPT09IC0yKSB7XG4gICAgICBib2R5U3RhcnQgPSBoZWFkZXJTdGFydCArIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gZGF0YS5pbmRleE9mIHJldHVybmVkIC0xIGR1ZSB0byBhIG1hbGZvcm1lZCBtZXNzYWdlLlxuICAgIGVsc2UgaWYoaGVhZGVyRW5kID09PSAtMSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdtYWxmb3JtZWQgbWVzc2FnZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IHBhcnNlSGVhZGVyKG1lc3NhZ2UsIGRhdGEsIGhlYWRlclN0YXJ0LCBoZWFkZXJFbmQpO1xuXG4gICAgaWYocGFyc2VkICE9PSB0cnVlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IocGFyc2VkLmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoZWFkZXJTdGFydCA9IGhlYWRlckVuZCArIDI7XG4gIH1cblxuICAvKiBSRkMzMjYxIDE4LjMuXG4gICAqIElmIHRoZXJlIGFyZSBhZGRpdGlvbmFsIGJ5dGVzIGluIHRoZSB0cmFuc3BvcnQgcGFja2V0XG4gICAqIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBib2R5LCB0aGV5IE1VU1QgYmUgZGlzY2FyZGVkLlxuICAgKi9cbiAgaWYobWVzc2FnZS5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgbWVzc2FnZS5ib2R5ID0gZGF0YS5zdWJzdHIoYm9keVN0YXJ0LCBjb250ZW50TGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlLmJvZHkgPSBkYXRhLnN1YnN0cmluZyhib2R5U3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuXG5TSVAuUGFyc2VyID0gUGFyc2VyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvUGFyc2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgTWVzc2FnZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyXG4gIE91dGdvaW5nUmVxdWVzdCxcbiAgSW5jb21pbmdNZXNzYWdlLFxuICBJbmNvbWluZ1JlcXVlc3QsXG4gIEluY29taW5nUmVzcG9uc2U7XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZEhlYWRlciAocmVxdWVzdCkge1xuICB2YXIgYWxsb3dVbnJlZ2lzdGVyZWQgPSByZXF1ZXN0LnVhLmNvbmZpZ3VyYXRpb24uaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncztcbiAgdmFyIG9wdGlvblRhZ3MgPSBbXTtcbiAgdmFyIG9wdGlvblRhZ1NldCA9IHt9O1xuXG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuUkVHSVNURVIpIHtcbiAgICBvcHRpb25UYWdzLnB1c2goJ3BhdGgnLCAnZ3J1dScpO1xuICB9IGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiZcbiAgICAgICAgICAgICAocmVxdWVzdC51YS5jb250YWN0LnB1Yl9ncnV1IHx8IHJlcXVlc3QudWEuY29udGFjdC50ZW1wX2dydXUpKSB7XG4gICAgb3B0aW9uVGFncy5wdXNoKCdncnV1Jyk7XG4gIH1cblxuICBpZiAocmVxdWVzdC51YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgIG9wdGlvblRhZ3MucHVzaCgnMTAwcmVsJyk7XG4gIH1cbiAgaWYgKHJlcXVlc3QudWEuY29uZmlndXJhdGlvbi5yZXBsYWNlcyA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgIG9wdGlvblRhZ3MucHVzaCgncmVwbGFjZXMnKTtcbiAgfVxuXG4gIG9wdGlvblRhZ3MucHVzaCgnb3V0Ym91bmQnKTtcblxuICBvcHRpb25UYWdzID0gb3B0aW9uVGFncy5jb25jYXQocmVxdWVzdC51YS5jb25maWd1cmF0aW9uLmV4dHJhU3VwcG9ydGVkKTtcblxuICBvcHRpb25UYWdzID0gb3B0aW9uVGFncy5maWx0ZXIoZnVuY3Rpb24ob3B0aW9uVGFnKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWQgPSBTSVAuQy5PUFRJT05fVEFHU1tvcHRpb25UYWddO1xuICAgIHZhciB1bmlxdWUgPSAhb3B0aW9uVGFnU2V0W29wdGlvblRhZ107XG4gICAgb3B0aW9uVGFnU2V0W29wdGlvblRhZ10gPSB0cnVlO1xuICAgIHJldHVybiAocmVnaXN0ZXJlZCB8fCBhbGxvd1VucmVnaXN0ZXJlZCkgJiYgdW5pcXVlO1xuICB9KTtcblxuICByZXR1cm4gJ1N1cHBvcnRlZDogJyArIG9wdGlvblRhZ3Muam9pbignLCAnKSArICdcXHJcXG4nO1xufVxuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBmb3Igb3V0Z29pbmcgU0lQIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIHJlcXVlc3QgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gcnVyaSByZXF1ZXN0IHVyaVxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGhhdmUgcHJpb3JpdHkgb3ZlciB1YS5jb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gKiA8YnI+XG4gKiAgLSBjc2VxLCBjYWxsX2lkLCBmcm9tX3RhZywgZnJvbV91cmksIGZyb21fZGlzcGxheU5hbWUsIHRvX3VyaSwgdG9fdGFnLCByb3V0ZV9zZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gZXh0cmEgaGVhZGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IFtib2R5XVxuICovXG5PdXRnb2luZ1JlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHJ1cmksIHVhLCBwYXJhbXMsIGV4dHJhSGVhZGVycywgYm9keSkge1xuICB2YXJcbiAgICB0byxcbiAgICBmcm9tLFxuICAgIGNhbGxfaWQsXG4gICAgY3NlcSxcbiAgICB0b191cmksXG4gICAgZnJvbV91cmk7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIC8vIE1hbmRhdG9yeSBwYXJhbWV0ZXJzIGNoZWNrXG4gIGlmKCFtZXRob2QgfHwgIXJ1cmkgfHwgIXVhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNpcG1lc3NhZ2UnKTtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMucnVyaSA9IHJ1cmk7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gKGV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgdGhpcy5zdGF0dXNDb2RlID0gcGFyYW1zLnN0YXR1c19jb2RlO1xuICB0aGlzLnJlYXNvblBocmFzZSA9IHBhcmFtcy5yZWFzb25fcGhyYXNlO1xuXG4gIC8vIEZpbGwgdGhlIENvbW1vbiBTSVAgUmVxdWVzdCBIZWFkZXJzXG5cbiAgLy8gUm91dGVcbiAgaWYgKHBhcmFtcy5yb3V0ZV9zZXQpIHtcbiAgICB0aGlzLnNldEhlYWRlcigncm91dGUnLCBwYXJhbXMucm91dGVfc2V0KTtcbiAgfSBlbHNlIGlmICh1YS5jb25maWd1cmF0aW9uLnVzZVByZWxvYWRlZFJvdXRlKXtcbiAgICB0aGlzLnNldEhlYWRlcigncm91dGUnLCB1YS50cmFuc3BvcnQuc2VydmVyLnNpcF91cmkpO1xuICB9XG5cbiAgLy8gVmlhXG4gIC8vIEVtcHR5IFZpYSBoZWFkZXIuIFdpbGwgYmUgZmlsbGVkIGJ5IHRoZSBjbGllbnQgdHJhbnNhY3Rpb24uXG4gIHRoaXMuc2V0SGVhZGVyKCd2aWEnLCAnJyk7XG5cbiAgLy8gTWF4LUZvcndhcmRzXG4gIHRoaXMuc2V0SGVhZGVyKCdtYXgtZm9yd2FyZHMnLCBTSVAuVUEuQy5NQVhfRk9SV0FSRFMpO1xuXG4gIC8vIFRvXG4gIHRvX3VyaSA9IHBhcmFtcy50b191cmkgfHwgcnVyaTtcbiAgdG8gPSAocGFyYW1zLnRvX2Rpc3BsYXlOYW1lIHx8IHBhcmFtcy50b19kaXNwbGF5TmFtZSA9PT0gMCkgPyAnXCInICsgcGFyYW1zLnRvX2Rpc3BsYXlOYW1lICsgJ1wiICcgOiAnJztcbiAgdG8gKz0gJzwnICsgKHRvX3VyaSAmJiB0b191cmkudG9SYXcgPyB0b191cmkudG9SYXcoKSA6IHRvX3VyaSkgKyAnPic7XG4gIHRvICs9IHBhcmFtcy50b190YWcgPyAnO3RhZz0nICsgcGFyYW1zLnRvX3RhZyA6ICcnO1xuICB0aGlzLnRvID0gbmV3IFNJUC5OYW1lQWRkckhlYWRlci5wYXJzZSh0byk7XG4gIHRoaXMuc2V0SGVhZGVyKCd0bycsIHRvKTtcblxuICAvLyBGcm9tXG4gIGZyb21fdXJpID0gcGFyYW1zLmZyb21fdXJpIHx8IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuICBpZiAocGFyYW1zLmZyb21fZGlzcGxheU5hbWUgfHwgcGFyYW1zLmZyb21fZGlzcGxheU5hbWUgPT09IDApIHtcbiAgICBmcm9tID0gJ1wiJyArIHBhcmFtcy5mcm9tX2Rpc3BsYXlOYW1lICsgJ1wiICc7XG4gIH0gZWxzZSBpZiAodWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZSkge1xuICAgIGZyb20gPSAnXCInICsgdWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZSArICdcIiAnO1xuICB9IGVsc2Uge1xuICAgIGZyb20gPSAnJztcbiAgfVxuICBmcm9tICs9ICc8JyArIChmcm9tX3VyaSAmJiBmcm9tX3VyaS50b1JhdyA/IGZyb21fdXJpLnRvUmF3KCkgOiBmcm9tX3VyaSkgKyAnPjt0YWc9JztcbiAgZnJvbSArPSBwYXJhbXMuZnJvbV90YWcgfHwgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB0aGlzLmZyb20gPSBuZXcgU0lQLk5hbWVBZGRySGVhZGVyLnBhcnNlKGZyb20pO1xuICB0aGlzLnNldEhlYWRlcignZnJvbScsIGZyb20pO1xuXG4gIC8vIENhbGwtSURcbiAgY2FsbF9pZCA9IHBhcmFtcy5jYWxsX2lkIHx8ICh1YS5jb25maWd1cmF0aW9uLnNpcGpzSWQgKyBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMTUpKTtcbiAgdGhpcy5jYWxsX2lkID0gY2FsbF9pZDtcbiAgdGhpcy5zZXRIZWFkZXIoJ2NhbGwtaWQnLCBjYWxsX2lkKTtcblxuICAvLyBDU2VxXG4gIGNzZXEgPSBwYXJhbXMuY3NlcSB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gIHRoaXMuY3NlcSA9IGNzZXE7XG4gIHRoaXMuc2V0SGVhZGVyKCdjc2VxJywgY3NlcSArICcgJyArIG1ldGhvZCk7XG59O1xuXG5PdXRnb2luZ1JlcXVlc3QucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogUmVwbGFjZSB0aGUgdGhlIGdpdmVuIGhlYWRlciBieSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IHZhbHVlIGhlYWRlciB2YWx1ZVxuICAgKi9cbiAgc2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIG5hbWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIGhlYWRlciwgdW5kZWZpbmVkIGlmIGhlYWRlciBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZ2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2V4cCwgaWR4LFxuICAgICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoLFxuICAgICAgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldO1xuXG4gICAgaWYoaGVhZGVyKSB7XG4gICAgICBpZihoZWFkZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlclswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKicgKyBuYW1lICsgJ1xcXFxzKjonLCdpJyk7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaGVhZGVyID0gdGhpcy5leHRyYUhlYWRlcnNbaWR4XTtcbiAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgICByZXR1cm4gaGVhZGVyLnN1YnN0cmluZyhoZWFkZXIuaW5kZXhPZignOicpKzEpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWFkZXIvcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFsbCB0aGUgaGVhZGVycyBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAqL1xuICBnZXRIZWFkZXJzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkeCwgbGVuZ3RoLCByZWdleHAsXG4gICAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0sXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgIGlmKGhlYWRlcikge1xuICAgICAgbGVuZ3RoID0gaGVhZGVyLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICByZXN1bHQucHVzaChoZWFkZXJbaWR4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0aGlzLmV4dHJhSGVhZGVycy5sZW5ndGg7XG4gICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqOicsJ2knKTtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLmV4dHJhSGVhZGVyc1tpZHhdO1xuICAgICAgICBpZiAocmVnZXhwLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGhlYWRlci5zdWJzdHJpbmcoaGVhZGVyLmluZGV4T2YoJzonKSsxKS50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBleGlzdGVuY2Ugb2YgdGhlIGdpdmVuIGhlYWRlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaGFzSGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2V4cCwgaWR4LFxuICAgICAgbGVuZ3RoID0gdGhpcy5leHRyYUhlYWRlcnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyonICsgbmFtZSArICdcXFxccyo6JywnaScpO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmIChyZWdleHAudGVzdCh0aGlzLmV4dHJhSGVhZGVyc1tpZHhdKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbXNnID0gJycsIGhlYWRlciwgbGVuZ3RoLCBpZHg7XG5cbiAgICBtc2cgKz0gdGhpcy5tZXRob2QgKyAnICcgKyAodGhpcy5ydXJpLnRvUmF3ID8gdGhpcy5ydXJpLnRvUmF3KCkgOiB0aGlzLnJ1cmkpICsgJyBTSVAvMi4wXFxyXFxuJztcblxuICAgIGZvciAoaGVhZGVyIGluIHRoaXMuaGVhZGVycykge1xuICAgICAgbGVuZ3RoID0gdGhpcy5oZWFkZXJzW2hlYWRlcl0ubGVuZ3RoO1xuICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIG1zZyArPSBoZWFkZXIgKyAnOiAnICsgdGhpcy5oZWFkZXJzW2hlYWRlcl1baWR4XSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHRoaXMuZXh0cmFIZWFkZXJzLmxlbmd0aDtcbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIG1zZyArPSB0aGlzLmV4dHJhSGVhZGVyc1tpZHhdLnRyaW0oKSArJ1xcclxcbic7XG4gICAgfVxuXG4gICAgbXNnICs9IGdldFN1cHBvcnRlZEhlYWRlcih0aGlzKTtcbiAgICBtc2cgKz0gJ1VzZXItQWdlbnQ6ICcgKyB0aGlzLnVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nICsnXFxyXFxuJztcblxuICAgIGlmKHRoaXMuYm9keSkge1xuICAgICAgbGVuZ3RoID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aCh0aGlzLmJvZHkpO1xuICAgICAgbXNnICs9ICdDb250ZW50LUxlbmd0aDogJyArIGxlbmd0aCArICdcXHJcXG5cXHJcXG4nO1xuICAgICAgbXNnICs9IHRoaXMuYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnICs9ICdDb250ZW50LUxlbmd0aDogMFxcclxcblxcclxcbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1zZztcbiAgfVxufTtcblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgZm9yIGluY29taW5nIFNJUCBtZXNzYWdlLlxuICovXG5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbigpe1xuICB0aGlzLmRhdGEgPSBudWxsO1xuICB0aGlzLmhlYWRlcnMgPSBudWxsO1xuICB0aGlzLm1ldGhvZCA9ICBudWxsO1xuICB0aGlzLnZpYSA9IG51bGw7XG4gIHRoaXMudmlhX2JyYW5jaCA9IG51bGw7XG4gIHRoaXMuY2FsbF9pZCA9IG51bGw7XG4gIHRoaXMuY3NlcSA9IG51bGw7XG4gIHRoaXMuZnJvbSA9IG51bGw7XG4gIHRoaXMuZnJvbV90YWcgPSBudWxsO1xuICB0aGlzLnRvID0gbnVsbDtcbiAgdGhpcy50b190YWcgPSBudWxsO1xuICB0aGlzLmJvZHkgPSBudWxsO1xufTtcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICogSW5zZXJ0IGEgaGVhZGVyIG9mIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZSBpbnRvIHRoZSBsYXN0IHBvc2l0aW9uIG9mIHRoZVxuICAqIGhlYWRlciBhcnJheS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBoZWFkZXIgdmFsdWVcbiAgKi9cbiAgYWRkSGVhZGVyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBoZWFkZXIgPSB7IHJhdzogdmFsdWUgfTtcblxuICAgIG5hbWUgPSBTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpO1xuXG4gICAgaWYodGhpcy5oZWFkZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0ucHVzaChoZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSBbaGVhZGVyXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBuYW1lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIHNwZWNpZmllZCBoZWFkZXIsIG51bGwgaWYgaGVhZGVyIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXRIZWFkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldO1xuXG4gICAgaWYoaGVhZGVyKSB7XG4gICAgICBpZihoZWFkZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlclswXS5yYXc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVhZGVyL3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBhbGwgdGhlIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgKi9cbiAgZ2V0SGVhZGVyczogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZHgsIGxlbmd0aCxcbiAgICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYoIWhlYWRlcikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IGhlYWRlci5sZW5ndGg7XG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICByZXN1bHQucHVzaChoZWFkZXJbaWR4XS5yYXcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBoZWFkZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGhlYWRlciB3aXRoIGdpdmVuIG5hbWUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGhhc0hlYWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybih0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0pID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgb24gdGhlIGdpdmVuIGluZGV4LlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGhlYWRlciBuYW1lXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtpZHg9MF0gaGVhZGVyIGluZGV4XG4gICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IFBhcnNlZCBoZWFkZXIgb2JqZWN0LCB1bmRlZmluZWQgaWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCBvciBpbiBjYXNlIG9mIGEgcGFyc2luZyBlcnJvci5cbiAgKi9cbiAgcGFyc2VIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIGlkeCkge1xuICAgIHZhciBoZWFkZXIsIHZhbHVlLCBwYXJzZWQ7XG5cbiAgICBuYW1lID0gU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKTtcblxuICAgIGlkeCA9IGlkeCB8fCAwO1xuXG4gICAgaWYoIXRoaXMuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdoZWFkZXIgXCInICsgbmFtZSArICdcIiBub3QgcHJlc2VudCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZihpZHggPj0gdGhpcy5oZWFkZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdub3Qgc28gbWFueSBcIicgKyBuYW1lICsgJ1wiIGhlYWRlcnMgcHJlc2VudCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhlYWRlciA9IHRoaXMuaGVhZGVyc1tuYW1lXVtpZHhdO1xuICAgIHZhbHVlID0gaGVhZGVyLnJhdztcblxuICAgIGlmKGhlYWRlci5wYXJzZWQpIHtcbiAgICAgIHJldHVybiBoZWFkZXIucGFyc2VkO1xuICAgIH1cblxuICAgIC8vc3Vic3RpdHV0ZSAnLScgYnkgJ18nIGZvciBncmFtbWFyIHJ1bGUgbWF0Y2hpbmcuXG4gICAgcGFyc2VkID0gU0lQLkdyYW1tYXIucGFyc2UodmFsdWUsIG5hbWUucmVwbGFjZSgvLS9nLCAnXycpKTtcblxuICAgIGlmKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXS5zcGxpY2UoaWR4LCAxKTsgLy9kZWxldGUgZnJvbSBoZWFkZXJzXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdlcnJvciBwYXJzaW5nIFwiJyArIG5hbWUgKyAnXCIgaGVhZGVyIGZpZWxkIHdpdGggdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNZXNzYWdlIEhlYWRlciBhdHRyaWJ1dGUgc2VsZWN0b3IuIEFsaWFzIG9mIHBhcnNlSGVhZGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBoZWFkZXIgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2lkeD0wXSBoZWFkZXIgaW5kZXhcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IFBhcnNlZCBoZWFkZXIgb2JqZWN0LCB1bmRlZmluZWQgaWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCBvciBpbiBjYXNlIG9mIGEgcGFyc2luZyBlcnJvci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbWVzc2FnZS5zKCd2aWEnLDMpLnBvcnRcbiAgICovXG4gIHM6IGZ1bmN0aW9uKG5hbWUsIGlkeCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlSGVhZGVyKG5hbWUsIGlkeCk7XG4gIH0sXG5cbiAgLyoqXG4gICogUmVwbGFjZSB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGhlYWRlciBieSB0aGUgdmFsdWUuXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgaGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgaGVhZGVyIHZhbHVlXG4gICovXG4gIHNldEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaGVhZGVyID0geyByYXc6IHZhbHVlIH07XG4gICAgdGhpcy5oZWFkZXJzW1NJUC5VdGlscy5oZWFkZXJpemUobmFtZSldID0gW2hlYWRlcl07XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQGF1Z21lbnRzIEluY29taW5nTWVzc2FnZVxuICogQGNsYXNzIENsYXNzIGZvciBpbmNvbWluZyBTSVAgcmVxdWVzdC5cbiAqL1xuSW5jb21pbmdSZXF1ZXN0ID0gZnVuY3Rpb24odWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zaXBtZXNzYWdlJyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5oZWFkZXJzID0ge307XG4gIHRoaXMucnVyaSA9IG51bGw7XG4gIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgdGhpcy5zZXJ2ZXJfdHJhbnNhY3Rpb24gPSBudWxsO1xufTtcbkluY29taW5nUmVxdWVzdC5wcm90b3R5cGUgPSBuZXcgSW5jb21pbmdNZXNzYWdlKCk7XG5cbi8qKlxuKiBTdGF0ZWZ1bCByZXBseS5cbiogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgc3RhdHVzIGNvZGVcbiogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiByZWFzb24gcGhyYXNlXG4qIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIGV4dHJhIGhlYWRlcnNcbiogQHBhcmFtIHtTdHJpbmd9IGJvZHkgYm9keVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBvblN1Y2Nlc3MgY2FsbGJhY2tcbiogQHBhcmFtIHtGdW5jdGlvbn0gW29uRmFpbHVyZV0gb25GYWlsdXJlIGNhbGxiYWNrXG4qL1xuSW5jb21pbmdSZXF1ZXN0LnByb3RvdHlwZS5yZXBseSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgZXh0cmFIZWFkZXJzLCBib2R5LCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICB2YXIgcnIsIHZpYXMsIGxlbmd0aCwgaWR4LCByZXNwb25zZSxcbiAgICB0byA9IHRoaXMuZ2V0SGVhZGVyKCdUbycpLFxuICAgIHIgPSAwLFxuICAgIHYgPSAwO1xuXG4gIHJlc3BvbnNlID0gU0lQLlV0aWxzLmJ1aWxkU3RhdHVzTGluZShjb2RlLCByZWFzb24pO1xuICBleHRyYUhlYWRlcnMgPSAoZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gIGlmKHRoaXMubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiYgY29kZSA+IDEwMCAmJiBjb2RlIDw9IDIwMCkge1xuICAgIHJyID0gdGhpcy5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKTtcbiAgICBsZW5ndGggPSByci5sZW5ndGg7XG5cbiAgICBmb3IocjsgciA8IGxlbmd0aDsgcisrKSB7XG4gICAgICByZXNwb25zZSArPSAnUmVjb3JkLVJvdXRlOiAnICsgcnJbcl0gKyAnXFxyXFxuJztcbiAgICB9XG4gIH1cblxuICB2aWFzID0gdGhpcy5nZXRIZWFkZXJzKCd2aWEnKTtcbiAgbGVuZ3RoID0gdmlhcy5sZW5ndGg7XG5cbiAgZm9yKHY7IHYgPCBsZW5ndGg7IHYrKykge1xuICAgIHJlc3BvbnNlICs9ICdWaWE6ICcgKyB2aWFzW3ZdICsgJ1xcclxcbic7XG4gIH1cblxuICBpZighdGhpcy50b190YWcgJiYgY29kZSA+IDEwMCkge1xuICAgIHRvICs9ICc7dGFnPScgKyBTSVAuVXRpbHMubmV3VGFnKCk7XG4gIH0gZWxzZSBpZih0aGlzLnRvX3RhZyAmJiAhdGhpcy5zKCd0bycpLmhhc1BhcmFtKCd0YWcnKSkge1xuICAgIHRvICs9ICc7dGFnPScgKyB0aGlzLnRvX3RhZztcbiAgfVxuXG4gIHJlc3BvbnNlICs9ICdUbzogJyArIHRvICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdGcm9tOiAnICsgdGhpcy5nZXRIZWFkZXIoJ0Zyb20nKSArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ2FsbC1JRDogJyArIHRoaXMuY2FsbF9pZCArICdcXHJcXG4nO1xuICByZXNwb25zZSArPSAnQ1NlcTogJyArIHRoaXMuY3NlcSArICcgJyArIHRoaXMubWV0aG9kICsgJ1xcclxcbic7XG5cbiAgbGVuZ3RoID0gZXh0cmFIZWFkZXJzLmxlbmd0aDtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgcmVzcG9uc2UgKz0gZXh0cmFIZWFkZXJzW2lkeF0udHJpbSgpICsnXFxyXFxuJztcbiAgfVxuXG4gIHJlc3BvbnNlICs9IGdldFN1cHBvcnRlZEhlYWRlcih0aGlzKTtcbiAgcmVzcG9uc2UgKz0gJ1VzZXItQWdlbnQ6ICcgKyB0aGlzLnVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nICsnXFxyXFxuJztcblxuICBpZihib2R5KSB7XG4gICAgbGVuZ3RoID0gU0lQLlV0aWxzLnN0cl91dGY4X2xlbmd0aChib2R5KTtcbiAgICByZXNwb25zZSArPSAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHBcXHJcXG4nO1xuICAgIHJlc3BvbnNlICs9ICdDb250ZW50LUxlbmd0aDogJyArIGxlbmd0aCArICdcXHJcXG5cXHJcXG4nO1xuICAgIHJlc3BvbnNlICs9IGJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgMCArICdcXHJcXG5cXHJcXG4nO1xuICB9XG5cbiAgdGhpcy5zZXJ2ZXJfdHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKGNvZGUsIHJlc3BvbnNlKS50aGVuKG9uU3VjY2Vzcywgb25GYWlsdXJlKTtcblxuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG4vKipcbiogU3RhdGVsZXNzIHJlcGx5LlxuKiBAcGFyYW0ge051bWJlcn0gY29kZSBzdGF0dXMgY29kZVxuKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIHJlYXNvbiBwaHJhc2VcbiovXG5JbmNvbWluZ1JlcXVlc3QucHJvdG90eXBlLnJlcGx5X3NsID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIHZhciB0bywgcmVzcG9uc2UsXG4gICAgdiA9IDAsXG4gICAgdmlhcyA9IHRoaXMuZ2V0SGVhZGVycygndmlhJyksXG4gICAgbGVuZ3RoID0gdmlhcy5sZW5ndGg7XG5cbiAgcmVzcG9uc2UgPSBTSVAuVXRpbHMuYnVpbGRTdGF0dXNMaW5lKGNvZGUsIHJlYXNvbik7XG5cbiAgZm9yKHY7IHYgPCBsZW5ndGg7IHYrKykge1xuICAgIHJlc3BvbnNlICs9ICdWaWE6ICcgKyB2aWFzW3ZdICsgJ1xcclxcbic7XG4gIH1cblxuICB0byA9IHRoaXMuZ2V0SGVhZGVyKCdUbycpO1xuXG4gIGlmKCF0aGlzLnRvX3RhZyAmJiBjb2RlID4gMTAwKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIFNJUC5VdGlscy5uZXdUYWcoKTtcbiAgfSBlbHNlIGlmKHRoaXMudG9fdGFnICYmICF0aGlzLnMoJ3RvJykuaGFzUGFyYW0oJ3RhZycpKSB7XG4gICAgdG8gKz0gJzt0YWc9JyArIHRoaXMudG9fdGFnO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gJ1RvOiAnICsgdG8gKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0Zyb206ICcgKyB0aGlzLmdldEhlYWRlcignRnJvbScpICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDYWxsLUlEOiAnICsgdGhpcy5jYWxsX2lkICsgJ1xcclxcbic7XG4gIHJlc3BvbnNlICs9ICdDU2VxOiAnICsgdGhpcy5jc2VxICsgJyAnICsgdGhpcy5tZXRob2QgKyAnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ1VzZXItQWdlbnQ6ICcgKyB0aGlzLnVhLmNvbmZpZ3VyYXRpb24udXNlckFnZW50U3RyaW5nICsnXFxyXFxuJztcbiAgcmVzcG9uc2UgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAnICsgMCArICdcXHJcXG5cXHJcXG4nO1xuXG4gIHRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpO1xufTtcblxuXG4vKipcbiAqIEBhdWdtZW50cyBJbmNvbWluZ01lc3NhZ2VcbiAqIEBjbGFzcyBDbGFzcyBmb3IgaW5jb21pbmcgU0lQIHJlc3BvbnNlLlxuICovXG5JbmNvbWluZ1Jlc3BvbnNlID0gZnVuY3Rpb24odWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zaXBtZXNzYWdlJyk7XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuICB0aGlzLnN0YXR1c19jb2RlID0gbnVsbDtcbiAgdGhpcy5yZWFzb25fcGhyYXNlID0gbnVsbDtcbn07XG5JbmNvbWluZ1Jlc3BvbnNlLnByb3RvdHlwZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2UoKTtcblxuU0lQLk91dGdvaW5nUmVxdWVzdCA9IE91dGdvaW5nUmVxdWVzdDtcblNJUC5JbmNvbWluZ1JlcXVlc3QgPSBJbmNvbWluZ1JlcXVlc3Q7XG5TSVAuSW5jb21pbmdSZXNwb25zZSA9IEluY29taW5nUmVzcG9uc2U7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TSVBNZXNzYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gMjIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgVVJJXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgVVJJLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NoZW1lXVxuICogQHBhcmFtIHtTdHJpbmd9IFt1c2VyXVxuICogQHBhcmFtIHtTdHJpbmd9IGhvc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcG9ydF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc11cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIFVSSTtcblxuVVJJID0gZnVuY3Rpb24oc2NoZW1lLCB1c2VyLCBob3N0LCBwb3J0LCBwYXJhbWV0ZXJzLCBoZWFkZXJzKSB7XG4gIHZhciBwYXJhbSwgaGVhZGVyLCByYXcsIG5vcm1hbDtcblxuICAvLyBDaGVja3NcbiAgaWYoIWhvc3QpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIG9yIGludmFsaWQgXCJob3N0XCIgcGFyYW1ldGVyJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHBhcmFtZXRlcnNcbiAgc2NoZW1lID0gc2NoZW1lIHx8IFNJUC5DLlNJUDtcbiAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gIHRoaXMuaGVhZGVycyA9IHt9O1xuXG4gIGZvciAocGFyYW0gaW4gcGFyYW1ldGVycykge1xuICAgIHRoaXMuc2V0UGFyYW0ocGFyYW0sIHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgfVxuXG4gIGZvciAoaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICB0aGlzLnNldEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gIH1cblxuICAvLyBSYXcgVVJJXG4gIHJhdyA9IHtcbiAgICBzY2hlbWU6IHNjaGVtZSxcbiAgICB1c2VyOiB1c2VyLFxuICAgIGhvc3Q6IGhvc3QsXG4gICAgcG9ydDogcG9ydFxuICB9O1xuXG4gIC8vIE5vcm1hbGl6ZWQgVVJJXG4gIG5vcm1hbCA9IHtcbiAgICBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLFxuICAgIHVzZXI6IHVzZXIsXG4gICAgaG9zdDogaG9zdC50b0xvd2VyQ2FzZSgpLFxuICAgIHBvcnQ6IHBvcnRcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgX25vcm1hbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbDsgfVxuICAgIH0sXG5cbiAgICBfcmF3OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmF3OyB9XG4gICAgfSxcblxuICAgIHNjaGVtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbC5zY2hlbWU7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJhdy5zY2hlbWUgPSB2YWx1ZTtcbiAgICAgICAgbm9ybWFsLnNjaGVtZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVzZXI6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWwudXNlcjsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgbm9ybWFsLnVzZXIgPSByYXcudXNlciA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBob3N0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLmhvc3Q7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJhdy5ob3N0ID0gdmFsdWU7XG4gICAgICAgIG5vcm1hbC5ob3N0ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYW9yOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnVzZXIgKyAnQCcgKyBub3JtYWwuaG9zdDsgfVxuICAgIH0sXG5cbiAgICBwb3J0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsLnBvcnQ7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG5vcm1hbC5wb3J0ID0gcmF3LnBvcnQgPSB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogKHBhcnNlSW50KHZhbHVlLDEwKSB8fCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuVVJJLnByb3RvdHlwZSA9IHtcbiAgc2V0UGFyYW06IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkgPyBudWxsIDogdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQYXJhbTogZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gIH0sXG5cbiAgaGFzUGFyYW06IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmKGtleSkge1xuICAgICAgcmV0dXJuICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoa2V5LnRvTG93ZXJDYXNlKCkpICYmIHRydWUpIHx8IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBkZWxldGVQYXJhbTogZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYXJQYXJhbXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuICB9LFxuXG4gIHNldEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmhlYWRlcnNbU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKV0gPSAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gIH0sXG5cbiAgZ2V0SGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1tTSVAuVXRpbHMuaGVhZGVyaXplKG5hbWUpXTtcbiAgICB9XG4gIH0sXG5cbiAgaGFzSGVhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYobmFtZSkge1xuICAgICAgcmV0dXJuICh0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoU0lQLlV0aWxzLmhlYWRlcml6ZShuYW1lKSkgJiYgdHJ1ZSkgfHwgZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZUhlYWRlcjogZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGhlYWRlciA9IFNJUC5VdGlscy5oZWFkZXJpemUoaGVhZGVyKTtcbiAgICBpZih0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLmhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmhlYWRlcnNbaGVhZGVyXTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgY2xlYXJIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBVUkkoXG4gICAgICB0aGlzLl9yYXcuc2NoZW1lLFxuICAgICAgdGhpcy5fcmF3LnVzZXIsXG4gICAgICB0aGlzLl9yYXcuaG9zdCxcbiAgICAgIHRoaXMuX3Jhdy5wb3J0LFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpKSxcbiAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKSkpO1xuICB9LFxuXG4gIHRvUmF3OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fcmF3KTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nKHRoaXMuX25vcm1hbCk7XG4gIH0sXG5cbiAgX3RvU3RyaW5nOiBmdW5jdGlvbih1cmkpIHtcbiAgICB2YXIgaGVhZGVyLCBwYXJhbWV0ZXIsIGlkeCwgdXJpU3RyaW5nLCBoZWFkZXJzID0gW107XG5cbiAgICB1cmlTdHJpbmcgID0gdXJpLnNjaGVtZSArICc6JztcbiAgICAvLyBhZGQgc2xhc2hlcyBpZiBpdCdzIG5vdCBhIHNpcChzKSBVUklcbiAgICBpZiAoIXVyaS5zY2hlbWUudG9Mb3dlckNhc2UoKS5tYXRjaChcIl5zaXBzPyRcIikpIHtcbiAgICAgIHVyaVN0cmluZyArPSBcIi8vXCI7XG4gICAgfVxuICAgIGlmICh1cmkudXNlcikge1xuICAgICAgdXJpU3RyaW5nICs9IFNJUC5VdGlscy5lc2NhcGVVc2VyKHVyaS51c2VyKSArICdAJztcbiAgICB9XG4gICAgdXJpU3RyaW5nICs9IHVyaS5ob3N0O1xuICAgIGlmICh1cmkucG9ydCB8fCB1cmkucG9ydCA9PT0gMCkge1xuICAgICAgdXJpU3RyaW5nICs9ICc6JyArIHVyaS5wb3J0O1xuICAgIH1cblxuICAgIGZvciAocGFyYW1ldGVyIGluIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgdXJpU3RyaW5nICs9ICc7JyArIHBhcmFtZXRlcjtcblxuICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgIHVyaVN0cmluZyArPSAnPScrIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcihoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICBmb3IoaWR4IGluIHRoaXMuaGVhZGVyc1toZWFkZXJdKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChoZWFkZXIgKyAnPScgKyB0aGlzLmhlYWRlcnNbaGVhZGVyXVtpZHhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB1cmlTdHJpbmcgKz0gJz8nICsgaGVhZGVycy5qb2luKCcmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaVN0cmluZztcbiAgfVxufTtcblxuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIGEgU0lQLlVSSSBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWZcbiAgKiBpdCBpcyBhbiBpbnZhbGlkIFVSSS5cbiAgKiBAcHVibGljXG4gICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICAqL1xuVVJJLnBhcnNlID0gZnVuY3Rpb24odXJpKSB7XG4gIHVyaSA9IFNJUC5HcmFtbWFyLnBhcnNlKHVyaSwnU0lQX1VSSScpO1xuXG4gIGlmICh1cmkgIT09IC0xKSB7XG4gICAgcmV0dXJuIHVyaTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG5TSVAuVVJJID0gVVJJO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvVVJJLmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgTmFtZUFkZHJIZWFkZXJcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIE5hbWUgQWRkcmVzcyBTSVAgaGVhZGVyLlxuICpcbiAqIEBwYXJhbSB7U0lQLlVSSX0gdXJpXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Rpc3BsYXlOYW1lXVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgTmFtZUFkZHJIZWFkZXI7XG5cbk5hbWVBZGRySGVhZGVyID0gZnVuY3Rpb24odXJpLCBkaXNwbGF5TmFtZSwgcGFyYW1ldGVycykge1xuICB2YXIgcGFyYW07XG5cbiAgLy8gQ2hlY2tzXG4gIGlmKCF1cmkgfHwgISh1cmkgaW5zdGFuY2VvZiBTSVAuVVJJKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBcInVyaVwiIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzXG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcblxuICBmb3IgKHBhcmFtIGluIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNldFBhcmFtKHBhcmFtLCBwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgZnJpZW5kbHlOYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5TmFtZSB8fCB1cmkuYW9yOyB9XG4gICAgfSxcblxuICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGlzcGxheU5hbWU7IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGRpc3BsYXlOYW1lID0gKHZhbHVlID09PSAwKSA/ICcwJyA6IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuTmFtZUFkZHJIZWFkZXIucHJvdG90eXBlID0ge1xuICBzZXRQYXJhbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZihrZXkpIHtcbiAgICAgIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkgPyBudWxsIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG4gIGdldFBhcmFtOiBTSVAuVVJJLnByb3RvdHlwZS5nZXRQYXJhbSxcbiAgaGFzUGFyYW06IFNJUC5VUkkucHJvdG90eXBlLmhhc1BhcmFtLFxuICBkZWxldGVQYXJhbTogU0lQLlVSSS5wcm90b3R5cGUuZGVsZXRlUGFyYW0sXG4gIGNsZWFyUGFyYW1zOiBTSVAuVVJJLnByb3RvdHlwZS5jbGVhclBhcmFtcyxcblxuICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lQWRkckhlYWRlcihcbiAgICAgIHRoaXMudXJpLmNsb25lKCksXG4gICAgICB0aGlzLmRpc3BsYXlOYW1lLFxuICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpKSk7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5LCBwYXJhbWV0ZXI7XG5cbiAgICBib2R5ICA9ICh0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMuZGlzcGxheU5hbWUgPT09IDApID8gJ1wiJyArIHRoaXMuZGlzcGxheU5hbWUgKyAnXCIgJyA6ICcnO1xuICAgIGJvZHkgKz0gJzwnICsgdGhpcy51cmkudG9TdHJpbmcoKSArICc+JztcblxuICAgIGZvciAocGFyYW1ldGVyIGluIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgYm9keSArPSAnOycgKyBwYXJhbWV0ZXI7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXSAhPT0gbnVsbCkge1xuICAgICAgICBib2R5ICs9ICc9JysgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn07XG5cblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyBhIFNJUC5OYW1lQWRkckhlYWRlciBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWZcbiAgKiBpdCBpcyBhbiBpbnZhbGlkIE5hbWVBZGRySGVhZGVyLlxuICAqIEBwdWJsaWNcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZV9hZGRyX2hlYWRlclxuICAqL1xuTmFtZUFkZHJIZWFkZXIucGFyc2UgPSBmdW5jdGlvbihuYW1lX2FkZHJfaGVhZGVyKSB7XG4gIG5hbWVfYWRkcl9oZWFkZXIgPSBTSVAuR3JhbW1hci5wYXJzZShuYW1lX2FkZHJfaGVhZGVyLCdOYW1lX0FkZHJfSGVhZGVyJyk7XG5cbiAgaWYgKG5hbWVfYWRkcl9oZWFkZXIgIT09IC0xKSB7XG4gICAgcmV0dXJuIG5hbWVfYWRkcl9oZWFkZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuU0lQLk5hbWVBZGRySGVhZGVyID0gTmFtZUFkZHJIZWFkZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9OYW1lQWRkckhlYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogU0lQIFRyYW5zYWN0aW9ucyBtb2R1bGUuXG4gKiBAYXVnbWVudHMgU0lQXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyXG4gIEMgPSB7XG4gICAgLy8gVHJhbnNhY3Rpb24gc3RhdGVzXG4gICAgU1RBVFVTX1RSWUlORzogICAgIDEsXG4gICAgU1RBVFVTX1BST0NFRURJTkc6IDIsXG4gICAgU1RBVFVTX0NBTExJTkc6ICAgIDMsXG4gICAgU1RBVFVTX0FDQ0VQVEVEOiAgIDQsXG4gICAgU1RBVFVTX0NPTVBMRVRFRDogIDUsXG4gICAgU1RBVFVTX1RFUk1JTkFURUQ6IDYsXG4gICAgU1RBVFVTX0NPTkZJUk1FRDogIDcsXG5cbiAgICAvLyBUcmFuc2FjdGlvbiB0eXBlc1xuICAgIE5PTl9JTlZJVEVfQ0xJRU5UOiAnbmljdCcsXG4gICAgTk9OX0lOVklURV9TRVJWRVI6ICduaXN0JyxcbiAgICBJTlZJVEVfQ0xJRU5UOiAnaWN0JyxcbiAgICBJTlZJVEVfU0VSVkVSOiAnaXN0J1xuICB9O1xuXG5mdW5jdGlvbiBidWlsZFZpYUhlYWRlciAocmVxdWVzdF9zZW5kZXIsIHRyYW5zcG9ydCwgaWQpIHtcbiAgdmFyIHZpYTtcbiAgdmlhID0gJ1NJUC8yLjAvJyArIChyZXF1ZXN0X3NlbmRlci51YS5jb25maWd1cmF0aW9uLmhhY2tWaWFUY3AgPyAnVENQJyA6IHRyYW5zcG9ydC5zZXJ2ZXIuc2NoZW1lKTtcbiAgdmlhICs9ICcgJyArIHJlcXVlc3Rfc2VuZGVyLnVhLmNvbmZpZ3VyYXRpb24udmlhSG9zdCArICc7YnJhbmNoPScgKyBpZDtcbiAgaWYgKHJlcXVlc3Rfc2VuZGVyLnVhLmNvbmZpZ3VyYXRpb24uZm9yY2VScG9ydCkge1xuICAgIHZpYSArPSAnO3Jwb3J0JztcbiAgfVxuICByZXR1cm4gdmlhO1xufVxuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIE5vbiBJbnZpdGUgQ2xpZW50IFRyYW5zYWN0aW9uXG4qIEBwYXJhbSB7U0lQLlJlcXVlc3RTZW5kZXJ9IHJlcXVlc3Rfc2VuZGVyXG4qIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuKi9cbnZhciBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3Rfc2VuZGVyLCByZXF1ZXN0LCB0cmFuc3BvcnQpIHtcbiAgdmFyIHZpYTtcblxuICB0aGlzLnR5cGUgPSBDLk5PTl9JTlZJVEVfQ0xJRU5UO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy5pZCA9ICd6OWhHNGJLJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlciA9IHJlcXVlc3Rfc2VuZGVyO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIHRoaXMubG9nZ2VyID0gcmVxdWVzdF9zZW5kZXIudWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24ubmljdCcsIHRoaXMuaWQpO1xuXG4gIHZpYSA9IGJ1aWxkVmlhSGVhZGVyKHJlcXVlc3Rfc2VuZGVyLCB0cmFuc3BvcnQsIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKCd2aWEnLCB2aWEpO1xuXG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHIgPSB0aGlzO1xuXG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RSWUlORyk7XG4gIHRoaXMuRiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9GLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0YpO1xuXG4gIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMucmVxdWVzdCkpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5sb2dnZXIubG9nKCd0cmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQsIGRlbGV0aW5nIG5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5GKTtcbiAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5LKTtcbiAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfVEVSTUlOQVRFRCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbn07XG5cbk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9GID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgRiBleHBpcmVkIGZvciBub24tSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci5vblJlcXVlc3RUaW1lb3V0KCk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy5yZXF1ZXN0X3NlbmRlci51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyXG4gICAgdHIgPSB0aGlzLFxuICAgIHN0YXR1c19jb2RlID0gcmVzcG9uc2Uuc3RhdHVzX2NvZGU7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPCAyMDApIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1BST0NFRURJTkcpO1xuICAgICAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NPTVBMRVRFRCk7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuRik7XG5cbiAgICAgICAgaWYoc3RhdHVzX2NvZGUgPT09IDQwOCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuSyA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9LLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ09NUExFVEVEOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIEludml0ZSBDbGllbnQgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuUmVxdWVzdFNlbmRlcn0gcmVxdWVzdF9zZW5kZXJcbiogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0XG4qL1xudmFyIEludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdF9zZW5kZXIsIHJlcXVlc3QsIHRyYW5zcG9ydCkge1xuICB2YXIgdmlhLFxuICAgIHRyID0gdGhpcztcblxuICB0aGlzLnR5cGUgPSBDLklOVklURV9DTElFTlQ7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLmlkID0gJ3o5aEc0YksnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyID0gcmVxdWVzdF9zZW5kZXI7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgdGhpcy5sb2dnZXIgPSByZXF1ZXN0X3NlbmRlci51YS5nZXRMb2dnZXIoJ3NpcC50cmFuc2FjdGlvbi5pY3QnLCB0aGlzLmlkKTtcblxuICB2aWEgPSBidWlsZFZpYUhlYWRlcihyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCB0aGlzLmlkKTtcbiAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcigndmlhJywgdmlhKTtcblxuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLm5ld1RyYW5zYWN0aW9uKHRoaXMpO1xuXG4gIC8vIEFkZCB0aGUgY2FuY2VsIHByb3BlcnR5IHRvIHRoZSByZXF1ZXN0LlxuICAvL1dpbGwgYmUgY2FsbGVkIGZyb20gdGhlIHJlcXVlc3QgaW5zdGFuY2UsIG5vdCB0aGUgdHJhbnNhY3Rpb24gaXRzZWxmLlxuICB0aGlzLnJlcXVlc3QuY2FuY2VsID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgdHIuY2FuY2VsX3JlcXVlc3QodHIsIHJlYXNvbik7XG4gIH07XG59O1xuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHIgPSB0aGlzO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19DQUxMSU5HKTtcbiAgdGhpcy5CID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0IuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfQik7XG5cbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5yZXF1ZXN0KSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZGVsZXRpbmcgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuRCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuTSk7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcblxuICBpZiAodGhpcy5zdGF0ZSAhPT0gQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuLy8gUkZDIDYwMjYgNy4yXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfTSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIE0gZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkIpO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG4vLyBSRkMgMzI2MSAxNy4xLjFcbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9CID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgQiBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQ0FMTElORykge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgIHRoaXMucmVxdWVzdF9zZW5kZXIub25SZXF1ZXN0VGltZW91dCgpO1xuICB9XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfRCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEQgZXhwaXJlZCBmb3IgSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLnVhLmRlc3Ryb3lUcmFuc2FjdGlvbih0aGlzKTtcbn07XG5cbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kQUNLID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIHRyID0gdGhpcztcblxuICB0aGlzLmFjayA9ICdBQ0sgJyArIHRoaXMucmVxdWVzdC5ydXJpICsgJyBTSVAvMi4wXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ1ZpYTogJyArIHRoaXMucmVxdWVzdC5oZWFkZXJzWydWaWEnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG5cbiAgaWYodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10pIHtcbiAgICB0aGlzLmFjayArPSAnUm91dGU6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snUm91dGUnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIH1cblxuICB0aGlzLmFjayArPSAnVG86ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3RvJykgKyAnXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0Zyb206ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snRnJvbSddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0NhbGwtSUQ6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ2FsbC1JRCddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0NvbnRlbnQtTGVuZ3RoOiAwXFxyXFxuJztcbiAgdGhpcy5hY2sgKz0gJ0NTZXE6ICcgKyB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ1NlcSddLnRvU3RyaW5nKCkuc3BsaXQoJyAnKVswXTtcbiAgdGhpcy5hY2sgKz0gJyBBQ0tcXHJcXG5cXHJcXG4nO1xuXG4gIHRoaXMuRCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9ELmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0QpO1xuXG4gIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5hY2spO1xufTtcblxuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLmNhbmNlbF9yZXF1ZXN0ID0gZnVuY3Rpb24odHIsIHJlYXNvbikge1xuICB2YXIgcmVxdWVzdCA9IHRyLnJlcXVlc3Q7XG5cbiAgdGhpcy5jYW5jZWwgPSBTSVAuQy5DQU5DRUwgKyAnICcgKyByZXF1ZXN0LnJ1cmkgKyAnIFNJUC8yLjBcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnVmlhOiAnICsgcmVxdWVzdC5oZWFkZXJzWydWaWEnXS50b1N0cmluZygpICsgJ1xcclxcbic7XG5cbiAgaWYodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10pIHtcbiAgICB0aGlzLmNhbmNlbCArPSAnUm91dGU6ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ1JvdXRlJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB9XG5cbiAgdGhpcy5jYW5jZWwgKz0gJ1RvOiAnICsgcmVxdWVzdC5oZWFkZXJzWydUbyddLnRvU3RyaW5nKCkgKyAnXFxyXFxuJztcbiAgdGhpcy5jYW5jZWwgKz0gJ0Zyb206ICcgKyByZXF1ZXN0LmhlYWRlcnNbJ0Zyb20nXS50b1N0cmluZygpICsgJ1xcclxcbic7XG4gIHRoaXMuY2FuY2VsICs9ICdDYWxsLUlEOiAnICsgcmVxdWVzdC5oZWFkZXJzWydDYWxsLUlEJ10udG9TdHJpbmcoKSArICdcXHJcXG4nO1xuICB0aGlzLmNhbmNlbCArPSAnQ1NlcTogJyArIHJlcXVlc3QuaGVhZGVyc1snQ1NlcSddLnRvU3RyaW5nKCkuc3BsaXQoJyAnKVswXSArXG4gICcgQ0FOQ0VMXFxyXFxuJztcblxuICBpZihyZWFzb24pIHtcbiAgICB0aGlzLmNhbmNlbCArPSAnUmVhc29uOiAnICsgcmVhc29uICsgJ1xcclxcbic7XG4gIH1cblxuICB0aGlzLmNhbmNlbCArPSAnQ29udGVudC1MZW5ndGg6IDBcXHJcXG5cXHJcXG4nO1xuXG4gIC8vIFNlbmQgb25seSBpZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlICg+MTAwKSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfUFJPQ0VFRElORykge1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5jYW5jZWwpO1xuICB9XG59O1xuXG5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyXG4gIHRyID0gdGhpcyxcbiAgc3RhdHVzX2NvZGUgPSByZXNwb25zZS5zdGF0dXNfY29kZTtcblxuICBpZihzdGF0dXNfY29kZSA+PSAxMDAgJiYgc3RhdHVzX2NvZGUgPD0gMTk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ0FMTElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfUFJPQ0VFRElORyk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMuY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSBpZihzdGF0dXNfY29kZSA+PSAyMDAgJiYgc3RhdHVzX2NvZGUgPD0gMjk5KSB7XG4gICAgc3dpdGNoKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgQy5TVEFUVVNfQ0FMTElORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQUNDRVBURUQpO1xuICAgICAgICB0aGlzLk0gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfTS5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9NKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0X3NlbmRlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQy5TVEFUVVNfQUNDRVBURUQ6XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMzAwICYmIHN0YXR1c19jb2RlIDw9IDY5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NBTExJTkc6XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0NPTVBMRVRFRCk7XG4gICAgICAgIHRoaXMuc2VuZEFDSyhyZXNwb25zZSk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9zZW5kZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgdGhpcy5zZW5kQUNLKHJlc3BvbnNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiAqIEBjbGFzcyBBQ0sgQ2xpZW50IFRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NJUC5SZXF1ZXN0U2VuZGVyfSByZXF1ZXN0X3NlbmRlclxuICogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuICovXG52YXIgQWNrQ2xpZW50VHJhbnNhY3Rpb24gPSBmdW5jdGlvbihyZXF1ZXN0X3NlbmRlciwgcmVxdWVzdCwgdHJhbnNwb3J0KSB7XG4gIHZhciB2aWE7XG5cbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMuaWQgPSAnejloRzRiSycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gIHRoaXMucmVxdWVzdF9zZW5kZXIgPSByZXF1ZXN0X3NlbmRlcjtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICB0aGlzLmxvZ2dlciA9IHJlcXVlc3Rfc2VuZGVyLnVhLmdldExvZ2dlcignc2lwLnRyYW5zYWN0aW9uLm5pY3QnLCB0aGlzLmlkKTtcblxuICB2aWEgPSBidWlsZFZpYUhlYWRlcihyZXF1ZXN0X3NlbmRlciwgdHJhbnNwb3J0LCB0aGlzLmlkKTtcbiAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcigndmlhJywgdmlhKTtcbn07XG5BY2tDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQWNrQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy5yZXF1ZXN0KSkge1xuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG59O1xuXG5BY2tDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ3RyYW5zcG9ydCBlcnJvciBvY2N1cnJlZCwgZm9yIGFuIEFDSyBjbGllbnQgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICB0aGlzLnJlcXVlc3Rfc2VuZGVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbn07XG5cblxuLyoqXG4qIEBhdWdtZW50cyBTSVAuVHJhbnNhY3Rpb25zXG4qIEBjbGFzcyBOb24gSW52aXRlIFNlcnZlciBUcmFuc2FjdGlvblxuKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiogQHBhcmFtIHtTSVAuVUF9IHVhXG4qL1xudmFyIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmVxdWVzdCwgdWEpIHtcbiAgdGhpcy50eXBlID0gQy5OT05fSU5WSVRFX1NFUlZFUjtcbiAgdGhpcy5pZCA9IHJlcXVlc3QudmlhX2JyYW5jaDtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgdGhpcy50cmFuc3BvcnQgPSByZXF1ZXN0LnRyYW5zcG9ydDtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxhc3RfcmVzcG9uc2UgPSAnJztcbiAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24gPSB0aGlzO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24ubmlzdCcsIHRoaXMuaWQpO1xuXG4gIHRoaXMuc3RhdGUgPSBDLlNUQVRVU19UUllJTkc7XG5cbiAgdWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEogZXhwaXJlZCBmb3Igbm9uLUlOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gJyArIHRoaXMuaWQpO1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudHJhbnNwb3J0RXJyb3IpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEVycm9yID0gdHJ1ZTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBub24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkopO1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24oc3RhdHVzX2NvZGUsIHJlc3BvbnNlKSB7XG4gIHZhciB0ciA9IHRoaXM7XG4gIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuXG4gIGlmKHN0YXR1c19jb2RlID09PSAxMDApIHtcbiAgICAvKiBSRkMgNDMyMCA0LjFcbiAgICAgKiAnQSBTSVAgZWxlbWVudCBNVVNUIE5PVFxuICAgICAqIHNlbmQgYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggYVxuICAgICAqIFN0YXR1cy1Db2RlIG90aGVyIHRoYW4gMTAwIHRvIGEgbm9uLUlOVklURSByZXF1ZXN0LidcbiAgICAgKi9cbiAgICBzd2l0Y2godGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1BST0NFRURJTkcpO1xuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpICB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMubGFzdF9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMjAwICYmIHN0YXR1c19jb2RlIDw9IDY5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1RSWUlORzpcbiAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuSiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9KLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0opO1xuICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEMuU1RBVFVTX0NPTVBMRVRFRDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiogQGF1Z21lbnRzIFNJUC5UcmFuc2FjdGlvbnNcbiogQGNsYXNzIEludml0ZSBTZXJ2ZXIgVHJhbnNhY3Rpb25cbiogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4qIEBwYXJhbSB7U0lQLlVBfSB1YVxuKi9cbnZhciBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHJlcXVlc3QsIHVhKSB7XG4gIHRoaXMudHlwZSA9IEMuSU5WSVRFX1NFUlZFUjtcbiAgdGhpcy5pZCA9IHJlcXVlc3QudmlhX2JyYW5jaDtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgdGhpcy50cmFuc3BvcnQgPSByZXF1ZXN0LnRyYW5zcG9ydDtcbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxhc3RfcmVzcG9uc2UgPSAnJztcbiAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24gPSB0aGlzO1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNhY3Rpb24uaXN0JywgdGhpcy5pZCk7XG5cbiAgdGhpcy5zdGF0ZSA9IEMuU1RBVFVTX1BST0NFRURJTkc7XG5cbiAgdWEubmV3VHJhbnNhY3Rpb24odGhpcyk7XG5cbiAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gbnVsbDtcblxuICByZXF1ZXN0LnJlcGx5KDEwMCk7XG59O1xuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJyk7XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxvZ2dlci5sb2coJ1RpbWVyIEggZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiAnICsgdGhpcy5pZCk7XG5cbiAgaWYodGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfQ09NUExFVEVEKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybigndHJhbnNhY3Rpb25zJywgJ0FDSyBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiB3YXMgbmV2ZXIgcmVjZWl2ZWQsIGNhbGwgd2lsbCBiZSB0ZXJtaW5hdGVkJyk7XG4gIH1cblxuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0YXRlQ2hhbmdlZChDLlNUQVRVU19URVJNSU5BVEVEKTtcbiAgdGhpcy51YS5kZXN0cm95VHJhbnNhY3Rpb24odGhpcyk7XG59O1xuXG4vLyBSRkMgNjAyNiA3LjFcbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9MID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubG9nZ2VyLmxvZygnVGltZXIgTCBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICBpZih0aGlzLnN0YXRlID09PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudHJhbnNwb3J0RXJyb3IpIHtcbiAgICB0aGlzLnRyYW5zcG9ydEVycm9yID0gdHJ1ZTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0IGVycm9yIG9jY3VycmVkLCBkZWxldGluZyBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uICcgKyB0aGlzLmlkKTtcblxuICAgIGlmICh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIpO1xuICAgICAgdGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLkwpO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMuSCk7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5JKTtcblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX1RFUk1JTkFURUQpO1xuICAgIHRoaXMudWEuZGVzdHJveVRyYW5zYWN0aW9uKHRoaXMpO1xuICB9XG59O1xuXG5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVzZW5kX3Byb3Zpc2lvbmFsID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMubGFzdF9yZXNwb25zZSkpIHtcbiAgICB0aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfVxufTtcblxuLy8gSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbiBSRkMgMzI2MSAxNy4yLjFcbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihzdGF0dXNfY29kZSwgcmVzcG9uc2UpIHtcbiAgdmFyIHRyID0gdGhpcztcbiAgdmFyIGRlZmVycmVkID0gU0lQLlV0aWxzLmRlZmVyKCk7XG5cbiAgaWYoc3RhdHVzX2NvZGUgPj0gMTAwICYmIHN0YXR1c19jb2RlIDw9IDE5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIGlmKCF0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKSkge1xuICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdF9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZihzdGF0dXNfY29kZSA+IDEwMCAmJiBzdGF0dXNfY29kZSA8PSAxOTkgJiYgdGhpcy5zdGF0ZSA9PT0gQy5TVEFUVVNfUFJPQ0VFRElORykge1xuICAgIC8vIFRyaWdnZXIgdGhlIHJlc2VuZFByb3Zpc2lvbmFsVGltZXIgb25seSBmb3IgdGhlIGZpcnN0IG5vbiAxMDAgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgaWYodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBTSVAuVGltZXJzLnNldEludGVydmFsKHRyLnJlc2VuZF9wcm92aXNpb25hbC5iaW5kKHRyKSxcbiAgICAgICAgU0lQLlRpbWVycy5QUk9WSVNJT05BTF9SRVNQT05TRV9JTlRFUlZBTCk7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMjAwICYmIHN0YXR1c19jb2RlIDw9IDI5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKEMuU1RBVFVTX0FDQ0VQVEVEKTtcbiAgICAgICAgdGhpcy5sYXN0X3Jlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMuTCA9IFNJUC5UaW1lcnMuc2V0VGltZW91dCh0ci50aW1lcl9MLmJpbmQodHIpLCBTSVAuVGltZXJzLlRJTUVSX0wpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyKTtcbiAgICAgICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSBDLlNUQVRVU19BQ0NFUFRFRDpcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBwb2ludCB3aWxsIGJlIHJlYWNoZWQgZm9yIHByb2NlZWRpbmcgdHIuc3RhdGUgYWxzby5cbiAgICAgICAgICBpZighdGhpcy50cmFuc3BvcnQuc2VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYoc3RhdHVzX2NvZGUgPj0gMzAwICYmIHN0YXR1c19jb2RlIDw9IDY5OSkge1xuICAgIHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgIGlmICh0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBTSVAuVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5yZXNlbmRQcm92aXNpb25hbFRpbWVyKTtcbiAgICAgICAgICB0aGlzLnJlc2VuZFByb3Zpc2lvbmFsVGltZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMudHJhbnNwb3J0LnNlbmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoQy5TVEFUVVNfQ09NUExFVEVEKTtcbiAgICAgICAgICB0aGlzLkggPSBTSVAuVGltZXJzLnNldFRpbWVvdXQodHIudGltZXJfSC5iaW5kKHRyKSwgU0lQLlRpbWVycy5USU1FUl9IKTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogSU5WSVRFOlxuICogIF90cnVlXyBpZiByZXRyYW5zbWlzc2lvblxuICogIF9mYWxzZV8gbmV3IHJlcXVlc3RcbiAqXG4gKiBBQ0s6XG4gKiAgX3RydWVfICBBQ0sgdG8gbm9uMnh4IHJlc3BvbnNlXG4gKiAgX2ZhbHNlXyBBQ0sgbXVzdCBiZSBwYXNzZWQgdG8gVFUgKGFjY2VwdGVkIHN0YXRlKVxuICogICAgICAgICAgQUNLIHRvIDJ4eCByZXNwb25zZVxuICpcbiAqIENBTkNFTDpcbiAqICBfdHJ1ZV8gIG5vIG1hdGNoaW5nIGludml0ZSB0cmFuc2FjdGlvblxuICogIF9mYWxzZV8gbWF0Y2hpbmcgaW52aXRlIHRyYW5zYWN0aW9uIGFuZCBubyBmaW5hbCByZXNwb25zZSBzZW50XG4gKlxuICogT1RIRVI6XG4gKiAgX3RydWVfICByZXRyYW5zbWlzc2lvblxuICogIF9mYWxzZV8gbmV3IHJlcXVlc3RcbiAqL1xudmFyIGNoZWNrVHJhbnNhY3Rpb24gPSBmdW5jdGlvbih1YSwgcmVxdWVzdCkge1xuICB2YXIgdHI7XG5cbiAgc3dpdGNoKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbcmVxdWVzdC52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHN3aXRjaCh0ci5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgQy5TVEFUVVNfUFJPQ0VFRElORzpcbiAgICAgICAgICAgIHRyLnRyYW5zcG9ydC5zZW5kKHRyLmxhc3RfcmVzcG9uc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MDI2IDcuMSBJbnZpdGUgcmV0cmFuc21pc3Npb25cbiAgICAgICAgICAgIC8vcmVjZWl2ZWQgd2hpbGUgaW4gQy5TVEFUVVNfQUNDRVBURUQgc3RhdGUuIEFic29yYiBpdC5cbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX0FDQ0VQVEVEOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLkFDSzpcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuXG4gICAgICAvLyBSRkMgNjAyNiA3LjFcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIGlmKHRyLnN0YXRlID09PSBDLlNUQVRVU19BQ0NFUFRFRCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmKHRyLnN0YXRlID09PSBDLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICAgICAgICB0ci5zdGF0ZSA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICB0ci5JID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHRyLnRpbWVyX0kuYmluZCh0ciksIFNJUC5UaW1lcnMuVElNRVJfSSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQUNLIHRvIDJYWCBSZXNwb25zZS5cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJUC5DLkNBTkNFTDpcbiAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseV9zbCgyMDApO1xuICAgICAgICBpZih0ci5zdGF0ZSA9PT0gQy5TVEFUVVNfUFJPQ0VFRElORykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg0ODEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG5cbiAgICAgIC8vIE5vbi1JTlZJVEUgU2VydmVyIFRyYW5zYWN0aW9uIFJGQyAzMjYxIDE3LjIuMlxuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMubmlzdFtyZXF1ZXN0LnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgc3dpdGNoKHRyLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19UUllJTkc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEMuU1RBVFVTX1BST0NFRURJTkc6XG4gICAgICAgICAgY2FzZSBDLlNUQVRVU19DT01QTEVURUQ6XG4gICAgICAgICAgICB0ci50cmFuc3BvcnQuc2VuZCh0ci5sYXN0X3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNJUC5UcmFuc2FjdGlvbnMgPSB7XG4gIEM6IEMsXG4gIGNoZWNrVHJhbnNhY3Rpb246IGNoZWNrVHJhbnNhY3Rpb24sXG4gIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uOiBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbixcbiAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb246IEludml0ZUNsaWVudFRyYW5zYWN0aW9uLFxuICBBY2tDbGllbnRUcmFuc2FjdGlvbjogQWNrQ2xpZW50VHJhbnNhY3Rpb24sXG4gIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uOiBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbixcbiAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb246IEludml0ZVNlcnZlclRyYW5zYWN0aW9uXG59O1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9UcmFuc2FjdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNJUCBEaWFsb2dcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBkaWFsb2cuXG4gKiBAcGFyYW0ge1NJUC5SVENTZXNzaW9ufSBvd25lclxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fFNJUC5JbmNvbWluZ1Jlc3BvbnNlfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0VudW19IHR5cGUgVUFDIC8gVUFTXG4gKiBAcGFyYW0ge0VudW19IHN0YXRlIFNJUC5EaWFsb2cuQy5TVEFUVVNfRUFSTFkgLyBTSVAuRGlhbG9nLkMuU1RBVFVTX0NPTkZJUk1FRFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIFJlcXVlc3RTZW5kZXIgPSByZXF1aXJlKCcuL0RpYWxvZy9SZXF1ZXN0U2VuZGVyJykoU0lQKTtcblxudmFyIERpYWxvZyxcbiAgQyA9IHtcbiAgICAvLyBEaWFsb2cgc3RhdGVzXG4gICAgU1RBVFVTX0VBUkxZOiAgICAgICAxLFxuICAgIFNUQVRVU19DT05GSVJNRUQ6ICAgMlxuICB9O1xuXG4vLyBSRkMgMzI2MSAxMi4xXG5EaWFsb2cgPSBmdW5jdGlvbihvd25lciwgbWVzc2FnZSwgdHlwZSwgc3RhdGUpIHtcbiAgdmFyIGNvbnRhY3Q7XG5cbiAgdGhpcy51YWNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuICB0aGlzLnVhc19wZW5kaW5nX3JlcGx5ID0gZmFsc2U7XG5cbiAgaWYoIW1lc3NhZ2UuaGFzSGVhZGVyKCdjb250YWN0JykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICd1bmFibGUgdG8gY3JlYXRlIGEgRGlhbG9nIHdpdGhvdXQgQ29udGFjdCBoZWFkZXIgZmllbGQnXG4gICAgfTtcbiAgfVxuXG4gIGlmKG1lc3NhZ2UgaW5zdGFuY2VvZiBTSVAuSW5jb21pbmdSZXNwb25zZSkge1xuICAgIHN0YXRlID0gKG1lc3NhZ2Uuc3RhdHVzX2NvZGUgPCAyMDApID8gQy5TVEFUVVNfRUFSTFkgOiBDLlNUQVRVU19DT05GSVJNRUQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3JlYXRlIGNvbmZpcm1lZCBkaWFsb2cgaWYgc3RhdGUgaXMgbm90IGRlZmluZWRcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgfVxuXG4gIGNvbnRhY3QgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCdjb250YWN0Jyk7XG5cbiAgLy8gUkZDIDMyNjEgMTIuMS4xXG4gIGlmKHR5cGUgPT09ICdVQVMnKSB7XG4gICAgdGhpcy5pZCA9IHtcbiAgICAgIGNhbGxfaWQ6IG1lc3NhZ2UuY2FsbF9pZCxcbiAgICAgIGxvY2FsX3RhZzogbWVzc2FnZS50b190YWcsXG4gICAgICByZW1vdGVfdGFnOiBtZXNzYWdlLmZyb21fdGFnLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsX2lkICsgdGhpcy5sb2NhbF90YWcgKyB0aGlzLnJlbW90ZV90YWc7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5yZW1vdGVfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcigndG8nKS51cmk7XG4gICAgdGhpcy5yZW1vdGVfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcignZnJvbScpLnVyaTtcbiAgICB0aGlzLnJlbW90ZV90YXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICB0aGlzLnJvdXRlX3NldCA9IG1lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJyk7XG4gICAgdGhpcy5pbnZpdGVfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICB9XG4gIC8vIFJGQyAzMjYxIDEyLjEuMlxuICBlbHNlIGlmKHR5cGUgPT09ICdVQUMnKSB7XG4gICAgdGhpcy5pZCA9IHtcbiAgICAgIGNhbGxfaWQ6IG1lc3NhZ2UuY2FsbF9pZCxcbiAgICAgIGxvY2FsX3RhZzogbWVzc2FnZS5mcm9tX3RhZyxcbiAgICAgIHJlbW90ZV90YWc6IG1lc3NhZ2UudG9fdGFnLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsX2lkICsgdGhpcy5sb2NhbF90YWcgKyB0aGlzLnJlbW90ZV90YWc7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5pbnZpdGVfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfc2VxbnVtID0gbWVzc2FnZS5jc2VxO1xuICAgIHRoaXMubG9jYWxfdXJpID0gbWVzc2FnZS5wYXJzZUhlYWRlcignZnJvbScpLnVyaTtcbiAgICB0aGlzLnByYWNrZWQgPSBbXTtcbiAgICB0aGlzLnJlbW90ZV91cmkgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKCd0bycpLnVyaTtcbiAgICB0aGlzLnJlbW90ZV90YXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICB0aGlzLnJvdXRlX3NldCA9IG1lc3NhZ2UuZ2V0SGVhZGVycygncmVjb3JkLXJvdXRlJykucmV2ZXJzZSgpO1xuXG4gICAgLy9SRU5ERVJCT0RZXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IEMuU1RBVFVTX0VBUkxZICYmICghb3duZXIuaGFzT2ZmZXIpKSB7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlciA9IG93bmVyLm1lZGlhSGFuZGxlckZhY3Rvcnkob3duZXIpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubG9nZ2VyID0gb3duZXIudWEuZ2V0TG9nZ2VyKCdzaXAuZGlhbG9nJywgdGhpcy5pZC50b1N0cmluZygpKTtcbiAgdGhpcy5vd25lciA9IG93bmVyO1xuICBvd25lci51YS5kaWFsb2dzW3RoaXMuaWQudG9TdHJpbmcoKV0gPSB0aGlzO1xuICB0aGlzLmxvZ2dlci5sb2coJ25ldyAnICsgdHlwZSArICcgZGlhbG9nIGNyZWF0ZWQgd2l0aCBzdGF0dXMgJyArICh0aGlzLnN0YXRlID09PSBDLlNUQVRVU19FQVJMWSA/ICdFQVJMWSc6ICdDT05GSVJNRUQnKSk7XG4gIG93bmVyLmVtaXQoJ2RpYWxvZycsIHRoaXMpO1xufTtcblxuRGlhbG9nLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U0lQLkluY29taW5nTWVzc2FnZX0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge0VudW19IFVBQy9VQVNcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgIHRoaXMuc3RhdGUgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2RpYWxvZyAnKyB0aGlzLmlkLnRvU3RyaW5nKCkgKycgIGNoYW5nZWQgdG8gQ09ORklSTUVEIHN0YXRlJyk7XG5cbiAgICBpZih0eXBlID09PSAnVUFDJykge1xuICAgICAgLy8gUkZDIDMyNjEgMTMuMi4yLjRcbiAgICAgIHRoaXMucm91dGVfc2V0ID0gbWVzc2FnZS5nZXRIZWFkZXJzKCdyZWNvcmQtcm91dGUnKS5yZXZlcnNlKCk7XG4gICAgfVxuICB9LFxuXG4gIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKCdkaWFsb2cgJyArIHRoaXMuaWQudG9TdHJpbmcoKSArICcgZGVsZXRlZCcpO1xuICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlciAmJiB0aGlzLnN0YXRlICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLm93bmVyLnVhLmRpYWxvZ3NbdGhpcy5pZC50b1N0cmluZygpXTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIHJlcXVlc3QgbWV0aG9kXG4gICogQHBhcmFtIHtPYmplY3R9IGV4dHJhSGVhZGVycyBleHRyYSBoZWFkZXJzXG4gICogQHJldHVybnMge1NJUC5PdXRnb2luZ1JlcXVlc3R9XG4gICovXG5cbiAgLy8gUkZDIDMyNjEgMTIuMi4xLjFcbiAgY3JlYXRlUmVxdWVzdDogZnVuY3Rpb24obWV0aG9kLCBleHRyYUhlYWRlcnMsIGJvZHkpIHtcbiAgICB2YXIgY3NlcSwgcmVxdWVzdDtcbiAgICBleHRyYUhlYWRlcnMgPSAoZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuXG4gICAgaWYoIXRoaXMubG9jYWxfc2VxbnVtKSB7IHRoaXMubG9jYWxfc2VxbnVtID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApOyB9XG5cbiAgICBjc2VxID0gKG1ldGhvZCA9PT0gU0lQLkMuQ0FOQ0VMIHx8IG1ldGhvZCA9PT0gU0lQLkMuQUNLKSA/IHRoaXMuaW52aXRlX3NlcW51bSA6IHRoaXMubG9jYWxfc2VxbnVtICs9IDE7XG5cbiAgICByZXF1ZXN0ID0gbmV3IFNJUC5PdXRnb2luZ1JlcXVlc3QoXG4gICAgICBtZXRob2QsXG4gICAgICB0aGlzLnJlbW90ZV90YXJnZXQsXG4gICAgICB0aGlzLm93bmVyLnVhLCB7XG4gICAgICAgICdjc2VxJzogY3NlcSxcbiAgICAgICAgJ2NhbGxfaWQnOiB0aGlzLmlkLmNhbGxfaWQsXG4gICAgICAgICdmcm9tX3VyaSc6IHRoaXMubG9jYWxfdXJpLFxuICAgICAgICAnZnJvbV90YWcnOiB0aGlzLmlkLmxvY2FsX3RhZyxcbiAgICAgICAgJ3RvX3VyaSc6IHRoaXMucmVtb3RlX3VyaSxcbiAgICAgICAgJ3RvX3RhZyc6IHRoaXMuaWQucmVtb3RlX3RhZyxcbiAgICAgICAgJ3JvdXRlX3NldCc6IHRoaXMucm91dGVfc2V0XG4gICAgICB9LCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuXG4gICAgcmVxdWVzdC5kaWFsb2cgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0XG4gICogQHJldHVybnMge0Jvb2xlYW59XG4gICovXG5cbiAgLy8gUkZDIDMyNjEgMTIuMi4yXG4gIGNoZWNrSW5EaWFsb2dSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIXRoaXMucmVtb3RlX3NlcW51bSkge1xuICAgICAgdGhpcy5yZW1vdGVfc2VxbnVtID0gcmVxdWVzdC5jc2VxO1xuICAgIH0gZWxzZSBpZihyZXF1ZXN0LmNzZXEgPCB0aGlzLnJlbW90ZV9zZXFudW0pIHtcbiAgICAgICAgLy9EbyBub3QgdHJ5IHRvIHJlcGx5IHRvIGFuIEFDSyByZXF1ZXN0LlxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoNTAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5jc2VxID09PSB0aGlzLmludml0ZV9zZXFudW0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmKHJlcXVlc3QuY3NlcSA+IHRoaXMucmVtb3RlX3NlcW51bSkge1xuICAgICAgdGhpcy5yZW1vdGVfc2VxbnVtID0gcmVxdWVzdC5jc2VxO1xuICAgIH1cblxuICAgIHN3aXRjaChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgLy8gUkZDMzI2MSAxNC4yIE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uIC1VQVMgQkVIQVZJT1ItXG4gICAgICBjYXNlIFNJUC5DLklOVklURTpcbiAgICAgICAgaWYgKHRoaXMudWFjX3BlbmRpbmdfcmVwbHkgPT09IHRydWUpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQ5MSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy51YXNfcGVuZGluZ19yZXBseSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZXRyeUFmdGVyID0gKE1hdGgucmFuZG9tKCkgKiAxMCB8IDApICsgMTtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDUwMCwgbnVsbCwgWydSZXRyeS1BZnRlcjonICsgcmV0cnlBZnRlcl0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVhc19wZW5kaW5nX3JlcGx5ID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24gc3RhdGVDaGFuZ2VkKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19BQ0NFUFRFRCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQ09NUExFVEVEIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG5cbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgc2VsZi51YXNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChzZWxmLnVhY19wZW5kaW5nX3JlcGx5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub3duZXIub25SZWFkeVRvUmVpbnZpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUkZDMzI2MSAxMi4yLjIgUmVwbGFjZSB0aGUgZGlhbG9nYHMgcmVtb3RlIHRhcmdldCBVUkkgaWYgdGhlIHJlcXVlc3QgaXMgYWNjZXB0ZWRcbiAgICAgICAgaWYocmVxdWVzdC5oYXNIZWFkZXIoJ2NvbnRhY3QnKSkge1xuICAgICAgICAgIHJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLm9uKCdzdGF0ZUNoYW5nZWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfQUNDRVBURUQpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdGVfdGFyZ2V0ID0gcmVxdWVzdC5wYXJzZUhlYWRlcignY29udGFjdCcpLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0lQLkMuTk9USUZZOlxuICAgICAgICAvLyBSRkM2NjY1IDMuMiBSZXBsYWNlIHRoZSBkaWFsb2dgcyByZW1vdGUgdGFyZ2V0IFVSSSBpZiB0aGUgcmVxdWVzdCBpcyBhY2NlcHRlZFxuICAgICAgICBpZihyZXF1ZXN0Lmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgICAgICAgcmVxdWVzdC5zZXJ2ZXJfdHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19DT01QTEVURUQpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdGVfdGFyZ2V0ID0gcmVxdWVzdC5wYXJzZUhlYWRlcignY29udGFjdCcpLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBzZW5kUmVxdWVzdDogZnVuY3Rpb24oYXBwbGljYW50LCBtZXRob2QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhclxuICAgICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBudWxsLFxuICAgICAgcmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdChtZXRob2QsIGV4dHJhSGVhZGVycywgYm9keSksXG4gICAgICByZXF1ZXN0X3NlbmRlciA9IG5ldyBSZXF1ZXN0U2VuZGVyKHRoaXMsIGFwcGxpY2FudCwgcmVxdWVzdCk7XG5cbiAgICByZXF1ZXN0X3NlbmRlci5zZW5kKCk7XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge1NJUC5JbmNvbWluZ1JlcXVlc3R9IHJlcXVlc3RcbiAgKi9cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAvL0NoZWNrIGluLWRpYWxvZyByZXF1ZXN0XG4gICAgaWYoIXRoaXMuY2hlY2tJbkRpYWxvZ1JlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm93bmVyLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICB9XG59O1xuXG5EaWFsb2cuQyA9IEM7XG5TSVAuRGlhbG9nID0gRGlhbG9nO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvRGlhbG9ncy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBJbi1EaWFsb2cgUmVxdWVzdCBTZW5kZXJcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVAuRGlhbG9nXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYW4gSW4tZGlhbG9nIHJlcXVlc3Qgc2VuZGVyLlxuICogQHBhcmFtIHtTSVAuRGlhbG9nfSBkaWFsb2dcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcHBsaWNhbnRcbiAqIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgaW4tRGlhbG9nIFJlcXVlc3QgU2VuZGVyXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgUmVxdWVzdFNlbmRlcjtcblxuUmVxdWVzdFNlbmRlciA9IGZ1bmN0aW9uKGRpYWxvZywgYXBwbGljYW50LCByZXF1ZXN0KSB7XG5cbiAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gIHRoaXMuYXBwbGljYW50ID0gYXBwbGljYW50O1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gIC8vIFJGQzMyNjEgMTQuMSBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvbi4gVUFDIEJlaGF2aW9yLlxuICB0aGlzLnJlYXR0ZW1wdCA9IGZhbHNlO1xuICB0aGlzLnJlYXR0ZW1wdFRpbWVyID0gbnVsbDtcbn07XG5cblJlcXVlc3RTZW5kZXIucHJvdG90eXBlID0ge1xuICBzZW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByZXF1ZXN0X3NlbmRlciA9IG5ldyBTSVAuUmVxdWVzdFNlbmRlcih0aGlzLCB0aGlzLmRpYWxvZy5vd25lci51YSk7XG5cbiAgICAgIHJlcXVlc3Rfc2VuZGVyLnNlbmQoKTtcblxuICAgIC8vIFJGQzMyNjEgMTQuMiBNb2RpZnlpbmcgYW4gRXhpc3RpbmcgU2Vzc2lvbiAtVUFDIEJFSEFWSU9SLVxuICAgIGlmICh0aGlzLnJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5JTlZJVEUgJiYgcmVxdWVzdF9zZW5kZXIuY2xpZW50VHJhbnNhY3Rpb24uc3RhdGUgIT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5kaWFsb2cudWFjX3BlbmRpbmdfcmVwbHkgPSB0cnVlO1xuICAgICAgcmVxdWVzdF9zZW5kZXIuY2xpZW50VHJhbnNhY3Rpb24ub24oJ3N0YXRlQ2hhbmdlZCcsIGZ1bmN0aW9uIHN0YXRlQ2hhbmdlZCgpe1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19BQ0NFUFRFRCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU0lQLlRyYW5zYWN0aW9ucy5DLlNUQVRVU19DT01QTEVURUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignc3RhdGVDaGFuZ2VkJywgc3RhdGVDaGFuZ2VkKTtcbiAgICAgICAgICBzZWxmLmRpYWxvZy51YWNfcGVuZGluZ19yZXBseSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHNlbGYuZGlhbG9nLnVhc19wZW5kaW5nX3JlcGx5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc2VsZi5kaWFsb2cub3duZXIub25SZWFkeVRvUmVpbnZpdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFwcGxpY2FudC5vblJlcXVlc3RUaW1lb3V0KCk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25UcmFuc3BvcnRFcnJvcigpO1xuICB9LFxuXG4gIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBSRkMzMjYxIDEyLjIuMS4yIDQwOCBvciA0ODEgaXMgcmVjZWl2ZWQgZm9yIGEgcmVxdWVzdCB3aXRoaW4gYSBkaWFsb2cuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c19jb2RlID09PSA0MDggfHwgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPT09IDQ4MSkge1xuICAgICAgdGhpcy5hcHBsaWNhbnQub25EaWFsb2dFcnJvcihyZXNwb25zZSk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5tZXRob2QgPT09IFNJUC5DLklOVklURSAmJiByZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDkxKSB7XG4gICAgICBpZiAodGhpcy5yZWF0dGVtcHQpIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdC5jc2VxLnZhbHVlID0gdGhpcy5kaWFsb2cubG9jYWxfc2VxbnVtICs9IDE7XG4gICAgICAgIHRoaXMucmVhdHRlbXB0VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hcHBsaWNhbnQub3duZXIuc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgIHNlbGYucmVhdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0X3NlbmRlci5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGlzLmdldFJlYXR0ZW1wdFRpbWVvdXQoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGxpY2FudC5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxufTtcblxucmV0dXJuIFJlcXVlc3RTZW5kZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9EaWFsb2cvUmVxdWVzdFNlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXF1ZXN0IFNlbmRlclxuICovXG5cbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgcmVxdWVzdCBzZW5kZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gYXBwbGljYW50XG4gKiBAcGFyYW0ge1NJUC5VQX0gdWFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgUmVxdWVzdFNlbmRlcjtcblxuUmVxdWVzdFNlbmRlciA9IGZ1bmN0aW9uKGFwcGxpY2FudCwgdWEpIHtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5yZXF1ZXN0c2VuZGVyJyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5hcHBsaWNhbnQgPSBhcHBsaWNhbnQ7XG4gIHRoaXMubWV0aG9kID0gYXBwbGljYW50LnJlcXVlc3QubWV0aG9kO1xuICB0aGlzLnJlcXVlc3QgPSBhcHBsaWNhbnQucmVxdWVzdDtcbiAgdGhpcy5jcmVkZW50aWFscyA9IG51bGw7XG4gIHRoaXMuY2hhbGxlbmdlZCA9IGZhbHNlO1xuICB0aGlzLnN0YWxlZCA9IGZhbHNlO1xuXG4gIC8vIElmIHVhIGlzIGluIGNsb3NpbmcgcHJvY2VzcyBvciBldmVuIGNsb3NlZCBqdXN0IGFsbG93IHNlbmRpbmcgQnllIGFuZCBBQ0tcbiAgaWYgKHVhLnN0YXR1cyA9PT0gU0lQLlVBLkMuU1RBVFVTX1VTRVJfQ0xPU0VEICYmICh0aGlzLm1ldGhvZCAhPT0gU0lQLkMuQllFIHx8IHRoaXMubWV0aG9kICE9PSBTSVAuQy5BQ0spKSB7XG4gICAgdGhpcy5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbn07XG5cbi8qKlxuKiBDcmVhdGUgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBhbmQgc2VuZCB0aGUgbWVzc2FnZS5cbiovXG5SZXF1ZXN0U2VuZGVyLnByb3RvdHlwZSA9IHtcbiAgc2VuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoKHRoaXMubWV0aG9kKSB7XG4gICAgICBjYXNlIFwiSU5WSVRFXCI6XG4gICAgICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLnJlcXVlc3QsIHRoaXMudWEudHJhbnNwb3J0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQUNLXCI6XG4gICAgICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24gPSBuZXcgU0lQLlRyYW5zYWN0aW9ucy5BY2tDbGllbnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLnJlcXVlc3QsIHRoaXMudWEudHJhbnNwb3J0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNsaWVudFRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24odGhpcywgdGhpcy5yZXF1ZXN0LCB0aGlzLnVhLnRyYW5zcG9ydCk7XG4gICAgfVxuICAgIHRoaXMuY2xpZW50VHJhbnNhY3Rpb24uc2VuZCgpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50VHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICogQ2FsbGJhY2sgZmlyZWQgd2hlbiByZWNlaXZpbmcgYSByZXF1ZXN0IHRpbWVvdXQgZXJyb3IgZnJvbSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uLlxuICAqIFRvIGJlIHJlLWRlZmluZWQgYnkgdGhlIGFwcGxpY2FudC5cbiAgKiBAZXZlbnRcbiAgKi9cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hcHBsaWNhbnQub25SZXF1ZXN0VGltZW91dCgpO1xuICB9LFxuXG4gIC8qKlxuICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gcmVjZWl2aW5nIGEgdHJhbnNwb3J0IGVycm9yIGZyb20gdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAgKiBUbyBiZSByZS1kZWZpbmVkIGJ5IHRoZSBhcHBsaWNhbnQuXG4gICogQGV2ZW50XG4gICovXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXBwbGljYW50Lm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgKiBDYWxsZWQgZnJvbSBjbGllbnQgdHJhbnNhY3Rpb24gd2hlbiByZWNlaXZpbmcgYSBjb3JyZWN0IHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0LlxuICAqIEF1dGhlbnRpY2F0ZSByZXF1ZXN0IGlmIG5lZWRlZCBvciBwYXNzIHRoZSByZXNwb25zZSBiYWNrIHRvIHRoZSBhcHBsaWNhbnQuXG4gICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXNwb25zZX0gcmVzcG9uc2VcbiAgKi9cbiAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBjc2VxLCBjaGFsbGVuZ2UsIGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUsXG4gICAgICBzdGF0dXNfY29kZSA9IHJlc3BvbnNlLnN0YXR1c19jb2RlO1xuXG4gICAgLypcbiAgICAqIEF1dGhlbnRpY2F0aW9uXG4gICAgKiBBdXRoZW50aWNhdGUgb25jZS4gX2NoYWxsZW5nZWRfIGZsYWcgdXNlZCB0byBhdm9pZCBpbmZpbml0ZSBhdXRoZW50aWNhdGlvbnMuXG4gICAgKi9cbiAgICBpZiAoc3RhdHVzX2NvZGUgPT09IDQwMSB8fCBzdGF0dXNfY29kZSA9PT0gNDA3KSB7XG5cbiAgICAgIC8vIEdldCBhbmQgcGFyc2UgdGhlIGFwcHJvcHJpYXRlIFdXVy1BdXRoZW50aWNhdGUgb3IgUHJveHktQXV0aGVudGljYXRlIGhlYWRlci5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA9PT0gNDAxKSB7XG4gICAgICAgIGNoYWxsZW5nZSA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgICAgIGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUgPSAnYXV0aG9yaXphdGlvbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFsbGVuZ2UgPSByZXNwb25zZS5wYXJzZUhlYWRlcigncHJveHktYXV0aGVudGljYXRlJyk7XG4gICAgICAgIGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUgPSAncHJveHktYXV0aG9yaXphdGlvbic7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBpdCBzZWVtcyBhIHZhbGlkIGNoYWxsZW5nZS5cbiAgICAgIGlmICghIGNoYWxsZW5nZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKHJlc3BvbnNlLnN0YXR1c19jb2RlICsgJyB3aXRoIHdyb25nIG9yIG1pc3NpbmcgY2hhbGxlbmdlLCBjYW5ub3QgYXV0aGVudGljYXRlJyk7XG4gICAgICAgIHRoaXMuYXBwbGljYW50LnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNoYWxsZW5nZWQgfHwgKCF0aGlzLnN0YWxlZCAmJiBjaGFsbGVuZ2Uuc3RhbGUgPT09IHRydWUpKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscykge1xuICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0aGlzLnVhLmNvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRpb25GYWN0b3J5KHRoaXMudWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNoYWxsZW5nZSBpcyByZWFsbHkgdmFsaWQuXG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5hdXRoZW50aWNhdGUodGhpcy5yZXF1ZXN0LCBjaGFsbGVuZ2UpKSB7XG4gICAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFsbGVuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY2hhbGxlbmdlLnN0YWxlKSB7XG4gICAgICAgICAgdGhpcy5zdGFsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gU0lQLkMuUkVHSVNURVIpIHtcbiAgICAgICAgICBjc2VxID0gdGhpcy5hcHBsaWNhbnQuY3NlcSArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdC5kaWFsb2cpe1xuICAgICAgICAgIGNzZXEgPSB0aGlzLnJlcXVlc3QuZGlhbG9nLmxvY2FsX3NlcW51bSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzZXEgPSB0aGlzLnJlcXVlc3QuY3NlcSArIDE7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0LmNzZXEgPSBjc2VxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ2NzZXEnLCBjc2VxICsnICcrIHRoaXMubWV0aG9kKTtcblxuICAgICAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKGF1dGhvcml6YXRpb25faGVhZGVyX25hbWUsIHRoaXMuY3JlZGVudGlhbHMudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBsaWNhbnQucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbn07XG5cblNJUC5SZXF1ZXN0U2VuZGVyID0gUmVxdWVzdFNlbmRlcjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1JlcXVlc3RTZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG5cbnZhciBSZWdpc3RlckNvbnRleHQ7XG5cblJlZ2lzdGVyQ29udGV4dCA9IGZ1bmN0aW9uICh1YSkge1xuICB2YXIgcGFyYW1zID0ge30sXG4gICAgICByZWdJZCA9IDE7XG5cbiAgdGhpcy5yZWdpc3RyYXIgPSB1YS5jb25maWd1cmF0aW9uLnJlZ2lzdHJhclNlcnZlcjtcbiAgdGhpcy5leHBpcmVzID0gdWEuY29uZmlndXJhdGlvbi5yZWdpc3RlckV4cGlyZXM7XG5cblxuICAvLyBDb250YWN0IGhlYWRlclxuICB0aGlzLmNvbnRhY3QgPSB1YS5jb250YWN0LnRvU3RyaW5nKCk7XG5cbiAgaWYocmVnSWQpIHtcbiAgICB0aGlzLmNvbnRhY3QgKz0gJztyZWctaWQ9JysgcmVnSWQ7XG4gICAgdGhpcy5jb250YWN0ICs9ICc7K3NpcC5pbnN0YW5jZT1cIjx1cm46dXVpZDonKyB1YS5jb25maWd1cmF0aW9uLmluc3RhbmNlSWQrJz5cIic7XG4gIH1cblxuICAvLyBDYWxsLUlEIGFuZCBDU2VxIHZhbHVlcyBSRkMzMjYxIDEwLjJcbiAgdGhpcy5jYWxsX2lkID0gU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDIyKTtcbiAgdGhpcy5jc2VxID0gODA7XG5cbiAgdGhpcy50b191cmkgPSB1YS5jb25maWd1cmF0aW9uLnVyaTtcblxuICBwYXJhbXMudG9fdXJpID0gdGhpcy50b191cmk7XG4gIHBhcmFtcy50b19kaXNwbGF5TmFtZSA9IHVhLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWU7XG4gIHBhcmFtcy5jYWxsX2lkID0gdGhpcy5jYWxsX2lkO1xuICBwYXJhbXMuY3NlcSA9IHRoaXMuY3NlcTtcblxuICAvLyBFeHRlbmRzIENsaWVudENvbnRleHRcbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLkNsaWVudENvbnRleHQsIFt1YSwgJ1JFR0lTVEVSJywgdGhpcy5yZWdpc3RyYXIsIHtwYXJhbXM6IHBhcmFtc31dKTtcblxuICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gbnVsbDtcbiAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuXG4gIC8vIFNldCBzdGF0dXNcbiAgdGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5yZWdpc3RlcmNvbnRleHQnKTtcbn07XG5cblJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcywgZXh0cmFIZWFkZXJzO1xuXG4gICAgLy8gSGFuZGxlIE9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGV4dHJhSGVhZGVycyA9ICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnICsgdGhpcy5jb250YWN0ICsgJztleHBpcmVzPScgKyB0aGlzLmV4cGlyZXMpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJyArIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICAgIC8vIFNhdmUgb3JpZ2luYWwgZXh0cmFIZWFkZXJzIHRvIGJlIHVzZWQgaW4gLmNsb3NlXG4gICAgdGhpcy5jbG9zZUhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuY2xvc2VXaXRoSGVhZGVycyA/XG4gICAgICAodGhpcy5vcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSA6IFtdO1xuXG4gICAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFyIGNvbnRhY3QsIGV4cGlyZXMsXG4gICAgICAgIGNvbnRhY3RzID0gcmVzcG9uc2UuZ2V0SGVhZGVycygnY29udGFjdCcpLmxlbmd0aCxcbiAgICAgICAgY2F1c2U7XG5cbiAgICAgIC8vIERpc2NhcmQgcmVzcG9uc2VzIHRvIG9sZGVyIFJFR0lTVEVSL3VuLVJFR0lTVEVSIHJlcXVlc3RzLlxuICAgICAgaWYocmVzcG9uc2UuY3NlcSAhPT0gdGhpcy5jc2VxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgcmVnaXN0cmF0aW9uIHRpbWVyXG4gICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gbnVsbCkge1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSk6XG4gICAgICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcignZXhwaXJlcycpKSB7XG4gICAgICAgICAgICBleHBpcmVzID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdleHBpcmVzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VhcmNoIHRoZSBDb250YWN0IHBvaW50aW5nIHRvIHVzIGFuZCB1cGRhdGUgdGhlIGV4cGlyZXMgdmFsdWUgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgaWYgKCFjb250YWN0cykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2Fybignbm8gQ29udGFjdCBoZWFkZXIgaW4gcmVzcG9uc2UgdG8gUkVHSVNURVIsIHJlc3BvbnNlIGlnbm9yZWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlKGNvbnRhY3RzLS0pIHtcbiAgICAgICAgICAgIGNvbnRhY3QgPSByZXNwb25zZS5wYXJzZUhlYWRlcignY29udGFjdCcsIGNvbnRhY3RzKTtcbiAgICAgICAgICAgIGlmKGNvbnRhY3QudXJpLnVzZXIgPT09IHRoaXMudWEuY29udGFjdC51cmkudXNlcikge1xuICAgICAgICAgICAgICBleHBpcmVzID0gY29udGFjdC5nZXRQYXJhbSgnZXhwaXJlcycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRhY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29udGFjdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2Fybignbm8gQ29udGFjdCBoZWFkZXIgcG9pbnRpbmcgdG8gdXMsIHJlc3BvbnNlIGlnbm9yZWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFleHBpcmVzKSB7XG4gICAgICAgICAgICBleHBpcmVzID0gdGhpcy5leHBpcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlLVJlZ2lzdGVyIGJlZm9yZSB0aGUgZXhwaXJhdGlvbiBpbnRlcnZhbCBoYXMgZWxhcHNlZC5cbiAgICAgICAgICAvLyBGb3IgdGhhdCwgZGVjcmVhc2UgdGhlIGV4cGlyZXMgdmFsdWUuIGllOiAzIHNlY29uZHNcbiAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnJlZ2lzdGVyKHNlbGYub3B0aW9ucyk7XG4gICAgICAgICAgfSwgKGV4cGlyZXMgKiAxMDAwKSAtIDMwMDApO1xuICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oJ3JlZ2lzdHJhdGlvbiBleHBpcmVkJyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgIHNlbGYudW5yZWdpc3RlcmVkKG51bGwsIFNJUC5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBleHBpcmVzICogMTAwMCk7XG5cbiAgICAgICAgICAvL1NhdmUgZ3J1dSB2YWx1ZXNcbiAgICAgICAgICBpZiAoY29udGFjdC5oYXNQYXJhbSgndGVtcC1ncnV1JykpIHtcbiAgICAgICAgICAgIHRoaXMudWEuY29udGFjdC50ZW1wX2dydXUgPSBTSVAuVVJJLnBhcnNlKGNvbnRhY3QuZ2V0UGFyYW0oJ3RlbXAtZ3J1dScpLnJlcGxhY2UoL1wiL2csJycpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhY3QuaGFzUGFyYW0oJ3B1Yi1ncnV1JykpIHtcbiAgICAgICAgICAgIHRoaXMudWEuY29udGFjdC5wdWJfZ3J1dSA9IFNJUC5VUkkucGFyc2UoY29udGFjdC5nZXRQYXJhbSgncHViLWdydXUnKS5yZXBsYWNlKC9cIi9nLCcnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlZ2lzdGVyZWQnLCByZXNwb25zZSB8fCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSW50ZXJ2YWwgdG9vIGJyaWVmIFJGQzMyNjEgMTAuMi44XG4gICAgICAgIGNhc2UgL140MjMkLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICBpZihyZXNwb25zZS5oYXNIZWFkZXIoJ21pbi1leHBpcmVzJykpIHtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIG91ciByZWdpc3RyYXRpb24gaW50ZXJ2YWwgdG8gdGhlIHN1Z2dlc3RlZCBtaW5pbXVtXG4gICAgICAgICAgICB0aGlzLmV4cGlyZXMgPSByZXNwb25zZS5nZXRIZWFkZXIoJ21pbi1leHBpcmVzJyk7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRoZSByZWdpc3RyYXRpb24gYWdhaW4gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2UgeyAvL1RoaXMgcmVzcG9uc2UgTVVTVCBjb250YWluIGEgTWluLUV4cGlyZXMgaGVhZGVyIGZpZWxkXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCc0MjMgcmVzcG9uc2UgcmVjZWl2ZWQgZm9yIFJFR0lTVEVSIHdpdGhvdXQgTWluLUV4cGlyZXMnKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShyZXNwb25zZSwgU0lQLkMuY2F1c2VzLlNJUF9GQUlMVVJFX0NPREUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYXVzZSA9IFNJUC5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c19jb2RlKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJhdGlvbkZhaWx1cmUobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfTtcblxuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jc2VxKys7XG4gICAgdGhpcy5yZXF1ZXN0LmNzZXEgPSB0aGlzLmNzZXE7XG4gICAgdGhpcy5yZXF1ZXN0LnNldEhlYWRlcignY3NlcScsIHRoaXMuY3NlcSArICcgUkVHSVNURVInKTtcbiAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgIHRoaXMuc2VuZCgpO1xuICB9LFxuXG4gIHJlZ2lzdHJhdGlvbkZhaWx1cmU6IGZ1bmN0aW9uIChyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlIHx8IG51bGwsIGNhdXNlIHx8IG51bGwpO1xuICB9LFxuXG4gIG9uVHJhbnNwb3J0Q2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRfYmVmb3JlID0gdGhpcy5yZWdpc3RlcmVkO1xuICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMucmVnaXN0ZXJlZCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblRyYW5zcG9ydENvbm5lY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWdpc3Rlcih0aGlzLm9wdGlvbnMpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGFsbDogZmFsc2UsXG4gICAgICBleHRyYUhlYWRlcnM6IHRoaXMuY2xvc2VIZWFkZXJzXG4gICAgfTtcblxuICAgIHRoaXMucmVnaXN0ZXJlZF9iZWZvcmUgPSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgdGhpcy51bnJlZ2lzdGVyKG9wdGlvbnMpO1xuICB9LFxuXG4gIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZXh0cmFIZWFkZXJzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZighdGhpcy5yZWdpc3RlcmVkICYmICFvcHRpb25zLmFsbCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignYWxyZWFkeSB1bnJlZ2lzdGVyZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIENsZWFyIHRoZSByZWdpc3RyYXRpb24gdGltZXIuXG4gICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uVGltZXIgIT09IG51bGwpIHtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVnaXN0cmF0aW9uVGltZXIpO1xuICAgICAgdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYob3B0aW9ucy5hbGwpIHtcbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAqJyk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnRXhwaXJlczogMCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0ICsgJztleHBpcmVzPTAnKTtcbiAgICB9XG5cblxuICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciBjYXVzZTtcblxuICAgICAgc3dpdGNoKHRydWUpIHtcbiAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdGVkJywgcmVzcG9uc2UpO1xuICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZChyZXNwb25zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICAgICAgdGhpcy51bnJlZ2lzdGVyZWQocmVzcG9uc2UsY2F1c2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSB1bnJlZ2lzdGVyZWQuLi5cbiAgICAgIC8vdGhpcy51bnJlZ2lzdGVyZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfTtcblxuICAgIHRoaXMub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IHVucmVnaXN0ZXJlZC4uLlxuICAgICAgLy90aGlzLnVucmVnaXN0ZXJlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfTtcblxuICAgIHRoaXMuY3NlcSsrO1xuICAgIHRoaXMucmVxdWVzdC5jc2VxID0gdGhpcy5jc2VxO1xuICAgIHRoaXMucmVxdWVzdC5zZXRIZWFkZXIoJ2NzZXEnLCB0aGlzLmNzZXEgKyAnIFJFR0lTVEVSJyk7XG4gICAgdGhpcy5yZXF1ZXN0LmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcblxuICAgIHRoaXMuc2VuZCgpO1xuICB9LFxuXG4gIHVucmVnaXN0ZXJlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCd1bnJlZ2lzdGVyZWQnLCByZXNwb25zZSB8fCBudWxsLCBjYXVzZSB8fCBudWxsKTtcbiAgfVxuXG59O1xuXG5cblNJUC5SZWdpc3RlckNvbnRleHQgPSBSZWdpc3RlckNvbnRleHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9SZWdpc3RlckNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1lZGlhSGFuZGxlclxuICovXG5cbi8qIE1lZGlhSGFuZGxlclxuICogQGNsYXNzIFBlZXJDb25uZWN0aW9uIGhlbHBlciBDbGFzcy5cbiAqIEBwYXJhbSB7U0lQLlNlc3Npb259IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoRXZlbnRFbWl0dGVyKSB7XG52YXIgTWVkaWFIYW5kbGVyID0gZnVuY3Rpb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAvLyBrZWVwIGpzaGludCBoYXBweVxuICBzZXNzaW9uID0gc2Vzc2lvbjtcbiAgb3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5NZWRpYUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gIGlzUmVhZHk6IHt2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeSAoKSB7fX0sXG5cbiAgY2xvc2U6IHt2YWx1ZTogZnVuY3Rpb24gY2xvc2UgKCkge319LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW21lZGlhSGludF0gQSBjdXN0b20gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG1lZGlhIHRvIGJlIHVzZWQgZHVyaW5nIHRoaXMgc2Vzc2lvbi5cbiAgICovXG4gIGdldERlc2NyaXB0aW9uOiB7dmFsdWU6IGZ1bmN0aW9uIGdldERlc2NyaXB0aW9uIChtZWRpYUhpbnQpIHtcbiAgICAvLyBrZWVwIGpzaGludCBoYXBweVxuICAgIG1lZGlhSGludCA9IG1lZGlhSGludDtcbiAgfX0sXG5cbiAgLyoqXG4gICogTWVzc2FnZSByZWNlcHRpb24uXG4gICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb25cbiAgKi9cbiAgc2V0RGVzY3JpcHRpb246IHt2YWx1ZTogZnVuY3Rpb24gc2V0RGVzY3JpcHRpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8ga2VlcCBqc2hpbnQgaGFwcHlcbiAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9fVxufSk7XG5cbnJldHVybiBNZWRpYUhhbmRsZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9NZWRpYUhhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0lQKSB7XG52YXIgQ2xpZW50Q29udGV4dDtcblxuQ2xpZW50Q29udGV4dCA9IGZ1bmN0aW9uICh1YSwgbWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuXG4gIC8vIFZhbGlkYXRlIGFyZ3VtZW50c1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICB9XG5cbiAgdGhpcy51YSA9IHVhO1xuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLmNsaWVudGNvbnRleHQnKTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRhcmdldCA9IHVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OiAnICsgb3JpZ2luYWxUYXJnZXQpO1xuICB9XG5cbiAgLyogT3B0aW9uc1xuICAgKiAtIGV4dHJhSGVhZGVyc1xuICAgKiAtIHBhcmFtc1xuICAgKiAtIGNvbnRlbnRUeXBlXG4gICAqIC0gYm9keVxuICAgKi9cbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG5cbiAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUpIHtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyB0aGlzLmNvbnRlbnRUeXBlKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSByZXF1ZXN0XG4gIHRoaXMucmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyk7XG4gIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgdGhpcy5yZXF1ZXN0LmJvZHkgPSB0aGlzLmJvZHk7XG4gIH1cblxuICAvKiBTZXQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSByZXF1ZXN0ICovXG4gIHRoaXMubG9jYWxJZGVudGl0eSA9IHRoaXMucmVxdWVzdC5mcm9tO1xuICB0aGlzLnJlbW90ZUlkZW50aXR5ID0gdGhpcy5yZXF1ZXN0LnRvO1xuXG4gIHRoaXMuZGF0YSA9IHt9O1xufTtcbkNsaWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIChuZXcgU0lQLlJlcXVlc3RTZW5kZXIodGhpcywgdGhpcy51YSkpLnNlbmQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5DbGllbnRDb250ZXh0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY2FuY2VsX3JlYXNvbiA9IFNJUC5VdGlscy5nZXRDYW5jZWxSZWFzb24ob3B0aW9ucy5zdGF0dXNfY29kZSwgb3B0aW9ucy5yZWFzb25fcGhyYXNlKTtcbiAgdGhpcy5yZXF1ZXN0LmNhbmNlbChjYW5jZWxfcmVhc29uKTtcblxuICB0aGlzLmVtaXQoJ2NhbmNlbCcpO1xufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBjYXVzZSA9IFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UocmVzcG9uc2Uuc3RhdHVzX2NvZGUpO1xuXG4gIHN3aXRjaCh0cnVlKSB7XG4gICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgIGlmKHRoaXMudWEuYXBwbGljYW50c1t0aGlzXSkge1xuICAgICAgICBkZWxldGUgdGhpcy51YS5hcHBsaWNhbnRzW3RoaXNdO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZih0aGlzLnVhLmFwcGxpY2FudHNbdGhpc10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudWEuYXBwbGljYW50c1t0aGlzXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgncmVqZWN0ZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgYnJlYWs7XG4gIH1cblxufTtcblxuQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbn07XG5cbkNsaWVudENvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xufTtcblxuU0lQLkNsaWVudENvbnRleHQgPSBDbGllbnRDb250ZXh0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvQ2xpZW50Q29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcbnZhciBTZXJ2ZXJDb250ZXh0O1xuXG5TZXJ2ZXJDb250ZXh0ID0gZnVuY3Rpb24gKHVhLCByZXF1ZXN0KSB7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zZXJ2ZXJjb250ZXh0Jyk7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBTSVAuVHJhbnNhY3Rpb25zLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHVhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IFNJUC5UcmFuc2FjdGlvbnMuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ocmVxdWVzdCwgdWEpO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgfVxuICBpZiAocmVxdWVzdC5oYXNIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKSB7XG4gICAgdGhpcy5jb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgfVxuICB0aGlzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuXG4gIHRoaXMuZGF0YSA9IHt9O1xuXG4gIHRoaXMubG9jYWxJZGVudGl0eSA9IHJlcXVlc3QudG87XG4gIHRoaXMucmVtb3RlSWRlbnRpdHkgPSByZXF1ZXN0LmZyb207XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAob3B0aW9ucy5zdGF0dXNDb2RlID0gMTgwKTtcbiAgb3B0aW9ucy5taW5Db2RlID0gMTAwO1xuICBvcHRpb25zLm1heENvZGUgPSAxOTk7XG4gIG9wdGlvbnMuZXZlbnRzID0gWydwcm9ncmVzcyddO1xuICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAob3B0aW9ucy5zdGF0dXNDb2RlID0gMjAwKTtcbiAgb3B0aW9ucy5taW5Db2RlID0gMjAwO1xuICBvcHRpb25zLm1heENvZGUgPSAyOTk7XG4gIG9wdGlvbnMuZXZlbnRzID0gWydhY2NlcHRlZCddO1xuICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAob3B0aW9ucy5zdGF0dXNDb2RlID0gNDgwKTtcbiAgb3B0aW9ucy5taW5Db2RlID0gMzAwO1xuICBvcHRpb25zLm1heENvZGUgPSA2OTk7XG4gIG9wdGlvbnMuZXZlbnRzID0gWydyZWplY3RlZCcsICdmYWlsZWQnXTtcbiAgcmV0dXJuIHRoaXMucmVwbHkob3B0aW9ucyk7XG59O1xuXG5TZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5yZXBseSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBUaGlzIGlzIG9rYXksIHNvIGxvbmcgYXMgd2UgdHJlYXQgb3B0aW9ucyBhcyByZWFkLW9ubHkgaW4gdGhpcyBtZXRob2RcbiAgdmFyXG4gICAgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxMDAsXG4gICAgbWluQ29kZSA9IG9wdGlvbnMubWluQ29kZSB8fCAxMDAsXG4gICAgbWF4Q29kZSA9IG9wdGlvbnMubWF4Q29kZSB8fCA2OTksXG4gICAgcmVhc29uUGhyYXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShzdGF0dXNDb2RlLCBvcHRpb25zLnJlYXNvblBocmFzZSksXG4gICAgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10sXG4gICAgYm9keSA9IG9wdGlvbnMuYm9keSxcbiAgICBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCBbXSxcbiAgICByZXNwb25zZTtcblxuICBpZiAoc3RhdHVzQ29kZSA8IG1pbkNvZGUgfHwgc3RhdHVzQ29kZSA+IG1heENvZGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c0NvZGU6ICcgKyBzdGF0dXNDb2RlKTtcbiAgfVxuICByZXNwb25zZSA9IHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZW1pdChldmVudCwgcmVzcG9uc2UsIHJlYXNvblBocmFzZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdmYWlsZWQnLCBudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbn07XG5cblNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xufTtcblxuU0lQLlNlcnZlckNvbnRleHQgPSBTZXJ2ZXJDb250ZXh0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvU2VydmVyQ29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG5cbnZhciBEVE1GID0gcmVxdWlyZSgnLi9TZXNzaW9uL0RUTUYnKShTSVApO1xuXG52YXIgU2Vzc2lvbiwgSW52aXRlU2VydmVyQ29udGV4dCwgSW52aXRlQ2xpZW50Q29udGV4dCxcbiBDID0ge1xuICAgIC8vU2Vzc2lvbiBzdGF0ZXNcbiAgICBTVEFUVVNfTlVMTDogICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgIFNUQVRVU19JTlZJVEVfU0VOVDogICAgICAgICAgICAgICAgIDEsXG4gICAgU1RBVFVTXzFYWF9SRUNFSVZFRDogICAgICAgICAgICAgICAgMixcbiAgICBTVEFUVVNfSU5WSVRFX1JFQ0VJVkVEOiAgICAgICAgICAgICAzLFxuICAgIFNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVI6ICAgICAgICAgIDQsXG4gICAgU1RBVFVTX0FOU1dFUkVEOiAgICAgICAgICAgICAgICAgICAgNSxcbiAgICBTVEFUVVNfV0FJVElOR19GT1JfUFJBQ0s6ICAgICAgICAgICA2LFxuICAgIFNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s6ICAgICAgICAgICAgIDcsXG4gICAgU1RBVFVTX0NBTkNFTEVEOiAgICAgICAgICAgICAgICAgICAgOCxcbiAgICBTVEFUVVNfVEVSTUlOQVRFRDogICAgICAgICAgICAgICAgICA5LFxuICAgIFNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSzogMTAsXG4gICAgU1RBVFVTX0VBUkxZX01FRElBOiAgICAgICAgICAgICAgICAxMSxcbiAgICBTVEFUVVNfQ09ORklSTUVEOiAgICAgICAgICAgICAgICAgIDEyXG4gIH07XG5cbi8qXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIHJldHVybmluZyBTSVAuTWVkaWFIYW5kbGVyfSBbbWVkaWFIYW5kbGVyRmFjdG9yeV1cbiAqICAgICAgICAoU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgbWVkaWFIYW5kbGVyRmFjdG9yeSBhcmd1bWVudCBvZiB0aGUgVUEgY29uc3RydWN0b3IuKVxuICovXG5TZXNzaW9uID0gZnVuY3Rpb24gKG1lZGlhSGFuZGxlckZhY3RvcnkpIHtcbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19OVUxMO1xuICB0aGlzLmRpYWxvZyA9IG51bGw7XG4gIHRoaXMuZWFybHlEaWFsb2dzID0ge307XG4gIHRoaXMubWVkaWFIYW5kbGVyRmFjdG9yeSA9IG1lZGlhSGFuZGxlckZhY3RvcnkgfHwgU0lQLldlYlJUQy5NZWRpYUhhbmRsZXIuZGVmYXVsdEZhY3Rvcnk7XG4gIC8vIHRoaXMubWVkaWFIYW5kbGVyIGdldHMgc2V0IGJ5IElDQy9JU0MgY29uc3RydWN0b3JzXG4gIHRoaXMuaGFzT2ZmZXIgPSBmYWxzZTtcbiAgdGhpcy5oYXNBbnN3ZXIgPSBmYWxzZTtcblxuICAvLyBTZXNzaW9uIFRpbWVyc1xuICB0aGlzLnRpbWVycyA9IHtcbiAgICBhY2tUaW1lcjogbnVsbCxcbiAgICBleHBpcmVzVGltZXI6IG51bGwsXG4gICAgaW52aXRlMnh4VGltZXI6IG51bGwsXG4gICAgdXNlck5vQW5zd2VyVGltZXI6IG51bGwsXG4gICAgcmVsMXh4VGltZXI6IG51bGwsXG4gICAgcHJhY2tUaW1lcjogbnVsbFxuICB9O1xuXG4gIC8vIFNlc3Npb24gaW5mb1xuICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gIHRoaXMudG9uZXMgPSBudWxsO1xuXG4gIC8vIE11dGUvSG9sZCBzdGF0ZVxuICB0aGlzLmxvY2FsX2hvbGQgPSBmYWxzZTtcbiAgdGhpcy5yZW1vdGVfaG9sZCA9IGZhbHNlO1xuXG4gIHRoaXMucGVuZGluZ19hY3Rpb25zID0ge1xuICAgIGFjdGlvbnM6IFtdLFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBpc1BlbmRpbmc6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgdmFyXG4gICAgICBpZHggPSAwLFxuICAgICAgbGVuZ3RoID0gdGhpcy5hY3Rpb25zLmxlbmd0aDtcblxuICAgICAgZm9yIChpZHg7IGlkeDxsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaWR4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5zaGlmdCgpO1xuICAgIH0sXG5cbiAgICBwdXNoOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFjdGlvbnMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhclxuICAgICAgaWR4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaWR4OyBpZHg8bGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zW2lkeF0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRoaXMuYWN0aW9ucy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICAgIGxlbmd0aCAtLTtcbiAgICAgICAgICBpZHgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgIH07XG5cbiAgdGhpcy5lYXJseV9zZHAgPSBudWxsO1xuICB0aGlzLnJlbDEwMCA9IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRDtcbn07XG5cblNlc3Npb24ucHJvdG90eXBlID0ge1xuICBkdG1mOiBmdW5jdGlvbih0b25lcywgb3B0aW9ucykge1xuICAgIHZhciB0b25lLCBkdG1mcyA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHRvbmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRvbmVzXG4gICAgaWYgKCh0eXBlb2YgdG9uZXMgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0b25lcyAhPT0gJ251bWJlcicpIHx8ICF0b25lcy50b1N0cmluZygpLm1hdGNoKC9eWzAtOUEtRCMqLF0rJC9pKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lczogJysgdG9uZXMpO1xuICAgIH1cblxuICAgIHRvbmVzID0gdG9uZXMudG9TdHJpbmcoKS5zcGxpdCgnJyk7XG5cbiAgICB3aGlsZSAodG9uZXMubGVuZ3RoID4gMCkgeyBkdG1mcy5wdXNoKG5ldyBEVE1GKHRoaXMsIHRvbmVzLnNoaWZ0KCksIG9wdGlvbnMpKTsgfVxuXG4gICAgaWYgKHRoaXMudG9uZXMpIHtcbiAgICAgIC8vIFRvbmVzIGFyZSBhbHJlYWR5IHF1ZXVlZCwganVzdCBhZGQgdG8gdGhlIHF1ZXVlXG4gICAgICB0aGlzLnRvbmVzID0gIHRoaXMudG9uZXMuY29uY2F0KGR0bWZzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzZW5kRFRNRiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkdG1mLCB0aW1lb3V0O1xuXG4gICAgICBpZiAoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQgfHwgIXNlbGYudG9uZXMgfHwgc2VsZi50b25lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gU3RvcCBzZW5kaW5nIERUTUZcbiAgICAgICAgc2VsZi50b25lcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBkdG1mID0gc2VsZi50b25lcy5zaGlmdCgpO1xuXG4gICAgICBpZiAodG9uZSA9PT0gJywnKSB7XG4gICAgICAgIHRpbWVvdXQgPSAyMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHRtZi5vbignZmFpbGVkJywgZnVuY3Rpb24oKXtzZWxmLnRvbmVzID0gbnVsbDt9KTtcbiAgICAgICAgZHRtZi5zZW5kKG9wdGlvbnMpO1xuICAgICAgICB0aW1lb3V0ID0gZHRtZi5kdXJhdGlvbiArIGR0bWYuaW50ZXJUb25lR2FwO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGltZW91dCBmb3IgdGhlIG5leHQgdG9uZVxuICAgICAgU0lQLlRpbWVycy5zZXRUaW1lb3V0KHNlbmREVE1GLCB0aW1lb3V0KTtcbiAgICB9O1xuXG4gICAgdGhpcy50b25lcyA9IGR0bWZzO1xuICAgIHNlbmREVE1GKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYnllOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRXJyb3I6IEF0dGVtcHRlZCB0byBzZW5kIEJZRSBpbiBhIHRlcm1pbmF0ZWQgc2Vzc2lvbi4nKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygndGVybWluYXRpbmcgU2Vzc2lvbicpO1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgJiYgKHN0YXR1c0NvZGUgPCAyMDAgfHwgc3RhdHVzQ29kZSA+PSA3MDApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c0NvZGU6ICcrIHN0YXR1c0NvZGUpO1xuICAgIH1cblxuICAgIG9wdGlvbnMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICByZXR1cm4gdGhpcy5cbiAgICAgIHNlbmRSZXF1ZXN0KFNJUC5DLkJZRSwgb3B0aW9ucykuXG4gICAgICB0ZXJtaW5hdGVkKCk7XG4gIH0sXG5cbiAgcmVmZXI6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICAgIHdpdGhSZXBsYWNlcyA9XG4gICAgICAgICAgdGFyZ2V0IGluc3RhbmNlb2YgU0lQLkludml0ZVNlcnZlckNvbnRleHQgfHxcbiAgICAgICAgICB0YXJnZXQgaW5zdGFuY2VvZiBTSVAuSW52aXRlQ2xpZW50Q29udGV4dCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICAvLyB0cmFuc2Zvcm0gYHRhcmdldGAgc28gdGhhdCBpdCBjYW4gYmUgYSBSZWZlci1UbyBoZWFkZXIgdmFsdWVcbiAgICBpZiAod2l0aFJlcGxhY2VzKSB7XG4gICAgICAvL0F0dGVuZGVkIFRyYW5zZmVyXG4gICAgICAvLyBCLnRyYW5zZmVyKEMpXG4gICAgICB0YXJnZXQgPSAnXCInICsgdGFyZ2V0LnJlbW90ZUlkZW50aXR5LmZyaWVuZGx5TmFtZSArICdcIiAnICtcbiAgICAgICAgJzwnICsgdGFyZ2V0LmRpYWxvZy5yZW1vdGVfdGFyZ2V0LnRvU3RyaW5nKCkgK1xuICAgICAgICAnP1JlcGxhY2VzPScgKyB0YXJnZXQuZGlhbG9nLmlkLmNhbGxfaWQgK1xuICAgICAgICAnJTNCdG8tdGFnJTNEJyArIHRhcmdldC5kaWFsb2cuaWQucmVtb3RlX3RhZyArXG4gICAgICAgICclM0Jmcm9tLXRhZyUzRCcgKyB0YXJnZXQuZGlhbG9nLmlkLmxvY2FsX3RhZyArICc+JztcbiAgICB9IGVsc2Uge1xuICAgICAgLy9CbGluZCBUcmFuc2ZlclxuICAgICAgLy8gbm9ybWFsaXplVGFyZ2V0IGFsbG93cyBpbnN0YW5jZXMgb2YgU0lQLlVSSSB0byBwYXNzIHRocm91Z2ggdW5hbHRlcmVkLFxuICAgICAgLy8gc28gdHJ5IHRvIG1ha2Ugb25lIGFoZWFkIG9mIHRpbWVcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhcmdldCA9IFNJUC5HcmFtbWFyLnBhcnNlKHRhcmdldCwgJ1JlZmVyX1RvJykudXJpIHx8IHRhcmdldDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCIucmVmZXIoKSBjYW5ub3QgcGFyc2UgUmVmZXJfVG8gZnJvbVwiLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIi4uLmZhbGxpbmcgdGhyb3VnaCB0byBub3JtYWxpemVUYXJnZXQoKVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGFyZ2V0IHZhbGlkaXR5XG4gICAgICB0YXJnZXQgPSB0aGlzLnVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0YXJnZXQ6ICcgKyBvcmlnaW5hbFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlZmVyLVRvOiAnKyB0YXJnZXQpO1xuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuUkVGRVIsIHtcbiAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgcmVjZWl2ZVJlc3BvbnNlOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCAhIC9eMlswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSkgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmcgdXAgb25seSBpZiB3ZSB0cmFuc2ZlcnJlZCB0byBhIFNJUCBhZGRyZXNzXG4gICAgICAgIGlmICh3aXRoUmVwbGFjZXMgfHwgKHRhcmdldC5zY2hlbWUgJiYgdGFyZ2V0LnNjaGVtZS5tYXRjaChcIl5zaXBzPyRcIikpKSB7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZm9sbG93UmVmZXI6IGZ1bmN0aW9uIGZvbGxvd1JlZmVyIChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiByZWZlckxpc3RlbmVyIChjYWxsYmFjaywgcmVxdWVzdCkge1xuICAgICAgLy8gb3BlbiBub24tU0lQIFVSSXMgaWYgcG9zc2libGUgYW5kIGtlZXAgc2Vzc2lvbiBvcGVuXG4gICAgICB2YXIgcmVmZXJUbyA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ3JlZmVyLXRvJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gcmVmZXJUby51cmk7XG4gICAgICBpZiAoIXRhcmdldC5zY2hlbWUubWF0Y2goXCJec2lwcz8kXCIpKSB7XG4gICAgICAgIHZhciB0YXJnZXRTdHJpbmcgPSB0YXJnZXQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZpcm9ubWVudC5vcGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBlbnZpcm9ubWVudC5vcGVuKHRhcmdldFN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInJlZmVycmVkIHRvIG5vbi1TSVAgVVJJIGJ1dCBgb3BlbmAgaXNuJ3QgaW4gdGhlIGVudmlyb25tZW50OiBcIiArIHRhcmdldFN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG5cbiAgICAgIC8qIENvcHkgdGhlIFJlcGxhY2VzIHF1ZXJ5IGludG8gYSBSZXBsYWNlcyBoZWFkZXIgKi9cbiAgICAgIC8qIFRPRE8gLSBtYWtlIHN1cmUgd2UgZG9uJ3QgY29weSBhIHBvb3JseSBmb3JtYXR0ZWQgaGVhZGVyPyAqL1xuICAgICAgdmFyIHJlcGxhY2VzID0gdGFyZ2V0LmdldEhlYWRlcignUmVwbGFjZXMnKTtcbiAgICAgIGlmIChyZXBsYWNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXBsYWNlczogJyArIGRlY29kZVVSSUNvbXBvbmVudChyZXBsYWNlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBkb24ndCBlbWJlZCBoZWFkZXJzIGludG8gUmVxdWVzdC1VUkkgb2YgSU5WSVRFXG4gICAgICB0YXJnZXQuY2xlYXJIZWFkZXJzKCk7XG5cbiAgICAgIC8qXG4gICAgICAgIEhhcm1sZXNzIHJhY2UgY29uZGl0aW9uLiAgQm90aCBzaWRlcyBvZiBSRUZFUlxuICAgICAgICBtYXkgc2VuZCBhIEJZRSwgYnV0IGluIHRoZSBlbmQgdGhlIGRpYWxvZ3MgYXJlIGRlc3Ryb3llZC5cbiAgICAgICovXG4gICAgICB2YXIgZ2V0UmVmZXJNZWRpYSA9IHRoaXMubWVkaWFIYW5kbGVyLmdldFJlZmVyTWVkaWE7XG4gICAgICB2YXIgbWVkaWFIaW50ID0gZ2V0UmVmZXJNZWRpYSA/IGdldFJlZmVyTWVkaWEuY2FsbCh0aGlzLm1lZGlhSGFuZGxlcikgOiB0aGlzLm1lZGlhSGludDtcblxuICAgICAgU0lQLkhhY2tzLkNocm9tZS5nZXRzQ29uZnVzZWRBYm91dEdVTSh0aGlzKTtcblxuICAgICAgdmFyIHJlZmVyU2Vzc2lvbiA9IHRoaXMudWEuaW52aXRlKHRhcmdldCwge1xuICAgICAgICBtZWRpYTogbWVkaWFIaW50LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB0b19kaXNwbGF5TmFtZTogcmVmZXJUby5mcmllbmRseU5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnNcbiAgICAgIH0pO1xuXG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHJlcXVlc3QsIHJlZmVyU2Vzc2lvbik7XG5cbiAgICAgIHRoaXMudGVybWluYXRlKCk7XG4gICAgfS5iaW5kKHRoaXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBzZW5kUmVxdWVzdDogZnVuY3Rpb24obWV0aG9kLG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgbWV0aG9kLFxuICAgICAgdGhpcy5kaWFsb2cucmVtb3RlX3RhcmdldCxcbiAgICAgIHRoaXMudWEsXG4gICAgICB7XG4gICAgICAgIGNzZXE6IG9wdGlvbnMuY3NlcSB8fCAodGhpcy5kaWFsb2cubG9jYWxfc2VxbnVtICs9IDEpLFxuICAgICAgICBjYWxsX2lkOiB0aGlzLmRpYWxvZy5pZC5jYWxsX2lkLFxuICAgICAgICBmcm9tX3VyaTogdGhpcy5kaWFsb2cubG9jYWxfdXJpLFxuICAgICAgICBmcm9tX3RhZzogdGhpcy5kaWFsb2cuaWQubG9jYWxfdGFnLFxuICAgICAgICB0b191cmk6IHRoaXMuZGlhbG9nLnJlbW90ZV91cmksXG4gICAgICAgIHRvX3RhZzogdGhpcy5kaWFsb2cuaWQucmVtb3RlX3RhZyxcbiAgICAgICAgcm91dGVfc2V0OiB0aGlzLmRpYWxvZy5yb3V0ZV9zZXQsXG4gICAgICAgIHN0YXR1c0NvZGU6IG9wdGlvbnMuc3RhdHVzQ29kZSxcbiAgICAgICAgcmVhc29uUGhyYXNlOiBvcHRpb25zLnJlYXNvblBocmFzZVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdLFxuICAgICAgb3B0aW9ucy5ib2R5XG4gICAgKTtcblxuICAgIG5ldyBTSVAuUmVxdWVzdFNlbmRlcih7XG4gICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgfSxcbiAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICAgIH0sXG4gICAgICByZWNlaXZlUmVzcG9uc2U6IG9wdGlvbnMucmVjZWl2ZVJlc3BvbnNlIHx8IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYucmVjZWl2ZU5vbkludml0ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnVhKS5zZW5kKCk7XG5cbiAgICAvLyBFbWl0IHRoZSByZXF1ZXN0IGV2ZW50XG4gICAgdGhpcy5lbWl0KG1ldGhvZC50b0xvd2VyQ2FzZSgpLCByZXF1ZXN0KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWR4O1xuXG4gICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBJTlZJVEUgc2Vzc2lvbiAnICsgdGhpcy5pZCk7XG5cbiAgICAvLyAxc3QgU3RlcC4gVGVybWluYXRlIG1lZGlhLlxuICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlcil7XG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8vIDJuZCBTdGVwLiBUZXJtaW5hdGUgc2lnbmFsaW5nLlxuXG4gICAgLy8gQ2xlYXIgc2Vzc2lvbiB0aW1lcnNcbiAgICBmb3IoaWR4IGluIHRoaXMudGltZXJzKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc1tpZHhdKTtcbiAgICB9XG5cbiAgICAvLyBUZXJtaW5hdGUgZGlhbG9nc1xuXG4gICAgLy8gVGVybWluYXRlIGNvbmZpcm1lZCBkaWFsb2dcbiAgICBpZih0aGlzLmRpYWxvZykge1xuICAgICAgdGhpcy5kaWFsb2cudGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5kaWFsb2c7XG4gICAgfVxuXG4gICAgLy8gVGVybWluYXRlIGVhcmx5IGRpYWxvZ3NcbiAgICBmb3IoaWR4IGluIHRoaXMuZWFybHlEaWFsb2dzKSB7XG4gICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZHhdLnRlcm1pbmF0ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZWFybHlEaWFsb2dzW2lkeF07XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19URVJNSU5BVEVEO1xuXG4gICAgZGVsZXRlIHRoaXMudWEuc2Vzc2lvbnNbdGhpcy5pZF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY3JlYXRlRGlhbG9nOiBmdW5jdGlvbihtZXNzYWdlLCB0eXBlLCBlYXJseSkge1xuICAgIHZhciBkaWFsb2csIGVhcmx5X2RpYWxvZyxcbiAgICAgIGxvY2FsX3RhZyA9IG1lc3NhZ2VbKHR5cGUgPT09ICdVQVMnKSA/ICd0b190YWcnIDogJ2Zyb21fdGFnJ10sXG4gICAgICByZW1vdGVfdGFnID0gbWVzc2FnZVsodHlwZSA9PT0gJ1VBUycpID8gJ2Zyb21fdGFnJyA6ICd0b190YWcnXSxcbiAgICAgIGlkID0gbWVzc2FnZS5jYWxsX2lkICsgbG9jYWxfdGFnICsgcmVtb3RlX3RhZztcblxuICAgIGVhcmx5X2RpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzW2lkXTtcblxuICAgIC8vIEVhcmx5IERpYWxvZ1xuICAgIGlmIChlYXJseSkge1xuICAgICAgaWYgKGVhcmx5X2RpYWxvZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhcmx5X2RpYWxvZyA9IG5ldyBTSVAuRGlhbG9nKHRoaXMsIG1lc3NhZ2UsIHR5cGUsIFNJUC5EaWFsb2cuQy5TVEFUVVNfRUFSTFkpO1xuXG4gICAgICAgIC8vIERpYWxvZyBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cbiAgICAgICAgaWYoZWFybHlfZGlhbG9nLmVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZWFybHlfZGlhbG9nLmVycm9yKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChtZXNzYWdlLCBTSVAuQy5jYXVzZXMuSU5URVJOQUxfRVJST1IpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0gPSBlYXJseV9kaWFsb2c7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29uZmlybWVkIERpYWxvZ1xuICAgIGVsc2Uge1xuICAgICAgLy8gSW4gY2FzZSB0aGUgZGlhbG9nIGlzIGluIF9lYXJseV8gc3RhdGUsIHVwZGF0ZSBpdFxuICAgICAgaWYgKGVhcmx5X2RpYWxvZykge1xuICAgICAgICBlYXJseV9kaWFsb2cudXBkYXRlKG1lc3NhZ2UsIHR5cGUpO1xuICAgICAgICB0aGlzLmRpYWxvZyA9IGVhcmx5X2RpYWxvZztcbiAgICAgICAgZGVsZXRlIHRoaXMuZWFybHlEaWFsb2dzW2lkXTtcbiAgICAgICAgZm9yICh2YXIgZGlhIGluIHRoaXMuZWFybHlEaWFsb2dzKSB7XG4gICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbZGlhXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5lYXJseURpYWxvZ3NbZGlhXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBfY29uZmlybWVkXyBkaWFsb2dcbiAgICAgIGRpYWxvZyA9IG5ldyBTSVAuRGlhbG9nKHRoaXMsIG1lc3NhZ2UsIHR5cGUpO1xuXG4gICAgICBpZihkaWFsb2cuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZGlhbG9nLmVycm9yKTtcbiAgICAgICAgdGhpcy5mYWlsZWQobWVzc2FnZSwgU0lQLkMuY2F1c2VzLklOVEVSTkFMX0VSUk9SKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b190YWcgPSBtZXNzYWdlLnRvX3RhZztcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBDaGVjayBpZiBTZXNzaW9uIGlzIHJlYWR5IGZvciBhIHJlLUlOVklURVxuICAqXG4gICogQHJldHVybnMge0Jvb2xlYW59XG4gICovXG4gIGlzUmVhZHlUb1JlaW52aXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZWRpYUhhbmRsZXIuaXNSZWFkeSgpICYmXG4gICAgICAhdGhpcy5kaWFsb2cudWFjX3BlbmRpbmdfcmVwbHkgJiZcbiAgICAgICF0aGlzLmRpYWxvZy51YXNfcGVuZGluZ19yZXBseTtcbiAgfSxcblxuICAvKipcbiAgICogTXV0ZVxuICAgKi9cbiAgbXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciByZXQgPSB0aGlzLm1lZGlhSGFuZGxlci5tdXRlKG9wdGlvbnMpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMub25tdXRlKHJldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm11dGVcbiAgICovXG4gIHVubXV0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciByZXQgPSB0aGlzLm1lZGlhSGFuZGxlci51bm11dGUob3B0aW9ucyk7XG4gICAgaWYgKHJldCkge1xuICAgICAgdGhpcy5vbnVubXV0ZShyZXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSG9sZFxuICAgKi9cbiAgaG9sZDogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhSGFuZGxlci5ob2xkKCk7XG5cbiAgICAvLyBDaGVjayBpZiBSVENTZXNzaW9uIGlzIHJlYWR5IHRvIHNlbmQgYSByZUlOVklURVxuICAgIGlmICghdGhpcy5pc1JlYWR5VG9SZWludml0ZSgpKSB7XG4gICAgICAvKiBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgJ3VuaG9sZCcgYWN0aW9uLCBjYW5jZWwgaXQgYW5kIGRvbid0IHF1ZXVlIHRoaXMgb25lXG4gICAgICAgKiBFbHNlLCBpZiB0aGVyZSBpc24ndCBhbnkgJ2hvbGQnIGFjdGlvbiwgYWRkIHRoaXMgb25lIHRvIHRoZSBxdWV1ZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXMgYWxyZWFkeSBhICdob2xkJyBhY3Rpb24sIHNraXBcbiAgICAgICAqL1xuICAgICAgaWYgKHRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygndW5ob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucG9wKCd1bmhvbGQnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGVuZGluZ19hY3Rpb25zLmlzUGVuZGluZygnaG9sZCcpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ19hY3Rpb25zLnB1c2goJ2hvbGQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxfaG9sZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbmhvbGQoJ2xvY2FsJyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm1hbmdsZSA9IGZ1bmN0aW9uKGJvZHkpe1xuXG4gICAgICAvLyBEb24ndCByZWNlaXZlIG1lZGlhXG4gICAgICAvLyBUT0RPIC0gVGhpcyB3aWxsIGJyZWFrIGZvciBtZWRpYSBzdHJlYW1zIHdpdGggZGlmZmVyZW50IGRpcmVjdGlvbnMuXG4gICAgICBpZiAoISgvYT0oc2VuZHJlY3Z8c2VuZG9ubHl8cmVjdm9ubHl8aW5hY3RpdmUpLykudGVzdChib2R5KSkge1xuICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKC8obT1bXlxccl0qXFxyXFxuKS9nLCAnJDFhPXNlbmRvbmx5XFxyXFxuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKC9hPXNlbmRyZWN2XFxyXFxuL2csICdhPXNlbmRvbmx5XFxyXFxuJyk7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL2E9cmVjdm9ubHlcXHJcXG4vZywgJ2E9aW5hY3RpdmVcXHJcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcblxuICAgIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbmhvbGRcbiAgICovXG4gIHVuaG9sZDogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhSGFuZGxlci51bmhvbGQoKTtcblxuICAgIGlmICghdGhpcy5pc1JlYWR5VG9SZWludml0ZSgpKSB7XG4gICAgICAvKiBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgJ2hvbGQnIGFjdGlvbiwgY2FuY2VsIGl0IGFuZCBkb24ndCBxdWV1ZSB0aGlzIG9uZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXNuJ3QgYW55ICd1bmhvbGQnIGFjdGlvbiwgYWRkIHRoaXMgb25lIHRvIHRoZSBxdWV1ZVxuICAgICAgICogRWxzZSwgaWYgdGhlcmUgaXMgYWxyZWFkeSBhICd1bmhvbGQnIGFjdGlvbiwgc2tpcFxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2FjdGlvbnMuaXNQZW5kaW5nKCdob2xkJykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2FjdGlvbnMucG9wKCdob2xkJyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdfYWN0aW9ucy5pc1BlbmRpbmcoJ3VuaG9sZCcpKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ19hY3Rpb25zLnB1c2goJ3VuaG9sZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbF9ob2xkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub251bmhvbGQoJ2xvY2FsJyk7XG5cbiAgICB0aGlzLnNlbmRSZWludml0ZShvcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogaXNPbkhvbGRcbiAgICovXG4gIGlzT25Ib2xkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYWw6IHRoaXMubG9jYWxfaG9sZCxcbiAgICAgIHJlbW90ZTogdGhpcy5yZW1vdGVfaG9sZFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluIGRpYWxvZyBJTlZJVEUgUmVjZXB0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWNlaXZlUmVpbnZpdGU6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXJlcXVlc3QuYm9keSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJykgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbnZhbGlkIENvbnRlbnQtVHlwZScpO1xuICAgICAgcmVxdWVzdC5yZXBseSg0MTUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlcXVlc3QuYm9keSlcbiAgICAudGhlbih0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbi5iaW5kKHRoaXMubWVkaWFIYW5kbGVyLCB0aGlzLm1lZGlhSGludCkpXG4gICAgLnRoZW4oZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmVxdWVzdC5yZXBseSgyMDAsIG51bGwsIFsnQ29udGFjdDogJyArIHNlbGYuY29udGFjdF0sIGJvZHksXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLO1xuICAgICAgICAgIHNlbGYuc2V0SW52aXRlMnh4VGltZXIocmVxdWVzdCwgYm9keSk7XG4gICAgICAgICAgc2VsZi5zZXRBQ0tUaW1lcigpO1xuXG4gICAgICAgICAgLy8gQXJlIHdlIGhvbGRpbmc/XG4gICAgICAgICAgdmFyIGhvbGQgPSAoL2E9KHNlbmRvbmx5fGluYWN0aXZlKS8pLnRlc3QocmVxdWVzdC5ib2R5KTtcblxuICAgICAgICAgIGlmIChzZWxmLnJlbW90ZV9ob2xkICYmICFob2xkKSB7XG4gICAgICAgICAgICBzZWxmLm9udW5ob2xkKCdyZW1vdGUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzZWxmLnJlbW90ZV9ob2xkICYmIGhvbGQpIHtcbiAgICAgICAgICAgIHNlbGYub25ob2xkKCdyZW1vdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLmNhdGNoKGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgdmFyIHN0YXR1c0NvZGU7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNJUC5FeGNlcHRpb25zLkdldERlc2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICBzdGF0dXNDb2RlID0gNDg4O1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5yZXBseShzdGF0dXNDb2RlKTtcbiAgICB9KTtcbiAgfSxcblxuICBzZW5kUmVpbnZpdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhclxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICBldmVudEhhbmRsZXJzID0gb3B0aW9ucy5ldmVudEhhbmRsZXJzIHx8IHt9LFxuICAgICAgbWFuZ2xlID0gb3B0aW9ucy5tYW5nbGUgfHwgbnVsbCxcbiAgICAgIHN1Y2NlZWRlZDtcblxuICAgIGlmIChldmVudEhhbmRsZXJzLnN1Y2NlZWRlZCkge1xuICAgICAgc3VjY2VlZGVkID0gZXZlbnRIYW5kbGVycy5zdWNjZWVkZWQ7XG4gICAgfVxuICAgIHRoaXMucmVpbnZpdGVTdWNjZWVkZWQgPSBmdW5jdGlvbigpe1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi50aW1lcnMuYWNrVGltZXIpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICBzdWNjZWVkZWQgJiYgc3VjY2VlZGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBpZiAoZXZlbnRIYW5kbGVycy5mYWlsZWQpIHtcbiAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQgPSBldmVudEhhbmRsZXJzLmZhaWxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJyArIHRoaXMuY29udGFjdCk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJyk7XG5cbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IHRoaXMucmVjZWl2ZVJlaW52aXRlUmVzcG9uc2U7XG4gICAgLy9SRVZJU0lUXG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oc2VsZi5tZWRpYUhpbnQpXG4gICAgLnRoZW4obWFuZ2xlKVxuICAgIC50aGVuKFxuICAgICAgZnVuY3Rpb24oYm9keSl7XG4gICAgICAgIHNlbGYuZGlhbG9nLnNlbmRSZXF1ZXN0KHNlbGYsIFNJUC5DLklOVklURSwge1xuICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLmlzUmVhZHlUb1JlaW52aXRlKCkpIHtcbiAgICAgICAgICBzZWxmLm9uUmVhZHlUb1JlaW52aXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgfVxuICAgICk7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgY2FzZSBTSVAuQy5CWUU6XG4gICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnYnllJywgcmVxdWVzdCk7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CWUUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlLUlOVklURSByZWNlaXZlZCcpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZVJlaW52aXRlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5JTkZPOlxuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEIHx8IHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgICB2YXIgYm9keSwgdG9uZSwgZHVyYXRpb24sXG4gICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpLFxuICAgICAgICAgICAgICByZWdfdG9uZSA9IC9eKFNpZ25hbFxccyo/PVxccyo/KShbMC05QS1EIypdezF9KShcXHMpPy4qLyxcbiAgICAgICAgICAgICAgcmVnX2R1cmF0aW9uID0gL14oRHVyYXRpb25cXHM/PVxccz8pKFswLTldezEsNH0pKFxccyk/LiovO1xuXG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUubWF0Y2goL15hcHBsaWNhdGlvblxcL2R0bWYtcmVsYXkvaSkpIHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSByZXF1ZXN0LmJvZHkuc3BsaXQoJ1xcclxcbicsIDIpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlZ190b25lLnRlc3QoYm9keVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9uZSA9IGJvZHlbMF0ucmVwbGFjZShyZWdfdG9uZSxcIiQyXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlZ19kdXJhdGlvbi50ZXN0KGJvZHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcGFyc2VJbnQoYm9keVsxXS5yZXBsYWNlKHJlZ19kdXJhdGlvbixcIiQyXCIpLCAxMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3IERUTUYodGhpcywgdG9uZSwge2R1cmF0aW9uOiBkdXJhdGlvbn0pLmluaXRfaW5jb21pbmcocmVxdWVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQxNSwgbnVsbCwgW1wiQWNjZXB0OiBhcHBsaWNhdGlvbi9kdG1mLXJlbGF5XCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLlJFRkVSOlxuICAgICAgICBpZih0aGlzLnN0YXR1cyA9PT0gIEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygnUkVGRVIgcmVjZWl2ZWQnKTtcbiAgICAgICAgICB2YXIgaGFzUmVmZXJMaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzKCdyZWZlcicpLmxlbmd0aCxcbiAgICAgICAgICAgICAgbm90aWZ5Qm9keTtcblxuICAgICAgICAgIGlmIChoYXNSZWZlckxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5KDIwMiwgJ0FjY2VwdGVkJyk7XG4gICAgICAgICAgICBub3RpZnlCb2R5ID0gJ1NJUC8yLjAgMTAwIFRyeWluZyc7XG5cbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuTk9USUZZLCB7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVyczpbXG4gICAgICAgICAgICAgICAgJ0V2ZW50OiByZWZlcicsXG4gICAgICAgICAgICAgICAgJ1N1YnNjcmlwdGlvbi1TdGF0ZTogdGVybWluYXRlZCcsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZTogbWVzc2FnZS9zaXBmcmFnJ1xuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBib2R5OiBub3RpZnlCb2R5LFxuICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlZmVyJywgcmVxdWVzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJGQyAzNTE1LjIuNC4yOiAndGhlIFVBIE1BWSBkZWNsaW5lIHRoZSByZXF1ZXN0LidcbiAgICAgICAgICAgIHJlcXVlc3QucmVwbHkoNjAzLCAnRGVjbGluZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLk5PVElGWTpcbiAgICAgICAgcmVxdWVzdC5yZXBseSgyMDAsICdPSycpO1xuICAgICAgICB0aGlzLmVtaXQoJ25vdGlmeScsIHJlcXVlc3QpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VwdGlvbiBvZiBSZXNwb25zZSBmb3IgaW4tZGlhbG9nIElOVklURVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVjZWl2ZVJlaW52aXRlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2godHJ1ZSkge1xuICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG5cbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse2NzZXE6cmVzcG9uc2UuY3NlcX0pO1xuXG4gICAgICAgIGlmKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vc2RwJykge1xuICAgICAgICAgIHRoaXMucmVpbnZpdGVGYWlsZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vUkVWSVNJVFxuICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5KVxuICAgICAgICAudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgc2VsZi5yZWludml0ZVN1Y2NlZWRlZCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVpbnZpdGVGYWlsZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yZWludml0ZUZhaWxlZCgpO1xuICAgIH1cbiAgfSxcblxuICBhY2NlcHRBbmRUZXJtaW5hdGU6IGZ1bmN0aW9uKHJlc3BvbnNlLCBzdGF0dXNfY29kZSwgcmVhc29uX3BocmFzZSkge1xuICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcblxuICAgIGlmIChzdGF0dXNfY29kZSkge1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JlYXNvbjogJyArIFNJUC5VdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZShzdGF0dXNfY29kZSwgcmVhc29uX3BocmFzZSkpO1xuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIG9uIGRpYWxvZyBjcmVhdGlvbiB3aWxsIGZpcmUgJ2ZhaWxlZCcgZXZlbnRcbiAgICBpZiAodGhpcy5kaWFsb2cgfHwgdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse2NzZXE6IHJlc3BvbnNlLmNzZXF9KTtcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3QoU0lQLkMuQllFLCB7XG4gICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUkZDMzI2MSAxMy4zLjEuNFxuICAgKiBSZXNwb25zZSByZXRyYW5zbWlzc2lvbnMgY2Fubm90IGJlIGFjY29tcGxpc2hlZCBieSB0cmFuc2FjdGlvbiBsYXllclxuICAgKiAgc2luY2UgaXQgaXMgZGVzdHJveWVkIHdoZW4gcmVjZWl2aW5nIHRoZSBmaXJzdCAyeHggYW5zd2VyXG4gICAqL1xuICBzZXRJbnZpdGUyeHhUaW1lcjogZnVuY3Rpb24ocmVxdWVzdCwgYm9keSkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdGltZW91dCA9IFNJUC5UaW1lcnMuVDE7XG5cbiAgICB0aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiBpbnZpdGUyeHhSZXRyYW5zbWlzc2lvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXR1cyAhPT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5sb2dnZXIubG9nKCdubyBBQ0sgcmVjZWl2ZWQsIGF0dGVtcHRpbmcgdG8gcmV0cmFuc21pdCBPSycpO1xuXG4gICAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgWydDb250YWN0OiAnICsgc2VsZi5jb250YWN0XSwgYm9keSk7XG5cbiAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0ICogMiwgU0lQLlRpbWVycy5UMik7XG5cbiAgICAgIHNlbGYudGltZXJzLmludml0ZTJ4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGludml0ZTJ4eFJldHJhbnNtaXNzaW9uLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSxcblxuICAvKipcbiAgICogUkZDMzI2MSAxNC4yXG4gICAqIElmIGEgVUFTIGdlbmVyYXRlcyBhIDJ4eCByZXNwb25zZSBhbmQgbmV2ZXIgcmVjZWl2ZXMgYW4gQUNLLFxuICAgKiAgaXQgU0hPVUxEIGdlbmVyYXRlIGEgQllFIHRvIHRlcm1pbmF0ZSB0aGUgZGlhbG9nLlxuICAgKi9cbiAgc2V0QUNLVGltZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMudGltZXJzLmFja1RpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYoc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ25vIEFDSyByZWNlaXZlZCBmb3IgYW4gZXh0ZW5kZWQgcGVyaW9kIG9mIHRpbWUsIHRlcm1pbmF0aW5nIHRoZSBjYWxsJyk7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHNlbGYudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgICAgc2VsZi5zZW5kUmVxdWVzdChTSVAuQy5CWUUpO1xuICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLk5PX0FDSyk7XG4gICAgICB9XG4gICAgfSwgU0lQLlRpbWVycy5USU1FUl9IKTtcbiAgfSxcblxuICAvKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25SZWFkeVRvUmVpbnZpdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhY3Rpb24gPSB0aGlzLnBlbmRpbmdfYWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgaWYgKCFhY3Rpb24gfHwgIXRoaXNbYWN0aW9uLm5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1thY3Rpb24ubmFtZV0oKTtcbiAgfSxcblxuICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH1cbiAgfSxcblxuICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgIH1cbiAgfSxcblxuICBvbkRpYWxvZ0Vycm9yOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25ob2xkOiBmdW5jdGlvbihvcmlnaW5hdG9yKSB7XG4gICAgdGhpc1tvcmlnaW5hdG9yID09PSAnbG9jYWwnID8gJ2xvY2FsX2hvbGQnIDogJ3JlbW90ZV9ob2xkJ10gPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnaG9sZCcsIHsgb3JpZ2luYXRvcjogb3JpZ2luYXRvciB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9udW5ob2xkOiBmdW5jdGlvbihvcmlnaW5hdG9yKSB7XG4gICAgdGhpc1tvcmlnaW5hdG9yID09PSAnbG9jYWwnID8gJ2xvY2FsX2hvbGQnIDogJ3JlbW90ZV9ob2xkJ10gPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3VuaG9sZCcsIHsgb3JpZ2luYXRvcjogb3JpZ2luYXRvciB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25tdXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5lbWl0KCdtdXRlZCcsIHtcbiAgICAgIGF1ZGlvOiBvcHRpb25zLmF1ZGlvLFxuICAgICAgdmlkZW86IG9wdGlvbnMudmlkZW9cbiAgICB9KTtcbiAgfSxcblxuICAvKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb251bm11dGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ3VubXV0ZWQnLCB7XG4gICAgICBhdWRpbzogb3B0aW9ucy5hdWRpbyxcbiAgICAgIHZpZGVvOiBvcHRpb25zLnZpZGVvXG4gICAgfSk7XG4gIH0sXG5cbiAgZmFpbGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlIHx8IG51bGwsIGNhdXNlIHx8IG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlamVjdGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLmVtaXQoJ3JlamVjdGVkJyxcbiAgICAgIHJlc3BvbnNlIHx8IG51bGwsXG4gICAgICBjYXVzZSB8fCBudWxsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjYW5jZWxlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbWl0KCdjYW5jZWwnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBhY2NlcHRlZDogZnVuY3Rpb24ocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgY2F1c2UgPSBTSVAuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlLCBjYXVzZSk7XG5cbiAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAodGhpcy5yZXBsYWNlZSkge1xuICAgICAgdGhpcy5yZXBsYWNlZS5lbWl0KCdyZXBsYWNlZCcsIHRoaXMpO1xuICAgICAgdGhpcy5yZXBsYWNlZS50ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdGVybWluYXRlZDogZnVuY3Rpb24obWVzc2FnZSwgY2F1c2UpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJyxcbiAgICAgIG1lc3NhZ2UgfHwgbnVsbCxcbiAgICAgIGNhdXNlIHx8IG51bGxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbm5lY3Rpbmc6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnLCB7IHJlcXVlc3Q6IHJlcXVlc3QgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cblNlc3Npb24uZGVzdWdhciA9IGZ1bmN0aW9uIGRlc3VnYXIob3B0aW9ucykge1xuICBpZiAoZW52aXJvbm1lbnQuSFRNTE1lZGlhRWxlbWVudCAmJiBvcHRpb25zIGluc3RhbmNlb2YgZW52aXJvbm1lbnQuSFRNTE1lZGlhRWxlbWVudCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtZWRpYToge1xuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiBvcHRpb25zLnRhZ05hbWUgPT09ICdWSURFTydcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyOiB7XG4gICAgICAgICAgcmVtb3RlOiBvcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBvcHRpb25zIHx8IHt9O1xufTtcblxuXG5TZXNzaW9uLkMgPSBDO1xuU0lQLlNlc3Npb24gPSBTZXNzaW9uO1xuXG5cbkludml0ZVNlcnZlckNvbnRleHQgPSBmdW5jdGlvbih1YSwgcmVxdWVzdCkge1xuICB2YXIgZXhwaXJlcyxcbiAgICBzZWxmID0gdGhpcyxcbiAgICBjb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSxcbiAgICBjb250ZW50RGlzcCA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKTtcblxuICAvLyBDaGVjayBib2R5IGFuZCBjb250ZW50IHR5cGVcbiAgaWYgKCghY29udGVudERpc3AgJiYgY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB8fCAoY29udGVudERpc3AgJiYgY29udGVudERpc3AudHlwZSA9PT0gJ3JlbmRlcicpKSB7XG4gICAgdGhpcy5yZW5kZXJib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgIHRoaXMucmVuZGVydHlwZSA9IGNvbnRlbnRUeXBlO1xuICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vc2RwJyAmJiAoY29udGVudERpc3AgJiYgY29udGVudERpc3AudHlwZSA9PT0gJ3Nlc3Npb24nKSkge1xuICAgIHJlcXVlc3QucmVwbHkoNDE1KTtcbiAgICAvL1RPRE86IGluc3RlYWQgb2YgNDE1LCBwYXNzIG9mZiB0byB0aGUgbWVkaWEgaGFuZGxlciwgd2hvIGNhbiB0aGVuIGRlY2lkZSBpZiB3ZSBjYW4gdXNlIGl0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9UT0RPOiBtb3ZlIHRoaXMgaW50byBtZWRpYSBoYW5kbGVyXG4gIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXF1ZXN0KTtcbiAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlcXVlc3QpO1xuXG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5TZXJ2ZXJDb250ZXh0LCBbdWEsIHJlcXVlc3RdKTtcbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLlNlc3Npb24sIFt1YS5jb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnldKTtcblxuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0lOVklURV9SRUNFSVZFRDtcbiAgdGhpcy5mcm9tX3RhZyA9IHJlcXVlc3QuZnJvbV90YWc7XG4gIHRoaXMuaWQgPSByZXF1ZXN0LmNhbGxfaWQgKyB0aGlzLmZyb21fdGFnO1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB0aGlzLmNvbnRhY3QgPSB0aGlzLnVhLmNvbnRhY3QudG9TdHJpbmcoKTtcblxuICB0aGlzLnJlY2VpdmVOb25JbnZpdGVSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHt9OyAvLyBpbnRlbnRpb25hbCBuby1vcFxuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlc2VydmVyY29udGV4dCcsIHRoaXMuaWQpO1xuXG4gIC8vU2F2ZSB0aGUgc2Vzc2lvbiBpbnRvIHRoZSB1YSBzZXNzaW9ucyBjb2xsZWN0aW9uLlxuICB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdID0gdGhpcztcblxuICAvL0dldCB0aGUgRXhwaXJlcyBoZWFkZXIgdmFsdWUgaWYgZXhpc3RzXG4gIGlmKHJlcXVlc3QuaGFzSGVhZGVyKCdleHBpcmVzJykpIHtcbiAgICBleHBpcmVzID0gcmVxdWVzdC5nZXRIZWFkZXIoJ2V4cGlyZXMnKSAqIDEwMDA7XG4gIH1cblxuICAvL1NldCAxMDByZWwgaWYgbmVjZXNzYXJ5XG4gIGZ1bmN0aW9uIHNldDEwMHJlbChoLGMpIHtcbiAgICBpZiAocmVxdWVzdC5oYXNIZWFkZXIoaCkgJiYgcmVxdWVzdC5nZXRIZWFkZXIoaCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcxMDByZWwnKSA+PSAwKSB7XG4gICAgICBzZWxmLnJlbDEwMCA9IGM7XG4gICAgfVxuICB9XG4gIHNldDEwMHJlbCgncmVxdWlyZScsIFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCk7XG4gIHNldDEwMHJlbCgnc3VwcG9ydGVkJywgU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCk7XG5cbiAgLyogU2V0IHRoZSB0b190YWcgYmVmb3JlXG4gICAqIHJlcGx5aW5nIGEgcmVzcG9uc2UgY29kZSB0aGF0IHdpbGwgY3JlYXRlIGEgZGlhbG9nLlxuICAgKi9cbiAgcmVxdWVzdC50b190YWcgPSBTSVAuVXRpbHMubmV3VGFnKCk7XG5cbiAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICBpZighdGhpcy5jcmVhdGVEaWFsb2cocmVxdWVzdCwgJ1VBUycsIHRydWUpKSB7XG4gICAgcmVxdWVzdC5yZXBseSg1MDAsICdNaXNzaW5nIENvbnRhY3QgaGVhZGVyIGZpZWxkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9Jbml0aWFsaXplIE1lZGlhIFNlc3Npb25cbiAgdGhpcy5tZWRpYUhhbmRsZXIgPSB0aGlzLm1lZGlhSGFuZGxlckZhY3RvcnkodGhpcywge1xuICAgIFJUQ0NvbnN0cmFpbnRzOiB7XCJvcHRpb25hbFwiOiBbeydEdGxzU3J0cEtleUFncmVlbWVudCc6ICd0cnVlJ31dfVxuICB9KTtcblxuICBpZiAodGhpcy5tZWRpYUhhbmRsZXIgJiYgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcykge1xuICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRMb2NhbFN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlTmV3U2Vzc2lvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtleHRyYUhlYWRlcnM6IFsnQ29udGFjdDogJyArIHNlbGYuY29udGFjdF19O1xuXG4gICAgaWYgKHNlbGYucmVsMTAwICE9PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgIHNlbGYucHJvZ3Jlc3Mob3B0aW9ucyk7XG4gICAgfVxuICAgIHNlbGYuc3RhdHVzID0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSO1xuXG4gICAgLy8gU2V0IHVzZXJOb0Fuc3dlclRpbWVyXG4gICAgc2VsZi50aW1lcnMudXNlck5vQW5zd2VyVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICByZXF1ZXN0LnJlcGx5KDQwOCk7XG4gICAgICBzZWxmLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuTk9fQU5TV0VSKTtcbiAgICAgIHNlbGYudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuTk9fQU5TV0VSKTtcbiAgICB9LCBzZWxmLnVhLmNvbmZpZ3VyYXRpb24ubm9BbnN3ZXJUaW1lb3V0KTtcblxuICAgIC8qIFNldCBleHBpcmVzVGltZXJcbiAgICAgKiBSRkMzMjYxIDEzLjMuMVxuICAgICAqL1xuICAgIGlmIChleHBpcmVzKSB7XG4gICAgICBzZWxmLnRpbWVycy5leHBpcmVzVGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4Nyk7XG4gICAgICAgICAgc2VsZi5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkVYUElSRVMpO1xuICAgICAgICAgIHNlbGYudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuRVhQSVJFUyk7XG4gICAgICAgIH1cbiAgICAgIH0sIGV4cGlyZXMpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgnaW52aXRlJyxyZXF1ZXN0KTtcbiAgfVxuXG4gIGlmICghcmVxdWVzdC5ib2R5IHx8IHRoaXMucmVuZGVyYm9keSkge1xuICAgIFNJUC5UaW1lcnMuc2V0VGltZW91dChmaXJlTmV3U2Vzc2lvbiwgMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgIC50aGVuKFxuICAgICAgZmlyZU5ld1Nlc3Npb24sXG4gICAgICBmdW5jdGlvbiBvbkZhaWx1cmUgKGUpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybignaW52YWxpZCBTRFAnKTtcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybihlKTtcbiAgICAgICAgcmVxdWVzdC5yZXBseSg0ODgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbkludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlID0ge1xuICByZWplY3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ3JlamVjdGluZyBSVENTZXNzaW9uJyk7XG5cbiAgICBTSVAuU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMudGVybWluYXRlZCgpO1xuICB9LFxuXG4gIHRlcm1pbmF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyXG4gICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgIGJvZHkgPSBvcHRpb25zLmJvZHksXG4gICAgZGlhbG9nLFxuICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiZcbiAgICAgICB0aGlzLnJlcXVlc3Quc2VydmVyX3RyYW5zYWN0aW9uLnN0YXRlICE9PSBTSVAuVHJhbnNhY3Rpb25zLkMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIGRpYWxvZyA9IHRoaXMuZGlhbG9nO1xuXG4gICAgICB0aGlzLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFNJUC5DLkFDSykge1xuICAgICAgICAgIHRoaXMucmVxdWVzdChTSVAuQy5CWUUsIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5yZXF1ZXN0LnNlcnZlcl90cmFuc2FjdGlvbi5vbignc3RhdGVDaGFuZ2VkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNJUC5UcmFuc2FjdGlvbnMuQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdCA9IG5ldyBTSVAuT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgICAgICAgU0lQLkMuQllFLFxuICAgICAgICAgICAgdGhpcy5kaWFsb2cucmVtb3RlX3RhcmdldCxcbiAgICAgICAgICAgIHRoaXMudWEsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICdjc2VxJzogdGhpcy5kaWFsb2cubG9jYWxfc2VxbnVtKz0xLFxuICAgICAgICAgICAgICAnY2FsbF9pZCc6IHRoaXMuZGlhbG9nLmlkLmNhbGxfaWQsXG4gICAgICAgICAgICAgICdmcm9tX3VyaSc6IHRoaXMuZGlhbG9nLmxvY2FsX3VyaSxcbiAgICAgICAgICAgICAgJ2Zyb21fdGFnJzogdGhpcy5kaWFsb2cuaWQubG9jYWxfdGFnLFxuICAgICAgICAgICAgICAndG9fdXJpJzogdGhpcy5kaWFsb2cucmVtb3RlX3VyaSxcbiAgICAgICAgICAgICAgJ3RvX3RhZyc6IHRoaXMuZGlhbG9nLmlkLnJlbW90ZV90YWcsXG4gICAgICAgICAgICAgICdyb3V0ZV9zZXQnOiB0aGlzLmRpYWxvZy5yb3V0ZV9zZXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIG5ldyBTSVAuUmVxdWVzdFNlbmRlcihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5yZXF1ZXN0LFxuICAgICAgICAgICAgICBvblJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uUmVxdWVzdFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy51YVxuICAgICAgICAgICkuc2VuZCgpO1xuICAgICAgICAgIGRpYWxvZy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZW1pdCgnYnllJywgdGhpcy5yZXF1ZXN0KTtcbiAgICAgIHRoaXMudGVybWluYXRlZCgpO1xuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBkaWFsb2cgaW50byAndGhpcycgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBzZW5kIHRoZSBpbi1kaWFsb2cgQllFIDotKVxuICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGRpYWxvZyBpbnRvICd1YScgc28gdGhlIEFDSyBjYW4gcmVhY2ggJ3RoaXMnIHNlc3Npb25cbiAgICAgIHRoaXMudWEuZGlhbG9nc1tkaWFsb2cuaWQudG9TdHJpbmcoKV0gPSBkaWFsb2c7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMuYnllKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlamVjdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5NZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24gYXMgbWVkaWFIaW50XG4gICAqL1xuICBwcm9ncmVzczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXJcbiAgICAgIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTgwLFxuICAgICAgcmVhc29uUGhyYXNlID0gb3B0aW9ucy5yZWFzb25QaHJhc2UsXG4gICAgICBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCksXG4gICAgICBpY2VTZXJ2ZXJzLFxuICAgICAgc3R1blNlcnZlcnMgPSBvcHRpb25zLnN0dW5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgICB0dXJuU2VydmVycyA9IG9wdGlvbnMudHVyblNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHksXG4gICAgICByZXNwb25zZTtcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiAxOTkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RhdHVzQ29kZTogJyArIHN0YXR1c0NvZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChzdHVuU2VydmVycyB8fCB0dXJuU2VydmVycykge1xuICAgICAgaWYgKHN0dW5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsnc3R1blNlcnZlcnMnXShzdHVuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3R1blNlcnZlcnM6ICcrIHN0dW5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0dW5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHVyblNlcnZlcnMpIHtcbiAgICAgICAgaWNlU2VydmVycyA9IFNJUC5VQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsWyd0dXJuU2VydmVycyddKHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgaWYgKCFpY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0dXJuU2VydmVyczogJysgdHVyblNlcnZlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHVyblNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnVwZGF0ZUljZVNlcnZlcnMoe1xuICAgICAgICBzdHVuU2VydmVyczogdGhpcy5zdHVuU2VydmVycyxcbiAgICAgICAgdHVyblNlcnZlcnM6IHRoaXMudHVyblNlcnZlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvMTAwcmVsKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgICAgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODM7XG5cbiAgICAgIC8vIFNldCBzdGF0dXMgYW5kIGFkZCBleHRyYSBoZWFkZXJzXG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLO1xuICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcrIHRoaXMuY29udGFjdCk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVxdWlyZTogMTAwcmVsJyk7XG4gICAgICBleHRyYUhlYWRlcnMucHVzaCgnUlNlcTogJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSk7XG5cbiAgICAgIC8vIFNhdmUgbWVkaWEgaGludCBmb3IgbGF0ZXIgKHJlZmVycmVkIHNlc3Npb25zKVxuICAgICAgdGhpcy5tZWRpYUhpbnQgPSBvcHRpb25zLm1lZGlhO1xuXG4gICAgICAvLyBHZXQgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24gdG8gYWRkIHRvIHByZWFjY2VwdCB3aXRoXG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbihvcHRpb25zLm1lZGlhKVxuICAgICAgLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoYm9keSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmVhcmx5X3NkcCA9IGJvZHk7XG4gICAgICAgICAgdGhpc1t0aGlzLmhhc09mZmVyID8gJ2hhc0Fuc3dlcicgOiAnaGFzT2ZmZXInXSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBSZXRyYW5zbWl0IHVudGlsIHdlIGdldCBhIHJlc3BvbnNlIG9yIHdlIHRpbWUgb3V0IChzZWUgcHJhY2tUaW1lciBiZWxvdylcbiAgICAgICAgICB2YXIgdGltZW91dCA9IFNJUC5UaW1lcnMuVDE7XG4gICAgICAgICAgdGhpcy50aW1lcnMucmVsMXh4VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoZnVuY3Rpb24gcmVsMXh4UmV0cmFuc21pc3Npb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoc3RhdHVzQ29kZSwgbnVsbCwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgICAgICAgIHRpbWVvdXQgKj0gMjtcbiAgICAgICAgICAgIHRoaXMudGltZXJzLnJlbDF4eFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHJlbDF4eFJldHJhbnNtaXNzaW9uLmJpbmQodGhpcyksIHRpbWVvdXQpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGltZW91dCk7XG5cbiAgICAgICAgICAvLyBUaW1lb3V0IGFuZCByZWplY3QgSU5WSVRFIGlmIG5vIHJlc3BvbnNlXG4gICAgICAgICAgdGhpcy50aW1lcnMucHJhY2tUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdubyBQUkFDSyByZWNlaXZlZCwgcmVqZWN0aW5nIHRoZSBjYWxsJyk7XG4gICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5yZWwxeHhUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoNTA0KTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuTk9fUFJBQ0spO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgU0lQLlRpbWVycy5UMSAqIDY0KTtcblxuICAgICAgICAgIC8vIFNlbmQgdGhlIGluaXRpYWwgcmVzcG9uc2VcbiAgICAgICAgICByZXNwb25zZSA9IHRoaXMucmVxdWVzdC5yZXBseShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlLCByZWFzb25QaHJhc2UpO1xuICAgICAgICB9LmJpbmQodGhpcyksXG5cbiAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlICgpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoNDgwKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgKTtcbiAgICB9IC8vIGVuZCBkbzEwMHJlbFxuXG4gICAgZnVuY3Rpb24gbm9ybWFsUmVwbHkoKSB7XG4gICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0LnJlcGx5KHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSwgcmVhc29uUGhyYXNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlICE9PSAxMDAgJiZcbiAgICAgICAgKHRoaXMucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQgfHxcbiAgICAgICAgICh0aGlzLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCAmJiBvcHRpb25zLnJlbDEwMCkgfHxcbiAgICAgICAgICh0aGlzLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCAmJiAodGhpcy51YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSkpKSB7XG4gICAgICBkbzEwMHJlbC5hcHBseSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsUmVwbHkuYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAgICovXG4gIGFjY2VwdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKFNlc3Npb24uZGVzdWdhcihvcHRpb25zKSk7XG4gICAgU0lQLlV0aWxzLm9wdGlvbnNPdmVycmlkZShvcHRpb25zLCAnbWVkaWEnLCAnbWVkaWFDb25zdHJhaW50cycsIHRydWUsIHRoaXMubG9nZ2VyLCB0aGlzLnVhLmNvbmZpZ3VyYXRpb24ubWVkaWEpO1xuICAgIHRoaXMubWVkaWFIaW50ID0gb3B0aW9ucy5tZWRpYTtcblxuICAgIC8vIGNvbW1lbnRlZCBvdXQgbm93LXVudXNlZCBob2xkLXJlbGF0ZWQgdmFyaWFibGVzIGZvciBqc2hpbnQuIFNlZSBiZWxvdy4gSk1GIDIwMTQtMS0yMVxuICAgIHZhclxuICAgICAgLy9pZHgsIGxlbmd0aCwgaGFzQXVkaW8sIGhhc1ZpZGVvLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LFxuICAgICAgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpLFxuICAgIC8vbWVkaWFTdHJlYW0gPSBvcHRpb25zLm1lZGlhU3RyZWFtIHx8IG51bGwsXG4gICAgICBpY2VTZXJ2ZXJzLFxuICAgICAgc3R1blNlcnZlcnMgPSBvcHRpb25zLnN0dW5TZXJ2ZXJzIHx8IG51bGwsXG4gICAgICB0dXJuU2VydmVycyA9IG9wdGlvbnMudHVyblNlcnZlcnMgfHwgbnVsbCxcbiAgICAgIHNkcENyZWF0aW9uU3VjY2VlZGVkID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAvLyBydW4gZm9yIHJlcGx5IHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICByZXBseVN1Y2NlZWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG5cbiAgICAgICAgICAgIHNlbGYuc2V0SW52aXRlMnh4VGltZXIocmVxdWVzdCwgYm9keSk7XG4gICAgICAgICAgICBzZWxmLnNldEFDS1RpbWVyKCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIHJ1biBmb3IgcmVwbHkgZmFpbHVyZSBjYWxsYmFja1xuICAgICAgICAgIHJlcGx5RmFpbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hyb21lIG1pZ2h0IGNhbGwgb25hZGRzdHJlYW0gYmVmb3JlIGFjY2VwdCgpIGlzIGNhbGxlZCwgd2hpY2ggbWVhbnNcbiAgICAgICAgLy8gbWVkaWFIYW5kbGVyLnJlbmRlcigpIHdhcyBjYWxsZWQgd2l0aG91dCBhIHJlbmRlckhpbnQsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmUtcmVuZGVyIG5vdyB0aGF0IG1lZGlhSGludC5yZW5kZXIgaGFzIGJlZW4gc2V0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBDaHJvbWUgc2VlbXMgdG8gYmUgaW4gdGhlIHJpZ2h0IHJlZ2FyZGluZyB0aGlzLCBzZWVcbiAgICAgICAgLy8gaHR0cDovL2Rldi53My5vcmcvMjAxMS93ZWJydGMvZWRpdG9yL3dlYnJ0Yy5odG1sI3dpZGwtUlRDUGVlckNvbm5lY3Rpb24tb25hZGRzdHJlYW1cbiAgICAgICAgc2VsZi5tZWRpYUhhbmRsZXIucmVuZGVyKCk7XG5cbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRhY3Q6ICcgKyBzZWxmLmNvbnRhY3QpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcgKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgaWYoIXNlbGYuaGFzT2ZmZXIpIHtcbiAgICAgICAgICBzZWxmLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2UgPSByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbHlTdWNjZWVkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVwbHlGYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIGlmIChzZWxmLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkgeyAvLyBEaWRuJ3QgZmFpbFxuICAgICAgICAgIHNlbGYuYWNjZXB0ZWQocmVzcG9uc2UsIFNJUC5VdGlscy5nZXRSZWFzb25QaHJhc2UoMjAwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNkcENyZWF0aW9uRmFpbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIC0gZmFpbCBvdXQgb24gZXJyb3JcbiAgICAgICAgc2VsZi5yZXF1ZXN0LnJlcGx5KDQ4MCk7XG4gICAgICAgIC8vc2VsZi5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5VU0VSX0RFTklFRF9NRURJQV9BQ0NFU1MpO1xuICAgICAgICBzZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgc2VsZi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgfTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUikge1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19BTlNXRVJFRDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0dW5TZXJ2ZXJzIHx8IHR1cm5TZXJ2ZXJzKSAmJlxuICAgICAgICAodGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX0VBUkxZX01FRElBICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykpIHtcbiAgICAgIGlmIChzdHVuU2VydmVycykge1xuICAgICAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3N0dW5TZXJ2ZXJzJ10oc3R1blNlcnZlcnMpO1xuICAgICAgICBpZiAoIWljZVNlcnZlcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0dW5TZXJ2ZXJzOiAnKyBzdHVuU2VydmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHVuU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR1cm5TZXJ2ZXJzKSB7XG4gICAgICAgIGljZVNlcnZlcnMgPSBTSVAuVUEuY29uZmlndXJhdGlvbl9jaGVjay5vcHRpb25hbFsndHVyblNlcnZlcnMnXSh0dXJuU2VydmVycyk7XG4gICAgICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdHVyblNlcnZlcnM6ICcrIHR1cm5TZXJ2ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR1cm5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1lZGlhSGFuZGxlci51cGRhdGVJY2VTZXJ2ZXJzKHtcbiAgICAgICAgc3R1blNlcnZlcnM6IHRoaXMuc3R1blNlcnZlcnMsXG4gICAgICAgIHR1cm5TZXJ2ZXJzOiB0aGlzLnR1cm5TZXJ2ZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciBvbiBkaWFsb2cgY3JlYXRpb24gd2lsbCBmaXJlICdmYWlsZWQnIGV2ZW50XG4gICAgaWYoIXRoaXMuY3JlYXRlRGlhbG9nKHJlcXVlc3QsICdVQVMnKSkge1xuICAgICAgcmVxdWVzdC5yZXBseSg1MDAsICdNaXNzaW5nIENvbnRhY3QgaGVhZGVyIGZpZWxkJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lcik7XG5cbiAgICAvLyB0aGlzIGhvbGQtcmVsYXRlZCBjb2RlIGJyZWFrcyBGRiBhY2NlcHRpbmcgbmV3IGNhbGxzIC0gSk1GIDIwMTQtMS0yMVxuICAgIC8qXG4gICAgbGVuZ3RoID0gdGhpcy5nZXRSZW1vdGVTdHJlYW1zKCkubGVuZ3RoO1xuXG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcygpW2lkeF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhc1ZpZGVvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhSGFuZGxlci5nZXRSZW1vdGVTdHJlYW1zKClbaWR4XS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFzQXVkaW8gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzQXVkaW8gJiYgdGhpcy5tZWRpYUNvbnN0cmFpbnRzLmF1ZGlvID09PSB0cnVlKSB7XG4gICAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgICAgIGlmIChtZWRpYVN0cmVhbSkge1xuICAgICAgICBsZW5ndGggPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sobWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVtpZHhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzVmlkZW8gJiYgdGhpcy5tZWRpYUNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgICAgIGlmIChtZWRpYVN0cmVhbSkge1xuICAgICAgICBsZW5ndGggPSBtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aDtcbiAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sobWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVtpZHhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSkge1xuICAgICAgc2RwQ3JlYXRpb25TdWNjZWVkZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oc2VsZi5tZWRpYUhpbnQpXG4gICAgICAudGhlbihcbiAgICAgICAgc2RwQ3JlYXRpb25TdWNjZWVkZWQsXG4gICAgICAgIHNkcENyZWF0aW9uRmFpbGVkXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG5cbiAgICAvLyBJU0MgUkVDRUlWRSBSRVFVRVNUXG5cbiAgICBmdW5jdGlvbiBjb25maXJtU2Vzc2lvbigpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuXG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5hY2tUaW1lcik7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgIHRoaXMudW5tdXRlKCk7XG5cbiAgICAgIC8vIFRPRE8gLSB0aGlzIGxvZ2ljIGFzc3VtZXMgQ29udGVudC1EaXNwb3NpdGlvbiBkZWZhdWx0c1xuICAgICAgY29udGVudFR5cGUgPSByZXF1ZXN0LmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICBpZiAoY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyYm9keSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgdGhpcy5yZW5kZXJ0eXBlID0gY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoKHJlcXVlc3QubWV0aG9kKSB7XG4gICAgY2FzZSBTSVAuQy5DQU5DRUw6XG4gICAgICAvKiBSRkMzMjYxIDE1IFN0YXRlcyB0aGF0IGEgVUFTIG1heSBoYXZlIGFjY2VwdGVkIGFuIGludml0YXRpb24gd2hpbGUgYSBDQU5DRUxcbiAgICAgICAqIHdhcyBpbiBwcm9ncmVzcyBhbmQgdGhhdCB0aGUgVUFDIE1BWSBjb250aW51ZSB3aXRoIHRoZSBzZXNzaW9uIGVzdGFibGlzaGVkIGJ5XG4gICAgICAgKiBhbnkgMnh4IHJlc3BvbnNlLCBvciBNQVkgdGVybWluYXRlIHdpdGggQllFLiBTSVAgZG9lcyBjb250aW51ZSB3aXRoIHRoZVxuICAgICAgICogZXN0YWJsaXNoZWQgc2Vzc2lvbi4gU28gdGhlIENBTkNFTCBpcyBwcm9jZXNzZWQgb25seSBpZiB0aGUgc2Vzc2lvbiBpcyBub3QgeWV0XG4gICAgICAgKiBlc3RhYmxpc2hlZC5cbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgICogVGVybWluYXRlIHRoZSB3aG9sZSBzZXNzaW9uIGluIGNhc2UgdGhlIHVzZXIgZGlkbid0IGFjY2VwdCAob3IgeWV0IHRvIHNlbmQgdGhlIGFuc3dlcikgbm9yIHJlamVjdCB0aGVcbiAgICAgICAqcmVxdWVzdCBvcGVuaW5nIHRoZSBzZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0sgfHxcbiAgICAgICAgIHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSyB8fFxuICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBIHx8XG4gICAgICAgICB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRUQpIHtcblxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0NBTkNFTEVEO1xuICAgICAgICB0aGlzLnJlcXVlc3QucmVwbHkoNDg3KTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZChyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgICAgaWYocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL3NkcCcpIHtcbiAgICAgICAgICAgIC8vIEFDSyBjb250YWlucyBhbnN3ZXIgdG8gYW4gSU5WSVRFIHcvbyBTRFAgbmVnb3RpYXRpb25cbiAgICAgICAgICAgIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIFNJUC5IYWNrcy5BbGxCcm93c2Vycy5tYXNrRHRscyhyZXF1ZXN0KTtcblxuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVxdWVzdC5ib2R5KVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgIGNvbmZpcm1TZXNzaW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogJzQ4OCcsXG4gICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6ICdCYWQgTWVkaWEgRGVzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVhcmx5X3NkcCkge1xuICAgICAgICAgICAgY29uZmlybVNlc3Npb24uYXBwbHkodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVE9ETzogUGFzcyB0byBtZWRpYWhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlcXVlc3QsIFNJUC5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25maXJtU2Vzc2lvbi5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVAuQy5QUkFDSzpcbiAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0sgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgIC8vbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgIGlmKCF0aGlzLmhhc0Fuc3dlcikge1xuICAgICAgICAgIGlmKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJykgPT09ICdhcHBsaWNhdGlvbi9zZHAnKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1lZGlhSGFuZGxlci5zZXREZXNjcmlwdGlvbihyZXF1ZXN0LmJvZHkpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5yZWwxeHhUaW1lcik7XG4gICAgICAgICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucHJhY2tUaW1lcik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXBseSgyMDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgIC8vUkVWSVNJVFxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZSgpO1xuICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICAgIC8vVE9ETzogU2VuZCB0byBtZWRpYSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAnNDg4JyxcbiAgICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogJ0JhZCBNZWRpYSBEZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVxdWVzdCwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAnNDg4JyxcbiAgICAgICAgICAgICAgcmVhc29uUGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChyZXF1ZXN0LCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMucmVsMXh4VGltZXIpO1xuICAgICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnByYWNrVGltZXIpO1xuICAgICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcblxuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgIC8vUkVWSVNJVFxuICAgICAgICAgIHRoaXMubXV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoMjAwKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdC5hcHBseSh0aGlzLCBbcmVxdWVzdF0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICB9LFxuXG4gIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyAhPT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgdGhpcy5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfVxuICB9XG5cbn07XG5cblNJUC5JbnZpdGVTZXJ2ZXJDb250ZXh0ID0gSW52aXRlU2VydmVyQ29udGV4dDtcblxuSW52aXRlQ2xpZW50Q29udGV4dCA9IGZ1bmN0aW9uKHVhLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoU2Vzc2lvbi5kZXN1Z2FyKG9wdGlvbnMpKTtcbiAgb3B0aW9ucy5wYXJhbXMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMucGFyYW1zIHx8IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHZhciBpY2VTZXJ2ZXJzLFxuICAgIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKSxcbiAgICBzdHVuU2VydmVycyA9IG9wdGlvbnMuc3R1blNlcnZlcnMgfHwgbnVsbCxcbiAgICB0dXJuU2VydmVycyA9IG9wdGlvbnMudHVyblNlcnZlcnMgfHwgbnVsbCxcbiAgICBtZWRpYUhhbmRsZXJGYWN0b3J5ID0gb3B0aW9ucy5tZWRpYUhhbmRsZXJGYWN0b3J5IHx8IHVhLmNvbmZpZ3VyYXRpb24ubWVkaWFIYW5kbGVyRmFjdG9yeSxcbiAgICBpc01lZGlhU3VwcG9ydGVkID0gbWVkaWFIYW5kbGVyRmFjdG9yeS5pc1N1cHBvcnRlZDtcblxuICAvLyBDaGVjayBXZWJSVEMgc3VwcG9ydFxuICBpZiAoaXNNZWRpYVN1cHBvcnRlZCAmJiAhaXNNZWRpYVN1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLk5vdFN1cHBvcnRlZEVycm9yKCdNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICB0aGlzLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB7fTtcbiAgdGhpcy5pbnZpdGVXaXRob3V0U2RwID0gb3B0aW9ucy5pbnZpdGVXaXRob3V0U2RwIHx8IGZhbHNlO1xuXG4gIC8vIFNldCBhbm9ueW1vdXMgcHJvcGVydHlcbiAgdGhpcy5hbm9ueW1vdXMgPSBvcHRpb25zLmFub255bW91cyB8fCBmYWxzZTtcblxuICAvLyBDdXN0b20gZGF0YSB0byBiZSBzZW50IGVpdGhlciBpbiBJTlZJVEUgb3IgaW4gQUNLXG4gIHRoaXMucmVuZGVyYm9keSA9IG9wdGlvbnMucmVuZGVyYm9keSB8fCBudWxsO1xuICB0aGlzLnJlbmRlcnR5cGUgPSBvcHRpb25zLnJlbmRlcnR5cGUgfHwgJ3RleHQvcGxhaW4nO1xuXG4gIG9wdGlvbnMucGFyYW1zLmZyb21fdGFnID0gdGhpcy5mcm9tX3RhZztcblxuICAvKiBEbyBub3QgYWRkIDtvYiBpbiBpbml0aWFsIGZvcm1pbmcgZGlhbG9nIHJlcXVlc3RzIGlmIHRoZSByZWdpc3RyYXRpb24gb3ZlclxuICAgKiAgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBnb3QgYSBHUlVVIFVSSS5cbiAgICovXG4gIHRoaXMuY29udGFjdCA9IHVhLmNvbnRhY3QudG9TdHJpbmcoe1xuICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG4gICAgb3V0Ym91bmQ6IHRoaXMuYW5vbnltb3VzID8gIXVhLmNvbnRhY3QudGVtcF9ncnV1IDogIXVhLmNvbnRhY3QucHViX2dydXVcbiAgfSk7XG5cbiAgaWYgKHRoaXMuYW5vbnltb3VzKSB7XG4gICAgb3B0aW9ucy5wYXJhbXMuZnJvbV9kaXNwbGF5TmFtZSA9ICdBbm9ueW1vdXMnO1xuICAgIG9wdGlvbnMucGFyYW1zLmZyb21fdXJpID0gJ3NpcDphbm9ueW1vdXNAYW5vbnltb3VzLmludmFsaWQnO1xuXG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ1AtUHJlZmVycmVkLUlkZW50aXR5OiAnKyB1YS5jb25maWd1cmF0aW9uLnVyaS50b1N0cmluZygpKTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUHJpdmFjeTogaWQnKTtcbiAgfVxuICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgZXh0cmFIZWFkZXJzLnB1c2goJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSk7XG4gIGlmICghdGhpcy5pbnZpdGVXaXRob3V0U2RwKSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vc2RwJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJib2R5KSB7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHRoaXMucmVuZGVydHlwZSk7XG4gICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtRGlzcG9zaXRpb246IHJlbmRlcjtoYW5kbGluZz1vcHRpb25hbCcpO1xuICB9XG5cbiAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnUmVxdWlyZTogMTAwcmVsJyk7XG4gIH1cbiAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSZXF1aXJlOiByZXBsYWNlcycpO1xuICB9XG5cbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG5cbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLkNsaWVudENvbnRleHQsIFt1YSwgU0lQLkMuSU5WSVRFLCB0YXJnZXQsIG9wdGlvbnNdKTtcbiAgU0lQLlV0aWxzLmF1Z21lbnQodGhpcywgU0lQLlNlc3Npb24sIFttZWRpYUhhbmRsZXJGYWN0b3J5XSk7XG5cbiAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19OVUxMKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgfVxuXG4gIC8vIFNlc3Npb24gcGFyYW1ldGVyIGluaXRpYWxpemF0aW9uXG4gIHRoaXMuZnJvbV90YWcgPSBTSVAuVXRpbHMubmV3VGFnKCk7XG5cbiAgLy8gT3V0Z29pbmdTZXNzaW9uIHNwZWNpZmljIHBhcmFtZXRlcnNcbiAgdGhpcy5pc0NhbmNlbGVkID0gZmFsc2U7XG4gIHRoaXMucmVjZWl2ZWRfMTAwID0gZmFsc2U7XG5cbiAgdGhpcy5tZXRob2QgPSBTSVAuQy5JTlZJVEU7XG5cbiAgdGhpcy5yZWNlaXZlTm9uSW52aXRlUmVzcG9uc2UgPSB0aGlzLnJlY2VpdmVSZXNwb25zZTtcbiAgdGhpcy5yZWNlaXZlUmVzcG9uc2UgPSB0aGlzLnJlY2VpdmVJbnZpdGVSZXNwb25zZTtcblxuICB0aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLmludml0ZWNsaWVudGNvbnRleHQnKTtcblxuICBpZiAoc3R1blNlcnZlcnMpIHtcbiAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3N0dW5TZXJ2ZXJzJ10oc3R1blNlcnZlcnMpO1xuICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHVuU2VydmVyczogJysgc3R1blNlcnZlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0dW5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICB9XG4gIH1cblxuICBpZiAodHVyblNlcnZlcnMpIHtcbiAgICBpY2VTZXJ2ZXJzID0gU0lQLlVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWxbJ3R1cm5TZXJ2ZXJzJ10odHVyblNlcnZlcnMpO1xuICAgIGlmICghaWNlU2VydmVycykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0dXJuU2VydmVyczogJysgdHVyblNlcnZlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR1cm5TZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICB9XG4gIH1cblxuICB1YS5hcHBsaWNhbnRzW3RoaXNdID0gdGhpcztcblxuICB0aGlzLmlkID0gdGhpcy5yZXF1ZXN0LmNhbGxfaWQgKyB0aGlzLmZyb21fdGFnO1xuXG4gIC8vSW5pdGlhbGl6ZSBNZWRpYSBTZXNzaW9uXG4gIHRoaXMubWVkaWFIYW5kbGVyID0gdGhpcy5tZWRpYUhhbmRsZXJGYWN0b3J5KHRoaXMsIHtcbiAgICBSVENDb25zdHJhaW50czogdGhpcy5SVENDb25zdHJhaW50cyxcbiAgICBzdHVuU2VydmVyczogdGhpcy5zdHVuU2VydmVycyxcbiAgICB0dXJuU2VydmVyczogdGhpcy50dXJuU2VydmVyc1xuICB9KTtcblxuICBpZiAodGhpcy5tZWRpYUhhbmRsZXIgJiYgdGhpcy5tZWRpYUhhbmRsZXIuZ2V0UmVtb3RlU3RyZWFtcykge1xuICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcyA9IHRoaXMubWVkaWFIYW5kbGVyLmdldFJlbW90ZVN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMgPSB0aGlzLm1lZGlhSGFuZGxlci5nZXRMb2NhbFN0cmVhbXMuYmluZCh0aGlzLm1lZGlhSGFuZGxlcik7XG4gIH1cblxuICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKG9wdGlvbnMsICdtZWRpYScsICdtZWRpYUNvbnN0cmFpbnRzJywgdHJ1ZSwgdGhpcy5sb2dnZXIsIHRoaXMudWEuY29uZmlndXJhdGlvbi5tZWRpYSk7XG4gIHRoaXMubWVkaWFIaW50ID0gb3B0aW9ucy5tZWRpYTtcbn07XG5cbkludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlID0ge1xuICBpbnZpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvL1NhdmUgdGhlIHNlc3Npb24gaW50byB0aGUgdWEgc2Vzc2lvbnMgY29sbGVjdGlvbi5cbiAgICAvL05vdGU6IHBsYWNpbmcgaW4gY29uc3RydWN0b3IgYnJlYWtzIGNhbGwgdG8gcmVxdWVzdC5jYW5jZWwgb24gY2xvc2UuLi4gVXNlciBkb2VzIG5vdCBuZWVkIHRoaXMgYW55d2F5XG4gICAgdGhpcy51YS5zZXNzaW9uc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAvL05vdGU6IGR1ZSB0byB0aGUgd2F5IEZpcmVmb3ggaGFuZGxlcyBnVU0gY2FsbHMsIGl0IGlzIHJlY29tbWVuZGVkIHRvIG1ha2UgdGhlIGdVTSBjYWxsIGF0IHRoZSBhcHAgbGV2ZWxcbiAgICAvLyBhbmQgaGFuZCBzaXAuanMgYSBzdHJlYW0gYXMgdGhlIG1lZGlhSGludFxuICAgIGlmICh0aGlzLmludml0ZVdpdGhvdXRTZHApIHtcbiAgICAgIC8vanVzdCBzZW5kIGFuIGludml0ZSB3aXRoIG5vIHNkcC4uLlxuICAgICAgdGhpcy5yZXF1ZXN0LmJvZHkgPSBzZWxmLnJlbmRlcmJvZHk7XG4gICAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0lOVklURV9TRU5UO1xuICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uKHNlbGYubWVkaWFIaW50KVxuICAgICAgLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyhvZmZlcikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQ2FuY2VsZWQgfHwgc2VsZi5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgICAgc2VsZi5yZXF1ZXN0LmJvZHkgPSBvZmZlcjtcbiAgICAgICAgICBzZWxmLnN0YXR1cyA9IEMuU1RBVFVTX0lOVklURV9TRU5UO1xuICAgICAgICAgIHNlbGYuc2VuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBvbkZhaWx1cmUoKSB7XG4gICAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8uLi5mYWlsIG91dFxuICAgICAgICAgIC8vc2VsZi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLlVTRVJfREVOSUVEX01FRElBX0FDQ0VTUyk7XG4gICAgICAgICAgLy9zZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICBzZWxmLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICBzZWxmLnRlcm1pbmF0ZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZUludml0ZVJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHZhciBjYXVzZSwgLy9sb2NhbE1lZGlhLFxuICAgICAgc2Vzc2lvbiA9IHRoaXMsXG4gICAgICBpZCA9IHJlc3BvbnNlLmNhbGxfaWQgKyByZXNwb25zZS5mcm9tX3RhZyArIHJlc3BvbnNlLnRvX3RhZyxcbiAgICAgIGV4dHJhSGVhZGVycyA9IFtdLFxuICAgICAgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEIHx8IHJlc3BvbnNlLm1ldGhvZCAhPT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlhbG9nICYmIChyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPD0gMjk5KSkge1xuICAgICAgaWYgKGlkICE9PSB0aGlzLmRpYWxvZy5pZC50b1N0cmluZygpICkge1xuICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJywgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLkFDSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogU0lQLlV0aWxzLmdlbmVyYXRlRmFrZVNEUChyZXNwb25zZS5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5CWUUpO1xuXG4gICAgICAgIC8qIE5PVEU6IFRoaXMgZmFpbHMgYmVjYXVzZSB0aGUgZm9ya2luZyBwcm94eSBkb2VzIG5vdCByZWNvZ25pemUgdGhhdCBhbiB1bmFuc3dlcmFibGVcbiAgICAgICAgICogbGVnIChkdWUgdG8gcGVlckNvbm5lY3Rpb24gbGltaXRhdGlvbnMpIGhhcyBiZWVuIGFuc3dlcmVkIGZpcnN0LiBJZiB5b3VyIGZvcmtpbmdcbiAgICAgICAgICogcHJveHkgZG9lcyBub3QgaGFuZyB1cCBhbGwgdW5hbnN3ZXJlZCBicmFuY2hlcyBvbiB0aGUgZmlyc3QgYnJhbmNoIGFuc3dlcmVkLCByZW1vdmUgdGhpcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse2NzZXE6IHJlc3BvbnNlLmNzZXF9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5oYXNBbnN3ZXIpIHtcbiAgICAgICAgLy8gaW52aXRlIHcvbyBzZHAgaXMgd2FpdGluZyBmb3IgY2FsbGJhY2tcbiAgICAgICAgLy9hbiBpbnZpdGUgd2l0aCBzZHAgbXVzdCBnbyBvbiwgYW5kIGhhc0Fuc3dlciBpcyB0cnVlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaWFsb2cgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPCAyMDApIHtcbiAgICAgIC8qXG4gICAgICAgIEVhcmx5IG1lZGlhIGhhcyBiZWVuIHNldCB1cCB3aXRoIGF0IGxlYXN0IG9uZSBvdGhlciBkaWZmZXJlbnQgYnJhbmNoLFxuICAgICAgICBidXQgYSBmaW5hbCAyeHggcmVzcG9uc2UgaGFzbid0IGJlZW4gcmVjZWl2ZWRcbiAgICAgICovXG4gICAgICBpZiAodGhpcy5kaWFsb2cucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSAhPT0gLTEgfHxcbiAgICAgICAgICAodGhpcy5kaWFsb2cucHJhY2tlZFt0aGlzLmRpYWxvZy5wcmFja2VkLmxlbmd0aC0xXSA+PSByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSAmJiB0aGlzLmRpYWxvZy5wcmFja2VkLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVhcmx5RGlhbG9nc1tpZF0gJiYgIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJywgdHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lYXJseURpYWxvZ3NbaWRdLnByYWNrZWQuaW5kZXhPZihyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSkgIT09IC0xIHx8XG4gICAgICAgICAgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkW3RoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aC0xXSA+PSByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSAmJiB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5sZW5ndGggPiAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdSQWNrOiAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykgKyAnICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSk7XG4gICAgICB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5wdXNoKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKTtcblxuICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLlBSQUNLLCB7XG4gICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICBib2R5OiBTSVAuVXRpbHMuZ2VuZXJhdGVGYWtlU0RQKHJlc3BvbnNlLmJvZHkpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcm9jZWVkIHRvIGNhbmNlbGxhdGlvbiBpZiB0aGUgdXNlciByZXF1ZXN0ZWQuXG4gICAgaWYodGhpcy5pc0NhbmNlbGVkKSB7XG4gICAgICBpZihyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAxMDAgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPCAyMDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LmNhbmNlbCh0aGlzLmNhbmNlbFJlYXNvbik7XG4gICAgICAgIHRoaXMuY2FuY2VsZWQobnVsbCk7XG4gICAgICB9IGVsc2UgaWYocmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c19jb2RlIDwgMjk5KSB7XG4gICAgICAgIHRoaXMuYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdieWUnLCB0aGlzLnJlcXVlc3QpO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNfY29kZSA+PSAzMDApIHtcbiAgICAgICAgY2F1c2UgPSBTSVAuQy5SRUFTT05fUEhSQVNFW3Jlc3BvbnNlLnN0YXR1c19jb2RlXSB8fCBTSVAuQy5jYXVzZXMuQ0FOQ0VMRUQ7XG4gICAgICAgIHRoaXMucmVqZWN0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKHRydWUpIHtcbiAgICAgIGNhc2UgL14xMDAkLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgdGhpcy5yZWNlaXZlZF8xMDAgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgcmVzcG9uc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKC9eMVswLTldezJ9JC8udGVzdChyZXNwb25zZS5zdGF0dXNfY29kZSkpOlxuICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggMXh4IHJlc3BvbnNlcyB3aXRob3V0IFRvIHRhZy5cbiAgICAgICAgaWYoIXJlc3BvbnNlLnRvX3RhZykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJzF4eCByZXNwb25zZSByZWNlaXZlZCB3aXRob3V0IHRvIHRhZycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIEVhcmx5IERpYWxvZyBpZiAxWFggY29tZXMgd2l0aCBjb250YWN0XG4gICAgICAgIGlmKHJlc3BvbnNlLmhhc0hlYWRlcignY29udGFjdCcpKSB7XG4gICAgICAgICAgLy8gQW4gZXJyb3Igb24gZGlhbG9nIGNyZWF0aW9uIHdpbGwgZmlyZSAnZmFpbGVkJyBldmVudFxuICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnLCB0cnVlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU18xWFhfUkVDRUlWRUQ7XG5cbiAgICAgICAgaWYocmVzcG9uc2UuaGFzSGVhZGVyKCdyZXF1aXJlJykgJiZcbiAgICAgICAgICAgcmVzcG9uc2UuZ2V0SGVhZGVyKCdyZXF1aXJlJykuaW5kZXhPZignMTAwcmVsJykgIT09IC0xKSB7XG5cbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoaXMuZGlhbG9nIGlzIGFscmVhZHkgY29uZmlybWVkXG4gICAgICAgICAgaWYgKHRoaXMuZGlhbG9nIHx8ICF0aGlzLmVhcmx5RGlhbG9nc1tpZF0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5pbmRleE9mKHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgKHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkW3RoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLmxlbmd0aC0xXSA+PSByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSAmJiB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ucHJhY2tlZC5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFNJUC5IYWNrcy5GaXJlZm94LmNhbm5vdEhhbmRsZUV4dHJhV2hpdGVzcGFjZShyZXNwb25zZSk7XG4gICAgICAgICAgU0lQLkhhY2tzLkFsbEJyb3dzZXJzLm1hc2tEdGxzKHJlc3BvbnNlKTtcblxuICAgICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2dzW2lkXS5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3NbaWRdLnNlbmRSZXF1ZXN0KHRoaXMsIFNJUC5DLlBSQUNLLCB7XG4gICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzT2ZmZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVEaWFsb2cocmVzcG9uc2UsICdVQUMnKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG5cbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnUkFjazogJyArIHJlc3BvbnNlLmdldEhlYWRlcigncnNlcScpICsgJyAnICsgcmVzcG9uc2UuZ2V0SGVhZGVyKCdjc2VxJykpO1xuXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5QUkFDSywge1xuICAgICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnN0YXR1cyA9IEMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubXV0ZSgpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbE1lZGlhID0gc2Vzc2lvbi5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKVswXS5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRmFpbHVyZSAoZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRBbmRUZXJtaW5hdGUocmVzcG9uc2UsIDQ4OCwgJ05vdCBBY2NlcHRhYmxlIEhlcmUnKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlYXJseURpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzW2lkXTtcbiAgICAgICAgICAgIHZhciBlYXJseU1lZGlhID0gZWFybHlEaWFsb2cubWVkaWFIYW5kbGVyO1xuXG4gICAgICAgICAgICBlYXJseURpYWxvZy5wcmFja2VkLnB1c2gocmVzcG9uc2UuZ2V0SGVhZGVyKCdyc2VxJykpO1xuXG4gICAgICAgICAgICBlYXJseU1lZGlhLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAudGhlbihlYXJseU1lZGlhLmdldERlc2NyaXB0aW9uLmJpbmQoZWFybHlNZWRpYSwgc2Vzc2lvbi5tZWRpYUhpbnQpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gb25TdWNjZXNzKHNkcCkge1xuICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9zZHAnKTtcbiAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ1JBY2s6ICcgKyByZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSArICcgJyArIHJlc3BvbnNlLmdldEhlYWRlcignY3NlcScpKTtcbiAgICAgICAgICAgICAgZWFybHlEaWFsb2cuc2VuZFJlcXVlc3Qoc2Vzc2lvbiwgU0lQLkMuUFJBQ0ssIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZHBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlc3Npb24uc3RhdHVzID0gQy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgIHNlc3Npb24uZW1pdCgncHJvZ3Jlc3MnLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIG9uRmFpbHVyZShlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnByYWNrZWQucHVzaChyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBmYWlsIG91dCBvbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHNlc3Npb24uZmFpbGVkKGd1bSBlcnJvcik7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5mYWlsZWQobnVsbCwgU0lQLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi50ZXJtaW5hdGVkKG51bGwsIFNJUC5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnByYWNrZWQuc3BsaWNlKGVhcmx5RGlhbG9nLnByYWNrZWQuaW5kZXhPZihyZXNwb25zZS5nZXRIZWFkZXIoJ3JzZXEnKSksIDEpO1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIG5vdCBzZXQgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5sb2dnZXIud2FybignaW52YWxpZCBTRFAnKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKTpcbiAgICAgICAgdmFyIGNzZXEgPSB0aGlzLnJlcXVlc3QuY3NlcSArICcgJyArIHRoaXMucmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIGlmIChjc2VxICE9PSByZXNwb25zZS5nZXRIZWFkZXIoJ2NzZXEnKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19FQVJMWV9NRURJQSAmJiB0aGlzLmRpYWxvZykge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgIHRoaXMudW5tdXRlKCk7XG4gICAgICAgICAgLypsb2NhbE1lZGlhID0gdGhpcy5tZWRpYUhhbmRsZXIubG9jYWxNZWRpYTtcbiAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgfSovXG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmJvZHkpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6ICcgKyB0aGlzLnJlbmRlcnR5cGUpO1xuICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSB0aGlzLnJlbmRlcmJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMuY3NlcSA9IHJlc3BvbnNlLmNzZXE7XG4gICAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChTSVAuQy5BQ0ssIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhpcy5kaWFsb2cgaXMgYWxyZWFkeSBjb25maXJtZWRcbiAgICAgICAgaWYgKHRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBTSVAuSGFja3MuRmlyZWZveC5jYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2UocmVzcG9uc2UpO1xuICAgICAgICBTSVAuSGFja3MuQWxsQnJvd3NlcnMubWFza0R0bHMocmVzcG9uc2UpO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW52aXRlIHdpdGhvdXQgc2RwXG4gICAgICAgIGlmICghdGhpcy5oYXNPZmZlcikge1xuICAgICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nc1tpZF0gJiYgdGhpcy5lYXJseURpYWxvZ3NbaWRdLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhKSB7XG4gICAgICAgICAgICAvL1JFVklTSVRcbiAgICAgICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIgPSB0aGlzLmVhcmx5RGlhbG9nc1tpZF0ubWVkaWFIYW5kbGVyO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZURpYWxvZyhyZXNwb25zZSwgJ1VBQycpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywge2NzZXE6cmVzcG9uc2UuY3NlcX0pO1xuXG4gICAgICAgICAgICB0aGlzLnVubXV0ZSgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRoaXMuYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZighcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICB0aGlzLmFjY2VwdEFuZFRlcm1pbmF0ZShyZXNwb25zZSwgNDAwLCAnTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFIYW5kbGVyLnNldERlc2NyaXB0aW9uKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAudGhlbih0aGlzLm1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbi5iaW5kKHRoaXMubWVkaWFIYW5kbGVyLCB0aGlzLm1lZGlhSGludCkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiBvblN1Y2Nlc3Moc2RwKSB7XG4gICAgICAgICAgICAgIC8vdmFyIGxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIGlmKHNlc3Npb24uaXNDYW5jZWxlZCB8fCBzZXNzaW9uLnN0YXR1cyA9PT0gQy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNkcCA9IFNJUC5IYWNrcy5GaXJlZm94Lmhhc01pc3NpbmdDTGluZUluU0RQKHNkcCk7XG5cbiAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgIHNlc3Npb24uaGFzQW5zd2VyID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBzZXNzaW9uLnVubXV0ZSgpO1xuICAgICAgICAgICAgICAvKmxvY2FsTWVkaWEgPSBzZXNzaW9uLm1lZGlhSGFuZGxlci5sb2NhbE1lZGlhO1xuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxvY2FsTWVkaWEuZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpWzBdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgc2Vzc2lvbi5zZW5kUmVxdWVzdChTSVAuQy5BQ0sse1xuICAgICAgICAgICAgICAgIGJvZHk6IHNkcCxcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6WydDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3NkcCddLFxuICAgICAgICAgICAgICAgIGNzZXE6cmVzcG9uc2UuY3NlcVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIG9uRmFpbHVyZShlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU0lQLkV4Y2VwdGlvbnMuR2V0RGVzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gZG8gc29tZXRoaW5nIGhlcmVcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKFwidGhlcmUgd2FzIGEgcHJvYmxlbVwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxvZ2dlci53YXJuKCdpbnZhbGlkIFNEUCcpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucmVwbHkoNDg4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQW5zd2VyKXtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJib2R5KSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGVudC1UeXBlOiAnICsgc2Vzc2lvbi5yZW5kZXJ0eXBlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gdGhpcy5yZW5kZXJib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KFNJUC5DLkFDSywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0MDAsICdNaXNzaW5nIHNlc3Npb24gZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRGlhbG9nKHJlc3BvbnNlLCAnVUFDJykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5tZWRpYUhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307Ly8sbG9jYWxNZWRpYTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgIHNlc3Npb24udW5tdXRlKCk7XG4gICAgICAgICAgICAgIC8qbG9jYWxNZWRpYSA9IHNlc3Npb24ubWVkaWFIYW5kbGVyLmxvY2FsTWVkaWE7XG4gICAgICAgICAgICAgIGlmIChsb2NhbE1lZGlhLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsTWVkaWEuZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobG9jYWxNZWRpYS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1lZGlhLmdldFZpZGVvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICBpZiAoc2Vzc2lvbi5yZW5kZXJib2R5KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goJ0NvbnRlbnQtVHlwZTogJyArIHNlc3Npb24ucmVuZGVydHlwZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gc2Vzc2lvbi5yZW5kZXJib2R5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wdGlvbnMuY3NlcSA9IHJlc3BvbnNlLmNzZXE7XG4gICAgICAgICAgICAgIHNlc3Npb24uc2VuZFJlcXVlc3QoU0lQLkMuQUNLLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbi5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gb25GYWlsdXJlIChlKSB7XG4gICAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICAgIHNlc3Npb24uYWNjZXB0QW5kVGVybWluYXRlKHJlc3BvbnNlLCA0ODgsICdOb3QgQWNjZXB0YWJsZSBIZXJlJyk7XG4gICAgICAgICAgICAgIHNlc3Npb24uZmFpbGVkKHJlc3BvbnNlLCBTSVAuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICAgIHRoaXMucmVqZWN0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgfVxuICB9LFxuXG4gIGNhbmNlbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1RFUk1JTkFURUQgfHwgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2NhbmNlbGluZyBSVENTZXNzaW9uJyk7XG5cbiAgICB2YXIgY2FuY2VsX3JlYXNvbiA9IFNJUC5VdGlscy5nZXRDYW5jZWxSZWFzb24ob3B0aW9ucy5zdGF0dXNfY29kZSwgb3B0aW9ucy5yZWFzb25fcGhyYXNlKTtcblxuICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19OVUxMIHx8XG4gICAgICAgICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfSU5WSVRFX1NFTlQgJiYgIXRoaXMucmVjZWl2ZWRfMTAwKSkge1xuICAgICAgdGhpcy5pc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FuY2VsUmVhc29uID0gY2FuY2VsX3JlYXNvbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19JTlZJVEVfU0VOVCB8fFxuICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTXzFYWF9SRUNFSVZFRCB8fFxuICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuY2FuY2VsKGNhbmNlbF9yZWFzb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhbmNlbGVkKCk7XG4gIH0sXG5cbiAgdGVybWluYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSyB8fCB0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICB0aGlzLmJ5ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW5jZWwob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZVJlcXVlc3Q6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAvLyBJQ0MgUkVDRUlWRSBSRVFVRVNUXG5cbiAgICAvLyBSZWplY3QgQ0FOQ0VMc1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gU0lQLkMuQ0FOQ0VMKSB7XG4gICAgICAvLyBUT0RPOyBtYWtlIHRoaXMgYSBzd2l0Y2ggd2hlbiBpdCBnZXRzIGFkZGVkXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBTSVAuQy5BQ0sgJiYgdGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuYWNrVGltZXIpO1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICB0aGlzLnVubXV0ZSgpO1xuXG4gICAgICB0aGlzLmFjY2VwdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlc3Npb24ucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0LmFwcGx5KHRoaXMsIFtyZXF1ZXN0XSk7XG4gIH0sXG5cbiAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19DT05GSVJNRUQgJiYgdGhpcy5zdGF0dXMgIT09IEMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgIHRoaXMuZmFpbGVkKG51bGwsIFNJUC5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZXF1ZXN0VGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBDLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLmZhaWxlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgIHRoaXMudGVybWluYXRlZChudWxsLCBTSVAuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9XG4gIH1cblxufTtcblxuU0lQLkludml0ZUNsaWVudENvbnRleHQgPSBJbnZpdGVDbGllbnRDb250ZXh0O1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TZXNzaW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBEVE1GXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRFRNRlxuICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxudmFyIERUTUYsXG4gIEMgPSB7XG4gICAgTUlOX0RVUkFUSU9OOiAgICAgICAgICAgIDcwLFxuICAgIE1BWF9EVVJBVElPTjogICAgICAgICAgICA2MDAwLFxuICAgIERFRkFVTFRfRFVSQVRJT046ICAgICAgICAxMDAsXG4gICAgTUlOX0lOVEVSX1RPTkVfR0FQOiAgICAgIDUwLFxuICAgIERFRkFVTFRfSU5URVJfVE9ORV9HQVA6ICA1MDBcbiAgfTtcblxuRFRNRiA9IGZ1bmN0aW9uKHNlc3Npb24sIHRvbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGR1cmF0aW9uLCBpbnRlclRvbmVHYXA7XG5cbiAgaWYgKHRvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIH1cblxuICB0aGlzLmxvZ2dlciA9IHNlc3Npb24udWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlY29udGV4dC5kdG1mJywgc2Vzc2lvbi5pZCk7XG4gIHRoaXMub3duZXIgPSBzZXNzaW9uO1xuICB0aGlzLmRpcmVjdGlvbiA9IG51bGw7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCBudWxsO1xuICBpbnRlclRvbmVHYXAgPSBvcHRpb25zLmludGVyVG9uZUdhcCB8fCBudWxsO1xuXG4gIC8vIENoZWNrIHRvbmUgdHlwZVxuICBpZiAodHlwZW9mIHRvbmUgPT09ICdzdHJpbmcnICkge1xuICAgIHRvbmUgPSB0b25lLnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvbmUgPT09ICdudW1iZXInKSB7XG4gICAgdG9uZSA9IHRvbmUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRvbmU6ICcrIHRvbmUpO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG9uZSB2YWx1ZVxuICBpZiAoIXRvbmUubWF0Y2goL15bMC05QS1EIypdJC8pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0b25lOiAnKyB0b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRvbmUgPSB0b25lO1xuICB9XG5cbiAgLy8gQ2hlY2sgZHVyYXRpb25cbiAgaWYgKGR1cmF0aW9uICYmICFTSVAuVXRpbHMuaXNEZWNpbWFsKGR1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdG9uZSBkdXJhdGlvbjogJysgZHVyYXRpb24pO1xuICB9IGVsc2UgaWYgKCFkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uID0gRFRNRi5DLkRFRkFVTFRfRFVSQVRJT047XG4gIH0gZWxzZSBpZiAoZHVyYXRpb24gPCBEVE1GLkMuTUlOX0RVUkFUSU9OKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignXCJkdXJhdGlvblwiIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIG1pbmltdW0gYWxsb3dlZCwgc2V0dGluZyBpdCB0byAnKyBEVE1GLkMuTUlOX0RVUkFUSU9OKyAnIG1pbGxpc2Vjb25kcycpO1xuICAgIGR1cmF0aW9uID0gRFRNRi5DLk1JTl9EVVJBVElPTjtcbiAgfSBlbHNlIGlmIChkdXJhdGlvbiA+IERUTUYuQy5NQVhfRFVSQVRJT04pIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdcImR1cmF0aW9uXCIgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gJysgRFRNRi5DLk1BWF9EVVJBVElPTiArJyBtaWxsaXNlY29uZHMnKTtcbiAgICBkdXJhdGlvbiA9IERUTUYuQy5NQVhfRFVSQVRJT047XG4gIH0gZWxzZSB7XG4gICAgZHVyYXRpb24gPSBNYXRoLmFicyhkdXJhdGlvbik7XG4gIH1cbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG4gIC8vIENoZWNrIGludGVyVG9uZUdhcFxuICBpZiAoaW50ZXJUb25lR2FwICYmICFTSVAuVXRpbHMuaXNEZWNpbWFsKGludGVyVG9uZUdhcCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGludGVyVG9uZUdhcDogJysgaW50ZXJUb25lR2FwKTtcbiAgfSBlbHNlIGlmICghaW50ZXJUb25lR2FwKSB7XG4gICAgaW50ZXJUb25lR2FwID0gRFRNRi5DLkRFRkFVTFRfSU5URVJfVE9ORV9HQVA7XG4gIH0gZWxzZSBpZiAoaW50ZXJUb25lR2FwIDwgRFRNRi5DLk1JTl9JTlRFUl9UT05FX0dBUCkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1wiaW50ZXJUb25lR2FwXCIgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkLCBzZXR0aW5nIGl0IHRvICcrIERUTUYuQy5NSU5fSU5URVJfVE9ORV9HQVAgKycgbWlsbGlzZWNvbmRzJyk7XG4gICAgaW50ZXJUb25lR2FwID0gRFRNRi5DLk1JTl9JTlRFUl9UT05FX0dBUDtcbiAgfSBlbHNlIHtcbiAgICBpbnRlclRvbmVHYXAgPSBNYXRoLmFicyhpbnRlclRvbmVHYXApO1xuICB9XG4gIHRoaXMuaW50ZXJUb25lR2FwID0gaW50ZXJUb25lR2FwO1xufTtcbkRUTUYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTSVAuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cblxuRFRNRi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGV4dHJhSGVhZGVycywgYm9keTtcblxuICB0aGlzLmRpcmVjdGlvbiA9ICdvdXRnb2luZyc7XG5cbiAgLy8gQ2hlY2sgUlRDU2Vzc2lvbiBTdGF0dXNcbiAgaWYgKHRoaXMub3duZXIuc3RhdHVzICE9PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19DT05GSVJNRUQgJiZcbiAgICB0aGlzLm93bmVyLnN0YXR1cyAhPT0gU0lQLlNlc3Npb24uQy5TVEFUVVNfV0FJVElOR19GT1JfQUNLKSB7XG4gICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMub3duZXIuc3RhdHVzKTtcbiAgfVxuXG4gIC8vIEdldCBEVE1GIG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzID8gb3B0aW9ucy5leHRyYUhlYWRlcnMuc2xpY2UoKSA6IFtdO1xuXG4gIGV4dHJhSGVhZGVycy5wdXNoKCdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2R0bWYtcmVsYXknKTtcblxuICBib2R5ID0gXCJTaWduYWw9IFwiICsgdGhpcy50b25lICsgXCJcXHJcXG5cIjtcbiAgYm9keSArPSBcIkR1cmF0aW9uPSBcIiArIHRoaXMuZHVyYXRpb247XG5cbiAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5vd25lci5kaWFsb2cuc2VuZFJlcXVlc3QodGhpcywgU0lQLkMuSU5GTywge1xuICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgIGJvZHk6IGJvZHlcbiAgfSk7XG5cbiAgdGhpcy5vd25lci5lbWl0KCdkdG1mJywgdGhpcy5yZXF1ZXN0LCB0aGlzKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIGNhdXNlO1xuXG4gIHN3aXRjaCh0cnVlKSB7XG4gICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgLy8gSWdub3JlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcy5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAvXjJbMC05XXsyfSQvLnRlc3QocmVzcG9uc2Uuc3RhdHVzX2NvZGUpOlxuICAgICAgdGhpcy5lbWl0KCdzdWNjZWVkZWQnLCB7XG4gICAgICAgIG9yaWdpbmF0b3I6ICdyZW1vdGUnLFxuICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY2F1c2UgPSBTSVAuVXRpbHMuc2lwRXJyb3JDYXVzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG4gICAgICB0aGlzLmVtaXQoJ2ZhaWxlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5vblJlcXVlc3RUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gIHRoaXMub3duZXIub25SZXF1ZXN0VGltZW91dCgpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgbnVsbCwgU0lQLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICB0aGlzLm93bmVyLm9uVHJhbnNwb3J0RXJyb3IoKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRFRNRi5wcm90b3R5cGUub25EaWFsb2dFcnJvciA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gIHRoaXMuZW1pdCgnZmFpbGVkJywgcmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICB0aGlzLm93bmVyLm9uRGlhbG9nRXJyb3IocmVzcG9uc2UpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5EVE1GLnByb3RvdHlwZS5pbml0X2luY29taW5nID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICB0aGlzLmRpcmVjdGlvbiA9ICdpbmNvbWluZyc7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgcmVxdWVzdC5yZXBseSgyMDApO1xuXG4gIGlmICghdGhpcy50b25lIHx8ICF0aGlzLmR1cmF0aW9uKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignaW52YWxpZCBJTkZPIERUTUYgcmVjZWl2ZWQsIGRpc2NhcmRlZCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3duZXIuZW1pdCgnZHRtZicsIHJlcXVlc3QsIHRoaXMpO1xuICB9XG59O1xuXG5EVE1GLkMgPSBDO1xucmV0dXJuIERUTUY7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TZXNzaW9uL0RUTUYuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0lQIFN1YnNjcmliZXIgKFNJUC1TcGVjaWZpYyBFdmVudCBOb3RpZmljYXRpb25zIFJGQzY2NjUpXG4gKi9cblxuLyoqXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgU3Vic2NyaXB0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblNJUC5TdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAodWEsIHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcblxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy5zdGF0ZSA9ICdpbml0JztcblxuICBpZiAoIWV2ZW50KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZlbnQgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBhIHN1YnNjcmlwdGlvbi4nKTtcbiAgfSBlbHNlIHtcbiAgICAvL1RPRE86IGNoZWNrIGZvciB2YWxpZCBldmVudHMgaGVyZSBwcm9iYWJseSBtYWtlIGEgbGlzdCBpbiBTSVAuQzsgb3IgbGVhdmUgaXQgdXAgdG8gYXBwIHRvIGNoZWNrP1xuICAgIC8vVGhlIGNoZWNrIG1heSBuZWVkIHRvL3Nob3VsZCBwcm9iYWJseSBvY2N1ciBvbiB0aGUgb3RoZXIgc2lkZSxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cblxuICBpZih0eXBlb2Ygb3B0aW9ucy5leHBpcmVzICE9PSAnbnVtYmVyJyl7XG4gICAgdWEubG9nZ2VyLndhcm4oJ2V4cGlyZXMgbXVzdCBiZSBhIG51bWJlci4gVXNpbmcgZGVmYXVsdCBvZiAzNjAwLicpO1xuICAgIHRoaXMuZXhwaXJlcyA9IDM2MDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuICB9XG5cbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnRXZlbnQ6ICcgKyB0aGlzLmV2ZW50KTtcbiAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaCgnRXhwaXJlczogJyArIHRoaXMuZXhwaXJlcyk7XG5cbiAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgfVxuXG4gIHRoaXMuY29udGFjdCA9IHVhLmNvbnRhY3QudG9TdHJpbmcoKTtcblxuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdDb250YWN0OiAnKyB0aGlzLmNvbnRhY3QpO1xuICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKCdBbGxvdzogJysgU0lQLlVBLkMuQUxMT1dFRF9NRVRIT0RTLnRvU3RyaW5nKCkpO1xuXG4gIFNJUC5VdGlscy5hdWdtZW50KHRoaXMsIFNJUC5DbGllbnRDb250ZXh0LCBbdWEsIFNJUC5DLlNVQlNDUklCRSwgdGFyZ2V0LCBvcHRpb25zXSk7XG5cbiAgdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoJ3NpcC5zdWJzY3JpcHRpb24nKTtcblxuICB0aGlzLmRpYWxvZyA9IG51bGw7XG4gIHRoaXMudGltZXJzID0ge046IG51bGwsIHN1Yl9kdXJhdGlvbjogbnVsbH07XG4gIHRoaXMuZXJyb3JDb2RlcyAgPSBbNDA0LDQwNSw0MTAsNDE2LDQ4MCw0ODEsNDgyLDQ4Myw0ODQsNDg1LDQ4OSw1MDEsNjA0XTtcbn07XG5cblNJUC5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0ge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdWIgPSB0aGlzO1xuXG4gICAgIC8vdGhlc2Ugc3RhdGVzIHBvaW50IHRvIGFuIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiwgbm8gc3Vic2NyaWJlIGlzIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnYWN0aXZlJykge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG4gICAgdGhpcy50aW1lcnMuTiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIudGltZXJfZmlyZS5iaW5kKHN1YiksIFNJUC5UaW1lcnMuVElNRVJfTik7XG5cbiAgICB0aGlzLnNlbmQoKTtcblxuICAgIHRoaXMuc3RhdGUgPSAnbm90aWZ5X3dhaXQnO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAndGVybWluYXRlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ3BlbmRpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpYWxvZy5zZW5kUmVxdWVzdCh0aGlzLCBTSVAuQy5TVUJTQ1JJQkUsIHtcbiAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmJvZHlcbiAgICB9KTtcbiAgfSxcblxuICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdmFyIGV4cGlyZXMsIHN1YiA9IHRoaXMsXG4gICAgICAgIGNhdXNlID0gU0lQLlV0aWxzLmdldFJlYXNvblBocmFzZShyZXNwb25zZS5zdGF0dXNfY29kZSk7XG5cbiAgICBpZiAoKHRoaXMuc3RhdGUgPT09ICdub3RpZnlfd2FpdCcgJiYgcmVzcG9uc2Uuc3RhdHVzX2NvZGUgPj0gMzAwKSB8fFxuICAgICAgICAodGhpcy5zdGF0ZSAhPT0gJ25vdGlmeV93YWl0JyAmJiB0aGlzLmVycm9yQ29kZXMuaW5kZXhPZihyZXNwb25zZS5zdGF0dXNfY29kZSkgIT09IC0xKSkge1xuICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAoL14yWzAtOV17Mn0kLy50ZXN0KHJlc3BvbnNlLnN0YXR1c19jb2RlKSl7XG4gICAgICBleHBpcmVzID0gcmVzcG9uc2UuZ2V0SGVhZGVyKCdFeHBpcmVzJyk7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcblxuICAgICAgaWYgKHRoaXMuY3JlYXRlQ29uZmlybWVkRGlhbG9nKHJlc3BvbnNlLCdVQUMnKSkge1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5kaWFsb2cuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KCdhY2NlcHRlZCcsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIC8vIFVQREFURSBST1VURSBTRVQgVE8gQkUgQkFDS1dBUkRTIENPTVBBVElCTEU/XG4gICAgICB9XG5cbiAgICAgIGlmIChleHBpcmVzICYmIGV4cGlyZXMgPD0gdGhpcy5leHBpcmVzKSB7XG4gICAgICAgIC8vIFByZXNlcnZlIG5ldyBleHBpcmVzIHZhbHVlIGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICAgIHRoaXMuZXhwaXJlcyA9IGV4cGlyZXM7XG4gICAgICAgIHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIucmVmcmVzaC5iaW5kKHN1YiksIGV4cGlyZXMgKiA5MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFleHBpcmVzKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignRXhwaXJlcyBoZWFkZXIgbWlzc2luZyBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBTVUJTQ1JJQkUnKTtcbiAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgU0lQLkMuRVhQSVJFU19IRUFERVJfTUlTU0lORyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignRXhwaXJlcyBoZWFkZXIgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFIHdpdGggYSBoaWdoZXIgdmFsdWUgdGhhbiB0aGUgb25lIGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLklOVkFMSURfRVhQSVJFU19IRUFERVIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvL1VzZWQgdG8ganVzdCBpZ25vcmUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzOyBub3cgaWdub3JlcyBldmVyeXRoaW5nIGV4Y2VwdCBlcnJvckNvZGVzIGFuZCAyeHhcbiAgfSxcblxuICB1bnN1YnNjcmliZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdLCBzdWIgPSB0aGlzO1xuXG4gICAgdGhpcy5zdGF0ZSA9ICd0ZXJtaW5hdGVkJztcblxuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdFdmVudDogJyArIHRoaXMuZXZlbnQpO1xuICAgIGV4dHJhSGVhZGVycy5wdXNoKCdFeHBpcmVzOiAwJyk7XG5cbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQ29udGFjdDogJysgdGhpcy5jb250YWN0KTtcbiAgICBleHRyYUhlYWRlcnMucHVzaCgnQWxsb3c6ICcrIFNJUC5VQS5DLkFMTE9XRURfTUVUSE9EUy50b1N0cmluZygpKTtcblxuICAgIC8vbWFrZXMgc3VyZSBleHBpcmVzIGlzbid0IHNldCwgYW5kIG90aGVyIHR5cGljYWwgcmVzdWJzY3JpYmUgYmVoYXZpb3JcbiAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uKCl7fTtcblxuICAgIHRoaXMuZGlhbG9nLnNlbmRSZXF1ZXN0KHRoaXMsIHRoaXMubWV0aG9kLCB7XG4gICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuYm9keVxuICAgIH0pO1xuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICB0aGlzLnRpbWVycy5OID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KHN1Yi50aW1lcl9maXJlLmJpbmQoc3ViKSwgU0lQLlRpbWVycy5USU1FUl9OKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aW1lcl9maXJlOiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAndGVybWluYXRlZCcpIHtcbiAgICAgIHRoaXMudGVybWluYXRlRGlhbG9nKCk7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnN1Yl9kdXJhdGlvbik7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnVhLnN1YnNjcmlwdGlvbnNbdGhpcy5pZF07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAncGVuZGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ25vdGlmeV93YWl0Jykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuc3RhdGUgIT09ICdub3RpZnlfd2FpdCcgJiYgdGhpcy5zdGF0ZSAhPT0gJ3Rlcm1pbmF0ZWQnKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIGNyZWF0ZUNvbmZpcm1lZERpYWxvZzogZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgIHZhciBkaWFsb2c7XG5cbiAgICB0aGlzLnRlcm1pbmF0ZURpYWxvZygpO1xuICAgIGRpYWxvZyA9IG5ldyBTSVAuRGlhbG9nKHRoaXMsIG1lc3NhZ2UsIHR5cGUpO1xuXG4gICAgaWYoIWRpYWxvZy5lcnJvcikge1xuICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRGlhbG9nIG5vdCBjcmVhdGVkIGR1ZSB0byBhbiBlcnJvclxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0ZXJtaW5hdGVEaWFsb2c6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuZGlhbG9nKSB7XG4gICAgICBkZWxldGUgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuICAgICAgdGhpcy5kaWFsb2cudGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5kaWFsb2c7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIHJlY2VpdmVSZXF1ZXN0OiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgdmFyIHN1Yl9zdGF0ZSwgc3ViID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHNldEV4cGlyZXNUaW1lb3V0KCkge1xuICAgICAgaWYgKHN1Yl9zdGF0ZS5leHBpcmVzKSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHN1Yi50aW1lcnMuc3ViX2R1cmF0aW9uKTtcbiAgICAgICAgc3ViX3N0YXRlLmV4cGlyZXMgPSBNYXRoLm1pbihzdWIuZXhwaXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChzdWJfc3RhdGUuZXhwaXJlcywgMCkpO1xuICAgICAgICBzdWIudGltZXJzLnN1Yl9kdXJhdGlvbiA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChzdWIucmVmcmVzaC5iaW5kKHN1YiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViX3N0YXRlLmV4cGlyZXMgKiA5MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXRjaEV2ZW50KHJlcXVlc3QpKSB7IC8vY2hlY2tzIGV2ZW50IGFuZCBzdWJzY3JpcHRpb25fc3RhdGUgaGVhZGVyc1xuICAgICAgcmVxdWVzdC5yZXBseSg0ODkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1Yl9zdGF0ZSA9IHJlcXVlc3QucGFyc2VIZWFkZXIoJ1N1YnNjcmlwdGlvbi1TdGF0ZScpO1xuXG4gICAgcmVxdWVzdC5yZXBseSgyMDAsIFNJUC5DLlJFQVNPTl8yMDApO1xuXG4gICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuTik7XG5cbiAgICB0aGlzLmVtaXQoJ25vdGlmeScsIHtyZXF1ZXN0OiByZXF1ZXN0fSk7XG5cbiAgICAvLyBpZiB3ZSd2ZSBzZXQgc3RhdGUgdG8gdGVybWluYXRlZCwgbm8gZnVydGhlciBwcm9jZXNzaW5nIHNob3VsZCB0YWtlIHBsYWNlXG4gICAgLy8gYW5kIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gY2xlYW5pbmcgdXAgYWZ0ZXIgdGhlIGFwcHJvcHJpYXRlIE5PVElGWVxuICAgIGlmICh0aGlzLnN0YXRlID09PSAndGVybWluYXRlZCcpIHtcbiAgICAgIGlmIChzdWJfc3RhdGUuc3RhdGUgPT09ICd0ZXJtaW5hdGVkJykge1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZURpYWxvZygpO1xuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5OKTtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc3ViX2R1cmF0aW9uKTtcblxuICAgICAgICBkZWxldGUgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3ViX3N0YXRlLnN0YXRlKSB7XG4gICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICB0aGlzLnN0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICAgIHNldEV4cGlyZXNUaW1lb3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnbm90aWZ5X3dhaXQnKSB7XG4gICAgICAgICAgc2V0RXhwaXJlc1RpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gJ3BlbmRpbmcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Rlcm1pbmF0ZWQnOlxuICAgICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24pO1xuICAgICAgICBpZiAoc3ViX3N0YXRlLnJlYXNvbikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygndGVybWluYXRpbmcgc3Vic2NyaXB0aW9uIHdpdGggcmVhc29uICcrIHN1Yl9zdGF0ZS5yZWFzb24pO1xuICAgICAgICAgIHN3aXRjaCAoc3ViX3N0YXRlLnJlYXNvbikge1xuICAgICAgICAgICAgY2FzZSAnZGVhY3RpdmF0ZWQnOlxuICAgICAgICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2JhdGlvbic6XG4gICAgICAgICAgICBjYXNlICdnaXZldXAnOlxuICAgICAgICAgICAgICBpZihzdWJfc3RhdGUucGFyYW1zICYmIHN1Yl9zdGF0ZS5wYXJhbXNbJ3JldHJ5LWFmdGVyJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVycy5zdWJfZHVyYXRpb24gPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoc3ViLnN1YnNjcmliZS5iaW5kKHN1YiksIHN1Yl9zdGF0ZS5wYXJhbXNbJ3JldHJ5LWFmdGVyJ10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgY2FzZSAnbm9yZXNvdXJjZSc6XG4gICAgICAgICAgICBjYXNlICdpbnZhcmlhbnQnOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgZmFpbGVkOiBmdW5jdGlvbihyZXNwb25zZSwgY2F1c2UpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5lbWl0KCdmYWlsZWQnLCByZXNwb25zZSwgY2F1c2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uRGlhbG9nRXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIFNJUC5DLmNhdXNlcy5ESUFMT0dfRVJST1IpO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICovXG4gIG1hdGNoRXZlbnQ6IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgZXZlbnQ7XG5cbiAgICAvLyBDaGVjayBtYW5kYXRvcnkgaGVhZGVyIEV2ZW50XG4gICAgaWYgKCFyZXF1ZXN0Lmhhc0hlYWRlcignRXZlbnQnKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignbWlzc2luZyBFdmVudCBoZWFkZXInKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgbWFuZGF0b3J5IGhlYWRlciBTdWJzY3JpcHRpb24tU3RhdGVcbiAgICBpZiAoIXJlcXVlc3QuaGFzSGVhZGVyKCdTdWJzY3JpcHRpb24tU3RhdGUnKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignbWlzc2luZyBTdWJzY3JpcHRpb24tU3RhdGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZXZlbnQgaW4gTk9USUZZIG1hdGNoZXMgdGhlIGV2ZW50IGluIFNVQlNDUklCRVxuICAgIGV2ZW50ID0gcmVxdWVzdC5wYXJzZUhlYWRlcignZXZlbnQnKS5ldmVudDtcblxuICAgIGlmICh0aGlzLmV2ZW50ICE9PSBldmVudCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignZXZlbnQgbWF0Y2ggZmFpbGVkJyk7XG4gICAgICByZXF1ZXN0LnJlcGx5KDQ4MSwgJ0V2ZW50IE1hdGNoIEZhaWxlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TdWJzY3JpcHRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFdlYlJUQ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcbnZhciBXZWJSVEM7XG5cbldlYlJUQyA9IHt9O1xuXG5XZWJSVEMuTWVkaWFIYW5kbGVyID0gcmVxdWlyZSgnLi9XZWJSVEMvTWVkaWFIYW5kbGVyJykoU0lQKTtcbldlYlJUQy5NZWRpYVN0cmVhbU1hbmFnZXIgPSByZXF1aXJlKCcuL1dlYlJUQy9NZWRpYVN0cmVhbU1hbmFnZXInKShTSVAsIGVudmlyb25tZW50KTtcblxudmFyIF9pc1N1cHBvcnRlZDtcblxuV2ViUlRDLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gX2lzU3VwcG9ydGVkO1xuICB9XG5cbiAgV2ViUlRDLk1lZGlhU3RyZWFtID0gZW52aXJvbm1lbnQuTWVkaWFTdHJlYW07XG4gIFdlYlJUQy5nZXRVc2VyTWVkaWEgPSBlbnZpcm9ubWVudC5nZXRVc2VyTWVkaWE7XG4gIFdlYlJUQy5SVENQZWVyQ29ubmVjdGlvbiA9IGVudmlyb25tZW50LlJUQ1BlZXJDb25uZWN0aW9uO1xuICBXZWJSVEMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gZW52aXJvbm1lbnQuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuXG4gIGlmIChXZWJSVEMuUlRDUGVlckNvbm5lY3Rpb24gJiYgV2ViUlRDLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgIGlmIChXZWJSVEMuZ2V0VXNlck1lZGlhKSB7XG4gICAgICBXZWJSVEMuZ2V0VXNlck1lZGlhID0gU0lQLlV0aWxzLnByb21pc2lmeShlbnZpcm9ubWVudCwgJ2dldFVzZXJNZWRpYScpO1xuICAgIH1cbiAgICBfaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIF9pc1N1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBfaXNTdXBwb3J0ZWQ7XG59O1xuXG5yZXR1cm4gV2ViUlRDO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvV2ViUlRDLmpzXG4gKiogbW9kdWxlIGlkID0gMjM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNZWRpYUhhbmRsZXJcbiAqL1xuXG4vKiBNZWRpYUhhbmRsZXJcbiAqIEBjbGFzcyBQZWVyQ29ubmVjdGlvbiBoZWxwZXIgQ2xhc3MuXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1NJUC5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyfSBbb3B0aW9ucy5tZWRpYVN0cmVhbU1hbmFnZXJdXG4gKiAgICAgICAgVGhlIE1lZGlhU3RyZWFtTWFuYWdlciB0byBhY3F1aXJlL3JlbGVhc2Ugc3RyZWFtcyBmcm9tL3RvLlxuICogICAgICAgIElmIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IE1lZGlhU3RyZWFtTWFuYWdlciB3aWxsIGJlIHVzZWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xuXG52YXIgTWVkaWFIYW5kbGVyID0gZnVuY3Rpb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLmxvZ2dlciA9IHNlc3Npb24udWEuZ2V0TG9nZ2VyKCdzaXAuaW52aXRlY29udGV4dC5tZWRpYWhhbmRsZXInLCBzZXNzaW9uLmlkKTtcbiAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgdGhpcy5sb2NhbE1lZGlhID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IHRydWU7XG4gIHRoaXMubWVkaWFTdHJlYW1NYW5hZ2VyID0gb3B0aW9ucy5tZWRpYVN0cmVhbU1hbmFnZXIgfHwgbmV3IFNJUC5XZWJSVEMuTWVkaWFTdHJlYW1NYW5hZ2VyKHRoaXMubG9nZ2VyKTtcbiAgdGhpcy5hdWRpb011dGVkID0gZmFsc2U7XG4gIHRoaXMudmlkZW9NdXRlZCA9IGZhbHNlO1xuXG4gIC8vIG9sZCBpbml0KCkgZnJvbSBoZXJlIG9uXG4gIHZhciBzZXJ2ZXJzID0gdGhpcy5wcmVwYXJlSWNlU2VydmVycyhvcHRpb25zLnN0dW5TZXJ2ZXJzLCBvcHRpb25zLnR1cm5TZXJ2ZXJzKTtcbiAgdGhpcy5SVENDb25zdHJhaW50cyA9IG9wdGlvbnMuUlRDQ29uc3RyYWludHMgfHwge307XG5cbiAgdGhpcy5pbml0UGVlckNvbm5lY3Rpb24oc2VydmVycywgdGhpcy5SVENDb25zdHJhaW50cyk7XG5cbiAgZnVuY3Rpb24gc2VsZkVtaXQobWgsIGV2ZW50KSB7XG4gICAgaWYgKG1oLm1lZGlhU3RyZWFtTWFuYWdlci5vbikge1xuICAgICAgbWgubWVkaWFTdHJlYW1NYW5hZ2VyLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1oLmVtaXQuYXBwbHkobWgsIFtldmVudF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNlbGZFbWl0KHRoaXMsICd1c2VyTWVkaWFSZXF1ZXN0Jyk7XG4gIHNlbGZFbWl0KHRoaXMsICd1c2VyTWVkaWEnKTtcbiAgc2VsZkVtaXQodGhpcywgJ3VzZXJNZWRpYUZhaWxlZCcpO1xufTtcblxuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5ID0gZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNZWRpYUhhbmRsZXIoc2Vzc2lvbiwgb3B0aW9ucyk7XG59O1xuTWVkaWFIYW5kbGVyLmRlZmF1bHRGYWN0b3J5LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gU0lQLldlYlJUQy5pc1N1cHBvcnRlZCgpO1xufTtcblxuTWVkaWFIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU0lQLk1lZGlhSGFuZGxlci5wcm90b3R5cGUsIHtcbi8vIEZ1bmN0aW9ucyB0aGUgc2Vzc2lvbiBjYW4gdXNlXG4gIGlzUmVhZHk6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGlzUmVhZHkgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5O1xuICB9fSxcblxuICBjbG9zZToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBQZWVyQ29ubmVjdGlvbicpO1xuICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAvLyBoYXZlIHRvIGNoZWNrIHNpZ25hbGluZ1N0YXRlIHNpbmNlIHRoaXMuY2xvc2UoKSBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIFRPRE8gZmlndXJlIG91dCB3aHkgdGhhdCBoYXBwZW5zXG4gICAgaWYodGhpcy5wZWVyQ29ubmVjdGlvbiAmJiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5jbG9zZSgpO1xuXG4gICAgICBpZih0aGlzLmxvY2FsTWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbU1hbmFnZXIucmVsZWFzZSh0aGlzLmxvY2FsTWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgfX0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U0lQLldlYlJUQy5NZWRpYVN0cmVhbSB8IChnZXRVc2VyTWVkaWEgY29uc3RyYWludHMpfSBbbWVkaWFIaW50XVxuICAgKiAgICAgICAgdGhlIE1lZGlhU3RyZWFtIChvciB0aGUgY29uc3RyYWludHMgZGVzY3JpYmluZyBpdCkgdG8gYmUgdXNlZCBmb3IgdGhlIHNlc3Npb25cbiAgICovXG4gIGdldERlc2NyaXB0aW9uOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXREZXNjcmlwdGlvbiAobWVkaWFIaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhY3F1aXJlID0gc2VsZi5tZWRpYVN0cmVhbU1hbmFnZXIuYWNxdWlyZTtcbiAgICBpZiAoYWNxdWlyZS5sZW5ndGggPiAxKSB7XG4gICAgICBhY3F1aXJlID0gU0lQLlV0aWxzLnByb21pc2lmeSh0aGlzLm1lZGlhU3RyZWFtTWFuYWdlciwgJ2FjcXVpcmUnLCB0cnVlKTtcbiAgICB9XG4gICAgbWVkaWFIaW50ID0gbWVkaWFIaW50IHx8IHt9O1xuICAgIGlmIChtZWRpYUhpbnQuZGF0YUNoYW5uZWwgPT09IHRydWUpIHtcbiAgICAgIG1lZGlhSGludC5kYXRhQ2hhbm5lbCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm1lZGlhSGludCA9IG1lZGlhSGludDtcblxuICAgIC8qXG4gICAgICogMS4gYWNxdWlyZSBzdHJlYW1zIChza2lwIGlmIE1lZGlhU3RyZWFtcyBwYXNzZWQgaW4pXG4gICAgICogMi4gYWRkU3RyZWFtc1xuICAgICAqIDMuIGNyZWF0ZU9mZmVyL2NyZWF0ZUFuc3dlclxuICAgICAqL1xuXG4gICAgdmFyIHN0cmVhbVByb21pc2U7XG4gICAgaWYgKHNlbGYubG9jYWxNZWRpYSkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdhbHJlYWR5IGhhdmUgbG9jYWwgbWVkaWEnKTtcbiAgICAgIHN0cmVhbVByb21pc2UgPSBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKHNlbGYubG9jYWxNZWRpYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdhY3F1aXJpbmcgbG9jYWwgbWVkaWEnKTtcbiAgICAgIHN0cmVhbVByb21pc2UgPSBhY3F1aXJlLmNhbGwoc2VsZi5tZWRpYVN0cmVhbU1hbmFnZXIsIG1lZGlhSGludClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gYWNxdWlyZVN1Y2NlZWRlZChzdHJlYW1zKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIubG9nKCdhY3F1aXJlZCBsb2NhbCBtZWRpYSBzdHJlYW1zJyk7XG4gICAgICAgICAgc2VsZi5sb2NhbE1lZGlhID0gc3RyZWFtcztcbiAgICAgICAgICBzZWxmLnNlc3Npb24uY29ubmVjdGluZygpO1xuICAgICAgICAgIHJldHVybiBzdHJlYW1zO1xuICAgICAgICB9LCBmdW5jdGlvbiBhY3F1aXJlRmFpbGVkKGVycikge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKCd1bmFibGUgdG8gYWNxdWlyZSBzdHJlYW1zJyk7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICBzZWxmLnNlc3Npb24uY29ubmVjdGluZygpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4odGhpcy5hZGRTdHJlYW1zLmJpbmQodGhpcykpXG4gICAgICA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmVhbVByb21pc2VcbiAgICAgIC50aGVuKGZ1bmN0aW9uIHN0cmVhbUFkZGl0aW9uU3VjY2VlZGVkKCkge1xuICAgICAgICBpZiAoc2VsZi5oYXNPZmZlcigncmVtb3RlJykpIHtcbiAgICAgICAgICBzZWxmLnBlZXJDb25uZWN0aW9uLm9uZGF0YWNoYW5uZWwgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBzZWxmLmRhdGFDaGFubmVsID0gZXZ0LmNoYW5uZWw7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2RhdGFDaGFubmVsJywgc2VsZi5kYXRhQ2hhbm5lbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYUhpbnQuZGF0YUNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgICAgICBzZWxmLnBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgc2VsZi5kYXRhQ2hhbm5lbCA9IHNlbGYucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwoXG4gICAgICAgICAgICAnc2lwanMnLFxuICAgICAgICAgICAgbWVkaWFIaW50LmRhdGFDaGFubmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2RhdGFDaGFubmVsJywgc2VsZi5kYXRhQ2hhbm5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gc2VsZi5jcmVhdGVPZmZlck9yQW5zd2VyKHNlbGYuUlRDQ29uc3RyYWludHMpO1xuICAgICAgfSlcbiAgICA7XG4gIH19LFxuXG4gIC8qKlxuICAqIE1lc3NhZ2UgcmVjZXB0aW9uLlxuICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICogQHBhcmFtIHtTdHJpbmd9IHNkcFxuICAqL1xuICBzZXREZXNjcmlwdGlvbjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gc2V0RGVzY3JpcHRpb24gKHNkcCkge1xuICAgIHZhciByYXdEZXNjcmlwdGlvbiA9IHtcbiAgICAgIHR5cGU6IHRoaXMuaGFzT2ZmZXIoJ2xvY2FsJykgPyAnYW5zd2VyJyA6ICdvZmZlcicsXG4gICAgICBzZHA6IHNkcFxuICAgIH07XG5cbiAgICB0aGlzLmVtaXQoJ3NldERlc2NyaXB0aW9uJywgcmF3RGVzY3JpcHRpb24pO1xuXG4gICAgdmFyIGRlc2NyaXB0aW9uID0gbmV3IFNJUC5XZWJSVEMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHJhd0Rlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gU0lQLlV0aWxzLnByb21pc2lmeSh0aGlzLnBlZXJDb25uZWN0aW9uLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nKShkZXNjcmlwdGlvbik7XG4gIH19LFxuXG4gIC8qKlxuICAgKiBJZiB0aGUgU2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBNZWRpYUhhbmRsZXIgd2VyZSB0byBiZSByZWZlcnJlZCxcbiAgICogd2hhdCBtZWRpYUhpbnQgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIHRoZSBVQSdzIGludml0ZSBtZXRob2Q/XG4gICAqL1xuICBnZXRSZWZlck1lZGlhOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWZlck1lZGlhICgpIHtcbiAgICBmdW5jdGlvbiBoYXNUcmFja3MgKHRyYWNrR2V0dGVyLCBzdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdHJlYW1bdHJhY2tHZXR0ZXJdKCkubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3RoSGF2ZVRyYWNrcyAodHJhY2tHZXR0ZXIpIHtcbiAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9jYWxTdHJlYW1zKCkuc29tZShoYXNUcmFja3MuYmluZChudWxsLCB0cmFja0dldHRlcikpICYmXG4gICAgICAgICAgICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zKCkuc29tZShoYXNUcmFja3MuYmluZChudWxsLCB0cmFja0dldHRlcikpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb25zdHJhaW50czoge1xuICAgICAgICBhdWRpbzogYm90aEhhdmVUcmFja3MuY2FsbCh0aGlzLCAnZ2V0QXVkaW9UcmFja3MnKSxcbiAgICAgICAgdmlkZW86IGJvdGhIYXZlVHJhY2tzLmNhbGwodGhpcywgJ2dldFZpZGVvVHJhY2tzJylcbiAgICAgIH1cbiAgICB9O1xuICB9fSxcblxuICB1cGRhdGVJY2VTZXJ2ZXJzOiB7d3JpdGVhYmxlOnRydWUsIHZhbHVlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZXJ2ZXJzID0gdGhpcy5wcmVwYXJlSWNlU2VydmVycyhvcHRpb25zLnN0dW5TZXJ2ZXJzLCBvcHRpb25zLnR1cm5TZXJ2ZXJzKTtcbiAgICB0aGlzLlJUQ0NvbnN0cmFpbnRzID0gb3B0aW9ucy5SVENDb25zdHJhaW50cyB8fCB0aGlzLlJUQ0NvbnN0cmFpbnRzO1xuXG4gICAgdGhpcy5pbml0UGVlckNvbm5lY3Rpb24oc2VydmVycywgdGhpcy5SVENDb25zdHJhaW50cyk7XG5cbiAgICAvKiBvbmNlIHVwZGF0ZUljZSBpcyBpbXBsZW1lbnRlZCBjb3JyZWN0bHksIHRoaXMgaXMgYmV0dGVyIHRoYW4gYWJvdmVcbiAgICAvL25vIG9wIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzXG4gICAgaWYgKCF0aGlzLnBlZXJDb25uZWN0aW9uLnVwZGF0ZUljZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24udXBkYXRlSWNlKHsnaWNlU2VydmVycyc6IHNlcnZlcnN9LCB0aGlzLlJUQ0NvbnN0cmFpbnRzKTtcbiAgICAqL1xuICB9fSxcblxuLy8gRnVuY3Rpb25zIHRoZSBzZXNzaW9uIGNhbiB1c2UsIGJ1dCBvbmx5IGJlY2F1c2UgaXQncyBjb252ZW5pZW50IGZvciB0aGUgYXBwbGljYXRpb25cbiAgaXNNdXRlZDoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gaXNNdXRlZCAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvOiB0aGlzLmF1ZGlvTXV0ZWQsXG4gICAgICB2aWRlbzogdGhpcy52aWRlb011dGVkXG4gICAgfTtcbiAgfX0sXG5cbiAgbXV0ZToge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gbXV0ZSAob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmdldExvY2FsU3RyZWFtcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgIGF1ZGlvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCxcbiAgICAgIHZpZGVvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMFxuICAgIH07XG5cbiAgICB2YXIgYXVkaW9NdXRlZCA9IGZhbHNlLFxuICAgICAgICB2aWRlb011dGVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hdWRpbyAmJiAhdGhpcy5hdWRpb011dGVkKSB7XG4gICAgICBhdWRpb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYXVkaW9NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy52aWRlbyAmJiAhdGhpcy52aWRlb011dGVkKSB7XG4gICAgICB2aWRlb011dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudmlkZW9NdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyh0cnVlKTtcbiAgICB9XG5cbiAgICAvL1JFVklTSVRcbiAgICBpZiAoYXVkaW9NdXRlZCB8fCB2aWRlb011dGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpbzogYXVkaW9NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvTXV0ZWRcbiAgICAgIH07XG4gICAgICAvKnRoaXMuc2Vzc2lvbi5vbm11dGUoe1xuICAgICAgICBhdWRpbzogYXVkaW9NdXRlZCxcbiAgICAgICAgdmlkZW86IHZpZGVvTXV0ZWRcbiAgICAgIH0pOyovXG4gICAgfVxuICB9fSxcblxuICB1bm11dGU6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHVubXV0ZSAob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmdldExvY2FsU3RyZWFtcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgIGF1ZGlvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCxcbiAgICAgIHZpZGVvOiB0aGlzLmdldExvY2FsU3RyZWFtcygpWzBdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID4gMFxuICAgIH07XG5cbiAgICB2YXIgYXVkaW9Vbk11dGVkID0gZmFsc2UsXG4gICAgICAgIHZpZGVvVW5NdXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgdGhpcy5hdWRpb011dGVkKSB7XG4gICAgICBhdWRpb1VuTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hdWRpb011dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudmlkZW8gJiYgdGhpcy52aWRlb011dGVkKSB7XG4gICAgICB2aWRlb1VuTXV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy52aWRlb011dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgLy9SRVZJU0lUXG4gICAgaWYgKGF1ZGlvVW5NdXRlZCB8fCB2aWRlb1VuTXV0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBhdWRpb1VuTXV0ZWQsXG4gICAgICAgIHZpZGVvOiB2aWRlb1VuTXV0ZWRcbiAgICAgIH07XG4gICAgICAvKnRoaXMuc2Vzc2lvbi5vbnVubXV0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb1VuTXV0ZWQsXG4gICAgICAgIHZpZGVvOiB2aWRlb1VuTXV0ZWRcbiAgICAgIH0pOyovXG4gICAgfVxuICB9fSxcblxuICBob2xkOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBob2xkICgpIHtcbiAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyh0cnVlKTtcbiAgICB0aGlzLnRvZ2dsZU11dGVWaWRlbyh0cnVlKTtcbiAgfX0sXG5cbiAgdW5ob2xkOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB1bmhvbGQgKCkge1xuICAgIGlmICghdGhpcy5hdWRpb011dGVkKSB7XG4gICAgICB0aGlzLnRvZ2dsZU11dGVBdWRpbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZpZGVvTXV0ZWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlTXV0ZVZpZGVvKGZhbHNlKTtcbiAgICB9XG4gIH19LFxuXG4vLyBGdW5jdGlvbnMgdGhlIGFwcGxpY2F0aW9uIGNhbiB1c2UsIGJ1dCBub3QgdGhlIHNlc3Npb25cbiAgZ2V0TG9jYWxTdHJlYW1zOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMgKCkge1xuICAgIHZhciBwYyA9IHRoaXMucGVlckNvbm5lY3Rpb247XG4gICAgaWYgKHBjICYmIHBjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigncGVlckNvbm5lY3Rpb24gaXMgY2xvc2VkLCBnZXRMb2NhbFN0cmVhbXMgcmV0dXJuaW5nIFtdJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiAocGMuZ2V0TG9jYWxTdHJlYW1zICYmIHBjLmdldExvY2FsU3RyZWFtcygpKSB8fFxuICAgICAgcGMubG9jYWxTdHJlYW1zIHx8IFtdO1xuICB9fSxcblxuICBnZXRSZW1vdGVTdHJlYW1zOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zICgpIHtcbiAgICB2YXIgcGMgPSB0aGlzLnBlZXJDb25uZWN0aW9uO1xuICAgIGlmIChwYyAmJiBwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3BlZXJDb25uZWN0aW9uIGlzIGNsb3NlZCwgZ2V0UmVtb3RlU3RyZWFtcyByZXR1cm5pbmcgdGhpcy5fcmVtb3RlU3RyZWFtcycpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXM7XG4gICAgfVxuICAgIHJldHVybihwYy5nZXRSZW1vdGVTdHJlYW1zICYmIHBjLmdldFJlbW90ZVN0cmVhbXMoKSkgfHxcbiAgICAgIHBjLnJlbW90ZVN0cmVhbXMgfHwgW107XG4gIH19LFxuXG4gIHJlbmRlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyIChyZW5kZXJIaW50KSB7XG4gICAgcmVuZGVySGludCA9IHJlbmRlckhpbnQgfHwgKHRoaXMubWVkaWFIaW50ICYmIHRoaXMubWVkaWFIaW50LnJlbmRlcik7XG4gICAgaWYgKCFyZW5kZXJIaW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzdHJlYW1HZXR0ZXJzID0ge1xuICAgICAgbG9jYWw6ICdnZXRMb2NhbFN0cmVhbXMnLFxuICAgICAgcmVtb3RlOiAnZ2V0UmVtb3RlU3RyZWFtcydcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHN0cmVhbUdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGxvYykge1xuICAgICAgdmFyIHN0cmVhbUdldHRlciA9IHN0cmVhbUdldHRlcnNbbG9jXTtcbiAgICAgIHZhciBzdHJlYW1zID0gdGhpc1tzdHJlYW1HZXR0ZXJdKCk7XG4gICAgICBTSVAuV2ViUlRDLk1lZGlhU3RyZWFtTWFuYWdlci5yZW5kZXIoc3RyZWFtcywgcmVuZGVySGludFtsb2NdKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9fSxcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb25zXG4gIGhhc09mZmVyOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBoYXNPZmZlciAod2hlcmUpIHtcbiAgICB2YXIgb2ZmZXJTdGF0ZSA9ICdoYXZlLScgKyB3aGVyZSArICctb2ZmZXInO1xuICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlID09PSBvZmZlclN0YXRlO1xuICAgIC8vIFRPRE8gY29uc2lkZXIgc2lnbmFsaW5nU3RhdGVzIHdpdGggJ3ByYW5zd2VyJz9cbiAgfX0sXG5cbiAgcHJlcGFyZUljZVNlcnZlcnM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVJY2VTZXJ2ZXJzIChzdHVuU2VydmVycywgdHVyblNlcnZlcnMpIHtcbiAgICB2YXIgc2VydmVycyA9IFtdLFxuICAgICAgY29uZmlnID0gdGhpcy5zZXNzaW9uLnVhLmNvbmZpZ3VyYXRpb247XG5cbiAgICBzdHVuU2VydmVycyA9IHN0dW5TZXJ2ZXJzIHx8IGNvbmZpZy5zdHVuU2VydmVycztcbiAgICB0dXJuU2VydmVycyA9IHR1cm5TZXJ2ZXJzIHx8IGNvbmZpZy50dXJuU2VydmVycztcblxuICAgIFtdLmNvbmNhdChzdHVuU2VydmVycykuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICBzZXJ2ZXJzLnB1c2goeyd1cmxzJzogc2VydmVyfSk7XG4gICAgfSk7XG5cbiAgICBbXS5jb25jYXQodHVyblNlcnZlcnMpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgc2VydmVycy5wdXNoKHtcbiAgICAgICAgJ3VybHMnOiBzZXJ2ZXIudXJscyxcbiAgICAgICAgJ3VzZXJuYW1lJzogc2VydmVyLnVzZXJuYW1lLFxuICAgICAgICAnY3JlZGVudGlhbCc6IHNlcnZlci5wYXNzd29yZFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VydmVycztcbiAgfX0sXG5cbiAgaW5pdFBlZXJDb25uZWN0aW9uOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiBpbml0UGVlckNvbm5lY3Rpb24oc2VydmVycywgUlRDQ29uc3RyYWludHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBjb25maWcgPSB0aGlzLnNlc3Npb24udWEuY29uZmlndXJhdGlvbjtcblxuICAgIHRoaXMub25JY2VDb21wbGV0ZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcbiAgICB0aGlzLm9uSWNlQ29tcGxldGVkLnByb21pc2UudGhlbihmdW5jdGlvbihwYykge1xuICAgICAgc2VsZi5lbWl0KCdpY2VHYXRoZXJpbmdDb21wbGV0ZScsIHBjKTtcbiAgICAgIGlmIChzZWxmLmljZUNoZWNraW5nVGltZXIpIHtcbiAgICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQoc2VsZi5pY2VDaGVja2luZ1RpbWVyKTtcbiAgICAgICAgc2VsZi5pY2VDaGVja2luZ1RpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG5ldyBTSVAuV2ViUlRDLlJUQ1BlZXJDb25uZWN0aW9uKHsnaWNlU2VydmVycyc6IHNlcnZlcnN9LCBSVENDb25zdHJhaW50cyk7XG5cbiAgICAvLyBGaXJlZm94ICgzNS4wLjEpIHNvbWV0aW1lcyB0aHJvd3Mgb24gY2FsbHMgdG8gcGVlckNvbm5lY3Rpb24uZ2V0UmVtb3RlU3RyZWFtc1xuICAgIC8vIGV2ZW4gaWYgcGVlckNvbm5lY3Rpb24ub25hZGRzdHJlYW0gd2FzIGp1c3QgY2FsbGVkLiBJbiBvcmRlciB0byBtYWtlXG4gICAgLy8gTWVkaWFIYW5kbGVyLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zIHdvcmssIGtlZXAgdHJhY2sgb2YgdGhlbSBtYW51YWxseVxuICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcblxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ3N0cmVhbSBhZGRlZDogJysgZS5zdHJlYW0uaWQpO1xuICAgICAgc2VsZi5fcmVtb3RlU3RyZWFtcy5wdXNoKGUuc3RyZWFtKTtcbiAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICBzZWxmLmVtaXQoJ2FkZFN0cmVhbScsIGUpO1xuICAgIH07XG5cbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9ucmVtb3Zlc3RyZWFtID0gZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdzdHJlYW0gcmVtb3ZlZDogJysgZS5zdHJlYW0uaWQpO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0SWNlQ2hlY2tpbmdUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5pY2VDaGVja2luZ1RpbWVyKSB7XG4gICAgICAgIHNlbGYuaWNlQ2hlY2tpbmdUaW1lciA9IFNJUC5UaW1lcnMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5sb2coJ1JUQ0ljZUNoZWNraW5nIFRpbWVvdXQgVHJpZ2dlcmVkIGFmdGVyICcrY29uZmlnLmljZUNoZWNraW5nVGltZW91dCsnIG1pbGxpc2Vjb25kcycpO1xuICAgICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMucGVlckNvbm5lY3Rpb24pLCBjb25maWcuaWNlQ2hlY2tpbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYuZW1pdCgnaWNlQ2FuZGlkYXRlJywgZSk7XG4gICAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgICAgc2VsZi5sb2dnZXIubG9nKCdJQ0UgY2FuZGlkYXRlIHJlY2VpdmVkOiAnKyAoZS5jYW5kaWRhdGUuY2FuZGlkYXRlID09PSBudWxsID8gbnVsbCA6IGUuY2FuZGlkYXRlLmNhbmRpZGF0ZS50cmltKCkpKTtcbiAgICAgICAgc2VsZi5zdGFydEljZUNoZWNraW5nVGltZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5sb2dnZXIubG9nKCdSVENJY2VHYXRoZXJpbmdTdGF0ZSBjaGFuZ2VkOiAnICsgdGhpcy5pY2VHYXRoZXJpbmdTdGF0ZSk7XG4gICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2dhdGhlcmluZycpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdpY2VHYXRoZXJpbmcnLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmljZUdhdGhlcmluZ1N0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQucmVzb2x2ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgeyAgLy9uZWVkIGUgZm9yIGNvbW1lbnRlZCBvdXQgY2FzZVxuICAgICAgdmFyIHN0YXRlRXZlbnQ7XG5cbiAgICAgIGlmICh0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NoZWNraW5nJykge1xuICAgICAgICBzZWxmLnN0YXJ0SWNlQ2hlY2tpbmdUaW1lcigpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICBjYXNlICduZXcnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb24nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ2hlY2tpbmcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkNvbm5lY3RlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ29tcGxldGVkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICBzdGF0ZUV2ZW50ID0gJ2ljZUNvbm5lY3Rpb25GYWlsZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgIHN0YXRlRXZlbnQgPSAnaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgc3RhdGVFdmVudCA9ICdpY2VDb25uZWN0aW9uQ2xvc2VkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKCdVbmtub3duIGljZUNvbm5lY3Rpb24gc3RhdGU6JywgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoc3RhdGVFdmVudCwgdGhpcyk7XG5cbiAgICAgIC8vQnJpYSBzdGF0ZSBjaGFuZ2VzIGFyZSBhbHdheXMgY29ubmVjdGVkIC0+IGRpc2Nvbm5lY3RlZCAtPiBjb25uZWN0ZWQgb24gYWNjZXB0LCBzbyBzZXNzaW9uIGdldHMgdGVybWluYXRlZFxuICAgICAgLy9ub3JtYWwgY2FsbHMgc3dpdGNoIGZyb20gZmFpbGVkIHRvIGNvbm5lY3RlZCBpbiBzb21lIGNhc2VzLCBzbyBjaGVja2luZyBmb3IgZmFpbGVkIGFuZCB0ZXJtaW5hdGVkXG4gICAgICAvKmlmICh0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgc2VsZi5zZXNzaW9uLnRlcm1pbmF0ZSh7XG4gICAgICAgIGNhdXNlOiBTSVAuQy5jYXVzZXMuUlRQX1RJTUVPVVQsXG4gICAgICAgIHN0YXR1c19jb2RlOiAyMDAsXG4gICAgICAgIHJlYXNvbl9waHJhc2U6IFNJUC5DLmNhdXNlcy5SVFBfVElNRU9VVFxuICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGUuY3VycmVudFRhcmdldC5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ2NvbXBsZXRlJyAmJiB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHNlbGYub25JY2VDb21wbGV0ZWQodGhpcyk7XG4gICAgICB9Ki9cbiAgICB9O1xuXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmxvZ2dlci5sb2coJ1BlZXJDb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQgdG8gXCInKyB0aGlzLnJlYWR5U3RhdGUgKydcIicpO1xuICAgIH07XG4gIH19LFxuXG4gIGNyZWF0ZU9mZmVyT3JBbnN3ZXI6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyT3JBbnN3ZXIgKGNvbnN0cmFpbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtZXRob2ROYW1lO1xuICAgIHZhciBwYyA9IHNlbGYucGVlckNvbm5lY3Rpb247XG5cbiAgICBzZWxmLnJlYWR5ID0gZmFsc2U7XG4gICAgbWV0aG9kTmFtZSA9IHNlbGYuaGFzT2ZmZXIoJ3JlbW90ZScpID8gJ2NyZWF0ZUFuc3dlcicgOiAnY3JlYXRlT2ZmZXInO1xuXG4gICAgcmV0dXJuIFNJUC5VdGlscy5wcm9taXNpZnkocGMsIG1ldGhvZE5hbWUsIHRydWUpKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4oU0lQLlV0aWxzLnByb21pc2lmeShwYywgJ3NldExvY2FsRGVzY3JpcHRpb24nKSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uIG9uU2V0TG9jYWxEZXNjcmlwdGlvblN1Y2Nlc3MoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IFNJUC5VdGlscy5kZWZlcigpO1xuICAgICAgICBpZiAocGMuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICdjb21wbGV0ZScgJiYgKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgcGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5vbkljZUNvbXBsZXRlZC5wcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gcmVhZHlTdWNjZXNzICgpIHtcbiAgICAgICAgdmFyIHNkcCA9IHBjLmxvY2FsRGVzY3JpcHRpb24uc2RwO1xuXG4gICAgICAgIHNkcCA9IFNJUC5IYWNrcy5DaHJvbWUubmVlZHNFeHBsaWNpdGx5SW5hY3RpdmVTRFAoc2RwKTtcbiAgICAgICAgc2RwID0gU0lQLkhhY2tzLkFsbEJyb3dzZXJzLnVubWFza0R0bHMoc2RwKTtcblxuICAgICAgICB2YXIgc2RwV3JhcHBlciA9IHtcbiAgICAgICAgICB0eXBlOiBtZXRob2ROYW1lID09PSAnY3JlYXRlT2ZmZXInID8gJ29mZmVyJyA6ICdhbnN3ZXInLFxuICAgICAgICAgIHNkcDogc2RwXG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5lbWl0KCdnZXREZXNjcmlwdGlvbicsIHNkcFdyYXBwZXIpO1xuXG4gICAgICAgIHNlbGYucmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc2RwV3JhcHBlci5zZHA7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIG1ldGhvZEZhaWxlZCAoZSkge1xuICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgc2VsZi5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5HZXREZXNjcmlwdGlvbkVycm9yKGUpO1xuICAgICAgfSlcbiAgICA7XG4gIH19LFxuXG4gIGFkZFN0cmVhbXM6IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0cmVhbXMgKHN0cmVhbXMpIHtcbiAgICB0cnkge1xuICAgICAgc3RyZWFtcyA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICAgIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uYWRkU3RyZWFtKHN0cmVhbSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdlcnJvciBhZGRpbmcgc3RyZWFtJyk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNJUC5VdGlscy5Qcm9taXNlLnJlc29sdmUoKTtcbiAgfX0sXG5cbiAgdG9nZ2xlTXV0ZUhlbHBlcjoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTXV0ZUhlbHBlciAodHJhY2tHZXR0ZXIsIG11dGUpIHtcbiAgICB0aGlzLmdldExvY2FsU3RyZWFtcygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgc3RyZWFtW3RyYWNrR2V0dGVyXSgpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhbXV0ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9fSxcblxuICB0b2dnbGVNdXRlQXVkaW86IHt3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU11dGVBdWRpbyAobXV0ZSkge1xuICAgIHRoaXMudG9nZ2xlTXV0ZUhlbHBlcignZ2V0QXVkaW9UcmFja3MnLCBtdXRlKTtcbiAgfX0sXG5cbiAgdG9nZ2xlTXV0ZVZpZGVvOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNdXRlVmlkZW8gKG11dGUpIHtcbiAgICB0aGlzLnRvZ2dsZU11dGVIZWxwZXIoJ2dldFZpZGVvVHJhY2tzJywgbXV0ZSk7XG4gIH19XG59KTtcblxuLy8gUmV0dXJuIHNpbmNlIGl0IHdpbGwgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZS5cbnJldHVybiBNZWRpYUhhbmRsZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9XZWJSVEMvTWVkaWFIYW5kbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBNZWRpYVN0cmVhbU1hbmFnZXJcbiAqL1xuXG4vKiBNZWRpYVN0cmVhbU1hbmFnZXJcbiAqIEBjbGFzcyBNYW5hZ2VzIHRoZSBhY3F1aXNpdGlvbiBhbmQgcmVsZWFzZSBvZiBNZWRpYVN0cmVhbXMuXG4gKiBAcGFyYW0ge21lZGlhSGludH0gW2RlZmF1bHRNZWRpYUhpbnRdIFRoZSBtZWRpYUhpbnQgdG8gdXNlIGlmIG5vbmUgaXMgcHJvdmlkZWQgdG8gYWNxdWlyZSgpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgZW52aXJvbm1lbnQpIHtcblxuLy8gRGVmYXVsdCBNZWRpYVN0cmVhbU1hbmFnZXIgcHJvdmlkZXMgc2luZ2xlLXVzZSBzdHJlYW1zIGNyZWF0ZWQgd2l0aCBnZXRVc2VyTWVkaWFcbnZhciBNZWRpYVN0cmVhbU1hbmFnZXIgPSBmdW5jdGlvbiBNZWRpYVN0cmVhbU1hbmFnZXIgKGxvZ2dlciwgZGVmYXVsdE1lZGlhSGludCkge1xuICBpZiAoIVNJUC5XZWJSVEMuaXNTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFcnJvcignTWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgdGhpcy5tZWRpYUhpbnQgPSBkZWZhdWx0TWVkaWFIaW50IHx8IHtcbiAgICBjb25zdHJhaW50czoge2F1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZX1cbiAgfTtcblxuICAvLyBtYXAgb2Ygc3RyZWFtcyB0byBhY3F1aXNpdGlvbiBtYW5uZXI6XG4gIC8vIHRydWUgLT4gcGFzc2VkIGluIGFzIG1lZGlhSGludC5zdHJlYW1cbiAgLy8gZmFsc2UgLT4gZ2V0VXNlck1lZGlhXG4gIHRoaXMuYWNxdWlzaXRpb25zID0ge307XG59O1xuTWVkaWFTdHJlYW1NYW5hZ2VyLnN0cmVhbUlkID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuY29uY2F0KHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpKVxuICAgIC5tYXAoZnVuY3Rpb24gdHJhY2tJZCAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICB9KVxuICAgIC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsoQXJyYXkgb2YpIE1lZGlhU3RyZWFtfSBzdHJlYW1zIC0gVGhlIHN0cmVhbXMgdG8gcmVuZGVyXG4gKlxuICogQHBhcmFtIHsoQXJyYXkgb2YpIEhUTUxNZWRpYUVsZW1lbnR9IGVsZW1lbnRzXG4gKiAgICAgICAgLSBUaGUgPGF1ZGlvPi88dmlkZW8+IGVsZW1lbnQocykgdGhhdCBzaG91bGQgcmVuZGVyIHRoZSBzdHJlYW1zXG4gKlxuICogRWFjaCBzdHJlYW0gaW4gc3RyZWFtcyByZW5kZXJzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gZWxlbWVudHMsXG4gKiB3cmFwcGluZyBhcm91bmQgZWxlbWVudHMgaWYgbmVlZGVkLlxuICovXG5NZWRpYVN0cmVhbU1hbmFnZXIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyIChzdHJlYW1zLCBlbGVtZW50cykge1xuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSAmJiAhZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudHMgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaE1lZGlhU3RyZWFtKGVsZW1lbnQsIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC5zcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbnZpcm9ubWVudC5yZXZva2VPYmplY3RVUkwoZWxlbWVudC5zcmMpO1xuICAgICAgZWxlbWVudC5zcmMgPSBlbnZpcm9ubWVudC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAoZWxlbWVudC5zcmNPYmplY3QgfHwgZWxlbWVudC5tb3pTcmNPYmplY3QpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBlbGVtZW50Lm1velNyY09iamVjdCA9IHN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlTWVkaWFQbGF5aW5nIChtZWRpYUVsZW1lbnQpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSAxMDA7XG4gICAgbWVkaWFFbGVtZW50LmVuc3VyZVBsYXlpbmdJbnRlcnZhbElkID0gU0lQLlRpbWVycy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWVkaWFFbGVtZW50LnBhdXNlZCkge1xuICAgICAgICBtZWRpYUVsZW1lbnQucGxheSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIFNJUC5UaW1lcnMuY2xlYXJJbnRlcnZhbChtZWRpYUVsZW1lbnQuZW5zdXJlUGxheWluZ0ludGVydmFsSWQpO1xuICAgICAgfVxuICAgIH0sIGludGVydmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaEFuZFBsYXkgKGVsZW1lbnRzLCBzdHJlYW0sIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWxlbWVudHMgPSBlbGVtZW50cygpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4ICUgZWxlbWVudHMubGVuZ3RoXTtcbiAgICAoZW52aXJvbm1lbnQuYXR0YWNoTWVkaWFTdHJlYW0gfHwgYXR0YWNoTWVkaWFTdHJlYW0pKGVsZW1lbnQsIHN0cmVhbSk7XG4gICAgZW5zdXJlTWVkaWFQbGF5aW5nKGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gW10uY29uY2F0IFwiY2FzdHNcIiBgZWxlbWVudHNgIGludG8gYW4gYXJyYXlcbiAgLy8gc28gZm9yRWFjaCB3b3JrcyBldmVuIGlmIGBlbGVtZW50c2Agd2FzIGEgc2luZ2xlIGVsZW1lbnRcbiAgZWxlbWVudHMgPSBbXS5jb25jYXQoZWxlbWVudHMpO1xuICBbXS5jb25jYXQoc3RyZWFtcykuZm9yRWFjaChhdHRhY2hBbmRQbGF5LmJpbmQobnVsbCwgZWxlbWVudHMpKTtcbn07XG5cbk1lZGlhU3RyZWFtTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gICdhY3F1aXJlJzoge3dyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZnVuY3Rpb24gYWNxdWlyZSAobWVkaWFIaW50KSB7XG4gICAgbWVkaWFIaW50ID0gT2JqZWN0LmtleXMobWVkaWFIaW50IHx8IHt9KS5sZW5ndGggPyBtZWRpYUhpbnQgOiB0aGlzLm1lZGlhSGludDtcblxuICAgIHZhciBzYXZlU3VjY2VzcyA9IGZ1bmN0aW9uIChpc0hpbnRTdHJlYW0sIHN0cmVhbXMpIHtcbiAgICAgIHN0cmVhbXMgPSBbXS5jb25jYXQoc3RyZWFtcyk7XG4gICAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICB2YXIgc3RyZWFtSWQgPSBNZWRpYVN0cmVhbU1hbmFnZXIuc3RyZWFtSWQoc3RyZWFtKTtcbiAgICAgICAgdGhpcy5hY3F1aXNpdGlvbnNbc3RyZWFtSWRdID0gISFpc0hpbnRTdHJlYW07XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBTSVAuVXRpbHMuUHJvbWlzZS5yZXNvbHZlKHN0cmVhbXMpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGlmIChtZWRpYUhpbnQuc3RyZWFtKSB7XG4gICAgICByZXR1cm4gc2F2ZVN1Y2Nlc3ModHJ1ZSwgbWVkaWFIaW50LnN0cmVhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGF1ZGlvL3ZpZGVvIGVuYWJsZWQgaWYgbm8gbWVkaWFIaW50IGNhbiBiZSBmb3VuZC5cbiAgICAgIHZhciBjb25zdHJhaW50cyA9IG1lZGlhSGludC5jb25zdHJhaW50cyB8fFxuICAgICAgICAodGhpcy5tZWRpYUhpbnQgJiYgdGhpcy5tZWRpYUhpbnQuY29uc3RyYWludHMpIHx8XG4gICAgICAgIHthdWRpbzogdHJ1ZSwgdmlkZW86IHRydWV9O1xuXG4gICAgICB2YXIgZGVmZXJyZWQgPSBTSVAuVXRpbHMuZGVmZXIoKTtcblxuICAgICAgLypcbiAgICAgICAqIE1ha2UgdGhlIGNhbGwgYXN5bmNocm9ub3VzLCBzbyB0aGF0IElDQ3MgaGF2ZSBhIGNoYW5jZVxuICAgICAgICogdG8gZGVmaW5lIGNhbGxiYWNrcyB0byBgdXNlck1lZGlhUmVxdWVzdGBcbiAgICAgICAqL1xuICAgICAgU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1c2VyTWVkaWFSZXF1ZXN0JywgY29uc3RyYWludHMpO1xuXG4gICAgICAgIHZhciBlbWl0VGhlbkNhbGwgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBjYWxsYmFja0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgIC8vIEVtaXQgd2l0aCBhbGwgb2YgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSByZWFsIGNhbGxiYWNrLlxuICAgICAgICAgIHZhciBuZXdBcmdzID0gW2V2ZW50TmFtZV0uY29uY2F0KGNhbGxiYWNrQXJncyk7XG5cbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgbmV3QXJncyk7XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmdzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbyB8fCBjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoXG4gICAgICAgICAgICBTSVAuV2ViUlRDLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICBlbWl0VGhlbkNhbGwuYmluZCh0aGlzLCAndXNlck1lZGlhJywgc2F2ZVN1Y2Nlc3MuYmluZChudWxsLCBmYWxzZSkpLFxuICAgICAgICAgICAgICBlbWl0VGhlbkNhbGwuYmluZCh0aGlzLCAndXNlck1lZGlhRmFpbGVkJywgZnVuY3Rpb24oZSl7dGhyb3cgZTt9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTG9jYWwgc3RyZWFtcyB3ZXJlIGV4cGxpY2l0bHkgZXhjbHVkZWQuXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgfX0sXG5cbiAgJ3JlbGVhc2UnOiB7d3JpdGFibGU6IHRydWUsIHZhbHVlOiBmdW5jdGlvbiByZWxlYXNlIChzdHJlYW1zKSB7XG4gICAgc3RyZWFtcyA9IFtdLmNvbmNhdChzdHJlYW1zKTtcbiAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgdmFyIHN0cmVhbUlkID0gTWVkaWFTdHJlYW1NYW5hZ2VyLnN0cmVhbUlkKHN0cmVhbSk7XG4gICAgICBpZiAodGhpcy5hY3F1aXNpdGlvbnNbc3RyZWFtSWRdID09PSBmYWxzZSkge1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuYWNxdWlzaXRpb25zW3N0cmVhbUlkXTtcbiAgICB9LCB0aGlzKTtcbiAgfX0sXG59KTtcblxuLy8gUmV0dXJuIHNpbmNlIGl0IHdpbGwgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZS5cbnJldHVybiBNZWRpYVN0cmVhbU1hbmFnZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9XZWJSVEMvTWVkaWFTdHJlYW1NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGF1Z21lbnRzIFNJUFxuICogQGNsYXNzIENsYXNzIGNyZWF0aW5nIGEgU0lQIFVzZXIgQWdlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIHJldHVybmluZyBTSVAuTWVkaWFIYW5kbGVyfSBbY29uZmlndXJhdGlvbi5tZWRpYUhhbmRsZXJGYWN0b3J5XVxuICogICAgICAgIEEgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJ5IGVhY2ggb2YgdGhlIFVBJ3MgU2Vzc2lvbnMgdG8gYnVpbGQgdGhlIE1lZGlhSGFuZGxlciBmb3IgdGhhdCBTZXNzaW9uLlxuICogICAgICAgIElmIG5vIChvciBhIGZhbHN5KSB2YWx1ZSBpcyBwcm92aWRlZCwgZWFjaCBTZXNzaW9uIHdpbGwgdXNlIGEgZGVmYXVsdCAoV2ViUlRDKSBNZWRpYUhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWd1cmF0aW9uLm1lZGlhXSBnZXRzIHBhc3NlZCB0byBTSVAuTWVkaWFIYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVAsIGVudmlyb25tZW50KSB7XG52YXIgVUEsXG4gIEMgPSB7XG4gICAgLy8gVUEgc3RhdHVzIGNvZGVzXG4gICAgU1RBVFVTX0lOSVQ6ICAgICAgICAgICAgICAgIDAsXG4gICAgU1RBVFVTX1NUQVJUSU5HOiAgICAgICAgICAgIDEsXG4gICAgU1RBVFVTX1JFQURZOiAgICAgICAgICAgICAgIDIsXG4gICAgU1RBVFVTX1VTRVJfQ0xPU0VEOiAgICAgICAgIDMsXG4gICAgU1RBVFVTX05PVF9SRUFEWTogICAgICAgICAgIDQsXG5cbiAgICAvLyBVQSBlcnJvciBjb2Rlc1xuICAgIENPTkZJR1VSQVRJT05fRVJST1I6ICAxLFxuICAgIE5FVFdPUktfRVJST1I6ICAgICAgICAyLFxuXG4gICAgQUxMT1dFRF9NRVRIT0RTOiBbXG4gICAgICAnQUNLJyxcbiAgICAgICdDQU5DRUwnLFxuICAgICAgJ0lOVklURScsXG4gICAgICAnTUVTU0FHRScsXG4gICAgICAnQllFJyxcbiAgICAgICdPUFRJT05TJyxcbiAgICAgICdJTkZPJyxcbiAgICAgICdOT1RJRlknLFxuICAgICAgJ1JFRkVSJ1xuICAgIF0sXG5cbiAgICBBQ0NFUFRFRF9CT0RZX1RZUEVTOiBbXG4gICAgICAnYXBwbGljYXRpb24vc2RwJyxcbiAgICAgICdhcHBsaWNhdGlvbi9kdG1mLXJlbGF5J1xuICAgIF0sXG5cbiAgICBNQVhfRk9SV0FSRFM6IDcwLFxuICAgIFRBR19MRU5HVEg6IDEwXG4gIH07XG5cblVBID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBmb3J3YXJkaW5nIGV2ZW50c1xuICBmdW5jdGlvbiBzZWxmRW1pdCh0eXBlKSB7XG4gICAgLy9yZWdpc3RyYXRpb25GYWlsZWQgaGFuZGxlciBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50cy4gQWxsb3cgZXZlbnQgaGFuZGxlcnMgdG8gYmUgaW52b2tlZCB3aXRoIGEgdmFyaWFibGUgbm8uIG9mIGFyZ3VtZW50c1xuICAgIHJldHVybiBzZWxmLmVtaXQuYmluZChzZWxmLCB0eXBlKTtcbiAgfVxuXG4gIC8vIFNldCBBY2NlcHRlZCBCb2R5IFR5cGVzXG4gIEMuQUNDRVBURURfQk9EWV9UWVBFUyA9IEMuQUNDRVBURURfQk9EWV9UWVBFUy50b1N0cmluZygpO1xuXG4gIHRoaXMubG9nID0gbmV3IFNJUC5Mb2dnZXJGYWN0b3J5KCk7XG4gIHRoaXMubG9nZ2VyID0gdGhpcy5nZXRMb2dnZXIoJ3NpcC51YScpO1xuXG4gIHRoaXMuY2FjaGUgPSB7XG4gICAgY3JlZGVudGlhbHM6IHt9XG4gIH07XG5cbiAgdGhpcy5jb25maWd1cmF0aW9uID0ge307XG4gIHRoaXMuZGlhbG9ncyA9IHt9O1xuXG4gIC8vVXNlciBhY3Rpb25zIG91dHNpZGUgYW55IHNlc3Npb24vZGlhbG9nIChNRVNTQUdFKVxuICB0aGlzLmFwcGxpY2FudHMgPSB7fTtcblxuICB0aGlzLmRhdGEgPSB7fTtcbiAgdGhpcy5zZXNzaW9ucyA9IHt9O1xuICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB0aGlzLmNvbnRhY3QgPSBudWxsO1xuICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX0lOSVQ7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xuICB0aGlzLnRyYW5zYWN0aW9ucyA9IHtcbiAgICBuaXN0OiB7fSxcbiAgICBuaWN0OiB7fSxcbiAgICBpc3Q6IHt9LFxuICAgIGljdDoge31cbiAgfTtcblxuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cyA9IDA7XG4gIHRoaXMudHJhbnNwb3J0UmVjb3ZlcnlUaW1lciA9IG51bGw7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHlwZSxcbiAgICAgICAgICB0cmFuc2FjdGlvbnMgPSBbJ25pc3QnLCduaWN0JywnaXN0JywnaWN0J10sXG4gICAgICAgICAgY291bnQgPSAwO1xuXG4gICAgICAgIGZvciAodHlwZSBpbiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBjb3VudCArPSBPYmplY3Qua2V5cyh0aGlzLnRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbnNbdHlwZV1dKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5pY3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWyduaWN0J10pLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmlzdFRyYW5zYWN0aW9uc0NvdW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFuc2FjdGlvbnNbJ25pc3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpY3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWydpY3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc3RUcmFuc2FjdGlvbnNDb3VudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNhY3Rpb25zWydpc3QnXSkubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIExvYWQgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAdGhyb3dzIHtTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3J9XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgICovXG5cbiAgaWYoY29uZmlndXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlndXJhdGlvbiA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uID09PSAnc3RyaW5nJyB8fCBjb25maWd1cmF0aW9uIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgIHVyaTogY29uZmlndXJhdGlvblxuICAgIH07XG4gIH1cblxuICAvLyBBcHBseSBsb2cgY29uZmlndXJhdGlvbiBpZiBwcmVzZW50XG4gIGlmIChjb25maWd1cmF0aW9uLmxvZykge1xuICAgIGlmIChjb25maWd1cmF0aW9uLmxvZy5oYXNPd25Qcm9wZXJ0eSgnYnVpbHRpbkVuYWJsZWQnKSkge1xuICAgICAgdGhpcy5sb2cuYnVpbHRpbkVuYWJsZWQgPSBjb25maWd1cmF0aW9uLmxvZy5idWlsdGluRW5hYmxlZDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cuaGFzT3duUHJvcGVydHkoJ2xldmVsJykpIHtcbiAgICAgIHRoaXMubG9nLmxldmVsID0gY29uZmlndXJhdGlvbi5sb2cubGV2ZWw7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KCdjb25uZWN0b3InKSkge1xuICAgICAgdGhpcy5sb2cuY29ubmVjdG9yID0gY29uZmlndXJhdGlvbi5sb2cuY29ubmVjdG9yO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5sb2FkQ29uZmlnKGNvbmZpZ3VyYXRpb24pO1xuICB9IGNhdGNoKGUpIHtcbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX05PVF9SRUFEWTtcbiAgICB0aGlzLmVycm9yID0gQy5DT05GSUdVUkFUSU9OX0VSUk9SO1xuICAgIHRocm93IGU7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHJlZ2lzdGVyQ29udGV4dFxuICB0aGlzLnJlZ2lzdGVyQ29udGV4dCA9IG5ldyBTSVAuUmVnaXN0ZXJDb250ZXh0KHRoaXMpO1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vbignZmFpbGVkJywgc2VsZkVtaXQoJ3JlZ2lzdHJhdGlvbkZhaWxlZCcpKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQub24oJ3JlZ2lzdGVyZWQnLCBzZWxmRW1pdCgncmVnaXN0ZXJlZCcpKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQub24oJ3VucmVnaXN0ZXJlZCcsIHNlbGZFbWl0KCd1bnJlZ2lzdGVyZWQnKSk7XG5cbiAgaWYodGhpcy5jb25maWd1cmF0aW9uLmF1dG9zdGFydCkge1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52aXJvbm1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEdvb2dsZSBDaHJvbWUgUGFja2FnZWQgQXBwcyBkb24ndCBhbGxvdyAndW5sb2FkJyBsaXN0ZW5lcnM6XG4gICAgLy8gdW5sb2FkIGlzIG5vdCBhdmFpbGFibGUgaW4gcGFja2FnZWQgYXBwc1xuICAgIGlmICghKGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZSkpIHtcbiAgICAgIGVudmlyb25tZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIHRoaXMuc3RvcC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbn07XG5VQS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNJUC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuLy89PT09PT09PT09PT09PT09PVxuLy8gIEhpZ2ggTGV2ZWwgQVBJXG4vLz09PT09PT09PT09PT09PT09XG5cblVBLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyID0gdHJ1ZTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXIob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsXSB1bnJlZ2lzdGVyIGFsbCB1c2VyIGJpbmRpbmdzLlxuICpcbiAqL1xuVUEucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3RlciA9IGZhbHNlO1xuXG4gIHZhciBjb250ZXh0ID0gdGhpcy5yZWdpc3RlckNvbnRleHQ7XG4gIHRoaXMuYWZ0ZXJDb25uZWN0ZWQoY29udGV4dC51bnJlZ2lzdGVyLmJpbmQoY29udGV4dCwgb3B0aW9ucykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVUEucHJvdG90eXBlLmlzUmVnaXN0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXJlZDtcbn07XG5cbi8qKlxuICogQ29ubmVjdGlvbiBzdGF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAqL1xuVUEucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRyYW5zcG9ydCA/IHRoaXMudHJhbnNwb3J0LmNvbm5lY3RlZCA6IGZhbHNlO1xufTtcblxuVUEucHJvdG90eXBlLmFmdGVyQ29ubmVjdGVkID0gZnVuY3Rpb24gYWZ0ZXJDb25uZWN0ZWQgKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub25jZSgnY29ubmVjdGVkJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYW4gb3V0Z29pbmcgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gdmlld3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZWRpYV0gZ2V0cyBwYXNzZWQgdG8gU0lQLk1lZGlhSGFuZGxlci5nZXREZXNjcmlwdGlvbiBhcyBtZWRpYUhpbnRcbiAqXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKlxuICovXG5VQS5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IFNJUC5JbnZpdGVDbGllbnRDb250ZXh0KHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5hZnRlckNvbm5lY3RlZChjb250ZXh0Lmludml0ZS5iaW5kKGNvbnRleHQpKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5VQS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgb3B0aW9ucykge1xuICB2YXIgc3ViID0gbmV3IFNJUC5TdWJzY3JpcHRpb24odGhpcywgdGFyZ2V0LCBldmVudCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5hZnRlckNvbm5lY3RlZChzdWIuc3Vic2NyaWJlLmJpbmQoc3ViKSk7XG4gIHJldHVybiBzdWI7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICpcbiAqL1xuVUEucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbih0YXJnZXQsIGJvZHksIG9wdGlvbnMpIHtcbiAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG4gIH1cblxuICAvLyBUaGVyZSBpcyBubyBNZXNzYWdlIG1vZHVsZSwgc28gaXQgaXMgb2theSB0aGF0IHRoZSBVQSBoYW5kbGVzIGRlZmF1bHRzIGhlcmUuXG4gIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gIG9wdGlvbnMuY29udGVudFR5cGUgfHwgKG9wdGlvbnMuY29udGVudFR5cGUgPSAndGV4dC9wbGFpbicpO1xuICBvcHRpb25zLmJvZHkgPSBib2R5O1xuXG4gIHJldHVybiB0aGlzLnJlcXVlc3QoU0lQLkMuTUVTU0FHRSwgdGFyZ2V0LCBvcHRpb25zKTtcbn07XG5cblVBLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciByZXEgPSBuZXcgU0lQLkNsaWVudENvbnRleHQodGhpcywgbWV0aG9kLCB0YXJnZXQsIG9wdGlvbnMpO1xuXG4gIHRoaXMuYWZ0ZXJDb25uZWN0ZWQocmVxLnNlbmQuYmluZChyZXEpKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogR3JhY2VmdWxseSBjbG9zZS5cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZXNzaW9uLCBzdWJzY3JpcHRpb24sIGFwcGxpY2FudCxcbiAgICB1YSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gdHJhbnNhY3Rpb25zTGlzdGVuZXIoKSB7XG4gICAgaWYgKHVhLm5pc3RUcmFuc2FjdGlvbnNDb3VudCA9PT0gMCAmJiB1YS5uaWN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDApIHtcbiAgICAgICAgdWEucmVtb3ZlTGlzdGVuZXIoJ3RyYW5zYWN0aW9uRGVzdHJveWVkJywgdHJhbnNhY3Rpb25zTGlzdGVuZXIpO1xuICAgICAgICB1YS50cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubG9nZ2VyLmxvZygndXNlciByZXF1ZXN0ZWQgY2xvc3VyZS4uLicpO1xuXG4gIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1VBIGFscmVhZHkgY2xvc2VkJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBDbGVhciB0cmFuc3BvcnRSZWNvdmVyeVRpbWVyXG4gIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudHJhbnNwb3J0UmVjb3ZlcnlUaW1lcik7XG5cbiAgLy8gQ2xvc2UgcmVnaXN0ZXJDb250ZXh0XG4gIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyByZWdpc3RlckNvbnRleHQnKTtcbiAgdGhpcy5yZWdpc3RlckNvbnRleHQuY2xvc2UoKTtcblxuICAvLyBSdW4gIF90ZXJtaW5hdGVfIG9uIGV2ZXJ5IFNlc3Npb25cbiAgZm9yKHNlc3Npb24gaW4gdGhpcy5zZXNzaW9ucykge1xuICAgIHRoaXMubG9nZ2VyLmxvZygnY2xvc2luZyBzZXNzaW9uICcgKyBzZXNzaW9uKTtcbiAgICB0aGlzLnNlc3Npb25zW3Nlc3Npb25dLnRlcm1pbmF0ZSgpO1xuICB9XG5cbiAgLy9SdW4gX2Nsb3NlXyBvbiBldmVyeSBTdWJzY3JpcHRpb25cbiAgZm9yKHN1YnNjcmlwdGlvbiBpbiB0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ3Vuc3Vic2NyaWJpbmcgZnJvbSBzdWJzY3JpcHRpb24gJyArIHN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbl0uY2xvc2UoKTtcbiAgfVxuXG4gIC8vIFJ1biAgX2Nsb3NlXyBvbiBldmVyeSBhcHBsaWNhbnRcbiAgZm9yKGFwcGxpY2FudCBpbiB0aGlzLmFwcGxpY2FudHMpIHtcbiAgICB0aGlzLmFwcGxpY2FudHNbYXBwbGljYW50XS5jbG9zZSgpO1xuICB9XG5cbiAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19VU0VSX0NMT1NFRDtcblxuICAvKlxuICAgKiBJZiB0aGUgcmVtYWluaW5nIHRyYW5zYWN0aW9ucyBhcmUgYWxsIElOVklURSB0cmFuc2FjdGlvbnMsIHRoZXJlIGlzIG5vIG5lZWQgdG9cbiAgICogd2FpdCBhbnltb3JlIGJlY2F1c2UgZXZlcnkgc2Vzc2lvbiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBieSB0aGlzIG1ldGhvZC5cbiAgICogLSBsb2NhbGx5IG9yaWdpbmF0ZWQgc2Vzc2lvbnMgd2hlcmUgdGVybWluYXRlZCAoQ0FOQ0VMIG9yIEJZRSlcbiAgICogLSByZW1vdGVseSBvcmlnaW5hdGVkIHNlc3Npb25zIHdoZXJlIHJlamVjdGVkICg0WFgpIG9yIHRlcm1pbmF0ZWQgKEJZRSlcbiAgICogUmVtYWluaW5nIElOVklURSB0cmFuc2FjdGlvbnMgYmVsb25nIHRobyBzZXNzaW9ucyB0aGF0IHdoZXJlIGFuc3dlcmVkLiBUaGlzIGFyZSBpblxuICAgKiAnYWNjZXB0ZWQnIHN0YXRlIGR1ZSB0byB0aW1lcnMgJ0wnIGFuZCAnTScgZGVmaW5lZCBpbiBbUkZDIDYwMjZdXG4gICAqL1xuICBpZiAodGhpcy5uaXN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDAgJiYgdGhpcy5uaWN0VHJhbnNhY3Rpb25zQ291bnQgPT09IDApIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbigndHJhbnNhY3Rpb25EZXN0cm95ZWQnLCB0cmFuc2FjdGlvbnNMaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29ubmVjdCB0byB0aGUgV1Mgc2VydmVyIGlmIHN0YXR1cyA9IFNUQVRVU19JTklULlxuICogUmVzdW1lIFVBIGFmdGVyIGJlaW5nIGNsb3NlZC5cbiAqXG4gKi9cblVBLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VydmVyO1xuXG4gIHRoaXMubG9nZ2VyLmxvZygndXNlciByZXF1ZXN0ZWQgc3RhcnR1cC4uLicpO1xuICBpZiAodGhpcy5zdGF0dXMgPT09IEMuU1RBVFVTX0lOSVQpIHtcbiAgICBzZXJ2ZXIgPSB0aGlzLmdldE5leHRXc1NlcnZlcigpO1xuICAgIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfU1RBUlRJTkc7XG4gICAgbmV3IFNJUC5UcmFuc3BvcnQodGhpcywgc2VydmVyKTtcbiAgfSBlbHNlIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygncmVzdW1pbmcnKTtcbiAgICB0aGlzLnN0YXR1cyA9IEMuU1RBVFVTX1JFQURZO1xuICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfU1RBUlRJTkcpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ1VBIGlzIGluIFNUQVJUSU5HIHN0YXR1cywgbm90IG9wZW5pbmcgbmV3IGNvbm5lY3Rpb24nKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfUkVBRFkpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coJ1VBIGlzIGluIFJFQURZIHN0YXR1cywgbm90IHJlc3VtaW5nJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Nvbm5lY3Rpb24gaXMgZG93bi4gQXV0by1SZWNvdmVyeSBzeXN0ZW0gaXMgdHJ5aW5nIHRvIGNvbm5lY3QnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBzdHJpbmcgaW50byBhIHZhbGlkIFNJUCByZXF1ZXN0IFVSSVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAqXG4gKiBAcmV0dXJucyB7U0lQLlVSSXx1bmRlZmluZWR9XG4gKi9cblVBLnByb3RvdHlwZS5ub3JtYWxpemVUYXJnZXQgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIFNJUC5VdGlscy5ub3JtYWxpemVUYXJnZXQodGFyZ2V0LCB0aGlzLmNvbmZpZ3VyYXRpb24uaG9zdHBvcnRQYXJhbXMpO1xufTtcblxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vICBQcml2YXRlIChGb3IgaW50ZXJuYWwgdXNlKVxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblVBLnByb3RvdHlwZS5zYXZlQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihjcmVkZW50aWFscykge1xuICB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW2NyZWRlbnRpYWxzLnJlYWxtXSA9IHRoaXMuY2FjaGUuY3JlZGVudGlhbHNbY3JlZGVudGlhbHMucmVhbG1dIHx8IHt9O1xuICB0aGlzLmNhY2hlLmNyZWRlbnRpYWxzW2NyZWRlbnRpYWxzLnJlYWxtXVtjcmVkZW50aWFscy51cmldID0gY3JlZGVudGlhbHM7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5VQS5wcm90b3R5cGUuZ2V0Q3JlZGVudGlhbHMgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciByZWFsbSwgY3JlZGVudGlhbHM7XG5cbiAgcmVhbG0gPSByZXF1ZXN0LnJ1cmkuaG9zdDtcblxuICBpZiAodGhpcy5jYWNoZS5jcmVkZW50aWFsc1tyZWFsbV0gJiYgdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tyZWFsbV1bcmVxdWVzdC5ydXJpXSkge1xuICAgIGNyZWRlbnRpYWxzID0gdGhpcy5jYWNoZS5jcmVkZW50aWFsc1tyZWFsbV1bcmVxdWVzdC5ydXJpXTtcbiAgICBjcmVkZW50aWFscy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgfVxuXG4gIHJldHVybiBjcmVkZW50aWFscztcbn07XG5cblVBLnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbihjYXRlZ29yeSwgbGFiZWwpIHtcbiAgcmV0dXJuIHRoaXMubG9nLmdldExvZ2dlcihjYXRlZ29yeSwgbGFiZWwpO1xufTtcblxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRXZlbnQgSGFuZGxlcnNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVHJhbnNwb3J0IENsb3NlIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICogQGV2ZW50XG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqL1xuVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0Q2xvc2VkID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gIC8vIFJ1biBfb25UcmFuc3BvcnRFcnJvcl8gY2FsbGJhY2sgb24gZXZlcnkgY2xpZW50IHRyYW5zYWN0aW9uIHVzaW5nIF90cmFuc3BvcnRfXG4gIHZhciB0eXBlLCBpZHgsIGxlbmd0aCxcbiAgICBjbGllbnRfdHJhbnNhY3Rpb25zID0gWyduaWN0JywgJ2ljdCcsICduaXN0JywgJ2lzdCddO1xuXG4gIHRyYW5zcG9ydC5zZXJ2ZXIuc3RhdHVzID0gU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19ESVNDT05ORUNURUQ7XG4gIHRoaXMubG9nZ2VyLmxvZygnY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJysgU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19ESVNDT05ORUNURUQpO1xuXG4gIGxlbmd0aCA9IGNsaWVudF90cmFuc2FjdGlvbnMubGVuZ3RoO1xuICBmb3IgKHR5cGUgPSAwOyB0eXBlIDwgbGVuZ3RoOyB0eXBlKyspIHtcbiAgICBmb3IoaWR4IGluIHRoaXMudHJhbnNhY3Rpb25zW2NsaWVudF90cmFuc2FjdGlvbnNbdHlwZV1dKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0aW9uc1tjbGllbnRfdHJhbnNhY3Rpb25zW3R5cGVdXVtpZHhdLm9uVHJhbnNwb3J0RXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICAvLyBDbG9zZSBzZXNzaW9ucyBpZiBHUlVVIGlzIG5vdCBiZWluZyB1c2VkXG4gIGlmICghdGhpcy5jb250YWN0LnB1Yl9ncnV1KSB7XG4gICAgdGhpcy5jbG9zZVNlc3Npb25zT25UcmFuc3BvcnRFcnJvcigpO1xuICB9XG5cbn07XG5cbi8qKlxuICogVW5yZWNvdmVyYWJsZSB0cmFuc3BvcnQgZXZlbnQuXG4gKiBDb25uZWN0aW9uIHJlYXR0ZW1wdCBsb2dpYyBoYXMgYmVlbiBkb25lIGFuZCBkaWRuJ3Qgc3VjY2Vzcy5cbiAqIEBwcml2YXRlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSB7U0lQLlRyYW5zcG9ydH0gdHJhbnNwb3J0LlxuICovXG5VQS5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICB2YXIgc2VydmVyO1xuXG4gIHRoaXMubG9nZ2VyLmxvZygndHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2VydmVyLndzX3VyaSArICcgZmFpbGVkIHwgY29ubmVjdGlvbiBzdGF0ZSBzZXQgdG8gJysgU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19FUlJPUik7XG5cbiAgLy8gQ2xvc2Ugc2Vzc2lvbnMuXG4gIC8vTWFyayB0aGlzIHRyYW5zcG9ydCBhcyAnZG93bidcbiAgdHJhbnNwb3J0LnNlcnZlci5zdGF0dXMgPSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX0VSUk9SO1xuXG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJywge1xuICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0XG4gIH0pO1xuXG4gIC8vIHRyeSB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIFVBIGlzbid0IGNsb3NlZFxuICBpZih0aGlzLnN0YXR1cyA9PT0gQy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXJ2ZXIgPSB0aGlzLmdldE5leHRXc1NlcnZlcigpO1xuXG4gIGlmKHNlcnZlcikge1xuICAgIG5ldyBTSVAuVHJhbnNwb3J0KHRoaXMsIHNlcnZlcik7XG4gIH1lbHNlIHtcbiAgICB0aGlzLmNsb3NlU2Vzc2lvbnNPblRyYW5zcG9ydEVycm9yKCk7XG4gICAgaWYgKCF0aGlzLmVycm9yIHx8IHRoaXMuZXJyb3IgIT09IEMuTkVUV09SS19FUlJPUikge1xuICAgICAgdGhpcy5zdGF0dXMgPSBDLlNUQVRVU19OT1RfUkVBRFk7XG4gICAgICB0aGlzLmVycm9yID0gQy5ORVRXT1JLX0VSUk9SO1xuICAgIH1cbiAgICAvLyBUcmFuc3BvcnQgUmVjb3ZlcnkgcHJvY2Vzc1xuICAgIHRoaXMucmVjb3ZlclRyYW5zcG9ydCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBjb25uZWN0aW9uIGV2ZW50LlxuICogQHByaXZhdGVcbiAqIEBldmVudFxuICogQHBhcmFtIHtTSVAuVHJhbnNwb3J0fSB0cmFuc3BvcnQuXG4gKi9cblVBLnByb3RvdHlwZS5vblRyYW5zcG9ydENvbm5lY3RlZCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBSZXNldCB0cmFuc3BvcnQgcmVjb3ZlcnkgY291bnRlclxuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cyA9IDA7XG5cbiAgdHJhbnNwb3J0LnNlcnZlci5zdGF0dXMgPSBTSVAuVHJhbnNwb3J0LkMuU1RBVFVTX1JFQURZO1xuICB0aGlzLmxvZ2dlci5sb2coJ2Nvbm5lY3Rpb24gc3RhdGUgc2V0IHRvICcrIFNJUC5UcmFuc3BvcnQuQy5TVEFUVVNfUkVBRFkpO1xuXG4gIGlmKHRoaXMuc3RhdHVzID09PSBDLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc3RhdHVzID0gQy5TVEFUVVNfUkVBRFk7XG4gIHRoaXMuZXJyb3IgPSBudWxsO1xuXG4gIGlmKHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3Rlcikge1xuICAgIHRoaXMuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZWdpc3RlckNvbnRleHQub25UcmFuc3BvcnRDb25uZWN0ZWQoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnLCB7XG4gICAgdHJhbnNwb3J0OiB0cmFuc3BvcnRcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVHJhbnNwb3J0IGNvbm5lY3RpbmcgZXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAqICNwYXJhbSB7SW50ZWdlcn0gYXR0ZW1wdHMuXG4gKi9cbiAgVUEucHJvdG90eXBlLm9uVHJhbnNwb3J0Q29ubmVjdGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgYXR0ZW1wdHMpIHtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmcnLCB7XG4gICAgICB0cmFuc3BvcnQ6IHRyYW5zcG9ydCxcbiAgICAgIGF0dGVtcHRzOiBhdHRlbXB0c1xuICAgIH0pO1xuICB9O1xuXG5cbi8qKlxuICogbmV3IFRyYW5zYWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uLlxuICovXG5VQS5wcm90b3R5cGUubmV3VHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICB0aGlzLnRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbi50eXBlXVt0cmFuc2FjdGlvbi5pZF0gPSB0cmFuc2FjdGlvbjtcbiAgdGhpcy5lbWl0KCduZXdUcmFuc2FjdGlvbicsIHt0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb259KTtcbn07XG5cblxuLyoqXG4gKiBkZXN0cm95IFRyYW5zYWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uLlxuICovXG5VQS5wcm90b3R5cGUuZGVzdHJveVRyYW5zYWN0aW9uID0gZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgZGVsZXRlIHRoaXMudHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uLnR5cGVdW3RyYW5zYWN0aW9uLmlkXTtcbiAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbkRlc3Ryb3llZCcsIHtcbiAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgfSk7XG59O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gcmVjZWl2ZVJlcXVlc3Rcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFJlcXVlc3QgcmVjZXB0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0LlxuICovXG5VQS5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHZhciBkaWFsb2csIHNlc3Npb24sIG1lc3NhZ2UsXG4gICAgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QsXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgcmVwbGFjZXMsXG4gICAgcmVwbGFjZWREaWFsb2csXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gcnVyaU1hdGNoZXMgKHVyaSkge1xuICAgIHJldHVybiB1cmkgJiYgdXJpLnVzZXIgPT09IHJlcXVlc3QucnVyaS51c2VyO1xuICB9XG5cbiAgLy8gQ2hlY2sgdGhhdCByZXF1ZXN0IFVSSSBwb2ludHMgdG8gdXNcbiAgaWYoIShydXJpTWF0Y2hlcyh0aGlzLmNvbmZpZ3VyYXRpb24udXJpKSB8fFxuICAgICAgIHJ1cmlNYXRjaGVzKHRoaXMuY29udGFjdC51cmkpIHx8XG4gICAgICAgcnVyaU1hdGNoZXModGhpcy5jb250YWN0LnB1Yl9ncnV1KSB8fFxuICAgICAgIHJ1cmlNYXRjaGVzKHRoaXMuY29udGFjdC50ZW1wX2dydXUpKSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ1JlcXVlc3QtVVJJIGRvZXMgbm90IHBvaW50IHRvIHVzJyk7XG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBTSVAuQy5BQ0spIHtcbiAgICAgIHJlcXVlc3QucmVwbHlfc2woNDA0KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2hlY2sgcmVxdWVzdCBVUkkgc2NoZW1lXG4gIGlmKHJlcXVlc3QucnVyaS5zY2hlbWUgPT09IFNJUC5DLlNJUFMpIHtcbiAgICByZXF1ZXN0LnJlcGx5X3NsKDQxNik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2hlY2sgdHJhbnNhY3Rpb25cbiAgaWYoU0lQLlRyYW5zYWN0aW9ucy5jaGVja1RyYW5zYWN0aW9uKHRoaXMsIHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogUkZDMzI2MSAxMi4yLjJcbiAgICogUmVxdWVzdHMgdGhhdCBkbyBub3QgY2hhbmdlIGluIGFueSB3YXkgdGhlIHN0YXRlIG9mIGEgZGlhbG9nIG1heSBiZVxuICAgKiByZWNlaXZlZCB3aXRoaW4gYSBkaWFsb2cgKGZvciBleGFtcGxlLCBhbiBPUFRJT05TIHJlcXVlc3QpLlxuICAgKiBUaGV5IGFyZSBwcm9jZXNzZWQgYXMgaWYgdGhleSBoYWQgYmVlbiByZWNlaXZlZCBvdXRzaWRlIHRoZSBkaWFsb2cuXG4gICAqL1xuICBpZihtZXRob2QgPT09IFNJUC5DLk9QVElPTlMpIHtcbiAgICBuZXcgU0lQLlRyYW5zYWN0aW9ucy5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB0aGlzKTtcbiAgICByZXF1ZXN0LnJlcGx5KDIwMCwgbnVsbCwgW1xuICAgICAgJ0FsbG93OiAnKyBTSVAuVUEuQy5BTExPV0VEX01FVEhPRFMudG9TdHJpbmcoKSxcbiAgICAgICdBY2NlcHQ6ICcrIEMuQUNDRVBURURfQk9EWV9UWVBFU1xuICAgIF0pO1xuICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gU0lQLkMuTUVTU0FHRSkge1xuICAgIG1lc3NhZ2UgPSBuZXcgU0lQLlNlcnZlckNvbnRleHQodGhpcywgcmVxdWVzdCk7XG4gICAgbWVzc2FnZS5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgIG1lc3NhZ2UuY29udGVudF90eXBlID0gcmVxdWVzdC5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpIHx8ICd0ZXh0L3BsYWluJztcblxuICAgIHJlcXVlc3QucmVwbHkoMjAwLCBudWxsKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgfSBlbHNlIGlmIChtZXRob2QgIT09IFNJUC5DLklOVklURSAmJlxuICAgICAgICAgICAgIG1ldGhvZCAhPT0gU0lQLkMuQUNLKSB7XG4gICAgLy8gTGV0IHRob3NlIG1ldGhvZHMgcGFzcyB0aHJvdWdoIHRvIG5vcm1hbCBwcm9jZXNzaW5nIGZvciBub3cuXG4gICAgdHJhbnNhY3Rpb24gPSBuZXcgU0lQLlNlcnZlckNvbnRleHQodGhpcywgcmVxdWVzdCk7XG4gIH1cblxuICAvLyBJbml0aWFsIFJlcXVlc3RcbiAgaWYoIXJlcXVlc3QudG9fdGFnKSB7XG4gICAgc3dpdGNoKG1ldGhvZCkge1xuICAgICAgY2FzZSBTSVAuQy5JTlZJVEU6XG4gICAgICAgIHJlcGxhY2VzID1cbiAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgIT09IFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCAmJlxuICAgICAgICAgIHJlcXVlc3QucGFyc2VIZWFkZXIoJ3JlcGxhY2VzJyk7XG5cbiAgICAgICAgaWYgKHJlcGxhY2VzKSB7XG4gICAgICAgICAgcmVwbGFjZWREaWFsb2cgPSB0aGlzLmRpYWxvZ3NbcmVwbGFjZXMuY2FsbF9pZCArIHJlcGxhY2VzLnJlcGxhY2VzX3RvX3RhZyArIHJlcGxhY2VzLnJlcGxhY2VzX2Zyb21fdGFnXTtcblxuICAgICAgICAgIGlmICghcmVwbGFjZWREaWFsb2cpIHtcbiAgICAgICAgICAgIC8vUmVwbGFjZWQgaGVhZGVyIHdpdGhvdXQgYSBtYXRjaGluZyBkaWFsb2csIHJlamVjdFxuICAgICAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg0ODEsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZWREaWFsb2cub3duZXIuc3RhdHVzID09PSBTSVAuU2Vzc2lvbi5DLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlcGx5X3NsKDYwMywgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlZERpYWxvZy5zdGF0ZSA9PT0gU0lQLkRpYWxvZy5DLlNUQVRVU19DT05GSVJNRUQgJiYgcmVwbGFjZXMuZWFybHlfb25seSkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXBseV9zbCg0ODYsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc01lZGlhU3VwcG9ydGVkID0gdGhpcy5jb25maWd1cmF0aW9uLm1lZGlhSGFuZGxlckZhY3RvcnkuaXNTdXBwb3J0ZWQ7XG4gICAgICAgIGlmKCFpc01lZGlhU3VwcG9ydGVkIHx8IGlzTWVkaWFTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIHNlc3Npb24gPSBuZXcgU0lQLkludml0ZVNlcnZlckNvbnRleHQodGhpcywgcmVxdWVzdCk7XG4gICAgICAgICAgc2Vzc2lvbi5yZXBsYWNlZSA9IHJlcGxhY2VkRGlhbG9nICYmIHJlcGxhY2VkRGlhbG9nLm93bmVyO1xuICAgICAgICAgIHNlc3Npb24ub24oJ2ludml0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdpbnZpdGUnLCB0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdJTlZJVEUgcmVjZWl2ZWQgYnV0IFdlYlJUQyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgcmVxdWVzdC5yZXBseSg0ODgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTSVAuQy5CWUU6XG4gICAgICAgIC8vIE91dCBvZiBkaWFsb2cgQllFIHJlY2VpdmVkXG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLkNBTkNFTDpcbiAgICAgICAgc2Vzc2lvbiA9IHRoaXMuZmluZFNlc3Npb24ocmVxdWVzdCk7XG4gICAgICAgIGlmKHNlc3Npb24pIHtcbiAgICAgICAgICBzZXNzaW9uLnJlY2VpdmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3JlY2VpdmVkIENBTkNFTCByZXF1ZXN0IGZvciBhIG5vbiBleGlzdGVudCBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNJUC5DLkFDSzpcbiAgICAgICAgLyogQWJzb3JiIGl0LlxuICAgICAgICAgKiBBQ0sgcmVxdWVzdCB3aXRob3V0IGEgY29ycmVzcG9uZGluZyBJbnZpdGUgVHJhbnNhY3Rpb25cbiAgICAgICAgICogYW5kIHdpdGhvdXQgVG8gdGFnLlxuICAgICAgICAgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXF1ZXN0LnJlcGx5KDQwNSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBJbi1kaWFsb2cgcmVxdWVzdFxuICBlbHNlIHtcbiAgICBkaWFsb2cgPSB0aGlzLmZpbmREaWFsb2cocmVxdWVzdCk7XG5cbiAgICBpZihkaWFsb2cpIHtcbiAgICAgIGlmIChtZXRob2QgPT09IFNJUC5DLklOVklURSkge1xuICAgICAgICBuZXcgU0lQLlRyYW5zYWN0aW9ucy5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbihyZXF1ZXN0LCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5yZWNlaXZlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gU0lQLkMuTk9USUZZKSB7XG4gICAgICBzZXNzaW9uID0gdGhpcy5maW5kU2Vzc2lvbihyZXF1ZXN0KTtcbiAgICAgIGlmKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5yZWNlaXZlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ3JlY2VpdmVkIE5PVElGWSByZXF1ZXN0IGZvciBhIG5vbiBleGlzdGVudCBzZXNzaW9uJyk7XG4gICAgICAgIHJlcXVlc3QucmVwbHkoNDgxLCAnU3Vic2NyaXB0aW9uIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFJGQzMyNjEgMTIuMi4yXG4gICAgICogUmVxdWVzdCB3aXRoIHRvIHRhZywgYnV0IG5vIG1hdGNoaW5nIGRpYWxvZyBmb3VuZC5cbiAgICAgKiBFeGNlcHRpb246IEFDSyBmb3IgYW4gSW52aXRlIHJlcXVlc3QgZm9yIHdoaWNoIGEgZGlhbG9nIGhhcyBub3RcbiAgICAgKiBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZWxzZSB7XG4gICAgICBpZihtZXRob2QgIT09IFNJUC5DLkFDSykge1xuICAgICAgICByZXF1ZXN0LnJlcGx5KDQ4MSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLz09PT09PT09PT09PT09PT09XG4vLyBVdGlsc1xuLy89PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCB0aGUgc2Vzc2lvbiB0byB3aGljaCB0aGUgcmVxdWVzdCBiZWxvbmdzIHRvLCBpZiBhbnkuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0LlxuICogQHJldHVybnMge1NJUC5PdXRnb2luZ1Nlc3Npb258U0lQLkluY29taW5nU2Vzc2lvbnxudWxsfVxuICovXG5VQS5wcm90b3R5cGUuZmluZFNlc3Npb24gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHJldHVybiB0aGlzLnNlc3Npb25zW3JlcXVlc3QuY2FsbF9pZCArIHJlcXVlc3QuZnJvbV90YWddIHx8XG4gICAgICAgICAgdGhpcy5zZXNzaW9uc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LnRvX3RhZ10gfHxcbiAgICAgICAgICBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpYWxvZyB0byB3aGljaCB0aGUgcmVxdWVzdCBiZWxvbmdzIHRvLCBpZiBhbnkuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fVxuICogQHJldHVybnMge1NJUC5EaWFsb2d8bnVsbH1cbiAqL1xuVUEucHJvdG90eXBlLmZpbmREaWFsb2cgPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gIHJldHVybiB0aGlzLmRpYWxvZ3NbcmVxdWVzdC5jYWxsX2lkICsgcmVxdWVzdC5mcm9tX3RhZyArIHJlcXVlc3QudG9fdGFnXSB8fFxuICAgICAgICAgIHRoaXMuZGlhbG9nc1tyZXF1ZXN0LmNhbGxfaWQgKyByZXF1ZXN0LnRvX3RhZyArIHJlcXVlc3QuZnJvbV90YWddIHx8XG4gICAgICAgICAgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIG5leHQgc2VydmVyIHRvIHdoaWNoIGNvbm5lY3QuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH0gd3Nfc2VydmVyXG4gKi9cblVBLnByb3RvdHlwZS5nZXROZXh0V3NTZXJ2ZXIgPSBmdW5jdGlvbigpIHtcbiAgLy8gT3JkZXIgc2VydmVycyBieSB3ZWlnaHRcbiAgdmFyIGlkeCwgbGVuZ3RoLCB3c19zZXJ2ZXIsXG4gICAgY2FuZGlkYXRlcyA9IFtdO1xuXG4gIGxlbmd0aCA9IHRoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnMubGVuZ3RoO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICB3c19zZXJ2ZXIgPSB0aGlzLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzW2lkeF07XG5cbiAgICBpZiAod3Nfc2VydmVyLnN0YXR1cyA9PT0gU0lQLlRyYW5zcG9ydC5DLlNUQVRVU19FUlJPUikge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FuZGlkYXRlcy5wdXNoKHdzX3NlcnZlcik7XG4gICAgfSBlbHNlIGlmICh3c19zZXJ2ZXIud2VpZ2h0ID4gY2FuZGlkYXRlc1swXS53ZWlnaHQpIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBbd3Nfc2VydmVyXTtcbiAgICB9IGVsc2UgaWYgKHdzX3NlcnZlci53ZWlnaHQgPT09IGNhbmRpZGF0ZXNbMF0ud2VpZ2h0KSB7XG4gICAgICBjYW5kaWRhdGVzLnB1c2god3Nfc2VydmVyKTtcbiAgICB9XG4gIH1cblxuICBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjYW5kaWRhdGVzLmxlbmd0aCk7XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXNbaWR4XTtcbn07XG5cbi8qKlxuICogQ2xvc2UgYWxsIHNlc3Npb25zIG9uIHRyYW5zcG9ydCBlcnJvci5cbiAqIEBwcml2YXRlXG4gKi9cblVBLnByb3RvdHlwZS5jbG9zZVNlc3Npb25zT25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWR4O1xuXG4gIC8vIFJ1biBfdHJhbnNwb3J0RXJyb3JfIGZvciBldmVyeSBTZXNzaW9uXG4gIGZvcihpZHggaW4gdGhpcy5zZXNzaW9ucykge1xuICAgIHRoaXMuc2Vzc2lvbnNbaWR4XS5vblRyYW5zcG9ydEVycm9yKCk7XG4gIH1cbiAgLy8gQ2FsbCByZWdpc3RlckNvbnRleHQgX29uVHJhbnNwb3J0Q2xvc2VkX1xuICB0aGlzLnJlZ2lzdGVyQ29udGV4dC5vblRyYW5zcG9ydENsb3NlZCgpO1xufTtcblxuVUEucHJvdG90eXBlLnJlY292ZXJUcmFuc3BvcnQgPSBmdW5jdGlvbih1YSkge1xuICB2YXIgaWR4LCBsZW5ndGgsIGssIG5leHRSZXRyeSwgY291bnQsIHNlcnZlcjtcblxuICB1YSA9IHVhIHx8IHRoaXM7XG4gIGNvdW50ID0gdWEudHJhbnNwb3J0UmVjb3ZlckF0dGVtcHRzO1xuXG4gIGxlbmd0aCA9IHVhLmNvbmZpZ3VyYXRpb24ud3NTZXJ2ZXJzLmxlbmd0aDtcbiAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgdWEuY29uZmlndXJhdGlvbi53c1NlcnZlcnNbaWR4XS5zdGF0dXMgPSAwO1xuICB9XG5cbiAgc2VydmVyID0gdWEuZ2V0TmV4dFdzU2VydmVyKCk7XG5cbiAgayA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLGNvdW50KSkgKzEpO1xuICBuZXh0UmV0cnkgPSBrICogdWEuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDtcblxuICBpZiAobmV4dFJldHJ5ID4gdWEuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygndGltZSBmb3IgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQgZXhjZWVkcyBjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCwgcmVzZXR0aW5nIGNvdW50ZXInKTtcbiAgICBuZXh0UmV0cnkgPSB1YS5jb25maWd1cmF0aW9uLmNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsO1xuICAgIGNvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMubG9nZ2VyLmxvZygnbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQgaW4gJysgbmV4dFJldHJ5ICsnIHNlY29uZHMnKTtcblxuICB0aGlzLnRyYW5zcG9ydFJlY292ZXJ5VGltZXIgPSBTSVAuVGltZXJzLnNldFRpbWVvdXQoXG4gICAgZnVuY3Rpb24oKXtcbiAgICAgIHVhLnRyYW5zcG9ydFJlY292ZXJBdHRlbXB0cyA9IGNvdW50ICsgMTtcbiAgICAgIG5ldyBTSVAuVHJhbnNwb3J0KHVhLCBzZXJ2ZXIpO1xuICAgIH0sIG5leHRSZXRyeSAqIDEwMDApO1xufTtcblxuZnVuY3Rpb24gY2hlY2tBdXRoZW50aWNhdGlvbkZhY3RvcnkgKGF1dGhlbnRpY2F0aW9uRmFjdG9yeSkge1xuICBpZiAoIShhdXRoZW50aWNhdGlvbkZhY3RvcnkgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFhdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSkge1xuICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeS5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZSAoKSB7XG4gICAgICByZXR1cm4gU0lQLlV0aWxzLlByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGxvYWQuXG4gKiBAcHJpdmF0ZVxuICogcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuVUEucHJvdG90eXBlLmxvYWRDb25maWcgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uKSB7XG4gIC8vIFNldHRpbmdzIGFuZCBkZWZhdWx0IHZhbHVlc1xuICB2YXIgcGFyYW1ldGVyLCB2YWx1ZSwgY2hlY2tlZF92YWx1ZSwgaG9zdHBvcnRQYXJhbXMsIHJlZ2lzdHJhclNlcnZlcixcbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIC8qIEhvc3QgYWRkcmVzc1xuICAgICAgKiBWYWx1ZSB0byBiZSBzZXQgaW4gVmlhIHNlbnRfYnkgYW5kIGhvc3QgcGFydCBvZiBDb250YWN0IEZRRE5cbiAgICAgICovXG4gICAgICB2aWFIb3N0OiBTSVAuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oMTIpICsgJy5pbnZhbGlkJyxcblxuICAgICAgdXJpOiBuZXcgU0lQLlVSSSgnc2lwJywgJ2Fub255bW91cy4nICsgU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDYpLCAnYW5vbnltb3VzLmludmFsaWQnLCBudWxsLCBudWxsKSxcbiAgICAgIHdzU2VydmVyczogW3tcbiAgICAgICAgc2NoZW1lOiAnV1NTJyxcbiAgICAgICAgc2lwX3VyaTogJzxzaXA6ZWRnZS5zaXAub25zaXAuY29tO3RyYW5zcG9ydD13cztscj4nLFxuICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgd3NfdXJpOiAnd3NzOi8vZWRnZS5zaXAub25zaXAuY29tJ1xuICAgICAgfV0sXG5cbiAgICAgIC8vIFBhc3N3b3JkXG4gICAgICBwYXNzd29yZDogbnVsbCxcblxuICAgICAgLy8gUmVnaXN0cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgIHJlZ2lzdGVyRXhwaXJlczogNjAwLFxuICAgICAgcmVnaXN0ZXI6IHRydWUsXG4gICAgICByZWdpc3RyYXJTZXJ2ZXI6IG51bGwsXG5cbiAgICAgIC8vIFRyYW5zcG9ydCByZWxhdGVkIHBhcmFtZXRlcnNcbiAgICAgIHdzU2VydmVyTWF4UmVjb25uZWN0aW9uOiAzLFxuICAgICAgd3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0OiA0LFxuXG4gICAgICBjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbDogMixcbiAgICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsOiAzMCxcblxuICAgICAga2VlcEFsaXZlSW50ZXJ2YWw6IDAsXG5cbiAgICAgIGV4dHJhU3VwcG9ydGVkOiBbXSxcblxuICAgICAgdXNlUHJlbG9hZGVkUm91dGU6IGZhbHNlLFxuXG4gICAgICAvL3N0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIFVzZXItQWdlbnQgcmVxdWVzdCBoZWFkZXJcbiAgICAgIHVzZXJBZ2VudFN0cmluZzogU0lQLkMuVVNFUl9BR0VOVCxcblxuICAgICAgLy8gU2Vzc2lvbiBwYXJhbWV0ZXJzXG4gICAgICBpY2VDaGVja2luZ1RpbWVvdXQ6IDUwMDAsXG4gICAgICBub0Fuc3dlclRpbWVvdXQ6IDYwLFxuICAgICAgc3R1blNlcnZlcnM6IFsnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMiddLFxuICAgICAgdHVyblNlcnZlcnM6IFtdLFxuXG4gICAgICAvLyBMb2dnaW5nIHBhcmFtZXRlcnNcbiAgICAgIHRyYWNlU2lwOiBmYWxzZSxcblxuICAgICAgLy8gSGFja3NcbiAgICAgIGhhY2tWaWFUY3A6IGZhbHNlLFxuICAgICAgaGFja0lwSW5Db250YWN0OiBmYWxzZSxcbiAgICAgIGhhY2tXc3NJblRyYW5zcG9ydDogZmFsc2UsXG4gICAgICBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzOiBmYWxzZSxcblxuICAgICAgY29udGFjdFRyYW5zcG9ydDogJ3dzJyxcbiAgICAgIGZvcmNlUnBvcnQ6IGZhbHNlLFxuXG4gICAgICAvL2F1dG9zdGFydGluZ1xuICAgICAgYXV0b3N0YXJ0OiB0cnVlLFxuXG4gICAgICAvL1JlbGlhYmxlIFByb3Zpc2lvbmFsIFJlc3BvbnNlc1xuICAgICAgcmVsMTAwOiBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQsXG5cbiAgICAgIC8vIFJlcGxhY2VzIGhlYWRlciAoUkZDIDM4OTEpXG4gICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzODkxXG4gICAgICByZXBsYWNlczogU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVELFxuXG4gICAgICBtZWRpYUhhbmRsZXJGYWN0b3J5OiBTSVAuV2ViUlRDLk1lZGlhSGFuZGxlci5kZWZhdWx0RmFjdG9yeSxcblxuICAgICAgYXV0aGVudGljYXRpb25GYWN0b3J5OiBjaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeShmdW5jdGlvbiBhdXRoZW50aWNhdGlvbkZhY3RvcnkgKHVhKSB7XG4gICAgICAgIHJldHVybiBuZXcgU0lQLkRpZ2VzdEF1dGhlbnRpY2F0aW9uKHVhKTtcbiAgICAgIH0pXG4gICAgfTtcblxuICAvLyBQcmUtQ29uZmlndXJhdGlvblxuICBmdW5jdGlvbiBhbGlhc1VuZGVyc2NvcmVkIChwYXJhbWV0ZXIsIGxvZ2dlcikge1xuICAgIHZhciB1bmRlcnNjb3JlZCA9IHBhcmFtZXRlci5yZXBsYWNlKC8oW2Etel1bQS1aXSkvZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtWzBdICsgJ18nICsgbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBhcmFtZXRlciA9PT0gdW5kZXJzY29yZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFyYW1ldGVyID0gY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpO1xuICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHVuZGVyc2NvcmVkKSkge1xuICAgICAgbG9nZ2VyLndhcm4odW5kZXJzY29yZWQgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIHBhcmFtZXRlcik7XG4gICAgICBpZiAoaGFzUGFyYW1ldGVyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKHBhcmFtZXRlciArICcgb3ZlcnJpZGluZyAnICsgdW5kZXJzY29yZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXSA9IGhhc1BhcmFtZXRlciA/IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXSA6IGNvbmZpZ3VyYXRpb25bdW5kZXJzY29yZWRdO1xuICB9XG5cbiAgLy8gQ2hlY2sgTWFuZGF0b3J5IHBhcmFtZXRlcnNcbiAgZm9yKHBhcmFtZXRlciBpbiBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm1hbmRhdG9yeSkge1xuICAgIGFsaWFzVW5kZXJzY29yZWQocGFyYW1ldGVyLCB0aGlzLmxvZ2dlcik7XG4gICAgaWYoIWNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFNJUC5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcbiAgICAgIGNoZWNrZWRfdmFsdWUgPSBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm1hbmRhdG9yeVtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgIGlmIChjaGVja2VkX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRfdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFNJUC5VdGlscy5vcHRpb25zT3ZlcnJpZGUoY29uZmlndXJhdGlvbiwgJ3JlbDEwMCcsICdyZWxpYWJsZScsIHRydWUsIHRoaXMubG9nZ2VyLCBTSVAuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQpO1xuXG4gIHZhciBlbXB0eUFycmF5c0FsbG93ZWQgPSBbJ3N0dW5TZXJ2ZXJzJywgJ3R1cm5TZXJ2ZXJzJ107XG5cbiAgLy8gQ2hlY2sgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICBmb3IocGFyYW1ldGVyIGluIFVBLmNvbmZpZ3VyYXRpb25fY2hlY2sub3B0aW9uYWwpIHtcbiAgICBhbGlhc1VuZGVyc2NvcmVkKHBhcmFtZXRlciwgdGhpcy5sb2dnZXIpO1xuICAgIGlmKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG5cbiAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgYW4gZW1wdHkgYXJyYXksIGJ1dCBzaG91bGRuJ3QgYmUsIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwICYmIGVtcHR5QXJyYXlzQWxsb3dlZC5pbmRleE9mKHBhcmFtZXRlcikgPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbnVsbCwgZW1wdHkgc3RyaW5nLCBvciB1bmRlZmluZWQgdGhlbiBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHsgY29udGludWU7IH1cbiAgICAgIC8vIElmIGl0J3MgYSBudW1iZXIgd2l0aCBOYU4gdmFsdWUgdGhlbiBhbHNvIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgLy8gTk9URTogSlMgZG9lcyBub3QgYWxsb3cgXCJ2YWx1ZSA9PT0gTmFOXCIsIHRoZSBmb2xsb3dpbmcgZG9lcyB0aGUgd29yazpcbiAgICAgIGVsc2UgaWYodHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGNoZWNrZWRfdmFsdWUgPSBVQS5jb25maWd1cmF0aW9uX2NoZWNrLm9wdGlvbmFsW3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgaWYgKGNoZWNrZWRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0aW5nc1twYXJhbWV0ZXJdID0gY2hlY2tlZF92YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTSVAuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXR5IENoZWNrc1xuXG4gIC8vIENvbm5lY3Rpb24gcmVjb3ZlcnkgaW50ZXJ2YWxzXG4gIGlmKHNldHRpbmdzLmNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsIDwgc2V0dGluZ3MuY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWwpIHtcbiAgICB0aHJvdyBuZXcgU0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKCdjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCcsIHNldHRpbmdzLmNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsKTtcbiAgfVxuXG4gIC8vIFBvc3QgQ29uZmlndXJhdGlvbiBQcm9jZXNzXG5cbiAgLy8gQWxsb3cgcGFzc2luZyAwIG51bWJlciBhcyBkaXNwbGF5TmFtZS5cbiAgaWYgKHNldHRpbmdzLmRpc3BsYXlOYW1lID09PSAwKSB7XG4gICAgc2V0dGluZ3MuZGlzcGxheU5hbWUgPSAnMCc7XG4gIH1cblxuICAvLyBJbnN0YW5jZS1pZCBmb3IgR1JVVVxuICBpZiAoIXNldHRpbmdzLmluc3RhbmNlSWQpIHtcbiAgICBzZXR0aW5ncy5pbnN0YW5jZUlkID0gU0lQLlV0aWxzLm5ld1VVSUQoKTtcbiAgfVxuXG4gIC8vIHNpcGpzSWQgaW5zdGFuY2UgcGFyYW1ldGVyLiBTdGF0aWMgcmFuZG9tIHRhZyBvZiBsZW5ndGggNVxuICBzZXR0aW5ncy5zaXBqc0lkID0gU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDUpO1xuXG4gIC8vIFN0cmluZyBjb250YWluaW5nIHNldHRpbmdzLnVyaSB3aXRob3V0IHNjaGVtZSBhbmQgdXNlci5cbiAgaG9zdHBvcnRQYXJhbXMgPSBzZXR0aW5ncy51cmkuY2xvbmUoKTtcbiAgaG9zdHBvcnRQYXJhbXMudXNlciA9IG51bGw7XG4gIHNldHRpbmdzLmhvc3Rwb3J0UGFyYW1zID0gaG9zdHBvcnRQYXJhbXMudG9SYXcoKS5yZXBsYWNlKC9ec2lwOi9pLCAnJyk7XG5cbiAgLyogQ2hlY2sgd2hldGhlciBhdXRob3JpemF0aW9uVXNlciBpcyBleHBsaWNpdGx5IGRlZmluZWQuXG4gICAqIFRha2UgJ3NldHRpbmdzLnVyaS51c2VyJyB2YWx1ZSBpZiBub3QuXG4gICAqL1xuICBpZiAoIXNldHRpbmdzLmF1dGhvcml6YXRpb25Vc2VyKSB7XG4gICAgc2V0dGluZ3MuYXV0aG9yaXphdGlvblVzZXIgPSBzZXR0aW5ncy51cmkudXNlcjtcbiAgfVxuXG4gIC8qIElmIG5vICdyZWdpc3RyYXJTZXJ2ZXInIGlzIHNldCB1c2UgdGhlICd1cmknIHZhbHVlIHdpdGhvdXQgdXNlciBwb3J0aW9uLiAqL1xuICBpZiAoIXNldHRpbmdzLnJlZ2lzdHJhclNlcnZlcikge1xuICAgIHJlZ2lzdHJhclNlcnZlciA9IHNldHRpbmdzLnVyaS5jbG9uZSgpO1xuICAgIHJlZ2lzdHJhclNlcnZlci51c2VyID0gbnVsbDtcbiAgICBzZXR0aW5ncy5yZWdpc3RyYXJTZXJ2ZXIgPSByZWdpc3RyYXJTZXJ2ZXI7XG4gIH1cblxuICAvLyBVc2VyIG5vQW5zd2VyVGltZW91dFxuICBzZXR0aW5ncy5ub0Fuc3dlclRpbWVvdXQgPSBzZXR0aW5ncy5ub0Fuc3dlclRpbWVvdXQgKiAxMDAwO1xuXG4gIC8vIFZpYSBIb3N0XG4gIGlmIChzZXR0aW5ncy5oYWNrSXBJbkNvbnRhY3QpIHtcbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmhhY2tJcEluQ29udGFjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBzZXR0aW5ncy52aWFIb3N0ID0gU0lQLlV0aWxzLmdldFJhbmRvbVRlc3ROZXRJUCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGFja0lwSW5Db250YWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgc2V0dGluZ3MudmlhSG9zdCA9IHNldHRpbmdzLmhhY2tJcEluQ29udGFjdDtcbiAgICB9XG4gIH1cblxuICAvLyBDb250YWN0IHRyYW5zcG9ydCBwYXJhbWV0ZXJcbiAgaWYgKHNldHRpbmdzLmhhY2tXc3NJblRyYW5zcG9ydCkge1xuICAgIHNldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnQgPSAnd3NzJztcbiAgfVxuXG4gIHRoaXMuY29udGFjdCA9IHtcbiAgICBwdWJfZ3J1dTogbnVsbCxcbiAgICB0ZW1wX2dydXU6IG51bGwsXG4gICAgdXJpOiBuZXcgU0lQLlVSSSgnc2lwJywgU0lQLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDgpLCBzZXR0aW5ncy52aWFIb3N0LCBudWxsLCB7dHJhbnNwb3J0OiBzZXR0aW5ncy5jb250YWN0VHJhbnNwb3J0fSksXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhclxuICAgICAgICBhbm9ueW1vdXMgPSBvcHRpb25zLmFub255bW91cyB8fCBudWxsLFxuICAgICAgICBvdXRib3VuZCA9IG9wdGlvbnMub3V0Ym91bmQgfHwgbnVsbCxcbiAgICAgICAgY29udGFjdCA9ICc8JztcblxuICAgICAgaWYgKGFub255bW91cykge1xuICAgICAgICBjb250YWN0ICs9ICh0aGlzLnRlbXBfZ3J1dSB8fCAoJ3NpcDphbm9ueW1vdXNAYW5vbnltb3VzLmludmFsaWQ7dHJhbnNwb3J0PScrc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCkpLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWN0ICs9ICh0aGlzLnB1Yl9ncnV1IHx8IHRoaXMudXJpKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0Ym91bmQpIHtcbiAgICAgICAgY29udGFjdCArPSAnO29iJztcbiAgICAgIH1cblxuICAgICAgY29udGFjdCArPSAnPic7XG5cbiAgICAgIHJldHVybiBjb250YWN0O1xuICAgIH1cbiAgfTtcblxuICAvLyBtZWRpYSBvdmVycmlkZXMgbWVkaWFDb25zdHJhaW50c1xuICBTSVAuVXRpbHMub3B0aW9uc092ZXJyaWRlKHNldHRpbmdzLCAnbWVkaWEnLCAnbWVkaWFDb25zdHJhaW50cycsIHRydWUsIHRoaXMubG9nZ2VyKTtcblxuICAvLyBGaWxsIHRoZSB2YWx1ZSBvZiB0aGUgY29uZmlndXJhdGlvbl9za2VsZXRvblxuICBmb3IocGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbltwYXJhbWV0ZXJdLnZhbHVlID0gc2V0dGluZ3NbcGFyYW1ldGVyXTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuY29uZmlndXJhdGlvbiwgVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbik7XG5cbiAgLy8gQ2xlYW4gVUEuY29uZmlndXJhdGlvbl9za2VsZXRvblxuICBmb3IocGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgVUEuY29uZmlndXJhdGlvbl9za2VsZXRvbltwYXJhbWV0ZXJdLnZhbHVlID0gJyc7XG4gIH1cblxuICB0aGlzLmxvZ2dlci5sb2coJ2NvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBhZnRlciB2YWxpZGF0aW9uOicpO1xuICBmb3IocGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgc3dpdGNoKHBhcmFtZXRlcikge1xuICAgICAgY2FzZSAndXJpJzpcbiAgICAgIGNhc2UgJ3JlZ2lzdHJhclNlcnZlcic6XG4gICAgICBjYXNlICdtZWRpYUhhbmRsZXJGYWN0b3J5JzpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCfCtyAnICsgcGFyYW1ldGVyICsgJzogJyArIHNldHRpbmdzW3BhcmFtZXRlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCfCtyAnICsgcGFyYW1ldGVyICsgJzogJyArICdOT1QgU0hPV04nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ8K3ICcgKyBwYXJhbWV0ZXIgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3NbcGFyYW1ldGVyXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn07XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBPYmplY3Qgc2tlbGV0b24uXG4gKiBAcHJpdmF0ZVxuICovXG5VQS5jb25maWd1cmF0aW9uX3NrZWxldG9uID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaWR4LCAgcGFyYW1ldGVyLFxuICAgIHNrZWxldG9uID0ge30sXG4gICAgcGFyYW1ldGVycyA9IFtcbiAgICAgIC8vIEludGVybmFsIHBhcmFtZXRlcnNcbiAgICAgIFwic2lwanNJZFwiLFxuICAgICAgXCJob3N0cG9ydFBhcmFtc1wiLFxuXG4gICAgICAvLyBPcHRpb25hbCB1c2VyIGNvbmZpZ3VyYWJsZSBwYXJhbWV0ZXJzXG4gICAgICBcInVyaVwiLFxuICAgICAgXCJ3c1NlcnZlcnNcIixcbiAgICAgIFwiYXV0aG9yaXphdGlvblVzZXJcIixcbiAgICAgIFwiY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWxcIixcbiAgICAgIFwiY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWxcIixcbiAgICAgIFwia2VlcEFsaXZlSW50ZXJ2YWxcIixcbiAgICAgIFwiZXh0cmFTdXBwb3J0ZWRcIixcbiAgICAgIFwiZGlzcGxheU5hbWVcIixcbiAgICAgIFwiaGFja1ZpYVRjcFwiLCAvLyBmYWxzZS5cbiAgICAgIFwiaGFja0lwSW5Db250YWN0XCIsIC8vZmFsc2VcbiAgICAgIFwiaGFja1dzc0luVHJhbnNwb3J0XCIsIC8vZmFsc2VcbiAgICAgIFwiaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnc1wiLCAvL2ZhbHNlXG4gICAgICBcImNvbnRhY3RUcmFuc3BvcnRcIiwgLy8gJ3dzJ1xuICAgICAgXCJmb3JjZVJwb3J0XCIsIC8vIGZhbHNlXG4gICAgICBcImljZUNoZWNraW5nVGltZW91dFwiLFxuICAgICAgXCJpbnN0YW5jZUlkXCIsXG4gICAgICBcIm5vQW5zd2VyVGltZW91dFwiLCAvLyAzMCBzZWNvbmRzLlxuICAgICAgXCJwYXNzd29yZFwiLFxuICAgICAgXCJyZWdpc3RlckV4cGlyZXNcIiwgLy8gNjAwIHNlY29uZHMuXG4gICAgICBcInJlZ2lzdHJhclNlcnZlclwiLFxuICAgICAgXCJyZWxpYWJsZVwiLFxuICAgICAgXCJyZWwxMDBcIixcbiAgICAgIFwicmVwbGFjZXNcIixcbiAgICAgIFwidXNlckFnZW50U3RyaW5nXCIsIC8vU0lQLkMuVVNFUl9BR0VOVFxuICAgICAgXCJhdXRvc3RhcnRcIixcbiAgICAgIFwic3R1blNlcnZlcnNcIixcbiAgICAgIFwidHJhY2VTaXBcIixcbiAgICAgIFwidHVyblNlcnZlcnNcIixcbiAgICAgIFwidXNlUHJlbG9hZGVkUm91dGVcIixcbiAgICAgIFwid3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb25cIixcbiAgICAgIFwid3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0XCIsXG4gICAgICBcIm1lZGlhSGFuZGxlckZhY3RvcnlcIixcbiAgICAgIFwibWVkaWFcIixcbiAgICAgIFwibWVkaWFDb25zdHJhaW50c1wiLFxuICAgICAgXCJhdXRoZW50aWNhdGlvbkZhY3RvcnlcIixcblxuICAgICAgLy8gUG9zdC1jb25maWd1cmF0aW9uIGdlbmVyYXRlZCBwYXJhbWV0ZXJzXG4gICAgICBcInZpYV9jb3JlX3ZhbHVlXCIsXG4gICAgICBcInZpYUhvc3RcIlxuICAgIF07XG5cbiAgZm9yKGlkeCBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpZHhdO1xuICAgIHNrZWxldG9uW3BhcmFtZXRlcl0gPSB7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHNrZWxldG9uWydyZWdpc3RlciddID0ge1xuICAgIHZhbHVlOiAnJyxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH07XG5cbiAgcmV0dXJuIHNrZWxldG9uO1xufSgpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGNoZWNrZXIuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuVUEuY29uZmlndXJhdGlvbl9jaGVjayA9IHtcbiAgbWFuZGF0b3J5OiB7XG4gIH0sXG5cbiAgb3B0aW9uYWw6IHtcblxuICAgIHVyaTogZnVuY3Rpb24odXJpKSB7XG4gICAgICB2YXIgcGFyc2VkO1xuXG4gICAgICBpZiAoISgvXnNpcDovaSkudGVzdCh1cmkpKSB7XG4gICAgICAgIHVyaSA9IFNJUC5DLlNJUCArICc6JyArIHVyaTtcbiAgICAgIH1cbiAgICAgIHBhcnNlZCA9IFNJUC5VUkkucGFyc2UodXJpKTtcblxuICAgICAgaWYoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYoIXBhcnNlZC51c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vTm90ZTogdGhpcyBmdW5jdGlvbiB1c2VkIHRvIGNhbGwgJ3RoaXMubG9nZ2VyLmVycm9yJyBidXQgY2FsbGluZyAndGhpcycgd2l0aCBhbnl0aGluZyBoZXJlIGlzIGludmFsaWRcbiAgICB3c1NlcnZlcnM6IGZ1bmN0aW9uKHdzU2VydmVycykge1xuICAgICAgdmFyIGlkeCwgbGVuZ3RoLCB1cmw7XG5cbiAgICAgIC8qIEFsbG93IGRlZmluaW5nIHdzU2VydmVycyBwYXJhbWV0ZXIgYXM6XG4gICAgICAgKiAgU3RyaW5nOiBcImhvc3RcIlxuICAgICAgICogIEFycmF5IG9mIFN0cmluZ3M6IFtcImhvc3QxXCIsIFwiaG9zdDJcIl1cbiAgICAgICAqICBBcnJheSBvZiBPYmplY3RzOiBbe3dzX3VyaTpcImhvc3QxXCIsIHdlaWdodDoxfSwge3dzX3VyaTpcImhvc3QyXCIsIHdlaWdodDowfV1cbiAgICAgICAqICBBcnJheSBvZiBPYmplY3RzIGFuZCBTdHJpbmdzOiBbe3dzX3VyaTpcImhvc3QxXCJ9LCBcImhvc3QyXCJdXG4gICAgICAgKi9cbiAgICAgIGlmICh0eXBlb2Ygd3NTZXJ2ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB3c1NlcnZlcnMgPSBbe3dzX3VyaTogd3NTZXJ2ZXJzfV07XG4gICAgICB9IGVsc2UgaWYgKHdzU2VydmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGxlbmd0aCA9IHdzU2VydmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd3NTZXJ2ZXJzW2lkeF0gPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHdzU2VydmVyc1tpZHhdID0ge3dzX3VyaTogd3NTZXJ2ZXJzW2lkeF19O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAod3NTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9IHdzU2VydmVycy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKCF3c1NlcnZlcnNbaWR4XS53c191cmkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdzU2VydmVyc1tpZHhdLndlaWdodCAmJiAhTnVtYmVyKHdzU2VydmVyc1tpZHhdLndlaWdodCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cmwgPSBTSVAuR3JhbW1hci5wYXJzZSh3c1NlcnZlcnNbaWR4XS53c191cmksICdhYnNvbHV0ZVVSSScpO1xuXG4gICAgICAgIGlmKHVybCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZihbJ3dzcycsICd3cycsICd1ZHAnXS5pbmRleE9mKHVybC5zY2hlbWUpIDwgMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3c1NlcnZlcnNbaWR4XS5zaXBfdXJpID0gJzxzaXA6JyArIHVybC5ob3N0ICsgKHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJykgKyAnO3RyYW5zcG9ydD0nICsgdXJsLnNjaGVtZS5yZXBsYWNlKC9ed3NzJC9pLCAnd3MnKSArICc7bHI+JztcblxuICAgICAgICAgIGlmICghd3NTZXJ2ZXJzW2lkeF0ud2VpZ2h0KSB7XG4gICAgICAgICAgICB3c1NlcnZlcnNbaWR4XS53ZWlnaHQgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdzU2VydmVyc1tpZHhdLnN0YXR1cyA9IDA7XG4gICAgICAgICAgd3NTZXJ2ZXJzW2lkeF0uc2NoZW1lID0gdXJsLnNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd3NTZXJ2ZXJzO1xuICAgIH0sXG5cbiAgICBhdXRob3JpemF0aW9uVXNlcjogZnVuY3Rpb24oYXV0aG9yaXphdGlvblVzZXIpIHtcbiAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKCdcIicrIGF1dGhvcml6YXRpb25Vc2VyICsnXCInLCAncXVvdGVkX3N0cmluZycpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXV0aG9yaXphdGlvblVzZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbm5lY3Rpb25SZWNvdmVyeU1heEludGVydmFsOiBmdW5jdGlvbihjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYoU0lQLlV0aWxzLmlzRGVjaW1hbChjb25uZWN0aW9uUmVjb3ZlcnlNYXhJbnRlcnZhbCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIoY29ubmVjdGlvblJlY292ZXJ5TWF4SW50ZXJ2YWwpO1xuICAgICAgICBpZih2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29ubmVjdGlvblJlY292ZXJ5TWluSW50ZXJ2YWw6IGZ1bmN0aW9uKGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZihTSVAuVXRpbHMuaXNEZWNpbWFsKGNvbm5lY3Rpb25SZWNvdmVyeU1pbkludGVydmFsKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihjb25uZWN0aW9uUmVjb3ZlcnlNaW5JbnRlcnZhbCk7XG4gICAgICAgIGlmKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24oZGlzcGxheU5hbWUpIHtcbiAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKCdcIicgKyBkaXNwbGF5TmFtZSArICdcIicsICdkaXNwbGF5TmFtZScpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tWaWFUY3A6IGZ1bmN0aW9uKGhhY2tWaWFUY3ApIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja1ZpYVRjcCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrVmlhVGNwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYWNrSXBJbkNvbnRhY3Q6IGZ1bmN0aW9uKGhhY2tJcEluQ29udGFjdCkge1xuICAgICAgaWYgKHR5cGVvZiBoYWNrSXBJbkNvbnRhY3QgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gaGFja0lwSW5Db250YWN0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGhhY2tJcEluQ29udGFjdCA9PT0gJ3N0cmluZycgJiYgU0lQLkdyYW1tYXIucGFyc2UoaGFja0lwSW5Db250YWN0LCAnaG9zdCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gaGFja0lwSW5Db250YWN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpY2VDaGVja2luZ1RpbWVvdXQ6IGZ1bmN0aW9uKGljZUNoZWNraW5nVGltZW91dCkge1xuICAgICAgaWYoU0lQLlV0aWxzLmlzRGVjaW1hbChpY2VDaGVja2luZ1RpbWVvdXQpKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCg1MDAsIGljZUNoZWNraW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tXc3NJblRyYW5zcG9ydDogZnVuY3Rpb24oaGFja1dzc0luVHJhbnNwb3J0KSB7XG4gICAgICBpZiAodHlwZW9mIGhhY2tXc3NJblRyYW5zcG9ydCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrV3NzSW5UcmFuc3BvcnQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3M6IGZ1bmN0aW9uKGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWN0VHJhbnNwb3J0OiBmdW5jdGlvbihjb250YWN0VHJhbnNwb3J0KSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnRhY3RUcmFuc3BvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjb250YWN0VHJhbnNwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmb3JjZVJwb3J0OiBmdW5jdGlvbihmb3JjZVJwb3J0KSB7XG4gICAgICBpZiAodHlwZW9mIGZvcmNlUnBvcnQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZm9yY2VScG9ydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5zdGFuY2VJZDogZnVuY3Rpb24oaW5zdGFuY2VJZCkge1xuICAgICAgaWYodHlwZW9mIGluc3RhbmNlSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCgvXnV1aWQ6L2kudGVzdChpbnN0YW5jZUlkKSkpIHtcbiAgICAgICAgaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQuc3Vic3RyKDUpO1xuICAgICAgfVxuXG4gICAgICBpZihTSVAuR3JhbW1hci5wYXJzZShpbnN0YW5jZUlkLCAndXVpZCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VJZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAga2VlcEFsaXZlSW50ZXJ2YWw6IGZ1bmN0aW9uKGtlZXBBbGl2ZUludGVydmFsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbChrZWVwQWxpdmVJbnRlcnZhbCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIoa2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4dHJhU3VwcG9ydGVkOiBmdW5jdGlvbihvcHRpb25UYWdzKSB7XG4gICAgICB2YXIgaWR4LCBsZW5ndGg7XG5cbiAgICAgIGlmICghKG9wdGlvblRhZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBvcHRpb25UYWdzLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvblRhZ3NbaWR4XSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvblRhZ3M7XG4gICAgfSxcblxuICAgIG5vQW5zd2VyVGltZW91dDogZnVuY3Rpb24obm9BbnN3ZXJUaW1lb3V0KSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoU0lQLlV0aWxzLmlzRGVjaW1hbChub0Fuc3dlclRpbWVvdXQpKSB7XG4gICAgICAgIHZhbHVlID0gTnVtYmVyKG5vQW5zd2VyVGltZW91dCk7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFzc3dvcmQ6IGZ1bmN0aW9uKHBhc3N3b3JkKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHBhc3N3b3JkKTtcbiAgICB9LFxuXG4gICAgcmVsMTAwOiBmdW5jdGlvbihyZWwxMDApIHtcbiAgICAgIGlmKHJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICAgIHJldHVybiBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQ7XG4gICAgICB9IGVsc2UgaWYgKHJlbDEwMCA9PT0gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlNVUFBPUlRFRDtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICByZXR1cm4gU0lQLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBsYWNlczogZnVuY3Rpb24ocmVwbGFjZXMpIHtcbiAgICAgIGlmKHJlcGxhY2VzID09PSBTSVAuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5SRVFVSVJFRDtcbiAgICAgIH0gZWxzZSBpZiAocmVwbGFjZXMgPT09IFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQpIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5TVVBQT1JURUQ7XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgcmV0dXJuIFNJUC5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHJlZ2lzdGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZWdpc3RlckV4cGlyZXM6IGZ1bmN0aW9uKHJlZ2lzdGVyRXhwaXJlcykge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKFNJUC5VdGlscy5pc0RlY2ltYWwocmVnaXN0ZXJFeHBpcmVzKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcihyZWdpc3RlckV4cGlyZXMpO1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlZ2lzdHJhclNlcnZlcjogZnVuY3Rpb24ocmVnaXN0cmFyU2VydmVyKSB7XG4gICAgICB2YXIgcGFyc2VkO1xuXG4gICAgICBpZih0eXBlb2YgcmVnaXN0cmFyU2VydmVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghL15zaXA6L2kudGVzdChyZWdpc3RyYXJTZXJ2ZXIpKSB7XG4gICAgICAgIHJlZ2lzdHJhclNlcnZlciA9IFNJUC5DLlNJUCArICc6JyArIHJlZ2lzdHJhclNlcnZlcjtcbiAgICAgIH1cbiAgICAgIHBhcnNlZCA9IFNJUC5VUkkucGFyc2UocmVnaXN0cmFyU2VydmVyKTtcblxuICAgICAgaWYoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYocGFyc2VkLnVzZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3R1blNlcnZlcnM6IGZ1bmN0aW9uKHN0dW5TZXJ2ZXJzKSB7XG4gICAgICB2YXIgaWR4LCBsZW5ndGgsIHN0dW5fc2VydmVyO1xuXG4gICAgICBpZiAodHlwZW9mIHN0dW5TZXJ2ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICBzdHVuU2VydmVycyA9IFtzdHVuU2VydmVyc107XG4gICAgICB9IGVsc2UgaWYgKCEoc3R1blNlcnZlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSBzdHVuU2VydmVycy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgc3R1bl9zZXJ2ZXIgPSBzdHVuU2VydmVyc1tpZHhdO1xuICAgICAgICBpZiAoISgvXnN0dW5zPzovLnRlc3Qoc3R1bl9zZXJ2ZXIpKSkge1xuICAgICAgICAgIHN0dW5fc2VydmVyID0gJ3N0dW46JyArIHN0dW5fc2VydmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU0lQLkdyYW1tYXIucGFyc2Uoc3R1bl9zZXJ2ZXIsICdzdHVuX1VSSScpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHVuU2VydmVyc1tpZHhdID0gc3R1bl9zZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHVuU2VydmVycztcbiAgICB9LFxuXG4gICAgdHJhY2VTaXA6IGZ1bmN0aW9uKHRyYWNlU2lwKSB7XG4gICAgICBpZiAodHlwZW9mIHRyYWNlU2lwID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlU2lwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0dXJuU2VydmVyczogZnVuY3Rpb24odHVyblNlcnZlcnMpIHtcbiAgICAgIHZhciBpZHgsIGpkeCwgbGVuZ3RoLCB0dXJuX3NlcnZlciwgbnVtX3R1cm5fc2VydmVyX3VybHMsIHVybDtcblxuICAgICAgaWYgKHR1cm5TZXJ2ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHVyblNlcnZlcnMgPSBbdHVyblNlcnZlcnNdO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSB0dXJuU2VydmVycy5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdHVybl9zZXJ2ZXIgPSB0dXJuU2VydmVyc1tpZHhdO1xuICAgICAgICAvL0JhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBBbGxvdyBkZWZpbmluZyB0aGUgdHVybl9zZXJ2ZXIgdXJsIHdpdGggdGhlICdzZXJ2ZXInIHByb3BlcnR5LlxuICAgICAgICBpZiAodHVybl9zZXJ2ZXIuc2VydmVyKSB7XG4gICAgICAgICAgdHVybl9zZXJ2ZXIudXJscyA9IFt0dXJuX3NlcnZlci5zZXJ2ZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dXJuX3NlcnZlci51cmxzIHx8ICF0dXJuX3NlcnZlci51c2VybmFtZSB8fCAhdHVybl9zZXJ2ZXIucGFzc3dvcmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHVybl9zZXJ2ZXIudXJscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgbnVtX3R1cm5fc2VydmVyX3VybHMgPSB0dXJuX3NlcnZlci51cmxzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0dXJuX3NlcnZlci51cmxzID0gW3R1cm5fc2VydmVyLnVybHNdO1xuICAgICAgICAgIG51bV90dXJuX3NlcnZlcl91cmxzID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoamR4ID0gMDsgamR4IDwgbnVtX3R1cm5fc2VydmVyX3VybHM7IGpkeCsrKSB7XG4gICAgICAgICAgdXJsID0gdHVybl9zZXJ2ZXIudXJsc1tqZHhdO1xuXG4gICAgICAgICAgaWYgKCEoL150dXJucz86Ly50ZXN0KHVybCkpKSB7XG4gICAgICAgICAgICB1cmwgPSAndHVybjonICsgdXJsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKFNJUC5HcmFtbWFyLnBhcnNlKHVybCwgJ3R1cm5fVVJJJykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHVyblNlcnZlcnM7XG4gICAgfSxcblxuICAgIHVzZXJBZ2VudFN0cmluZzogZnVuY3Rpb24odXNlckFnZW50U3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHVzZXJBZ2VudFN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJBZ2VudFN0cmluZztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXNlUHJlbG9hZGVkUm91dGU6IGZ1bmN0aW9uKHVzZVByZWxvYWRlZFJvdXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHVzZVByZWxvYWRlZFJvdXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHVzZVByZWxvYWRlZFJvdXRlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB3c1NlcnZlck1heFJlY29ubmVjdGlvbjogZnVuY3Rpb24od3NTZXJ2ZXJNYXhSZWNvbm5lY3Rpb24pIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKHdzU2VydmVyTWF4UmVjb25uZWN0aW9uKSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcih3c1NlcnZlck1heFJlY29ubmVjdGlvbik7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgd3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0OiBmdW5jdGlvbih3c1NlcnZlclJlY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChTSVAuVXRpbHMuaXNEZWNpbWFsKHdzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCkpIHtcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIod3NTZXJ2ZXJSZWNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdXRvc3RhcnQ6IGZ1bmN0aW9uKGF1dG9zdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBhdXRvc3RhcnQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gYXV0b3N0YXJ0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtZWRpYUhhbmRsZXJGYWN0b3J5OiBmdW5jdGlvbihtZWRpYUhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICBpZiAobWVkaWFIYW5kbGVyRmFjdG9yeSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBwcm9taXNpZmllZEZhY3RvcnkgPSBmdW5jdGlvbiBwcm9taXNpZmllZEZhY3RvcnkgKCkge1xuICAgICAgICAgIHZhciBtZWRpYUhhbmRsZXIgPSBtZWRpYUhhbmRsZXJGYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXRjaE1ldGhvZCAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG1lZGlhSGFuZGxlclttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmIChtZXRob2QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzRmlyc3QgPSBtZXRob2ROYW1lID09PSAnZ2V0RGVzY3JpcHRpb24nO1xuICAgICAgICAgICAgICBtZWRpYUhhbmRsZXJbbWV0aG9kTmFtZV0gPSBTSVAuVXRpbHMucHJvbWlzaWZ5KG1lZGlhSGFuZGxlciwgbWV0aG9kTmFtZSwgY2FsbGJhY2tzRmlyc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGNoTWV0aG9kKCdnZXREZXNjcmlwdGlvbicpO1xuICAgICAgICAgIHBhdGNoTWV0aG9kKCdzZXREZXNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgcmV0dXJuIG1lZGlhSGFuZGxlcjtcbiAgICAgICAgfTtcblxuICAgICAgICBwcm9taXNpZmllZEZhY3RvcnkuaXNTdXBwb3J0ZWQgPSBtZWRpYUhhbmRsZXJGYWN0b3J5LmlzU3VwcG9ydGVkO1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZpZWRGYWN0b3J5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdXRoZW50aWNhdGlvbkZhY3Rvcnk6IGNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5XG4gIH1cbn07XG5cblVBLkMgPSBDO1xuU0lQLlVBID0gVUE7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9VQS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSGFja3MgLSBUaGlzIGZpbGUgY29udGFpbnMgYWxsIG9mIHRoZSB0aGluZ3Mgd2VcbiAqIHdpc2ggd2UgZGlkbid0IGhhdmUgdG8gZG8sIGp1c3QgZm9yIGludGVyb3AuICBJdCBpcyBzaW1pbGFyIHRvXG4gKiBVdGlscywgd2hpY2ggcHJvdmlkZXMgYWN0dWFsbHkgdXNlZnVsIGFuZCByZWxldmFudCBmdW5jdGlvbnMgZm9yXG4gKiBhIFNJUCBsaWJyYXJ5LiBNZXRob2RzIGluIHRoaXMgZmlsZSBhcmUgZ3JvdXBlZCBieSB2ZW5kb3IsIHNvXG4gKiBhcyB0byBtb3N0IGVhc2lseSB0cmFjayB3aGVuIHBhcnRpY3VsYXIgaGFja3MgbWF5IG5vdCBiZSBuZWNlc3NhcnkgYW55bW9yZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxuLy9rZWVwIHRvIHF1aWV0IGpzaGludCwgYW5kIHJlbWFpbiBjb25zaXN0ZW50IHdpdGggb3RoZXIgZmlsZXNcblNJUCA9IFNJUDtcblxudmFyIEhhY2tzID0ge1xuICBBbGxCcm93c2Vyczoge1xuICAgIG1hc2tEdGxzOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgICBtZXNzYWdlLmJvZHkgPSBtZXNzYWdlLmJvZHkucmVwbGFjZSgvIFVEUFxcL1RMU1xcL1JUUFxcL1NBVlAvZ21pLCBcIiBSVFAvU0FWUFwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVubWFza0R0bHM6IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgIC8qKlxuICAgICAgICogQ2hyb21lIGRvZXMgbm90IGhhbmRsZSBEVExTIGNvcnJlY3RseSAoQ2FuYXJheSBkb2VzLCBidXQgbm90IHByb2R1Y3Rpb24pXG4gICAgICAgKiBrZWVwaW5nIENocm9tZSBhcyBTREVTIHVudGlsIERUTFMgaXMgZml4ZWQgKGNvbW1lbnQgb3V0ICdpc19vcGVyYScgY29uZGl0aW9uKVxuICAgICAgICpcbiAgICAgICAqIFVQREFURTogTWF5IDIxLCAyMDE0XG4gICAgICAgKiBDaHJvbWUgMzUgbm93IHByb3Blcmx5IGRlZmF1bHRzIHRvIERUTFMuICBPbmx5IE9wZXJhIHJlbWFpbnMgdXNpbmcgU0RFU1xuICAgICAgICpcbiAgICAgICAqIFVQREFURTogMjAxNC0wOS0yNFxuICAgICAgICogT3BlcmEgbm93IHN1cHBvcnRzIERUTFMgYnkgZGVmYXVsdCBhcyB3ZWxsLlxuICAgICAgICpcbiAgICAgICAqKi9cbiAgICAgIHJldHVybiBzZHAucmVwbGFjZSgvIFJUUFxcL1NBVlAvZ21pLCBcIiBVRFAvVExTL1JUUC9TQVZQXCIpO1xuICAgIH1cbiAgfSxcbiAgRmlyZWZveDoge1xuICAgIC8qIENvbmRpdGlvbiB0byBkZXRlY3QgaWYgaGFja3MgYXJlIGFwcGxpY2FibGUgKi9cbiAgICBpc0ZpcmVmb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbW96UlRDUGVlckNvbm5lY3Rpb24gIT09ICd1bmRlZmluZWQnO1xuICAgIH0sXG5cbiAgICBjYW5ub3RIYW5kbGVFeHRyYVdoaXRlc3BhY2U6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAodGhpcy5pc0ZpcmVmb3goKSAmJiBtZXNzYWdlLmJvZHkpIHtcbiAgICAgICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5LnJlcGxhY2UoLyBcXHJcXG4vZywgXCJcXHJcXG5cIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhc01pc3NpbmdDTGluZUluU0RQOiBmdW5jdGlvbiAoc2RwKSB7XG4gICAgICAvKlxuICAgICAgICogVGhpcyBpcyBhIEZpcmVmb3ggaGFjayB0byBpbnNlcnQgdmFsaWQgc2RwIHdoZW4gZ2V0RGVzY3JpcHRpb24gaXNcbiAgICAgICAqIGNhbGxlZCB3aXRoIHRoZSBjb25zdHJhaW50IG9mZmVyVG9SZWNlaXZlVmlkZW8gPSBmYWxzZS5cbiAgICAgICAqIFdlIHNlYXJjaCBmb3IgZWl0aGVyIGEgYy1saW5lIGF0IHRoZSB0b3Agb2YgdGhlIHNkcCBhYm92ZSBhbGxcbiAgICAgICAqIG0tbGluZXMuIElmIHRoYXQgZG9lcyBub3QgZXhpc3QgdGhlbiB3ZSBzZWFyY2ggZm9yIGEgYy1saW5lXG4gICAgICAgKiBiZW5lYXRoIGVhY2ggbS1saW5lLiBJZiBpdCBpcyBtaXNzaW5nIGEgYy1saW5lLCB3ZSBpbnNlcnRcbiAgICAgICAqIGEgZmFrZSBjLWxpbmUgd2l0aCB0aGUgaXAgYWRkcmVzcyAwLjAuMC4wLiBUaGlzIGlzIHRoZW4gdmFsaWRcbiAgICAgICAqIHNkcCBhbmQgbm8gbWVkaWEgd2lsbCBiZSBzZW50IGZvciB0aGF0IG0tbGluZS5cbiAgICAgICAqXG4gICAgICAgKiBWYWxpZCBTRFAgaXM6XG4gICAgICAgKiBtPVxuICAgICAgICogaT1cbiAgICAgICAqIGM9XG4gICAgICAgKi9cbiAgICAgIHZhciBpbnNlcnRBdCwgbWxpbmVzO1xuICAgICAgaWYgKHNkcC5pbmRleE9mKCdjPScpID4gc2RwLmluZGV4T2YoJ209JykpIHtcblxuICAgICAgICAvLyBGaW5kIGFsbCBtPSBsaW5lc1xuICAgICAgICBtbGluZXMgPSBzZHAubWF0Y2goL209LipcXHJcXG4uKi9nKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG1saW5lcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgLy8gSWYgaXQgaGFzIGFuIGk9IGxpbmUsIGNoZWNrIGlmIHRoZSBuZXh0IGxpbmUgaXMgdGhlIGM9IGxpbmVcbiAgICAgICAgICBpZiAobWxpbmVzW2ldLnRvU3RyaW5nKCkuc2VhcmNoKC9pPS4qLykgPj0gMCkge1xuICAgICAgICAgICAgaW5zZXJ0QXQgPSBzZHAuaW5kZXhPZihtbGluZXNbaV0udG9TdHJpbmcoKSkrbWxpbmVzW2ldLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNkcC5zdWJzdHIoaW5zZXJ0QXQsMikhPT0nYz0nKSB7XG4gICAgICAgICAgICAgIHNkcCA9IHNkcC5zdWJzdHIoMCxpbnNlcnRBdCkgKyAnXFxyXFxuYz1JTiBJUDQgMC4wLjAuMCcgKyBzZHAuc3Vic3RyKGluc2VydEF0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGVsc2UgYWRkIHRoZSBDIGxpbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgICAgfSBlbHNlIGlmIChtbGluZXNbaV0udG9TdHJpbmcoKS5zZWFyY2goL2M9LiovKSA8IDApIHtcbiAgICAgICAgICAgIGluc2VydEF0ID0gc2RwLmluZGV4T2YobWxpbmVzW2ldLnRvU3RyaW5nKCkubWF0Y2goLy4qLykpK21saW5lc1tpXS50b1N0cmluZygpLm1hdGNoKC8uKi8pLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgc2RwID0gc2RwLnN1YnN0cigwLGluc2VydEF0KSArICdcXHJcXG5jPUlOIElQNCAwLjAuMC4wJyArIHNkcC5zdWJzdHIoaW5zZXJ0QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9LFxuICB9LFxuXG4gIENocm9tZToge1xuICAgIG5lZWRzRXhwbGljaXRseUluYWN0aXZlU0RQOiBmdW5jdGlvbiAoc2RwKSB7XG4gICAgICB2YXIgc3ViLCBpbmRleDtcblxuICAgICAgaWYgKEhhY2tzLkZpcmVmb3guaXNGaXJlZm94KCkpIHsgLy8gRml4IHRoaXMgaW4gRmlyZWZveCBiZWZvcmUgc2VuZGluZ1xuICAgICAgICBpbmRleCA9IHNkcC5pbmRleE9mKCdtPXZpZGVvIDAnKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHN1YiA9IHNkcC5zdWJzdHIoaW5kZXgpO1xuICAgICAgICAgIHN1YiA9IHN1Yi5yZXBsYWNlKC9cXHJcXG5jPUlOIElQNC4qXFxyXFxuJC8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcclxcbmM9SU4gSVA0IDAuMC4wLjBcXHJcXG5hPWluYWN0aXZlXFxyXFxuJyk7XG4gICAgICAgICAgcmV0dXJuIHNkcC5zdWJzdHIoMCwgaW5kZXgpICsgc3ViO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH0sXG5cbiAgICBnZXRzQ29uZnVzZWRBYm91dEdVTTogZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgIGlmIChzZXNzaW9uLm1lZGlhSGFuZGxlcikge1xuICAgICAgICBzZXNzaW9uLm1lZGlhSGFuZGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnJldHVybiBIYWNrcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9IYWNrcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW5jb21pbmcgU0lQIE1lc3NhZ2UgU2FuaXR5IENoZWNrXG4gKi9cblxuLyoqXG4gKiBTSVAgbWVzc2FnZSBzYW5pdHkgY2hlY2suXG4gKiBAYXVnbWVudHMgU0lQXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U0lQLkluY29taW5nTWVzc2FnZX0gbWVzc2FnZVxuICogQHBhcmFtIHtTSVAuVUF9IHVhXG4gKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCkge1xudmFyIHNhbml0eUNoZWNrLFxuIGxvZ2dlcixcbiBtZXNzYWdlLCB1YSwgdHJhbnNwb3J0LFxuIHJlcXVlc3RzID0gW10sXG4gcmVzcG9uc2VzID0gW10sXG4gYWxsID0gW107XG5cbi8vIFJlcGx5XG5mdW5jdGlvbiByZXBseShzdGF0dXNfY29kZSkge1xuICB2YXIgdG8sXG4gICAgcmVzcG9uc2UgPSBTSVAuVXRpbHMuYnVpbGRTdGF0dXNMaW5lKHN0YXR1c19jb2RlKSxcbiAgICB2aWFzID0gbWVzc2FnZS5nZXRIZWFkZXJzKCd2aWEnKSxcbiAgICBsZW5ndGggPSB2aWFzLmxlbmd0aCxcbiAgICBpZHggPSAwO1xuXG4gIGZvcihpZHg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICByZXNwb25zZSArPSBcIlZpYTogXCIgKyB2aWFzW2lkeF0gKyBcIlxcclxcblwiO1xuICB9XG5cbiAgdG8gPSBtZXNzYWdlLmdldEhlYWRlcignVG8nKTtcblxuICBpZighbWVzc2FnZS50b190YWcpIHtcbiAgICB0byArPSAnO3RhZz0nICsgU0lQLlV0aWxzLm5ld1RhZygpO1xuICB9XG5cbiAgcmVzcG9uc2UgKz0gXCJUbzogXCIgKyB0byArIFwiXFxyXFxuXCI7XG4gIHJlc3BvbnNlICs9IFwiRnJvbTogXCIgKyBtZXNzYWdlLmdldEhlYWRlcignRnJvbScpICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJDYWxsLUlEOiBcIiArIG1lc3NhZ2UuY2FsbF9pZCArIFwiXFxyXFxuXCI7XG4gIHJlc3BvbnNlICs9IFwiQ1NlcTogXCIgKyBtZXNzYWdlLmNzZXEgKyBcIiBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCJcXHJcXG5cIjtcbiAgcmVzcG9uc2UgKz0gXCJcXHJcXG5cIjtcblxuICB0cmFuc3BvcnQuc2VuZChyZXNwb25zZSk7XG59XG5cbi8qXG4gKiBTYW5pdHkgQ2hlY2sgZm9yIGluY29taW5nIE1lc3NhZ2VzXG4gKlxuICogUmVxdWVzdHM6XG4gKiAgLSBfcmZjMzI2MV84XzJfMl8xXyBSZWNlaXZlIGEgUmVxdWVzdCB3aXRoIGEgbm9uIHN1cHBvcnRlZCBVUkkgc2NoZW1lXG4gKiAgLSBfcmZjMzI2MV8xNl8zXzRfIFJlY2VpdmUgYSBSZXF1ZXN0IGFscmVhZHkgc2VudCBieSB1c1xuICogICBEb2VzIG5vdCBsb29rIGF0IHZpYSBzZW50LWJ5IGJ1dCBhdCBzaXBqc0lkLCB3aGljaCBpcyBpbnNlcnRlZCBhc1xuICogICBhIHByZWZpeCBpbiBhbGwgaW5pdGlhbCByZXF1ZXN0cyBnZW5lcmF0ZWQgYnkgdGhlIHVhXG4gKiAgLSBfcmZjMzI2MV8xOF8zX3JlcXVlc3RfIEJvZHkgQ29udGVudC1MZW5ndGhcbiAqICAtIF9yZmMzMjYxXzhfMl8yXzJfIE1lcmdlZCBSZXF1ZXN0c1xuICpcbiAqIFJlc3BvbnNlczpcbiAqICAtIF9yZmMzMjYxXzhfMV8zXzNfIE11bHRpcGxlIFZpYSBoZWFkZXJzXG4gKiAgLSBfcmZjMzI2MV8xOF8xXzJfIHNlbnQtYnkgbWlzbWF0Y2hcbiAqICAtIF9yZmMzMjYxXzE4XzNfcmVzcG9uc2VfIEJvZHkgQ29udGVudC1MZW5ndGhcbiAqXG4gKiBBbGw6XG4gKiAgLSBNaW5pbXVtIGhlYWRlcnMgaW4gYSBTSVAgbWVzc2FnZVxuICovXG5cbi8vIFNhbml0eSBDaGVjayBmdW5jdGlvbnMgZm9yIHJlcXVlc3RzXG5mdW5jdGlvbiByZmMzMjYxXzhfMl8yXzEoKSB7XG4gIGlmKCFtZXNzYWdlLnJ1cmkgfHwgbWVzc2FnZS5ydXJpLnNjaGVtZSAhPT0gJ3NpcCcpIHtcbiAgICByZXBseSg0MTYpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE2XzNfNCgpIHtcbiAgaWYoIW1lc3NhZ2UudG9fdGFnKSB7XG4gICAgaWYobWVzc2FnZS5jYWxsX2lkLnN1YnN0cigwLCA1KSA9PT0gdWEuY29uZmlndXJhdGlvbi5zaXBqc0lkKSB7XG4gICAgICByZXBseSg0ODIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE4XzNfcmVxdWVzdCgpIHtcbiAgdmFyIGxlbiA9IFNJUC5VdGlscy5zdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KSxcbiAgY29udGVudExlbmd0aCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcpO1xuXG4gIGlmKGxlbiA8IGNvbnRlbnRMZW5ndGgpIHtcbiAgICByZXBseSg0MDApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzhfMl8yXzIoKSB7XG4gIHZhciB0ciwgaWR4LFxuICAgIGZyb21UYWcgPSBtZXNzYWdlLmZyb21fdGFnLFxuICAgIGNhbGxfaWQgPSBtZXNzYWdlLmNhbGxfaWQsXG4gICAgY3NlcSA9IG1lc3NhZ2UuY3NlcTtcblxuICBpZighbWVzc2FnZS50b190YWcpIHtcbiAgICBpZihtZXNzYWdlLm1ldGhvZCA9PT0gU0lQLkMuSU5WSVRFKSB7XG4gICAgICB0ciA9IHVhLnRyYW5zYWN0aW9ucy5pc3RbbWVzc2FnZS52aWFfYnJhbmNoXTtcbiAgICAgIGlmKHRyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihpZHggaW4gdWEudHJhbnNhY3Rpb25zLmlzdCkge1xuICAgICAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLmlzdFtpZHhdO1xuICAgICAgICAgIGlmKHRyLnJlcXVlc3QuZnJvbV90YWcgPT09IGZyb21UYWcgJiYgdHIucmVxdWVzdC5jYWxsX2lkID09PSBjYWxsX2lkICYmIHRyLnJlcXVlc3QuY3NlcSA9PT0gY3NlcSkge1xuICAgICAgICAgICAgcmVwbHkoNDgyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHIgPSB1YS50cmFuc2FjdGlvbnMubmlzdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgaWYodHIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGlkeCBpbiB1YS50cmFuc2FjdGlvbnMubmlzdCkge1xuICAgICAgICAgIHRyID0gdWEudHJhbnNhY3Rpb25zLm5pc3RbaWR4XTtcbiAgICAgICAgICBpZih0ci5yZXF1ZXN0LmZyb21fdGFnID09PSBmcm9tVGFnICYmIHRyLnJlcXVlc3QuY2FsbF9pZCA9PT0gY2FsbF9pZCAmJiB0ci5yZXF1ZXN0LmNzZXEgPT09IGNzZXEpIHtcbiAgICAgICAgICAgIHJlcGx5KDQ4Mik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFNhbml0eSBDaGVjayBmdW5jdGlvbnMgZm9yIHJlc3BvbnNlc1xuZnVuY3Rpb24gcmZjMzI2MV84XzFfM18zKCkge1xuICBpZihtZXNzYWdlLmdldEhlYWRlcnMoJ3ZpYScpLmxlbmd0aCA+IDEpIHtcbiAgICBsb2dnZXIud2FybignTW9yZSB0aGFuIG9uZSBWaWEgaGVhZGVyIGZpZWxkIHByZXNlbnQgaW4gdGhlIHJlc3BvbnNlLiBEcm9wcGluZyB0aGUgcmVzcG9uc2UnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmZjMzI2MV8xOF8xXzIoKSB7XG4gIHZhciB2aWFIb3N0ID0gdWEuY29uZmlndXJhdGlvbi52aWFIb3N0O1xuICBpZihtZXNzYWdlLnZpYS5ob3N0ICE9PSB2aWFIb3N0IHx8IG1lc3NhZ2UudmlhLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGxvZ2dlci53YXJuKCdWaWEgc2VudC1ieSBpbiB0aGUgcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggVUEgVmlhIGhvc3QgdmFsdWUuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZmMzMjYxXzE4XzNfcmVzcG9uc2UoKSB7XG4gIHZhclxuICAgIGxlbiA9IFNJUC5VdGlscy5zdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KSxcbiAgICBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cbiAgICBpZihsZW4gPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybignTWVzc2FnZSBib2R5IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSB2YWx1ZSBpbiBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gU2FuaXR5IENoZWNrIGZ1bmN0aW9ucyBmb3IgcmVxdWVzdHMgYW5kIHJlc3BvbnNlc1xuZnVuY3Rpb24gbWluaW11bUhlYWRlcnMoKSB7XG4gIHZhclxuICAgIG1hbmRhdG9yeUhlYWRlcnMgPSBbJ2Zyb20nLCAndG8nLCAnY2FsbF9pZCcsICdjc2VxJywgJ3ZpYSddLFxuICAgIGlkeCA9IG1hbmRhdG9yeUhlYWRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlKGlkeC0tKSB7XG4gICAgaWYoIW1lc3NhZ2UuaGFzSGVhZGVyKG1hbmRhdG9yeUhlYWRlcnNbaWR4XSkpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdNaXNzaW5nIG1hbmRhdG9yeSBoZWFkZXIgZmllbGQgOiAnKyBtYW5kYXRvcnlIZWFkZXJzW2lkeF0gKycuIERyb3BwaW5nIHRoZSByZXNwb25zZScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfOF8yXzJfMSk7XG5yZXF1ZXN0cy5wdXNoKHJmYzMyNjFfMTZfM180KTtcbnJlcXVlc3RzLnB1c2gocmZjMzI2MV8xOF8zX3JlcXVlc3QpO1xucmVxdWVzdHMucHVzaChyZmMzMjYxXzhfMl8yXzIpO1xuXG5yZXNwb25zZXMucHVzaChyZmMzMjYxXzhfMV8zXzMpO1xucmVzcG9uc2VzLnB1c2gocmZjMzI2MV8xOF8xXzIpO1xucmVzcG9uc2VzLnB1c2gocmZjMzI2MV8xOF8zX3Jlc3BvbnNlKTtcblxuYWxsLnB1c2gobWluaW11bUhlYWRlcnMpO1xuXG5zYW5pdHlDaGVjayA9IGZ1bmN0aW9uKG0sIHUsIHQpIHtcbiAgdmFyIGxlbiwgcGFzcztcblxuICBtZXNzYWdlID0gbTtcbiAgdWEgPSB1O1xuICB0cmFuc3BvcnQgPSB0O1xuXG4gIGxvZ2dlciA9IHVhLmdldExvZ2dlcignc2lwLnNhbml0eWNoZWNrJyk7XG5cbiAgbGVuID0gYWxsLmxlbmd0aDtcbiAgd2hpbGUobGVuLS0pIHtcbiAgICBwYXNzID0gYWxsW2xlbl0obWVzc2FnZSk7XG4gICAgaWYocGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVxdWVzdCkge1xuICAgIGxlbiA9IHJlcXVlc3RzLmxlbmd0aDtcbiAgICB3aGlsZShsZW4tLSkge1xuICAgICAgcGFzcyA9IHJlcXVlc3RzW2xlbl0obWVzc2FnZSk7XG4gICAgICBpZihwYXNzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVzcG9uc2UpIHtcbiAgICBsZW4gPSByZXNwb25zZXMubGVuZ3RoO1xuICAgIHdoaWxlKGxlbi0tKSB7XG4gICAgICBwYXNzID0gcmVzcG9uc2VzW2xlbl0obWVzc2FnZSk7XG4gICAgICBpZihwYXNzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9FdmVyeXRoaW5nIGlzIE9LXG4gIHJldHVybiB0cnVlO1xufTtcblxuU0lQLnNhbml0eUNoZWNrID0gc2FuaXR5Q2hlY2s7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9TYW5pdHlDaGVjay5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTSVAgRGlnZXN0IEF1dGhlbnRpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBTSVAgRGlnZXN0IEF1dGhlbnRpY2F0aW9uLlxuICogQGF1Z21lbnRzIFNJUC5cbiAqIEBmdW5jdGlvbiBEaWdlc3QgQXV0aGVudGljYXRpb25cbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChVdGlscykge1xudmFyIERpZ2VzdEF1dGhlbnRpY2F0aW9uO1xuXG5EaWdlc3RBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uKHVhKSB7XG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXBqcy5kaWdlc3RhdXRoZW50aWNhdGlvbicpO1xuICB0aGlzLnVzZXJuYW1lID0gdWEuY29uZmlndXJhdGlvbi5hdXRob3JpemF0aW9uVXNlcjtcbiAgdGhpcy5wYXNzd29yZCA9IHVhLmNvbmZpZ3VyYXRpb24ucGFzc3dvcmQ7XG4gIHRoaXMuY25vbmNlID0gbnVsbDtcbiAgdGhpcy5uYyA9IDA7XG4gIHRoaXMubmNIZXggPSAnMDAwMDAwMDAnO1xuICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbn07XG5cblxuLyoqXG4qIFBlcmZvcm1zIERpZ2VzdCBhdXRoZW50aWNhdGlvbiBnaXZlbiBhIFNJUCByZXF1ZXN0IGFuZCB0aGUgY2hhbGxlbmdlXG4qIHJlY2VpdmVkIGluIGEgcmVzcG9uc2UgdG8gdGhhdCByZXF1ZXN0LlxuKiBSZXR1cm5zIHRydWUgaWYgY3JlZGVudGlhbHMgd2VyZSBzdWNjZXNzZnVsbHkgZ2VuZXJhdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4qXG4qIEBwYXJhbSB7U0lQLk91dGdvaW5nUmVxdWVzdH0gcmVxdWVzdFxuKiBAcGFyYW0ge09iamVjdH0gY2hhbGxlbmdlXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIGNoYWxsZW5nZSkge1xuICAvLyBJbnNwZWN0IGFuZCB2YWxpZGF0ZSB0aGUgY2hhbGxlbmdlLlxuXG4gIHRoaXMuYWxnb3JpdGhtID0gY2hhbGxlbmdlLmFsZ29yaXRobTtcbiAgdGhpcy5yZWFsbSA9IGNoYWxsZW5nZS5yZWFsbTtcbiAgdGhpcy5ub25jZSA9IGNoYWxsZW5nZS5ub25jZTtcbiAgdGhpcy5vcGFxdWUgPSBjaGFsbGVuZ2Uub3BhcXVlO1xuICB0aGlzLnN0YWxlID0gY2hhbGxlbmdlLnN0YWxlO1xuXG4gIGlmICh0aGlzLmFsZ29yaXRobSkge1xuICAgIGlmICh0aGlzLmFsZ29yaXRobSAhPT0gJ01ENScpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRoIERpZ2VzdCBhbGdvcml0aG0gZGlmZmVyZW50IHRoYW4gXCJNRDVcIiwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFsZ29yaXRobSA9ICdNRDUnO1xuICB9XG5cbiAgaWYgKCEgdGhpcy5yZWFsbSkge1xuICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCByZWFsbSwgYXV0aGVudGljYXRpb24gYWJvcnRlZCcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghIHRoaXMubm9uY2UpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3Qgbm9uY2UsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWQnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyAncW9wJyBjYW4gY29udGFpbiBhIGxpc3Qgb2YgdmFsdWVzIChBcnJheSkuIExldCdzIGNob29zZSBqdXN0IG9uZS5cbiAgaWYgKGNoYWxsZW5nZS5xb3ApIHtcbiAgICBpZiAoY2hhbGxlbmdlLnFvcC5pbmRleE9mKCdhdXRoJykgPiAtMSkge1xuICAgICAgdGhpcy5xb3AgPSAnYXV0aCc7XG4gICAgfSBlbHNlIGlmIChjaGFsbGVuZ2UucW9wLmluZGV4T2YoJ2F1dGgtaW50JykgPiAtMSkge1xuICAgICAgdGhpcy5xb3AgPSAnYXV0aC1pbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgJ3FvcCcgaXMgcHJlc2VudCBidXQgZG9lcyBub3QgY29udGFpbiAnYXV0aCcgb3IgJ2F1dGgtaW50Jywgc28gYWJvcnQgaGVyZS5cbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2NoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCBxb3AgZGlmZmVyZW50IHRoYW4gXCJhdXRoXCIgb3IgXCJhdXRoLWludFwiLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMucW9wID0gbnVsbDtcbiAgfVxuXG4gIC8vIEZpbGwgb3RoZXIgYXR0cmlidXRlcy5cblxuICB0aGlzLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICB0aGlzLnVyaSA9IHJlcXVlc3QucnVyaTtcbiAgdGhpcy5jbm9uY2UgPSBVdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxMik7XG4gIHRoaXMubmMgKz0gMTtcbiAgdGhpcy51cGRhdGVOY0hleCgpO1xuXG4gIC8vIG5jLXZhbHVlID0gOExIRVguIE1heCB2YWx1ZSA9ICdGRkZGRkZGRicuXG4gIGlmICh0aGlzLm5jID09PSA0Mjk0OTY3Mjk2KSB7XG4gICAgdGhpcy5uYyA9IDE7XG4gICAgdGhpcy5uY0hleCA9ICcwMDAwMDAwMSc7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlIERpZ2VzdCBcInJlc3BvbnNlXCIgdmFsdWUuXG4gIHRoaXMuY2FsY3VsYXRlUmVzcG9uc2UoKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4qIEdlbmVyYXRlIERpZ2VzdCAncmVzcG9uc2UnIHZhbHVlLlxuKiBAcHJpdmF0ZVxuKi9cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVSZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGExLCBoYTI7XG5cbiAgLy8gSEExID0gTUQ1KEExKSA9IE1ENSh1c2VybmFtZTpyZWFsbTpwYXNzd29yZClcbiAgaGExID0gVXRpbHMuY2FsY3VsYXRlTUQ1KHRoaXMudXNlcm5hbWUgKyBcIjpcIiArIHRoaXMucmVhbG0gKyBcIjpcIiArIHRoaXMucGFzc3dvcmQpO1xuXG4gIGlmICh0aGlzLnFvcCA9PT0gJ2F1dGgnKSB7XG4gICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJKVxuICAgIGhhMiA9IFV0aWxzLmNhbGN1bGF0ZU1ENSh0aGlzLm1ldGhvZCArIFwiOlwiICsgdGhpcy51cmkpO1xuICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpub25jZUNvdW50OmNyZWRlbnRpYWxzTm9uY2U6cW9wOkhBMilcbiAgICB0aGlzLnJlc3BvbnNlID0gVXRpbHMuY2FsY3VsYXRlTUQ1KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgdGhpcy5uY0hleCArIFwiOlwiICsgdGhpcy5jbm9uY2UgKyBcIjphdXRoOlwiICsgaGEyKTtcblxuICB9IGVsc2UgaWYgKHRoaXMucW9wID09PSAnYXV0aC1pbnQnKSB7XG4gICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJOk1ENShlbnRpdHlCb2R5KSlcbiAgICBoYTIgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpICsgXCI6XCIgKyBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5ib2R5ID8gdGhpcy5ib2R5IDogXCJcIikpO1xuICAgIC8vIHJlc3BvbnNlID0gTUQ1KEhBMTpub25jZTpub25jZUNvdW50OmNyZWRlbnRpYWxzTm9uY2U6cW9wOkhBMilcbiAgICB0aGlzLnJlc3BvbnNlID0gVXRpbHMuY2FsY3VsYXRlTUQ1KGhhMSArIFwiOlwiICsgdGhpcy5ub25jZSArIFwiOlwiICsgdGhpcy5uY0hleCArIFwiOlwiICsgdGhpcy5jbm9uY2UgKyBcIjphdXRoLWludDpcIiArIGhhMik7XG5cbiAgfSBlbHNlIGlmICh0aGlzLnFvcCA9PT0gbnVsbCkge1xuICAgIC8vIEhBMiA9IE1ENShBMikgPSBNRDUobWV0aG9kOmRpZ2VzdFVSSSlcbiAgICBoYTIgPSBVdGlscy5jYWxjdWxhdGVNRDUodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpKTtcbiAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6SEEyKVxuICAgIHRoaXMucmVzcG9uc2UgPSBVdGlscy5jYWxjdWxhdGVNRDUoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyBoYTIpO1xuICB9XG59O1xuXG5cbi8qKlxuKiBSZXR1cm4gdGhlIFByb3h5LUF1dGhvcml6YXRpb24gb3IgV1dXLUF1dGhvcml6YXRpb24gaGVhZGVyIHZhbHVlLlxuKi9cbkRpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aF9wYXJhbXMgPSBbXTtcblxuICBpZiAoISB0aGlzLnJlc3BvbnNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBmaWVsZCBkb2VzIG5vdCBleGlzdCwgY2Fubm90IGdlbmVyYXRlIEF1dGhvcml6YXRpb24gaGVhZGVyJyk7XG4gIH1cblxuICBhdXRoX3BhcmFtcy5wdXNoKCdhbGdvcml0aG09JyArIHRoaXMuYWxnb3JpdGhtKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgndXNlcm5hbWU9XCInICsgdGhpcy51c2VybmFtZSArICdcIicpO1xuICBhdXRoX3BhcmFtcy5wdXNoKCdyZWFsbT1cIicgKyB0aGlzLnJlYWxtICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ25vbmNlPVwiJyArIHRoaXMubm9uY2UgKyAnXCInKTtcbiAgYXV0aF9wYXJhbXMucHVzaCgndXJpPVwiJyArIHRoaXMudXJpICsgJ1wiJyk7XG4gIGF1dGhfcGFyYW1zLnB1c2goJ3Jlc3BvbnNlPVwiJyArIHRoaXMucmVzcG9uc2UgKyAnXCInKTtcbiAgaWYgKHRoaXMub3BhcXVlKSB7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgnb3BhcXVlPVwiJyArIHRoaXMub3BhcXVlICsgJ1wiJyk7XG4gIH1cbiAgaWYgKHRoaXMucW9wKSB7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgncW9wPScgKyB0aGlzLnFvcCk7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgnY25vbmNlPVwiJyArIHRoaXMuY25vbmNlICsgJ1wiJyk7XG4gICAgYXV0aF9wYXJhbXMucHVzaCgnbmM9JyArIHRoaXMubmNIZXgpO1xuICB9XG5cbiAgcmV0dXJuICdEaWdlc3QgJyArIGF1dGhfcGFyYW1zLmpvaW4oJywgJyk7XG59O1xuXG5cbi8qKlxuKiBHZW5lcmF0ZSB0aGUgJ25jJyB2YWx1ZSBhcyByZXF1aXJlZCBieSBEaWdlc3QgaW4gdGhpcy5uY0hleCBieSByZWFkaW5nIHRoaXMubmMuXG4qIEBwcml2YXRlXG4qL1xuRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLnVwZGF0ZU5jSGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoZXggPSBOdW1iZXIodGhpcy5uYykudG9TdHJpbmcoMTYpO1xuICB0aGlzLm5jSGV4ID0gJzAwMDAwMDAwJy5zdWJzdHIoMCwgOC1oZXgubGVuZ3RoKSArIGhleDtcbn07XG5cbnJldHVybiBEaWdlc3RBdXRoZW50aWNhdGlvbjtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0RpZ2VzdEF1dGhlbnRpY2F0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBHcmFtbWFyID0gcmVxdWlyZSgnLi9HcmFtbWFyL2Rpc3QvR3JhbW1hcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTSVApIHtcblxucmV0dXJuIHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlQ3VzdG9tIChpbnB1dCwgc3RhcnRSdWxlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7c3RhcnRSdWxlOiBzdGFydFJ1bGUsIFNJUDogU0lQfTtcbiAgICB0cnkge1xuICAgICAgR3JhbW1hci5wYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmRhdGE7XG4gIH1cbn07XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL0dyYW1tYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuICB9XG5cbiAgcGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICAgIHBlZyRzdGFydFJ1bGVJbmRpY2VzID0geyBDb250YWN0OiAxMTgsIE5hbWVfQWRkcl9IZWFkZXI6IDE1NSwgUmVjb3JkX1JvdXRlOiAxNzUsIFJlcXVlc3RfUmVzcG9uc2U6IDgxLCBTSVBfVVJJOiA0NSwgU3Vic2NyaXB0aW9uX1N0YXRlOiAxODUsIFN1cHBvcnRlZDogMTkwLCBSZXF1aXJlOiAxODEsIFZpYTogMTkzLCBhYnNvbHV0ZVVSSTogODQsIENhbGxfSUQ6IDExNywgQ29udGVudF9EaXNwb3NpdGlvbjogMTI5LCBDb250ZW50X0xlbmd0aDogMTM0LCBDb250ZW50X1R5cGU6IDEzNSwgQ1NlcTogMTQ1LCBkaXNwbGF5TmFtZTogMTIxLCBFdmVudDogMTQ4LCBGcm9tOiAxNTAsIGhvc3Q6IDUyLCBNYXhfRm9yd2FyZHM6IDE1MywgTWluX1NFOiAyMTIsIFByb3h5X0F1dGhlbnRpY2F0ZTogMTU2LCBxdW90ZWRfc3RyaW5nOiA0MCwgUmVmZXJfVG86IDE3NywgUmVwbGFjZXM6IDE3OCwgU2Vzc2lvbl9FeHBpcmVzOiAyMDksIHN0dW5fVVJJOiAyMTYsIFRvOiAxOTEsIHR1cm5fVVJJOiAyMjMsIHV1aWQ6IDIyNiwgV1dXX0F1dGhlbnRpY2F0ZTogMjA4LCBjaGFsbGVuZ2U6IDE1NyB9LFxuICAgICAgICBwZWckc3RhcnRSdWxlSW5kZXggICA9IDExOCxcblxuICAgICAgICBwZWckY29uc3RzID0gW1xuICAgICAgICAgIFwiXFxyXFxuXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxyXFxuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcclxcXFxuXFxcIlwiIH0sXG4gICAgICAgICAgL15bMC05XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTldXCIsIGRlc2NyaXB0aW9uOiBcIlswLTldXCIgfSxcbiAgICAgICAgICAvXlthLXpBLVpdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWl1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWl1cIiB9LFxuICAgICAgICAgIC9eWzAtOWEtZkEtRl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05YS1mQS1GXVwiLCBkZXNjcmlwdGlvbjogXCJbMC05YS1mQS1GXVwiIH0sXG4gICAgICAgICAgL15bXFwwLVxceEZGXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcMC1cXFxceEZGXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXDAtXFxcXHhGRl1cIiB9LFxuICAgICAgICAgIC9eW1wiXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFwiXVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcIl1cIiB9LFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiBcIiwgZGVzY3JpcHRpb246IFwiXFxcIiBcXFwiXCIgfSxcbiAgICAgICAgICBcIlxcdFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcdFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXHRcXFwiXCIgfSxcbiAgICAgICAgICAvXlthLXpBLVowLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWjAtOV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOV1cIiB9LFxuICAgICAgICAgIFwiO1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjtcIiwgZGVzY3JpcHRpb246IFwiXFxcIjtcXFwiXCIgfSxcbiAgICAgICAgICBcIi9cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIvXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIvXFxcIlwiIH0sXG4gICAgICAgICAgXCI/XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiP1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiP1xcXCJcIiB9LFxuICAgICAgICAgIFwiOlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgICAgICBcIkBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJAXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJAXFxcIlwiIH0sXG4gICAgICAgICAgXCImXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiJlxcXCJcIiB9LFxuICAgICAgICAgIFwiPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj1cXFwiXCIgfSxcbiAgICAgICAgICBcIitcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIrXFxcIlwiIH0sXG4gICAgICAgICAgXCIkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiJFxcXCJcIiB9LFxuICAgICAgICAgIFwiLFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIixcIiwgZGVzY3JpcHRpb246IFwiXFxcIixcXFwiXCIgfSxcbiAgICAgICAgICBcIi1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCItXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCItXFxcIlwiIH0sXG4gICAgICAgICAgXCJfXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiX1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiX1xcXCJcIiB9LFxuICAgICAgICAgIFwiLlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgICAgICBcIiFcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIhXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIhXFxcIlwiIH0sXG4gICAgICAgICAgXCJ+XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiflwiLCBkZXNjcmlwdGlvbjogXCJcXFwiflxcXCJcIiB9LFxuICAgICAgICAgIFwiKlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIipcIiwgZGVzY3JpcHRpb246IFwiXFxcIipcXFwiXCIgfSxcbiAgICAgICAgICBcIidcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCInXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCInXFxcIlwiIH0sXG4gICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKFxcXCJcIiB9LFxuICAgICAgICAgIFwiKVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgICAgICBwZWckRkFJTEVELFxuICAgICAgICAgIFwiJVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiVcIiwgZGVzY3JpcHRpb246IFwiXFxcIiVcXFwiXCIgfSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIiBcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gJzonOyB9LFxuICAgICAgICAgIC9eWyEtfl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIS1+XVwiLCBkZXNjcmlwdGlvbjogXCJbIS1+XVwiIH0sXG4gICAgICAgICAgL15bXFx4ODAtXFx1RkZGRl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXHg4MC1cXFxcdUZGRkZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDgwLVxcXFx1RkZGRl1cIiB9LFxuICAgICAgICAgIC9eW1xceDgwLVxceEJGXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDgwLVxcXFx4QkZdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDgwLVxcXFx4QkZdXCIgfSxcbiAgICAgICAgICAvXlthLWZdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtZl1cIiwgZGVzY3JpcHRpb246IFwiW2EtZl1cIiB9LFxuICAgICAgICAgIFwiYFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImBcIiwgZGVzY3JpcHRpb246IFwiXFxcImBcXFwiXCIgfSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI8XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI8XFxcIlwiIH0sXG4gICAgICAgICAgXCI+XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPlxcXCJcIiB9LFxuICAgICAgICAgIFwiXFxcXFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFxcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcXFxcIlwiIH0sXG4gICAgICAgICAgXCJbXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiW1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiW1xcXCJcIiB9LFxuICAgICAgICAgIFwiXVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl1cIiwgZGVzY3JpcHRpb246IFwiXFxcIl1cXFwiXCIgfSxcbiAgICAgICAgICBcIntcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ7XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ7XFxcIlwiIH0sXG4gICAgICAgICAgXCJ9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwifVwiLCBkZXNjcmlwdGlvbjogXCJcXFwifVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIipcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIvXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiPVwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIihcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIpXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiPlwiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIjxcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCIsXCI7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIFwiO1wiOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBcIjpcIjsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gXCJcXFwiXCI7IH0sXG4gICAgICAgICAgL15bIS0nXS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlshLSddXCIsIGRlc2NyaXB0aW9uOiBcIlshLSddXCIgfSxcbiAgICAgICAgICAvXlsqLVtdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyotW11cIiwgZGVzY3JpcHRpb246IFwiWyotW11cIiB9LFxuICAgICAgICAgIC9eW1xcXS1+XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxcXS1+XVwiLCBkZXNjcmlwdGlvbjogXCJbXFxcXF0tfl1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzOyB9LFxuICAgICAgICAgIC9eWyMtW10vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIy1bXVwiLCBkZXNjcmlwdGlvbjogXCJbIy1bXVwiIH0sXG4gICAgICAgICAgL15bXFwwLVxcdF0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXDAtXFxcXHRdXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxcMC1cXFxcdF1cIiB9LFxuICAgICAgICAgIC9eW1xceDBCLVxcZl0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXHgwQi1cXFxcZl1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFx4MEItXFxcXGZdXCIgfSxcbiAgICAgICAgICAvXltcXHgwRS1/XS8sXG4gICAgICAgICAgeyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIltcXFxceDBFLX9dXCIsIGRlc2NyaXB0aW9uOiBcIltcXFxceDBFLX9dXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IG9wdGlvbnMuU0lQLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IG9wdGlvbnMuU0lQLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTSVBfVVJJJykgeyBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEudXJpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInNpcHNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzaXBzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzaXBzXFxcIlwiIH0sXG4gICAgICAgICAgXCJzaXBcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzaXBcIiwgZGVzY3JpcHRpb246IFwiXFxcInNpcFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHVyaV9zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWUgPSB1cmlfc2NoZW1lOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVzZXIgPSBkZWNvZGVVUklDb21wb25lbnQodGV4dCgpLnNsaWNlKDAsIC0xKSk7fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXNzd29yZCA9IHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YS5ob3N0OyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnZG9tYWluJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIC9eW2EtekEtWjAtOV9cXC1dLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2EtekEtWjAtOV9cXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiW2EtekEtWjAtOV9cXFxcLV1cIiB9LFxuICAgICAgICAgIC9eW2EtekEtWjAtOVxcLV0vLFxuICAgICAgICAgIHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05XFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIlthLXpBLVowLTlcXFxcLV1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdJUHY2JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCI6OlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjo6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6OlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2Nic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2NCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCgpOyB9LFxuICAgICAgICAgIFwiMjVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIyNVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMjVcXFwiXCIgfSxcbiAgICAgICAgICAvXlswLTVdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtNV1cIiwgZGVzY3JpcHRpb246IFwiWzAtNV1cIiB9LFxuICAgICAgICAgIFwiMlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjJcIiwgZGVzY3JpcHRpb246IFwiXFxcIjJcXFwiXCIgfSxcbiAgICAgICAgICAvXlswLTRdLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtNF1cIiwgZGVzY3JpcHRpb246IFwiWzAtNF1cIiB9LFxuICAgICAgICAgIFwiMVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjFcIiwgZGVzY3JpcHRpb246IFwiXFxcIjFcXFwiXCIgfSxcbiAgICAgICAgICAvXlsxLTldLyxcbiAgICAgICAgICB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzEtOV1cIiwgZGVzY3JpcHRpb246IFwiWzEtOV1cIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwb3J0LmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wb3J0ID0gcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3J0OyB9LFxuICAgICAgICAgIFwidHJhbnNwb3J0PVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRyYW5zcG9ydD1cIiwgZGVzY3JpcHRpb246IFwiXFxcInRyYW5zcG9ydD1cXFwiXCIgfSxcbiAgICAgICAgICBcInVkcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVkcFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidWRwXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0Y3BcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0Y3BcIiwgZGVzY3JpcHRpb246IFwiXFxcInRjcFxcXCJcIiB9LFxuICAgICAgICAgIFwic2N0cFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNjdHBcIiwgZGVzY3JpcHRpb246IFwiXFxcInNjdHBcXFwiXCIgfSxcbiAgICAgICAgICBcInRsc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRsc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidGxzXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWyd0cmFuc3BvcnQnXSA9IHRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpOyB9LFxuICAgICAgICAgIFwidXNlcj1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1c2VyPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidXNlcj1cXFwiXCIgfSxcbiAgICAgICAgICBcInBob25lXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicGhvbmVcIiwgZGVzY3JpcHRpb246IFwiXFxcInBob25lXFxcIlwiIH0sXG4gICAgICAgICAgXCJpcFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImlwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpcFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ3VzZXInXSA9IHVzZXIudG9Mb3dlckNhc2UoKTsgfSxcbiAgICAgICAgICBcIm1ldGhvZD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtZXRob2Q9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtZXRob2Q9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydtZXRob2QnXSA9IG1ldGhvZDsgfSxcbiAgICAgICAgICBcInR0bD1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0dGw9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dGw9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odHRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEucGFyYW1zKSBvcHRpb25zLmRhdGEucGFyYW1zPXt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWyd0dGwnXSA9IHR0bDsgfSxcbiAgICAgICAgICBcIm1hZGRyPVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1hZGRyPVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibWFkZHI9XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obWFkZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKSBvcHRpb25zLmRhdGEudXJpX3BhcmFtcz17fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ21hZGRyJ10gPSBtYWRkcjsgfSxcbiAgICAgICAgICBcImxyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibHJcIiwgZGVzY3JpcHRpb246IFwiXFxcImxyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcykgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM9e307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWydsciddID0gdW5kZWZpbmVkOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHBhcmFtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1twYXJhbS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCk7fSxcbiAgICAgICAgICBmdW5jdGlvbihobmFtZSwgaHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhuYW1lID0gaG5hbWUuam9pbignJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHZhbHVlID0gaHZhbHVlLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKSBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX2hlYWRlcnNbaG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXSA9IFtodmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0ucHVzaChodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG90cyBvZiB0ZXN0cyBmYWlsIGlmIHRoaXMgaXNuJ3QgZ3VhcmRlZC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdSZWZlcl9UbycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IG9wdGlvbnMuU0lQLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCIvL1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi8vXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIvL1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZT0gdGV4dCgpOyB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlNJUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiU0lQXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc2lwX3ZlcnNpb24gPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCJJTlZJVEVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJJTlZJVEVcIiwgZGVzY3JpcHRpb246IFwiXFxcIklOVklURVxcXCJcIiB9LFxuICAgICAgICAgIFwiQUNLXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQUNLXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJBQ0tcXFwiXCIgfSxcbiAgICAgICAgICBcIlZYQUNIXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVlhBQ0hcIiwgZGVzY3JpcHRpb246IFwiXFxcIlZYQUNIXFxcIlwiIH0sXG4gICAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiT1BUSU9OU1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiT1BUSU9OU1xcXCJcIiB9LFxuICAgICAgICAgIFwiQllFXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiQllFXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJCWUVcXFwiXCIgfSxcbiAgICAgICAgICBcIkNBTkNFTFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkNBTkNFTFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiQ0FOQ0VMXFxcIlwiIH0sXG4gICAgICAgICAgXCJSRUdJU1RFUlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlJFR0lTVEVSXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJSRUdJU1RFUlxcXCJcIiB9LFxuICAgICAgICAgIFwiU1VCU0NSSUJFXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiU1VCU0NSSUJFXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJTVUJTQ1JJQkVcXFwiXCIgfSxcbiAgICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk5PVElGWVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiTk9USUZZXFxcIlwiIH0sXG4gICAgICAgICAgXCJSRUZFUlwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlJFRkVSXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJSRUZFUlxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEubWV0aG9kID0gdGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YS5tZXRob2Q7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oc3RhdHVzX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuc3RhdHVzX2NvZGUgPSBwYXJzZUludChzdGF0dXNfY29kZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlYXNvbl9waHJhc2UgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCwgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXJbaWR4XS5wYXJzZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIpIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIucHVzaCggeyAncG9zaXRpb24nOiBwZWckY3VyclBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvZmZzZXQnOiBvZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJzZWQnOiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTt9LFxuICAgICAgICAgIGZ1bmN0aW9uKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWUgPSB0ZXh0KCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5TmFtZVswXSA9PT0gJ1xcXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lLnN1YnN0cmluZygxLCBkaXNwbGF5TmFtZS5sZW5ndGgtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lOyB9LFxuICAgICAgICAgIFwicVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInFcIiwgZGVzY3JpcHRpb246IFwiXFxcInFcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWydxJ10gPSBxOyB9LFxuICAgICAgICAgIFwiZXhwaXJlc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImV4cGlyZXNcIiwgZGVzY3JpcHRpb246IFwiXFxcImV4cGlyZXNcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihleHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWydleHBpcmVzJ10gPSBleHBpcmVzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGRlbHRhX3NlY29uZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZGVsdGFfc2Vjb25kcy5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgXCIwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiMFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiMFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRleHQoKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocGFyYW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuZGF0YS5wYXJhbXMpIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1twYXJhbS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO30sXG4gICAgICAgICAgXCJyZW5kZXJcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZW5kZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlbmRlclxcXCJcIiB9LFxuICAgICAgICAgIFwic2Vzc2lvblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNlc3Npb25cIiwgZGVzY3JpcHRpb246IFwiXFxcInNlc3Npb25cXFwiXCIgfSxcbiAgICAgICAgICBcImljb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpY29uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJpY29uXFxcIlwiIH0sXG4gICAgICAgICAgXCJhbGVydFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImFsZXJ0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhbGVydFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdDb250ZW50X0Rpc3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50eXBlID0gdGV4dCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoYW5kbGluZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImhhbmRsaW5nXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJoYW5kbGluZ1xcXCJcIiB9LFxuICAgICAgICAgIFwib3B0aW9uYWxcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJvcHRpb25hbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwib3B0aW9uYWxcXFwiXCIgfSxcbiAgICAgICAgICBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVxdWlyZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlcXVpcmVkXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gcGFyc2VJbnQobGVuZ3RoLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH0sXG4gICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGV4dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGV4dFxcXCJcIiB9LFxuICAgICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpbWFnZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaW1hZ2VcXFwiXCIgfSxcbiAgICAgICAgICBcImF1ZGlvXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXVkaW9cIiwgZGVzY3JpcHRpb246IFwiXFxcImF1ZGlvXFxcIlwiIH0sXG4gICAgICAgICAgXCJ2aWRlb1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInZpZGVvXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ2aWRlb1xcXCJcIiB9LFxuICAgICAgICAgIFwiYXBwbGljYXRpb25cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXBwbGljYXRpb25cXFwiXCIgfSxcbiAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtZXNzYWdlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtZXNzYWdlXFxcIlwiIH0sXG4gICAgICAgICAgXCJtdWx0aXBhcnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtdWx0aXBhcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcIm11bHRpcGFydFxcXCJcIiB9LFxuICAgICAgICAgIFwieC1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ4LVwiLCBkZXNjcmlwdGlvbjogXCJcXFwieC1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihjc2VxX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnZhbHVlPXBhcnNlSW50KGNzZXFfdmFsdWUuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV4cGlyZXMpIHtvcHRpb25zLmRhdGEgPSBleHBpcmVzOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGV2ZW50X3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ldmVudCA9IGV2ZW50X3R5cGUudG9Mb3dlckNhc2UoKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMuZGF0YS50YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZykge29wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJyx0YWcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwidGFnXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGFnXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0YWdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0YWcpIHtvcHRpb25zLmRhdGEudGFnID0gdGFnOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGZvcndhcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gcGFyc2VJbnQoZm9yd2FyZHMuam9pbignJykpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG1pbl9leHBpcmVzKSB7b3B0aW9ucy5kYXRhID0gbWluX2V4cGlyZXM7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG9wdGlvbnMuU0lQLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkaWdlc3RcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJEaWdlc3RcIiwgZGVzY3JpcHRpb246IFwiXFxcIkRpZ2VzdFxcXCJcIiB9LFxuICAgICAgICAgIFwicmVhbG1cIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJyZWFsbVwiLCBkZXNjcmlwdGlvbjogXCJcXFwicmVhbG1cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZWFsbSkgeyBvcHRpb25zLmRhdGEucmVhbG0gPSByZWFsbTsgfSxcbiAgICAgICAgICBcImRvbWFpblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRvbWFpblwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZG9tYWluXFxcIlwiIH0sXG4gICAgICAgICAgXCJub25jZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm5vbmNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJub25jZVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKG5vbmNlKSB7IG9wdGlvbnMuZGF0YS5ub25jZT1ub25jZTsgfSxcbiAgICAgICAgICBcIm9wYXF1ZVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm9wYXF1ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwib3BhcXVlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ob3BhcXVlKSB7IG9wdGlvbnMuZGF0YS5vcGFxdWU9b3BhcXVlOyB9LFxuICAgICAgICAgIFwic3RhbGVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzdGFsZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwic3RhbGVcXFwiXCIgfSxcbiAgICAgICAgICBcInRydWVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0cnVlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0cnVlXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IG9wdGlvbnMuZGF0YS5zdGFsZT10cnVlOyB9LFxuICAgICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJmYWxzZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZmFsc2VcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgb3B0aW9ucy5kYXRhLnN0YWxlPWZhbHNlOyB9LFxuICAgICAgICAgIFwiYWxnb3JpdGhtXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYWxnb3JpdGhtXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJhbGdvcml0aG1cXFwiXCIgfSxcbiAgICAgICAgICBcIm1kNVwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk1ENVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiTUQ1XFxcIlwiIH0sXG4gICAgICAgICAgXCJtZDUtc2Vzc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIk1ENS1zZXNzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJNRDUtc2Vzc1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuYWxnb3JpdGhtPWFsZ29yaXRobS50b1VwcGVyQ2FzZSgpOyB9LFxuICAgICAgICAgIFwicW9wXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicW9wXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJxb3BcXFwiXCIgfSxcbiAgICAgICAgICBcImF1dGgtaW50XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXV0aC1pbnRcIiwgZGVzY3JpcHRpb246IFwiXFxcImF1dGgtaW50XFxcIlwiIH0sXG4gICAgICAgICAgXCJhdXRoXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiYXV0aFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYXV0aFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHFvcF92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5xb3AgfHwgKG9wdGlvbnMuZGF0YS5xb3A9W10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5xb3AucHVzaChxb3BfdmFsdWUudG9Mb3dlckNhc2UoKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24ocmFja192YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZT1wYXJzZUludChyYWNrX3ZhbHVlLmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcltpZHhdLnBhcnNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlcikgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlci5wdXNoKCB7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mZnNldCc6IG9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhcnNlZCc6IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO30sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvcHRpb25zLmRhdGEucmVwbGFjZXNfZnJvbV90YWcgJiYgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxfaWQ6IG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcImZyb20tdGFnXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZnJvbS10YWdcIiwgZGVzY3JpcHRpb246IFwiXFxcImZyb20tdGFnXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZnJvbV90YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX2Zyb21fdGFnID0gZnJvbV90YWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwidG8tdGFnXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG8tdGFnXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0by10YWdcXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbih0b190YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZyA9IHRvX3RhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlYXJseS1vbmx5XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZWFybHktb25seVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZWFybHktb25seVxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZWFybHlfb25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHIpIHtyZXR1cm4gcjt9LFxuICAgICAgICAgIGZ1bmN0aW9uKGZpcnN0LCByZXN0KSB7IHJldHVybiBsaXN0KGZpcnN0LCByZXN0KTsgfSxcbiAgICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdSZXF1aXJlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHJzZXFfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudmFsdWU9cGFyc2VJbnQocnNlcV92YWx1ZS5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgXCJhY3RpdmVcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJhY3RpdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcImFjdGl2ZVxcXCJcIiB9LFxuICAgICAgICAgIFwicGVuZGluZ1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInBlbmRpbmdcIiwgZGVzY3JpcHRpb246IFwiXFxcInBlbmRpbmdcXFwiXCIgfSxcbiAgICAgICAgICBcInRlcm1pbmF0ZWRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0ZXJtaW5hdGVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0ZXJtaW5hdGVkXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnN0YXRlID0gdGV4dCgpOyB9LFxuICAgICAgICAgIFwicmVhc29uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVhc29uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWFzb25cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYXNvbiAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuZGF0YS5yZWFzb24gPSByZWFzb247IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJlcyAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMuZGF0YS5leHBpcmVzID0gZXhwaXJlczsgfSxcbiAgICAgICAgICBcInJldHJ5X2FmdGVyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmV0cnlfYWZ0ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJldHJ5X2FmdGVyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24ocmV0cnlfYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJldHJ5X2FmdGVyICE9PSAndW5kZWZpbmVkJykgb3B0aW9ucy5kYXRhLnJldHJ5X2FmdGVyID0gcmV0cnlfYWZ0ZXI7IH0sXG4gICAgICAgICAgXCJkZWFjdGl2YXRlZFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRlYWN0aXZhdGVkXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkZWFjdGl2YXRlZFxcXCJcIiB9LFxuICAgICAgICAgIFwicHJvYmF0aW9uXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicHJvYmF0aW9uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJwcm9iYXRpb25cXFwiXCIgfSxcbiAgICAgICAgICBcInJlamVjdGVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVqZWN0ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlamVjdGVkXFxcIlwiIH0sXG4gICAgICAgICAgXCJ0aW1lb3V0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidGltZW91dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidGltZW91dFxcXCJcIiB9LFxuICAgICAgICAgIFwiZ2l2ZXVwXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZ2l2ZXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJnaXZldXBcXFwiXCIgfSxcbiAgICAgICAgICBcIm5vcmVzb3VyY2VcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJub3Jlc291cmNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJub3Jlc291cmNlXFxcIlwiIH0sXG4gICAgICAgICAgXCJpbnZhcmlhbnRcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJpbnZhcmlhbnRcIiwgZGVzY3JpcHRpb246IFwiXFxcImludmFyaWFudFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1N1cHBvcnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBvcHRpb25zLmRhdGEudGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBuZXcgb3B0aW9ucy5TSVAuTmFtZUFkZHJIZWFkZXIob3B0aW9ucy5kYXRhLnVyaSwgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lLCBvcHRpb25zLmRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZykge29wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJyx0YWcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICBcInR0bFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR0bFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHRsXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3R0bF92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudHRsID0gdmlhX3R0bF92YWx1ZTsgfSxcbiAgICAgICAgICBcIm1hZGRyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibWFkZHJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1hZGRyXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX21hZGRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tYWRkciA9IHZpYV9tYWRkcjsgfSxcbiAgICAgICAgICBcInJlY2VpdmVkXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVjZWl2ZWRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJlY2VpdmVkXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX3JlY2VpdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZWNlaXZlZCA9IHZpYV9yZWNlaXZlZDsgfSxcbiAgICAgICAgICBcImJyYW5jaFwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImJyYW5jaFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiYnJhbmNoXFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24odmlhX2JyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuYnJhbmNoID0gdmlhX2JyYW5jaDsgfSxcbiAgICAgICAgICBcInJwb3J0XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicnBvcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcInJwb3J0XFxcIlwiIH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiByZXNwb25zZV9wb3J0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucnBvcnQgPSByZXNwb25zZV9wb3J0LmpvaW4oJycpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucHJvdG9jb2wgPSB2aWFfcHJvdG9jb2w7IH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiVURQXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJVRFBcXFwiXCIgfSxcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJUQ1BcIiwgZGVzY3JpcHRpb246IFwiXFxcIlRDUFxcXCJcIiB9LFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlRMU1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiVExTXFxcIlwiIH0sXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiU0NUUFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiU0NUUFxcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV90cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHZpYV90cmFuc3BvcnQ7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpOyB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZpYV9zZW50X2J5X3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBvcnQgPSBwYXJzZUludCh2aWFfc2VudF9ieV9wb3J0LmpvaW4oJycpKTsgfSxcbiAgICAgICAgICBmdW5jdGlvbih0dGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR0bC5qb2luKCcnKSk7IH0sXG4gICAgICAgICAgZnVuY3Rpb24oZGVsdGFTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1Nlc3Npb25fRXhwaXJlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZGVsdGFTZWNvbmRzID0gZGVsdGFTZWNvbmRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVmcmVzaGVyXCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwicmVmcmVzaGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJyZWZyZXNoZXJcXFwiXCIgfSxcbiAgICAgICAgICBcInVhc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVhc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwidWFzXFxcIlwiIH0sXG4gICAgICAgICAgXCJ1YWNcIixcbiAgICAgICAgICB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1YWNcIiwgZGVzY3JpcHRpb246IFwiXFxcInVhY1xcXCJcIiB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1Nlc3Npb25fRXhwaXJlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVmcmVzaGVyID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZGVsdGFTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ01pbl9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzdHVuc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN0dW5zXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJzdHVuc1xcXCJcIiB9LFxuICAgICAgICAgIFwic3R1blwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInN0dW5cIiwgZGVzY3JpcHRpb246IFwiXFxcInN0dW5cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbihzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHNjaGVtZTsgfSxcbiAgICAgICAgICBmdW5jdGlvbihob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gaG9zdDsgfSxcbiAgICAgICAgICBcIj90cmFuc3BvcnQ9XCIsXG4gICAgICAgICAgeyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiP3RyYW5zcG9ydD1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj90cmFuc3BvcnQ9XFxcIlwiIH0sXG4gICAgICAgICAgXCJ0dXJuc1wiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR1cm5zXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0dXJuc1xcXCJcIiB9LFxuICAgICAgICAgIFwidHVyblwiLFxuICAgICAgICAgIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInR1cm5cIiwgZGVzY3JpcHRpb246IFwiXFxcInR1cm5cXFwiXCIgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0ZXh0KCk7IH1cbiAgICAgICAgXSxcblxuICAgICAgICBwZWckYnl0ZWNvZGUgPSBbXG4gICAgICAgICAgcGVnJGRlY29kZShcIi4gXFxcIlxcXCIyIDMhXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwXFxcIlxcXCJcXFwiMSEzI1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMCRcXFwiXFxcIjEhMyVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAmXFxcIlxcXCIxITMnXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3JyojIFxcXCI3KFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMChcXFwiXFxcIjEhMylcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAqXFxcIlxcXCIxITMrXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuLFxcXCJcXFwiMiwzLVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLi5cXFwiXFxcIjIuMy9cIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjAwXFxcIlxcXCIxITMxXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuMlxcXCJcXFwiMjIzMypcXHg4OSBcXFwiLjRcXFwiXFxcIjI0MzUqfSBcXFwiLjZcXFwiXFxcIjI2MzcqcSBcXFwiLjhcXFwiXFxcIjI4MzkqZSBcXFwiLjpcXFwiXFxcIjI6MzsqWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcpKiMgXFxcIjcsXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuRlxcXCJcXFwiMkYzRyp9IFxcXCIuSFxcXCJcXFwiMkgzSSpxIFxcXCIuSlxcXCJcXFwiMkozSyplIFxcXCIuTFxcXCJcXFwiMkwzTSpZIFxcXCIuTlxcXCJcXFwiMk4zTypNIFxcXCIuUFxcXCJcXFwiMlAzUSpBIFxcXCIuUlxcXCJcXFwiMlIzUyo1IFxcXCIuVFxcXCJcXFwiMlQzVSopIFxcXCIuVlxcXCJcXFwiMlYzV1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISEuWVxcXCJcXFwiMlkzWis3JDcjKy0lNyMrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhISBcXFxcNyQsIyY3JFxcXCIrLSQ3ICsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytAJCBcXFxcNyQrJiQsIyY3JFxcXCJcXFwiXFxcIiBYKyclNFxcXCI2XVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNy4qIyBcXFwiIFtcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcnKiMgXFxcIjcoLCkmNycqIyBcXFwiNyhcXFwiK0EkLjhcXFwiXFxcIjI4MzkrMSU3LysnJTQjNl4jICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISEgXFxcXDcyKyYkLCMmNzJcXFwiXFxcIlxcXCIgWCtvJCBcXFxcISBcXFxcNy4sIyY3LlxcXCIrLSQ3MisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCxAJiEgXFxcXDcuLCMmNy5cXFwiKy0kNzIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjBfXFxcIlxcXCIxITNgKiMgXFxcIjczXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwYVxcXCJcXFwiMSEzYlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiMGNcXFwiXFxcIjEhM2RcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjchKikgXFxcIjBlXFxcIlxcXCIxITNmXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3KSpcXHg5NSBcXFwiLkZcXFwiXFxcIjJGM0cqXFx4ODkgXFxcIi5KXFxcIlxcXCIySjNLKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPK1xceDlFJCxcXHg5QiY3KSpcXHg5NSBcXFwiLkZcXFwiXFxcIjJGM0cqXFx4ODkgXFxcIi5KXFxcIlxcXCIySjNLKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNykqXFx4ODkgXFxcIi5GXFxcIlxcXCIyRjNHKn0gXFxcIi5MXFxcIlxcXCIyTDNNKnEgXFxcIi5ZXFxcIlxcXCIyWTNaKmUgXFxcIi5QXFxcIlxcXCIyUDNRKlkgXFxcIi5IXFxcIlxcXCIySDNJKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5nXFxcIlxcXCIyZzNoKjUgXFxcIi5SXFxcIlxcXCIyUjNTKikgXFxcIi5OXFxcIlxcXCIyTjNPK1xceDkyJCxcXHg4RiY3KSpcXHg4OSBcXFwiLkZcXFwiXFxcIjJGM0cqfSBcXFwiLkxcXFwiXFxcIjJMM00qcSBcXFwiLllcXFwiXFxcIjJZM1oqZSBcXFwiLlBcXFwiXFxcIjJQM1EqWSBcXFwiLkhcXFwiXFxcIjJIM0kqTSBcXFwiLkBcXFwiXFxcIjJAM0EqQSBcXFwiLmdcXFwiXFxcIjJnM2gqNSBcXFwiLlJcXFwiXFxcIjJSM1MqKSBcXFwiLk5cXFwiXFxcIjJOM09cXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuVFxcXCJcXFwiMlQzVSpcXHhFMyBcXFwiLlZcXFwiXFxcIjJWM1cqXFx4RDcgXFxcIi5pXFxcIlxcXCIyaTNqKlxceENCIFxcXCIua1xcXCJcXFwiMmszbCpcXHhCRiBcXFwiLjpcXFwiXFxcIjI6MzsqXFx4QjMgXFxcIi5EXFxcIlxcXCIyRDNFKlxceEE3IFxcXCIuMlxcXCJcXFwiMjIzMypcXHg5QiBcXFwiLjhcXFwiXFxcIjI4MzkqXFx4OEYgXFxcIi5tXFxcIlxcXCIybTNuKlxceDgzIFxcXCI3Jip9IFxcXCIuNFxcXCJcXFwiMjQzNSpxIFxcXCIub1xcXCJcXFwiMm8zcCplIFxcXCIucVxcXCJcXFwiMnEzcipZIFxcXCIuNlxcXCJcXFwiMjYzNypNIFxcXCIuPlxcXCJcXFwiMj4zPypBIFxcXCIuc1xcXCJcXFwiMnMzdCo1IFxcXCIudVxcXCJcXFwiMnUzdiopIFxcXCI3JyojIFxcXCI3KFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNykqXFx1MDEyQiBcXFwiLkZcXFwiXFxcIjJGM0cqXFx1MDExRiBcXFwiLkpcXFwiXFxcIjJKM0sqXFx1MDExMyBcXFwiLkxcXFwiXFxcIjJMM00qXFx1MDEwNyBcXFwiLllcXFwiXFxcIjJZM1oqXFx4RkIgXFxcIi5QXFxcIlxcXCIyUDNRKlxceEVGIFxcXCIuSFxcXCJcXFwiMkgzSSpcXHhFMyBcXFwiLkBcXFwiXFxcIjJAM0EqXFx4RDcgXFxcIi5nXFxcIlxcXCIyZzNoKlxceENCIFxcXCIuUlxcXCJcXFwiMlIzUypcXHhCRiBcXFwiLk5cXFwiXFxcIjJOM08qXFx4QjMgXFxcIi5UXFxcIlxcXCIyVDNVKlxceEE3IFxcXCIuVlxcXCJcXFwiMlYzVypcXHg5QiBcXFwiLmlcXFwiXFxcIjJpM2oqXFx4OEYgXFxcIi5rXFxcIlxcXCIyazNsKlxceDgzIFxcXCIuOFxcXCJcXFwiMjgzOSp3IFxcXCIubVxcXCJcXFwiMm0zbiprIFxcXCI3JiplIFxcXCIuNFxcXCJcXFwiMjQzNSpZIFxcXCIub1xcXCJcXFwiMm8zcCpNIFxcXCIucVxcXCJcXFwiMnEzcipBIFxcXCIuNlxcXCJcXFwiMjYzNyo1IFxcXCIuc1xcXCJcXFwiMnMzdCopIFxcXCIudVxcXCJcXFwiMnUzditcXHUwMTM0JCxcXHUwMTMxJjcpKlxcdTAxMkIgXFxcIi5GXFxcIlxcXCIyRjNHKlxcdTAxMUYgXFxcIi5KXFxcIlxcXCIySjNLKlxcdTAxMTMgXFxcIi5MXFxcIlxcXCIyTDNNKlxcdTAxMDcgXFxcIi5ZXFxcIlxcXCIyWTNaKlxceEZCIFxcXCIuUFxcXCJcXFwiMlAzUSpcXHhFRiBcXFwiLkhcXFwiXFxcIjJIM0kqXFx4RTMgXFxcIi5AXFxcIlxcXCIyQDNBKlxceEQ3IFxcXCIuZ1xcXCJcXFwiMmczaCpcXHhDQiBcXFwiLlJcXFwiXFxcIjJSM1MqXFx4QkYgXFxcIi5OXFxcIlxcXCIyTjNPKlxceEIzIFxcXCIuVFxcXCJcXFwiMlQzVSpcXHhBNyBcXFwiLlZcXFwiXFxcIjJWM1cqXFx4OUIgXFxcIi5pXFxcIlxcXCIyaTNqKlxceDhGIFxcXCIua1xcXCJcXFwiMmszbCpcXHg4MyBcXFwiLjhcXFwiXFxcIjI4MzkqdyBcXFwiLm1cXFwiXFxcIjJtM24qayBcXFwiNyYqZSBcXFwiLjRcXFwiXFxcIjI0MzUqWSBcXFwiLm9cXFwiXFxcIjJvM3AqTSBcXFwiLnFcXFwiXFxcIjJxM3IqQSBcXFwiLjZcXFwiXFxcIjI2MzcqNSBcXFwiLnNcXFwiXFxcIjJzM3QqKSBcXFwiLnVcXFwiXFxcIjJ1M3ZcXFwiXFxcIlxcXCIgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuUFxcXCJcXFwiMlAzUSsxJTcvKyclNCM2dyMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuNFxcXCJcXFwiMjQzNSsxJTcvKyclNCM2eCMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuPlxcXCJcXFwiMj4zPysxJTcvKyclNCM2eSMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuVFxcXCJcXFwiMlQzVSsxJTcvKyclNCM2eiMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rQSQuVlxcXCJcXFwiMlYzVysxJTcvKyclNCM2eyMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLmtcXFwiXFxcIjJrM2wrMSQ3LysnJTRcXFwiNnxcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3Lys3JC5pXFxcIlxcXCIyaTNqKyclNFxcXCI2fVxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLkRcXFwiXFxcIjJEM0UrMSU3LysnJTQjNn4jICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLjJcXFwiXFxcIjIyMzMrMSU3LysnJTQjNn8jICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcvK0EkLjhcXFwiXFxcIjI4MzkrMSU3LysnJTQjNlxceDgwIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3LysxJDcmKyclNFxcXCI2XFx4ODFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3JisxJDcvKyclNFxcXCI2XFx4ODFcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3PStXJCBcXFxcN0cqKSBcXFwiN0sqIyBcXFwiN0YsLyY3RyopIFxcXCI3SyojIFxcXCI3RlxcXCIrLSU3PisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIwXFx4ODJcXFwiXFxcIjEhM1xceDgzKkEgXFxcIjBcXHg4NFxcXCJcXFwiMSEzXFx4ODUqNSBcXFwiMFxceDg2XFxcIlxcXCIxITNcXHg4NyopIFxcXCI3MyojIFxcXCI3LlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3LytVJDcmK0slIFxcXFw3SiojIFxcXCI3SywpJjdKKiMgXFxcIjdLXFxcIistJTcmKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCshICglXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNy8rYCQ3JitWJSEgXFxcXDdKKiMgXFxcIjdLLCkmN0oqIyBcXFwiN0tcXFwiKyEgKCUrMiU3JisoJTQkNlxceDg4JCEhJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcuKkcgXFxcIi5MXFxcIlxcXCIyTDNNKjsgXFxcIjBcXHg4OVxcXCJcXFwiMSEzXFx4OEEqLyBcXFwiMFxceDg2XFxcIlxcXCIxITNcXHg4NyojIFxcXCI3M1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5tXFxcIlxcXCIybTNuK0skMFxceDhCXFxcIlxcXCIxITNcXHg4Qyo1IFxcXCIwXFx4OERcXFwiXFxcIjEhM1xceDhFKikgXFxcIjBcXHg4RlxcXCJcXFwiMSEzXFx4OTArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TitRJC44XFxcIlxcXCIyODM5K0ElN08qIyBcXFwiIFsrMSU3UysnJTQkNlxceDkxJCAlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdOK2skLjhcXFwiXFxcIjI4MzkrWyU3TyojIFxcXCIgWytLJTdTK0ElN18rNyU3bCojIFxcXCIgWysnJTQmNlxceDkyJiAlJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4OTNcXFwiXFxcIjEkM1xceDk0KikgXFxcIi9cXHg5NVxcXCJcXFwiMSMzXFx4OTYrJyA0ITZcXHg5NyEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3UCtiJCEuOFxcXCJcXFwiMjgzOSstJDdSKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKzclLjpcXFwiXFxcIjI6MzsrJyU0IzZcXHg5OCMgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDcrKikgXFxcIjctKiMgXFxcIjdRKzIkLC8mNysqKSBcXFwiNy0qIyBcXFwiN1FcXFwiXFxcIlxcXCIgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLjxcXFwiXFxcIjI8Mz0qcSBcXFwiLj5cXFwiXFxcIjI+Mz8qZSBcXFwiLkBcXFwiXFxcIjJAM0EqWSBcXFwiLkJcXFwiXFxcIjJCM0MqTSBcXFwiLkRcXFwiXFxcIjJEM0UqQSBcXFwiLjJcXFwiXFxcIjIyMzMqNSBcXFwiLjZcXFwiXFxcIjI2MzcqKSBcXFwiLjRcXFwiXFxcIjI0MzVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDcrKl8gXFxcIjctKlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFLGUmNysqXyBcXFwiNy0qWSBcXFwiLjxcXFwiXFxcIjI8Mz0qTSBcXFwiLj5cXFwiXFxcIjI+Mz8qQSBcXFwiLkBcXFwiXFxcIjJAM0EqNSBcXFwiLkJcXFwiXFxcIjJCM0MqKSBcXFwiLkRcXFwiXFxcIjJEM0VcXFwiKyYgNCE2XFx4OTkhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3VCtOJCEuOFxcXCJcXFwiMjgzOSstJDdeKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1UqKSBcXFwiN1xcXFwqIyBcXFwiN1grJiA0ITZcXHg5QSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcITdWKzMkLkpcXFwiXFxcIjJKM0srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhN1YrMyQuSlxcXCJcXFwiMkozSysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrRyQ3Vys9JS5KXFxcIlxcXCIySjNLKiMgXFxcIiBbKyclNCM2XFx4OUIjICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFwwXFx4OUNcXFwiXFxcIjEhM1xceDlEKywkLCkmMFxceDlDXFxcIlxcXCIxITNcXHg5RFxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhMCRcXFwiXFxcIjEhMyUrQSQgXFxcXDBcXHg5RVxcXCJcXFwiMSEzXFx4OUYsKSYwXFx4OUVcXFwiXFxcIjEhM1xceDlGXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5vXFxcIlxcXCIybzNwK0EkN1krNyUucVxcXCJcXFwiMnEzcisnJTQjNlxceEEwIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEhN1orXFx4QkYkLjhcXFwiXFxcIjI4MzkrXFx4QUYlN1orXFx4QTUlLjhcXFwiXFxcIjI4MzkrXFx4OTUlN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJSctJSQtIyBYJCwjIFgkKyMgWCQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDgzOCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK1xceEFGJDdaK1xceEE1JS44XFxcIlxcXCIyODM5K1xceDk1JTdaK1xceDhCJS44XFxcIlxcXCIyODM5K3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnLCUkLCMgWCQrIyBYJCojIFgkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWCpcXHUwNzk1IFxcXCIhLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrXFx4OTUkN1orXFx4OEIlLjhcXFwiXFxcIjI4MzkreyU3WitxJS44XFxcIlxcXCIyODM5K2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScqJSQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDcwQyBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK3skN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDY5RCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK2EkN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScmJSQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA2NDggXFxcIiEuXFx4QTFcXFwiXFxcIjJcXHhBMTNcXHhBMitHJDdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDYwRCBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0kN1srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqXFx1MDVFQyBcXFwiIS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqXFx1MDVDQiBcXFwiITdaK1xceEE1JC5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK1xceDk1JTdaK1xceDhCJS44XFxcIlxcXCIyODM5K3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKyUkKyMgWCQqIyBYJCkjIFgkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDUzOCBcXFwiITdaK1xceEI2JCEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbK1xceDhCJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK3slN1orcSUuOFxcXCJcXFwiMjgzOSthJTdaK1clLjhcXFwiXFxcIjI4MzkrRyU3Wis9JS44XFxcIlxcXCIyODM5Ky0lN1srIyUnKiUkKiMgWCQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTA0OTQgXFxcIiE3WitcXHhDNyQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg5QyUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytxJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK2ElN1orVyUuOFxcXCJcXFwiMjgzOStHJTdaKz0lLjhcXFwiXFxcIjI4MzkrLSU3WysjJScpJSQpIyBYJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTAzREYgXFxcIiE3WitcXHhEOCQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhBRCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg4MiUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytXJS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyK0clN1orPSUuOFxcXCJcXFwiMjgzOSstJTdbKyMlJyglJCgjIFgkJyMgWCQmIyBYJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKlxcdTAzMTkgXFxcIiE3WitcXHhFOSQhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhCRSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg5MyUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytoJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKz0lLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrLSU3WysjJScnJSQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDI0MiBcXFwiITdaK1xcdTAxMTQkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4RTklIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4QkUlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx4OTMlIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsraCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWys9JS5cXHhBMVxcXCJcXFwiMlxceEExM1xceEEyKy0lN1orIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx1MDE0MCBcXFwiITdaK1xcdTAxMzUkIS44XFxcIlxcXCIyODM5Ky0kN1orIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrXFx1MDEwQSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhERiUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHhCNCUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWytcXHg4OSUhLjhcXFwiXFxcIjI4MzkrLSQ3WisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyteJSEuOFxcXCJcXFwiMjgzOSstJDdaKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKzMlLlxceEExXFxcIlxcXCIyXFx4QTEzXFx4QTIrIyUnKCUkKCMgWCQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrJiA0ITZcXHhBMyEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcjK1MkNyMqIyBcXFwiIFsrQyU3IyojIFxcXCIgWyszJTcjKiMgXFxcIiBbKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdaKz0kLjhcXFwiXFxcIjI4MzkrLSU3WisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdcXFxcXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN10rdSQuSlxcXCJcXFwiMkozSytlJTddK1slLkpcXFwiXFxcIjJKM0srSyU3XStBJS5KXFxcIlxcXCIySjNLKzElN10rJyU0JzZcXHhBNCcgJSQnIyBYJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEuXFx4QTVcXFwiXFxcIjJcXHhBNTNcXHhBNiszJDBcXHhBN1xcXCJcXFwiMSEzXFx4QTgrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqXFx4QTAgXFxcIiEuXFx4QTlcXFwiXFxcIjJcXHhBOTNcXHhBQSs9JDBcXHhBQlxcXCJcXFwiMSEzXFx4QUMrLSU3ISsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYKm8gXFxcIiEuXFx4QURcXFwiXFxcIjJcXHhBRDNcXHhBRSs3JDchKy0lNyErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCpEIFxcXCIhMFxceEFGXFxcIlxcXCIxITNcXHhCMCstJDchKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjchXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITchKiMgXFxcIiBbK2MkNyEqIyBcXFwiIFsrUyU3ISojIFxcXCIgWytDJTchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrJyA0ITZcXHhCMSEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcIS4yXFxcIlxcXCIyMjMzKy0kN2ArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjJcXFwiXFxcIjIyMzMrLSQ3YCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdhKkEgXFxcIjdiKjsgXFxcIjdjKjUgXFxcIjdkKi8gXFxcIjdlKikgXFxcIjdmKiMgXFxcIjdnXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEIyXFxcIlxcXCIxKjNcXHhCMytiJC9cXHhCNFxcXCJcXFwiMSMzXFx4QjUqRyBcXFwiL1xceEI2XFxcIlxcXCIxIzNcXHhCNyo7IFxcXCIvXFx4QjhcXFwiXFxcIjEkM1xceEI5Ki8gXFxcIi9cXHhCQVxcXCJcXFwiMSMzXFx4QkIqIyBcXFwiNzYrKCU0XFxcIjZcXHhCQ1xcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4QkRcXFwiXFxcIjElM1xceEJFK0okL1xceEJGXFxcIlxcXCIxJTNcXHhDMCovIFxcXCIvXFx4QzFcXFwiXFxcIjFcXFwiM1xceEMyKiMgXFxcIjc2KyglNFxcXCI2XFx4QzNcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEM0XFxcIlxcXCIxJzNcXHhDNSsyJDdcXHg4RisoJTRcXFwiNlxceEM2XFxcIiEgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhDN1xcXCJcXFwiMSQzXFx4QzgrMiQ3XFx4RUYrKCU0XFxcIjZcXHhDOVxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4Q0FcXFwiXFxcIjEmM1xceENCKzIkN1QrKCU0XFxcIjZcXHhDQ1xcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4Q0RcXFwiXFxcIjFcXFwiM1xceENFK1IkIS4+XFxcIlxcXCIyPjM/Ky0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHhDRlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdoK1QkIS4+XFxcIlxcXCIyPjM/Ky0kN2krIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrKSU0XFxcIjZcXHhEMFxcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3aismJCwjJjdqXFxcIlxcXCJcXFwiIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN2orJiQsIyY3alxcXCJcXFwiXFxcIiBYKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdrKikgXFxcIjcrKiMgXFxcIjctXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIub1xcXCJcXFwiMm8zcCplIFxcXCIucVxcXCJcXFwiMnEzcipZIFxcXCIuNFxcXCJcXFwiMjQzNSpNIFxcXCIuOFxcXCJcXFwiMjgzOSpBIFxcXCIuPFxcXCJcXFwiMjwzPSo1IFxcXCIuQFxcXCJcXFwiMkAzQSopIFxcXCIuQlxcXCJcXFwiMkIzQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS42XFxcIlxcXCIyNjM3K3UkN20rayUgXFxcXCEuPFxcXCJcXFwiMjwzPSstJDdtKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS48XFxcIlxcXCIyPDM9Ky0kN20rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3bitDJC4+XFxcIlxcXCIyPjM/KzMlN28rKSU0IzZcXHhEMSNcXFwiXFxcIiAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN3AqKSBcXFwiNysqIyBcXFwiNy0rMiQsLyY3cCopIFxcXCI3KyojIFxcXCI3LVxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDdwKikgXFxcIjcrKiMgXFxcIjctLC8mN3AqKSBcXFwiNysqIyBcXFwiNy1cXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIub1xcXCJcXFwiMm8zcCplIFxcXCIucVxcXCJcXFwiMnEzcipZIFxcXCIuNFxcXCJcXFwiMjQzNSpNIFxcXCIuNlxcXCJcXFwiMjYzNypBIFxcXCIuOFxcXCJcXFwiMjgzOSo1IFxcXCIuQFxcXCJcXFwiMkAzQSopIFxcXCIuQlxcXCJcXFwiMkIzQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceDkwKiMgXFxcIjdyXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDhGK0skNycrQSU3cys3JTcnKy0lN1xceDg0KyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3TSojIFxcXCI3dFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITd/K0ckLjhcXFwiXFxcIjI4MzkrNyU3dSojIFxcXCI3eCsnJTQjNlxceEQyIyAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3diojIFxcXCI3dytOJCEuNlxcXCJcXFwiMjYzNystJDdcXHg4MysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHhEM1xcXCJcXFwiMlxceEQzM1xceEQ0Kz0kN1xceDgwKzMlN3cqIyBcXFwiIFsrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS40XFxcIlxcXCIyNDM1Ky0kN3srIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3eis1JCBcXFxcN3ksIyY3eVxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcqKikgXFxcIjcrKiMgXFxcIjctXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3KypcXHg4RiBcXFwiNy0qXFx4ODkgXFxcIi4yXFxcIlxcXCIyMjMzKn0gXFxcIi42XFxcIlxcXCIyNjM3KnEgXFxcIi44XFxcIlxcXCIyODM5KmUgXFxcIi46XFxcIlxcXCIyOjM7KlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN3wrayQgXFxcXCEuNFxcXCJcXFwiMjQzNSstJDd8KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS40XFxcIlxcXCIyNDM1Ky0kN3wrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3fiwjJjd+XFxcIitrJCBcXFxcIS4yXFxcIlxcXCIyMjMzKy0kN30rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLjJcXFwiXFxcIjIyMzMrLSQ3fSsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiBcXFxcN34sIyY3flxcXCJcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjcrKncgXFxcIjctKnEgXFxcIi44XFxcIlxcXCIyODM5KmUgXFxcIi46XFxcIlxcXCIyOjM7KlkgXFxcIi48XFxcIlxcXCIyPDM9Kk0gXFxcIi4+XFxcIlxcXCIyPjM/KkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5CXFxcIlxcXCIyQjNDKikgXFxcIi5EXFxcIlxcXCIyRDNFXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcXCIrXFx4OEQkIFxcXFw3XFxcIipHIFxcXCI3ISpBIFxcXCIuQFxcXCJcXFwiMkAzQSo1IFxcXCIuRlxcXCJcXFwiMkYzRyopIFxcXCIuSlxcXCJcXFwiMkozSyxNJjdcXFwiKkcgXFxcIjchKkEgXFxcIi5AXFxcIlxcXCIyQDNBKjUgXFxcIi5GXFxcIlxcXCIyRjNHKikgXFxcIi5KXFxcIlxcXCIySjNLXFxcIisnJTRcXFwiNlxceEQ1XFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4ODEqIyBcXFwiN1xceDgyXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITdPKzMkLjpcXFwiXFxcIjI6MzsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrLSQ3UysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgW1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3KypcXHg4MyBcXFwiNy0qfSBcXFwiLkJcXFwiXFxcIjJCM0MqcSBcXFwiLkRcXFwiXFxcIjJEM0UqZSBcXFwiLjJcXFwiXFxcIjIyMzMqWSBcXFwiLjhcXFwiXFxcIjI4MzkqTSBcXFwiLjpcXFwiXFxcIjI6MzsqQSBcXFwiLjxcXFwiXFxcIjI8Mz0qNSBcXFwiLj5cXFwiXFxcIjI+Mz8qKSBcXFwiLkBcXFwiXFxcIjJAM0ErXFx4OEMkLFxceDg5JjcrKlxceDgzIFxcXCI3LSp9IFxcXCIuQlxcXCJcXFwiMkIzQypxIFxcXCIuRFxcXCJcXFwiMkQzRSplIFxcXCIuMlxcXCJcXFwiMjIzMypZIFxcXCIuOFxcXCJcXFwiMjgzOSpNIFxcXCIuOlxcXCJcXFwiMjozOypBIFxcXCIuPFxcXCJcXFwiMjwzPSo1IFxcXCIuPlxcXCJcXFwiMj4zPyopIFxcXCIuQFxcXCJcXFwiMkAzQVxcXCJcXFwiXFxcIiBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIgXFxcXDd5LCMmN3lcXFwiXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceDk1XFxcIlxcXCIxIzNcXHhENit5JC40XFxcIlxcXCIyNDM1K2klIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrUCUuSlxcXCJcXFwiMkozSytAJSBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKyclNCU2XFx4RDclICUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhEOFxcXCJcXFwiMlxceEQ4M1xceEQ5XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4REFcXFwiXFxcIjJcXHhEQTNcXHhEQlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceERDXFxcIlxcXCIyXFx4REMzXFx4RERcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhERVxcXCJcXFwiMlxceERFM1xceERGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTBcXFwiXFxcIjJcXHhFMDNcXHhFMVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEUyXFxcIlxcXCIyXFx4RTIzXFx4RTNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFNFxcXCJcXFwiMlxceEU0M1xceEU1XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuXFx4RTZcXFwiXFxcIjJcXHhFNjNcXHhFN1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiLlxceEU4XFxcIlxcXCIyXFx4RTgzXFx4RTlcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi5cXHhFQVxcXCJcXFwiMlxceEVBM1xceEVCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDg1KlMgXFxcIjdcXHg4NipNIFxcXCI3XFx4ODgqRyBcXFwiN1xceDg5KkEgXFxcIjdcXHg4QSo7IFxcXCI3XFx4OEIqNSBcXFwiN1xceDhDKi8gXFxcIjdcXHg4RCopIFxcXCI3XFx4OEUqIyBcXFwiNzYrJiA0ITZcXHhFQyEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg4NCtLJDcnK0ElN1xceDkxKzclNycrLSU3XFx4OTMrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTIrJyA0ITZcXHhFRCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3ISs3JDchKy0lNyErIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyoqQSBcXFwiNysqOyBcXFwiNy0qNSBcXFwiNzMqLyBcXFwiNzQqKSBcXFwiNycqIyBcXFwiNygsRyY3KipBIFxcXCI3Kyo7IFxcXCI3LSo1IFxcXCI3MyovIFxcXCI3NCopIFxcXCI3JyojIFxcXCI3KFxcXCIrJiA0ITZcXHhFRSEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhCNStfJCBcXFxcITdBKy0kN1xceEI1KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdBKy0kN1xceEI1KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc5K1IkIS46XFxcIlxcXCIyOjM7Ky0kNzkrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrJyU0XFxcIjZcXHhFRlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc6KmogXFxcIiE3XFx4OTcrXyQgXFxcXCE3QSstJDdcXHg5NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHg5NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrJiA0ITZcXHhGMCEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKiMgXFxcIjdcXHg5OCtjJCBcXFxcITdCKy0kN1xceDlBKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlBKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxceEYxXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDk5KiMgXFxcIiBbK0EkN0ArNyU3TSstJTc/KyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NitfJCBcXFxcITcuKy0kNzYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhNy4rLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiN0grJyA0ITZcXHhGMiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHg5QiopIFxcXCI3XFx4OUMqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEYzXFxcIlxcXCIxITNcXHhGNCs8JDc8KzIlN1xceDlFKyglNCM2XFx4RjUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx4RjZcXFwiXFxcIjEnM1xceEY3KzwkNzwrMiU3XFx4OUQrKCU0IzZcXHhGOCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx4RjkhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhLlxceEZBXFxcIlxcXCIyXFx4RkEzXFx4RkIreCQhLkpcXFwiXFxcIjJKM0srUyQ3ISojIFxcXCIgWytDJTchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyclNFxcXCI2XFx4RkNcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3NitOJCE3PCstJDdcXHhBMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWyspJTRcXFwiNlxceEZEXFxcIlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjc2KikgXFxcIjdUKiMgXFxcIjdIXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEEyK18kIFxcXFwhN0IrLSQ3XFx4QTMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4QTMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xceEZFXFxcIlxcXCIxJjNcXHhGRipHIFxcXCIvXFx1MDEwMFxcXCJcXFwiMSczXFx1MDEwMSo7IFxcXCIvXFx1MDEwMlxcXCJcXFwiMSQzXFx1MDEwMyovIFxcXCIvXFx1MDEwNFxcXCJcXFwiMSUzXFx1MDEwNSojIFxcXCI3NismIDQhNlxcdTAxMDYhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhBNCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEwN1xcXCJcXFwiMSgzXFx1MDEwOCtPJDc8K0UlL1xcdTAxMDlcXFwiXFxcIjEoM1xcdTAxMEEqLyBcXFwiL1xcdTAxMEJcXFwiXFxcIjEoM1xcdTAxMEMqIyBcXFwiNzYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K18kIFxcXFwhN0ErLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcNyErJiQsIyY3IVxcXCJcXFwiXFxcIiBYKycgNCE2XFx1MDEwRCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QTgrJiA0ITZcXHUwMTBFISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEE5K3MkNzsraSU3XFx4QUUrXyUgXFxcXCE3QistJDdcXHhBRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhBRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QUEqIyBcXFwiN1xceEFCXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIvXFx1MDEwRlxcXCJcXFwiMSQzXFx1MDExMCpTIFxcXCIvXFx1MDExMVxcXCJcXFwiMSUzXFx1MDExMipHIFxcXCIvXFx1MDExM1xcXCJcXFwiMSUzXFx1MDExNCo7IFxcXCIvXFx1MDExNVxcXCJcXFwiMSUzXFx1MDExNiovIFxcXCIvXFx1MDExN1xcXCJcXFwiMSszXFx1MDExOCojIFxcXCI3XFx4QUNcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi9cXHUwMTE5XFxcIlxcXCIxJzNcXHUwMTFBKi8gXFxcIi9cXHUwMTFCXFxcIlxcXCIxKTNcXHUwMTFDKiMgXFxcIjdcXHhBQ1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiNzYqIyBcXFwiN1xceEFEXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMURcXFwiXFxcIjFcXFwiM1xcdTAxMUUrLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEFDKiMgXFxcIjc2XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrNyQ3PCstJTdcXHhCMCsjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3NiojIFxcXCI3SFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhCMis3JDcuKy0lN1xceDhGKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxMUYhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceDlEKycgNCE2XFx1MDEyMCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4QjUrZCQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrKCU0XFxcIjZcXHUwMTIxXFxcIiEhJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NytrJCBcXFxcIS5KXFxcIlxcXCIySjNLKy0kNzcrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsPiYhLkpcXFwiXFxcIjJKM0srLSQ3NysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgrISAoJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdMKiMgXFxcIjdcXHg5OCtjJCBcXFxcITdCKy0kN1xceEI3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEI3KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxMjJcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCOCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyM1xcXCJcXFwiMSMzXFx1MDEyNCs8JDc8KzIlNzYrKCU0IzZcXHUwMTI1IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3ISsmJCwjJjchXFxcIlxcXCJcXFwiIFgrJyA0ITZcXHUwMTI2ISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5RCsnIDQhNlxcdTAxMjchISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhIFxcXFw3XFx4OTksIyY3XFx4OTlcXFwiK1xceDgxJDdAK3clN00rbSU3PytjJSBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTQlNlxcdTAxMjglICUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhCRFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTI5XFxcIlxcXCIxJjNcXHUwMTJBK3MkNy4raSU3XFx4QzArXyUgXFxcXCE3QSstJDdcXHhDMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhDMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYKiMgXFxcIjdcXHhCRVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K3MkNy4raSU3XFx4QkYrXyUgXFxcXCE3QSstJDdcXHhCRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhCRisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhNzYrPSQ3PCszJTc2KiMgXFxcIjdIKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXHhDMSpHIFxcXCI3XFx4QzMqQSBcXFwiN1xceEM1KjsgXFxcIjdcXHhDNyo1IFxcXCI3XFx4QzgqLyBcXFwiN1xceEM5KikgXFxcIjdcXHhDQSojIFxcXCI3XFx4QkZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEyQlxcXCJcXFwiMSUzXFx1MDEyQys3JDc8Ky0lN1xceEMyKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3SSsnIDQhNlxcdTAxMkQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMkVcXFwiXFxcIjEmM1xcdTAxMkYrXFx4QTUkNzwrXFx4OUIlN0QrXFx4OTElN1xceEM0K1xceDg3JSBcXFxcISBcXFxcNycrJiQsIyY3J1xcXCJcXFwiXFxcIiBYKy0kN1xceEM0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLEcmISBcXFxcNycrJiQsIyY3J1xcXCJcXFwiXFxcIiBYKy0kN1xceEM0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIistJTdFKyMlJyYlJCYjIFgkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjd0KiMgXFxcIjd3XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxMzBcXFwiXFxcIjElM1xcdTAxMzErNyQ3PCstJTdcXHhDNisjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN0krJyA0ITZcXHUwMTMyISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTMzXFxcIlxcXCIxJjNcXHUwMTM0KzwkNzwrMiU3SSsoJTQjNlxcdTAxMzUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzNlxcXCJcXFwiMSUzXFx1MDEzNytfJDc8K1UlIS9cXHUwMTM4XFxcIlxcXCIxJDNcXHUwMTM5KyYgNCE2XFx1MDEzQSEgJSo0IFxcXCIhL1xcdTAxM0JcXFwiXFxcIjElM1xcdTAxM0MrJiA0ITZcXHUwMTNEISAlKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDEzRVxcXCJcXFwiMSkzXFx1MDEzRitUJDc8K0olL1xcdTAxNDBcXFwiXFxcIjEjM1xcdTAxNDEqLyBcXFwiL1xcdTAxNDJcXFwiXFxcIjEoM1xcdTAxNDMqIyBcXFwiNzYrKCU0IzZcXHUwMTQ0IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNDVcXFwiXFxcIjEjM1xcdTAxNDYrXFx4OUUkNzwrXFx4OTQlN0QrXFx4OEElITdcXHhDQitrJCBcXFxcIS5EXFxcIlxcXCIyRDNFKy0kN1xceENCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLD4mIS5EXFxcIlxcXCIyRDNFKy0kN1xceENCKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCstJTdFKyMlJyUlJCUjIFgkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNDdcXFwiXFxcIjEoM1xcdTAxNDgqLyBcXFwiL1xcdTAxNDlcXFwiXFxcIjEkM1xcdTAxNEEqIyBcXFwiNzYrJyA0ITZcXHUwMTRCISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2K18kIFxcXFwhN0ErLSQ3NisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDc2KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhDRStLJDcuK0ElN1xceENFKzclNy4rLSU3XFx4OEYrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxNEMhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEQwK2MkIFxcXFwhN0ErLSQ3XFx4RDArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4RDArIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE0RFxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHg5OCtjJCBcXFxcITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceDlGKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxNEVcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TCpUIFxcXCI3XFx4OTgqTiBcXFwiITdAKiMgXFxcIiBbKz0kN3QrMyU3PyojIFxcXCIgWysjJScjJSQjIyBYJFxcXCIjIFhcXFwiIyBYK2MkIFxcXFwhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4OUYrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyclNFxcXCI2XFx1MDE0RlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhEMytjJCBcXFxcITdCKy0kN1xceEQ0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYLDgmITdCKy0kN1xceEQ0KyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXFxcIisnJTRcXFwiNlxcdTAxNTBcXFwiICUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTUrJiA0ITZcXHUwMTUxISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNTJcXFwiXFxcIjEoM1xcdTAxNTMrPCQ3PCsyJTc2KyglNCM2XFx1MDE1NCMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCpqIFxcXCIhL1xcdTAxNTVcXFwiXFxcIjEmM1xcdTAxNTYrPCQ3PCsyJTc2KyglNCM2XFx1MDE1NyMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCo6IFxcXCIhL1xcdTAxNThcXFwiXFxcIjEqM1xcdTAxNTkrJiA0ITZcXHUwMTVBISAlKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NitvJCBcXFxcITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWCw9JiE3QSsyJDc2KyglNFxcXCI2XFx1MDE1QlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcXFwiKyklNFxcXCI2XFx1MDE1Q1xcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKycgNCE2XFx1MDE1RCEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4RDcrXyQgXFxcXCE3QSstJDdcXHhENysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QSstJDdcXHhENysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OTgrXyQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEgXFxcXDchKyYkLCMmNyFcXFwiXFxcIlxcXCIgWCsnIDQhNlxcdTAxNUUhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceERBK18kIFxcXFwhN0IrLSQ3XFx4REIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0IrLSQ3XFx4REIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNUZcXFwiXFxcIjEmM1xcdTAxNjAqOyBcXFwiL1xcdTAxNjFcXFwiXFxcIjEnM1xcdTAxNjIqLyBcXFwiL1xcdTAxNjNcXFwiXFxcIjEqM1xcdTAxNjQqIyBcXFwiNzYrJiA0ITZcXHUwMTY1ISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxNjZcXFwiXFxcIjEmM1xcdTAxNjcrPCQ3PCsyJTdcXHhEQysoJTQjNlxcdTAxNjgjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFgqXFx4ODMgXFxcIiEvXFx4RjZcXFwiXFxcIjEnM1xceEY3KzwkNzwrMiU3XFx4OUQrKCU0IzZcXHUwMTY5IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYKlMgXFxcIiEvXFx1MDE2QVxcXCJcXFwiMSszXFx1MDE2Qis8JDc8KzIlN1xceDlEKyglNCM2XFx1MDE2QyMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWCojIFxcXCI3XFx4OUZcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIi9cXHUwMTZEXFxcIlxcXCIxKzNcXHUwMTZFKmsgXFxcIi9cXHUwMTZGXFxcIlxcXCIxKTNcXHUwMTcwKl8gXFxcIi9cXHUwMTcxXFxcIlxcXCIxKDNcXHUwMTcyKlMgXFxcIi9cXHUwMTczXFxcIlxcXCIxJzNcXHUwMTc0KkcgXFxcIi9cXHUwMTc1XFxcIlxcXCIxJjNcXHUwMTc2KjsgXFxcIi9cXHUwMTc3XFxcIlxcXCIxKjNcXHUwMTc4Ki8gXFxcIi9cXHUwMTc5XFxcIlxcXCIxKTNcXHUwMTdBKiMgXFxcIjc2XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3MSojIFxcXCIgW1wiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3NitvJCBcXFxcITdBKzIkNzYrKCU0XFxcIjZcXHUwMTVCXFxcIiEgJSRcXFwiIyBYXFxcIiMgWCw9JiE3QSsyJDc2KyglNFxcXCI2XFx1MDE1QlxcXCIhICUkXFxcIiMgWFxcXCIjIFhcXFwiKyklNFxcXCI2XFx1MDE1Q1xcXCJcXFwiISAlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKycgNCE2XFx1MDE3QiEhICVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3TCojIFxcXCI3XFx4OTgrYyQgXFxcXCE3QistJDdcXHhFMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhFMCsjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrJyU0XFxcIjZcXHUwMTdDXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QjgqIyBcXFwiN1xceDlGXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEUyK18kIFxcXFwhN0ErLSQ3XFx4RTIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgsOCYhN0ErLSQ3XFx4RTIrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEU5K3MkNy4raSU3XFx4RUMrXyUgXFxcXCE3QistJDdcXHhFMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhFMysjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrIyUnJCUkJCMgWCQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4RTQqOyBcXFwiN1xceEU1KjUgXFxcIjdcXHhFNiovIFxcXCI3XFx4RTcqKSBcXFwiN1xceEU4KiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTdEXFxcIlxcXCIxIzNcXHUwMTdFKzwkNzwrMiU3XFx4RUYrKCU0IzZcXHUwMTdGIyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODBcXFwiXFxcIjElM1xcdTAxODErPCQ3PCsyJTdUKyglNCM2XFx1MDE4MiMhICUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHUwMTgzXFxcIlxcXCIxKDNcXHUwMTg0K0IkNzwrOCU3XFxcXCojIFxcXCI3WSsoJTQjNlxcdTAxODUjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE4NlxcXCJcXFwiMSYzXFx1MDE4Nys8JDc8KzIlNzYrKCU0IzZcXHUwMTg4IyEgJSQjIyBYJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhL1xcdTAxODlcXFwiXFxcIjElM1xcdTAxOEErVCQhNzwrNSQgXFxcXDchLCMmNyFcXFwiKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyclNFxcXCI2XFx1MDE4QlxcXCIgJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhFQStLJDc7K0ElNzYrNyU3OystJTdcXHhFQisjJSclJSQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHg5NVxcXCJcXFwiMSMzXFx4RDYqIyBcXFwiNzYrJyA0ITZcXHUwMThDISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS9cXHhCNFxcXCJcXFwiMSMzXFx1MDE4RCpHIFxcXCIvXFx4QjZcXFwiXFxcIjEjM1xcdTAxOEUqOyBcXFwiL1xceEJBXFxcIlxcXCIxIzNcXHUwMThGKi8gXFxcIi9cXHhCOFxcXCJcXFwiMSQzXFx1MDE5MCojIFxcXCI3NisnIDQhNlxcdTAxOTEhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEVEK0gkITdDKy0kN1xceEVFKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYKiMgXFxcIiBbKyMlJ1xcXCIlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1UqKSBcXFwiN1xcXFwqIyBcXFwiN1grJiA0ITZcXHUwMTkyISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhITchKiMgXFxcIiBbK2MkNyEqIyBcXFwiIFsrUyU3ISojIFxcXCIgWytDJTchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnJSUkJSMgWCQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFgrJyA0ITZcXHUwMTkzISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISE3IStDJDchKiMgXFxcIiBbKzMlNyEqIyBcXFwiIFsrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWCsnIDQhNlxcdTAxOTQhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCI3XFx4QkRcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrZCQgXFxcXCE3QistJDdcXHhGMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHhGMisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrKCU0XFxcIjZcXHUwMTk1XFxcIiEhJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiN1xceEYzKiMgXFxcIjdcXHg5RlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIS5cXHUwMTk2XFxcIlxcXCIyXFx1MDE5NjNcXHUwMTk3K04kNzwrRCUuXFx1MDE5OFxcXCJcXFwiMlxcdTAxOTgzXFx1MDE5OSopIFxcXCIuXFx1MDE5QVxcXCJcXFwiMlxcdTAxOUEzXFx1MDE5QisoJTQjNlxcdTAxOUMjISAlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx4OUQrZCQgXFxcXCE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCw4JiE3QistJDdcXHg5RisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWFxcXCIrKCU0XFxcIjZcXHUwMTlEXFxcIiEhJSRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITc2KzckNzArLSU3XFx4RjYrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3MiopIFxcXCI3NCojIFxcXCI3LiwvJjcyKikgXFxcIjc0KiMgXFxcIjcuXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiIFxcXFw3JSwjJjclXFxcIlwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHhGOSs9JC44XFxcIlxcXCIyODM5Ky0lN1xceEZBKyMlJyMlJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDE5RVxcXCJcXFwiMSUzXFx1MDE5RiopIFxcXCIvXFx1MDFBMFxcXCJcXFwiMSQzXFx1MDFBMSsnIDQhNlxcdTAxQTIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEZCK04kIS44XFxcIlxcXCIyODM5Ky0kN14rIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFgqIyBcXFwiIFsrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFxcXCopIFxcXCI3WCojIFxcXCI3XFx4ODIrJyA0ITZcXHUwMUEzISEgJVwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiISBcXFxcN1xceEZEKikgXFxcIjctKiMgXFxcIjdcXHhGRSwvJjdcXHhGRCopIFxcXCI3LSojIFxcXCI3XFx4RkVcXFwiKyEgKCVcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIjdcXFwiKlMgXFxcIjchKk0gXFxcIi5GXFxcIlxcXCIyRjNHKkEgXFxcIi5KXFxcIlxcXCIySjNLKjUgXFxcIi5IXFxcIlxcXCIySDNJKikgXFxcIi5OXFxcIlxcXCIyTjNPXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIuTFxcXCJcXFwiMkwzTSpcXHg5NSBcXFwiLkJcXFwiXFxcIjJCM0MqXFx4ODkgXFxcIi48XFxcIlxcXCIyPDM9Kn0gXFxcIi5SXFxcIlxcXCIyUjNTKnEgXFxcIi5UXFxcIlxcXCIyVDNVKmUgXFxcIi5WXFxcIlxcXCIyVjNXKlkgXFxcIi5QXFxcIlxcXCIyUDNRKk0gXFxcIi5AXFxcIlxcXCIyQDNBKkEgXFxcIi5EXFxcIlxcXCIyRDNFKjUgXFxcIi4yXFxcIlxcXCIyMjMzKikgXFxcIi4+XFxcIlxcXCIyPjM/XCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDAraCQuOFxcXCJcXFwiMjgzOStYJTdcXHhGQStOJSEuXFx1MDFBNFxcXCJcXFwiMlxcdTAxQTQzXFx1MDFBNSstJDdcXHhFQisjJSdcXFwiJSRcXFwiIyBYXFxcIiMgWCojIFxcXCIgWysjJSckJSQkIyBYJCMjIFgkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiEvXFx1MDFBNlxcXCJcXFwiMSUzXFx1MDFBNyopIFxcXCIvXFx1MDFBOFxcXCJcXFwiMSQzXFx1MDFBOSsnIDQhNlxcdTAxQTIhISAlXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xceEVCK1EkL1xceEI0XFxcIlxcXCIxIzNcXHhCNSo3IFxcXCIvXFx4QjZcXFwiXFxcIjEjM1xceEI3KisgXFxcIiBcXFxcNyssIyY3K1xcXCIrJyU0XFxcIjZcXHUwMUFBXFxcIiAlJFxcXCIjIFhcXFwiIyBYXCIpLFxuICAgICAgICAgIHBlZyRkZWNvZGUoXCIhN1xcdTAxMDQrXFx4OEYkLkZcXFwiXFxcIjJGM0crfyU3XFx1MDEwMyt1JS5GXFxcIlxcXCIyRjNHK2UlN1xcdTAxMDMrWyUuRlxcXCJcXFwiMkYzRytLJTdcXHUwMTAzK0ElLkZcXFwiXFxcIjJGM0crMSU3XFx1MDEwNSsnJTQpNlxcdTAxQUIpICUkKSMgWCQoIyBYJCcjIFgkJiMgWCQlIyBYJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITcjK0EkNyMrNyU3IystJTcjKyMlJyQlJCQjIFgkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKSxcbiAgICAgICAgICBwZWckZGVjb2RlKFwiITdcXHUwMTAzKy0kN1xcdTAxMDMrIyUnXFxcIiUkXFxcIiMgWFxcXCIjIFhcIiksXG4gICAgICAgICAgcGVnJGRlY29kZShcIiE3XFx1MDEwMys3JDdcXHUwMTAzKy0lN1xcdTAxMDMrIyUnIyUkIyMgWCRcXFwiIyBYXFxcIiMgWFwiKVxuICAgICAgICBdLFxuXG4gICAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfSxcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgICBwZWckc2lsZW50RmFpbHMgICAgICA9IDAsXG5cbiAgICAgICAgcGVnJHJlc3VsdDtcblxuICAgIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVJbmRpY2VzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHBlZyRzdGFydFJ1bGVJbmRleCA9IHBlZyRzdGFydFJ1bGVJbmRpY2VzW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckcmVwb3J0ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlcG9ydGVkUG9zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykubGluZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2x1bW4oKSB7XG4gICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykuY29sdW1uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICAgIG51bGwsXG4gICAgICAgIFt7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIG51bGwsIHBlZyRyZXBvcnRlZFBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgICAgZnVuY3Rpb24gYWR2YW5jZShkZXRhaWxzLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBwLCBjaDtcblxuICAgICAgICBmb3IgKHAgPSBzdGFydFBvczsgcCA8IGVuZFBvczsgcCsrKSB7XG4gICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIWRldGFpbHMuc2VlbkNSKSB7IGRldGFpbHMubGluZSsrOyB9XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7XG4gICAgICAgIGlmIChwZWckY2FjaGVkUG9zID4gcG9zKSB7XG4gICAgICAgICAgcGVnJGNhY2hlZFBvcyA9IDA7XG4gICAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2UocGVnJGNhY2hlZFBvc0RldGFpbHMsIHBlZyRjYWNoZWRQb3MsIHBvcyk7XG4gICAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlscztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgZXhwZWN0ZWQsIHBvcykge1xuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciBpID0gMTtcblxuICAgICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYS5kZXNjcmlwdGlvbiA8IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChleHBlY3RlZFtpIC0gMV0gPT09IGV4cGVjdGVkW2ldKSB7XG4gICAgICAgICAgICBleHBlY3RlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykge1xuICAgICAgICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuXG4gICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICAgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAgICAnXFxcXFwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAgICdcXFxcdCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICAgJ1xcXFxuJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywgICAnXFxcXGYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAgICdcXFxccicpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRVxceDBGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDgwLVxceEZGXS9nLCAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMTgwLVxcdTBGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdTAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MTA4MC1cXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUnICArIGhleChjaCk7IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRGVzY3MgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcbiAgICAgICAgICAgIGV4cGVjdGVkRGVzYywgZm91bmREZXNjLCBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGV4cGVjdGVkRGVzY3NbaV0gPSBleHBlY3RlZFtpXS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdGVkRGVzYyA9IGV4cGVjdGVkLmxlbmd0aCA+IDFcbiAgICAgICAgICA/IGV4cGVjdGVkRGVzY3Muc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXVxuICAgICAgICAgIDogZXhwZWN0ZWREZXNjc1swXTtcblxuICAgICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFwiXFxcIlwiICsgc3RyaW5nRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcblxuICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkRGVzYyArIFwiIGJ1dCBcIiArIGZvdW5kRGVzYyArIFwiIGZvdW5kLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpLFxuICAgICAgICAgIGZvdW5kICAgICAgPSBwb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocG9zKSA6IG51bGw7XG5cbiAgICAgIGlmIChleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcG9zRGV0YWlscy5saW5lLFxuICAgICAgICBwb3NEZXRhaWxzLmNvbHVtblxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckZGVjb2RlKHMpIHtcbiAgICAgIHZhciBiYyA9IG5ldyBBcnJheShzLmxlbmd0aCksIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJjW2ldID0gcy5jaGFyQ29kZUF0KGkpIC0gMzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VSdWxlKGluZGV4KSB7XG4gICAgICB2YXIgYmMgICAgPSBwZWckYnl0ZWNvZGVbaW5kZXhdLFxuICAgICAgICAgIGlwICAgID0gMCxcbiAgICAgICAgICBpcHMgICA9IFtdLFxuICAgICAgICAgIGVuZCAgID0gYmMubGVuZ3RoLFxuICAgICAgICAgIGVuZHMgID0gW10sXG4gICAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgICBwYXJhbXMsIGk7XG5cbiAgICAgIGZ1bmN0aW9uIHByb3RlY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iamVjdCkgPT09IFwiW29iamVjdCBBcnJheV1cIiA/IFtdIDogb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB3aGlsZSAoaXAgPCBlbmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGJjW2lwXSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHByb3RlY3QocGVnJGNvbnN0c1tiY1tpcCArIDFdXSkpO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCAtPSBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBzdGFjay5zcGxpY2UoLTIsIDEpO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wdXNoKHN0YWNrLnBvcCgpKTtcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAxXSwgYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChpbnB1dC5zdWJzdHJpbmcoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sIHBlZyRjdXJyUG9zKSk7XG4gICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwKTtcblxuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMiArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpcCArPSAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDMgKyBiY1tpcCArIDFdICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBwZWckY29uc3RzW2JjW2lwICsgMV1dKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl0gKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0udGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgaXAgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRGQUlMRUQpO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVnJGZhaWwocGVnJGNvbnN0c1tiY1tpcCArIDFdXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBiY1tpcCArIDFdXTtcbiAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcGFyYW1zID0gYmMuc2xpY2UoaXAgKyA0LCBpcCArIDQgKyBiY1tpcCArIDNdKTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJjW2lwICsgM107IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBwYXJhbXNbaV1dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKFxuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCAtIGJjW2lwICsgMl0sXG4gICAgICAgICAgICAgICAgYmNbaXAgKyAyXSxcbiAgICAgICAgICAgICAgICBwZWckY29uc3RzW2JjW2lwICsgMV1dLmFwcGx5KG51bGwsIHBhcmFtcylcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gocGVnJHBhcnNlUnVsZShiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGNvZGU6IFwiICsgYmNbaXBdICsgXCIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbmQgPSBlbmRzLnBvcCgpO1xuICAgICAgICAgIGlwID0gaXBzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9XG5cblxuICAgICAgb3B0aW9ucy5kYXRhID0ge307IC8vIE9iamVjdCB0byB3aGljaCBoZWFkZXIgYXR0cmlidXRlcyB3aWxsIGJlIGFzc2lnbmVkIGR1cmluZyBwYXJzaW5nXG5cbiAgICAgIGZ1bmN0aW9uIGxpc3QgKGZpcnN0LCByZXN0KSB7XG4gICAgICAgIHJldHVybiBbZmlyc3RdLmNvbmNhdChyZXN0KTtcbiAgICAgIH1cblxuXG4gICAgcGVnJHJlc3VsdCA9IHBlZyRwYXJzZVJ1bGUocGVnJHN0YXJ0UnVsZUluZGV4KTtcblxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICAgIHBhcnNlOiAgICAgICBwYXJzZVxuICB9O1xufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NpcC5qcy9zcmMvR3JhbW1hci9kaXN0L0dyYW1tYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9wbGV2ZWwgPSBnbG9iYWwud2luZG93IHx8IGdsb2JhbDtcblxuZnVuY3Rpb24gZ2V0UHJlZml4ZWRQcm9wZXJ0eSAob2JqZWN0LCBuYW1lKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FwaXRhbGl6ZWROYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gIHZhciBwcmVmaXhlZE5hbWVzID0gW25hbWUsICd3ZWJraXQnICsgY2FwaXRhbGl6ZWROYW1lLCAnbW96JyArIGNhcGl0YWxpemVkTmFtZV07XG4gIGZvciAodmFyIGkgaW4gcHJlZml4ZWROYW1lcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IG9iamVjdFtwcmVmaXhlZE5hbWVzW2ldXTtcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eS5iaW5kKG9iamVjdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJTb2NrZXQ6IHRvcGxldmVsLldlYlNvY2tldCxcbiAgVHJhbnNwb3J0OiByZXF1aXJlKCcuL1RyYW5zcG9ydCcpLFxuICBvcGVuOiB0b3BsZXZlbC5vcGVuLFxuICBQcm9taXNlOiB0b3BsZXZlbC5Qcm9taXNlLFxuICB0aW1lcnM6IHRvcGxldmVsLFxuXG4gIC8vIENvbnNvbGUgaXMgbm90IGRlZmluZWQgaW4gRUNNQVNjcmlwdCwgc28ganVzdCBpbiBjYXNlLi4uXG4gIGNvbnNvbGU6IHRvcGxldmVsLmNvbnNvbGUgfHwge1xuICAgIGRlYnVnOiBmdW5jdGlvbiAoKSB7fSxcbiAgICBsb2c6IGZ1bmN0aW9uICgpIHt9LFxuICAgIHdhcm46IGZ1bmN0aW9uICgpIHt9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7fVxuICB9LFxuXG4gIE1lZGlhU3RyZWFtOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLCAnTWVkaWFTdHJlYW0nKSxcbiAgZ2V0VXNlck1lZGlhOiBnZXRQcmVmaXhlZFByb3BlcnR5KHRvcGxldmVsLm5hdmlnYXRvciwgJ2dldFVzZXJNZWRpYScpLFxuICBSVENQZWVyQ29ubmVjdGlvbjogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ1JUQ1BlZXJDb25uZWN0aW9uJyksXG4gIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogZ2V0UHJlZml4ZWRQcm9wZXJ0eSh0b3BsZXZlbCwgJ1JUQ1Nlc3Npb25EZXNjcmlwdGlvbicpLFxuXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGdldFByZWZpeGVkUHJvcGVydHkodG9wbGV2ZWwsICdhZGRFdmVudExpc3RlbmVyJyksXG4gIEhUTUxNZWRpYUVsZW1lbnQ6IHRvcGxldmVsLkhUTUxNZWRpYUVsZW1lbnQsXG5cbiAgYXR0YWNoTWVkaWFTdHJlYW06IHRvcGxldmVsLmF0dGFjaE1lZGlhU3RyZWFtLFxuICBjcmVhdGVPYmplY3RVUkw6IHRvcGxldmVsLlVSTCAmJiB0b3BsZXZlbC5VUkwuY3JlYXRlT2JqZWN0VVJMLFxuICByZXZva2VPYmplY3RVUkw6IHRvcGxldmVsLlVSTCAmJiB0b3BsZXZlbC5VUkwucmV2b2tlT2JqZWN0VVJMXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2lwLmpzL3NyYy9lbnZpcm9ubWVudF9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBUcmFuc3BvcnRcbiAqL1xuXG4vKipcbiAqIEBhdWdtZW50cyBTSVBcbiAqIEBjbGFzcyBUcmFuc3BvcnRcbiAqIEBwYXJhbSB7U0lQLlVBfSB1YVxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZlciB3c19zZXJ2ZXIgT2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFNJUCwgV2ViU29ja2V0KSB7XG52YXIgVHJhbnNwb3J0LFxuICBDID0ge1xuICAgIC8vIFRyYW5zcG9ydCBzdGF0dXMgY29kZXNcbiAgICBTVEFUVVNfUkVBRFk6ICAgICAgICAwLFxuICAgIFNUQVRVU19ESVNDT05ORUNURUQ6IDEsXG4gICAgU1RBVFVTX0VSUk9SOiAgICAgICAgMlxuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzZW5kaW5nIGFub3RoZXJcbiAqIGtlZXAtYWxpdmUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb21wdXRlS2VlcEFsaXZlVGltZW91dCh1cHBlckJvdW5kKSB7XG4gIHZhciBsb3dlckJvdW5kID0gdXBwZXJCb3VuZCAqIDAuODtcbiAgcmV0dXJuIDEwMDAgKiAoTWF0aC5yYW5kb20oKSAqICh1cHBlckJvdW5kIC0gbG93ZXJCb3VuZCkgKyBsb3dlckJvdW5kKTtcbn1cblxuVHJhbnNwb3J0ID0gZnVuY3Rpb24odWEsIHNlcnZlcikge1xuXG4gIHRoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKCdzaXAudHJhbnNwb3J0Jyk7XG4gIHRoaXMudWEgPSB1YTtcbiAgdGhpcy53cyA9IG51bGw7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA9IDA7XG4gIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvciA9IHt9O1xuXG4gIHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgPSB1YS5jb25maWd1cmF0aW9uLmtlZXBBbGl2ZUludGVydmFsO1xuICB0aGlzLmtlZXBBbGl2ZVRpbWVvdXQgPSBudWxsO1xuICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gbnVsbDtcblxuICB0aGlzLnVhLnRyYW5zcG9ydCA9IHRoaXM7XG5cbiAgLy8gQ29ubmVjdFxuICB0aGlzLmNvbm5lY3QoKTtcbn07XG5cblRyYW5zcG9ydC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTSVAuT3V0Z29pbmdSZXF1ZXN0fFN0cmluZ30gbXNnXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBtc2cudG9TdHJpbmcoKTtcblxuICAgIGlmKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3NlbmRpbmcgV2ViU29ja2V0IG1lc3NhZ2U6XFxuXFxuJyArIG1lc3NhZ2UgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLndzLnNlbmQobWVzc2FnZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIud2FybigndW5hYmxlIHRvIHNlbmQgbWVzc2FnZSwgV2ViU29ja2V0IGlzIG5vdCBvcGVuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIGEga2VlcC1hbGl2ZSAoYSBkb3VibGUtQ1JMRiBzZXF1ZW5jZSkuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgc2VuZEtlZXBBbGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5rZWVwQWxpdmVUaW1lb3V0KSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy51YS5lbWl0KCdrZWVwQWxpdmVUaW1lb3V0Jyk7XG4gICAgfS5iaW5kKHRoaXMpLCAxMDAwMCk7XG5cbiAgICByZXR1cm4gdGhpcy5zZW5kKCdcXHJcXG5cXHJcXG4nKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgc2VuZGluZyBrZWVwLWFsaXZlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmtlZXBBbGl2ZUludGVydmFsICYmICF0aGlzLmtlZXBBbGl2ZVRpbWVyKSB7XG4gICAgICB0aGlzLmtlZXBBbGl2ZVRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbmRLZWVwQWxpdmUoKTtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnRTZW5kaW5nS2VlcEFsaXZlcygpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBjb21wdXRlS2VlcEFsaXZlVGltZW91dCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9wIHNlbmRpbmcga2VlcC1hbGl2ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdG9wU2VuZGluZ0tlZXBBbGl2ZXM6IGZ1bmN0aW9uKCkge1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlVGltZXIpO1xuICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMua2VlcEFsaXZlVGltZW91dCk7XG4gICAgdGhpcy5rZWVwQWxpdmVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5rZWVwQWxpdmVUaW1lb3V0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgKiBEaXNjb25uZWN0IHNvY2tldC5cbiAgKi9cbiAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy53cykge1xuICAgICAgLy8gQ2xlYXIgcmVjb25uZWN0VGltZXJcbiAgICAgIFNJUC5UaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuXG4gICAgICB0aGlzLnN0b3BTZW5kaW5nS2VlcEFsaXZlcygpO1xuXG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ2Nsb3NpbmcgV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkpO1xuICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICBTSVAuVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy51YS5lbWl0KCdkaXNjb25uZWN0ZWQnLCB7XG4gICAgICAgIHRyYW5zcG9ydDogdGhpcyxcbiAgICAgICAgY29kZTogdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IuY29kZSxcbiAgICAgICAgcmVhc29uOiB0aGlzLmxhc3RUcmFuc3BvcnRFcnJvci5yZWFzb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBDb25uZWN0IHNvY2tldC5cbiAgKi9cbiAgY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zcG9ydCA9IHRoaXM7XG5cbiAgICBpZih0aGlzLndzICYmICh0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOIHx8IHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ1dlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpICsgJyBpcyBhbHJlYWR5IGNvbm5lY3RlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHRoaXMud3MpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coJ2Nvbm5lY3RpbmcgdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkpO1xuICAgIHRoaXMudWEub25UcmFuc3BvcnRDb25uZWN0aW5nKHRoaXMsXG4gICAgICAodGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPT09IDApPzE6dGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMuc2VydmVyLndzX3VyaSwgJ3NpcCcpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignZXJyb3IgY29ubmVjdGluZyB0byBXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICc6ICcgKyBlKTtcbiAgICB9XG5cbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyYW5zcG9ydC5vbk9wZW4oKTtcbiAgICB9O1xuXG4gICAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgICAgdHJhbnNwb3J0Lm9uQ2xvc2UoZSk7XG4gICAgfTtcblxuICAgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgdHJhbnNwb3J0Lm9uTWVzc2FnZShlKTtcbiAgICB9O1xuXG4gICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgdHJhbnNwb3J0Lm9uRXJyb3IoZSk7XG4gICAgfTtcbiAgfSxcblxuICAvLyBUcmFuc3BvcnQgRXZlbnQgSGFuZGxlcnNcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKCdXZWJTb2NrZXQgJyArIHRoaXMuc2VydmVyLndzX3VyaSArICcgY29ubmVjdGVkJyk7XG4gICAgLy8gQ2xlYXIgcmVjb25uZWN0VGltZXIgc2luY2Ugd2UgYXJlIG5vdCBkaXNjb25uZWN0ZWRcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLy8gUmVzZXQgcmVjb25uZWN0aW9uX2F0dGVtcHRzXG4gICAgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgPSAwO1xuICAgIC8vIERpc2FibGUgY2xvc2VkXG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAvLyBUcmlnZ2VyIG9uVHJhbnNwb3J0Q29ubmVjdGVkIGNhbGxiYWNrXG4gICAgdGhpcy51YS5vblRyYW5zcG9ydENvbm5lY3RlZCh0aGlzKTtcbiAgICAvLyBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzXG4gICAgdGhpcy5zdGFydFNlbmRpbmdLZWVwQWxpdmVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICogQGV2ZW50XG4gICogQHBhcmFtIHtldmVudH0gZVxuICAqL1xuICBvbkNsb3NlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNvbm5lY3RlZF9iZWZvcmUgPSB0aGlzLmNvbm5lY3RlZDtcblxuICAgIHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLmNvZGUgPSBlLmNvZGU7XG4gICAgdGhpcy5sYXN0VHJhbnNwb3J0RXJyb3IucmVhc29uID0gZS5yZWFzb247XG5cbiAgICB0aGlzLnN0b3BTZW5kaW5nS2VlcEFsaXZlcygpO1xuXG4gICAgaWYgKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID4gMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCAnICsgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgKyAnIGZhaWxlZCAoY29kZTogJyArIGUuY29kZSArIChlLnJlYXNvbj8gJ3wgcmVhc29uOiAnICsgZS5yZWFzb24gOiAnJykgKycpJyk7XG4gICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkIChjb2RlOiAnICsgZS5jb2RlICsgKGUucmVhc29uPyAnfCByZWFzb246ICcgKyBlLnJlYXNvbiA6ICcnKSArJyknKTtcblxuICAgICAgaWYoZS53YXNDbGVhbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybignV2ViU29ja2V0IGFicnVwdCBkaXNjb25uZWN0aW9uJyk7XG4gICAgICB9XG4gICAgICAvLyBUcmFuc3BvcnQgd2FzIGNvbm5lY3RlZFxuICAgICAgaWYoY29ubmVjdGVkX2JlZm9yZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVhLm9uVHJhbnNwb3J0Q2xvc2VkKHRoaXMpO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIHJlcXVlc3RlZCB0byBjbG9zZS5cbiAgICAgICAgaWYoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVhLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydDogdGhpcyxcbiAgICAgICAgICAgIGNvZGU6IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLmNvZGUsXG4gICAgICAgICAgICByZWFzb246IHRoaXMubGFzdFRyYW5zcG9ydEVycm9yLnJlYXNvblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAgICAvL05ldHdvcmsgZXJyb3JcbiAgICAgICAgdGhpcy51YS5vblRyYW5zcG9ydEVycm9yKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAZXZlbnRcbiAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICovXG4gIG9uTWVzc2FnZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciBtZXNzYWdlLCB0cmFuc2FjdGlvbixcbiAgICAgIGRhdGEgPSBlLmRhdGE7XG5cbiAgICAvLyBDUkxGIEtlZXAgQWxpdmUgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuIElnbm9yZSBpdC5cbiAgICBpZihkYXRhID09PSAnXFxyXFxuJykge1xuICAgICAgU0lQLlRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVUaW1lb3V0KTtcbiAgICAgIHRoaXMua2VlcEFsaXZlVGltZW91dCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnVhLmNvbmZpZ3VyYXRpb24udHJhY2VTaXAgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdyZWNlaXZlZCBXZWJTb2NrZXQgbWVzc2FnZSB3aXRoIENSTEYgS2VlcCBBbGl2ZSByZXNwb25zZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgfSBjYXRjaChldnQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybigncmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlIGZhaWxlZCB0byBiZSBjb252ZXJ0ZWQgaW50byBzdHJpbmcsIG1lc3NhZ2UgZGlzY2FyZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY2VpdmVkIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZTpcXG5cXG4nICsgZGF0YSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZWJTb2NrZXQgdGV4dCBtZXNzYWdlLlxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMudWEuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3JlY2VpdmVkIFdlYlNvY2tldCB0ZXh0IG1lc3NhZ2U6XFxuXFxuJyArIGRhdGEgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IFNJUC5QYXJzZXIucGFyc2VNZXNzYWdlKGRhdGEsIHRoaXMudWEpO1xuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYodGhpcy51YS5zdGF0dXMgPT09IFNJUC5VQS5DLlNUQVRVU19VU0VSX0NMT1NFRCAmJiBtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvIHNvbWUgc2FuaXR5IGNoZWNrXG4gICAgaWYoU0lQLnNhbml0eUNoZWNrKG1lc3NhZ2UsIHRoaXMudWEsIHRoaXMpKSB7XG4gICAgICBpZihtZXNzYWdlIGluc3RhbmNlb2YgU0lQLkluY29taW5nUmVxdWVzdCkge1xuICAgICAgICBtZXNzYWdlLnRyYW5zcG9ydCA9IHRoaXM7XG4gICAgICAgIHRoaXMudWEucmVjZWl2ZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYobWVzc2FnZSBpbnN0YW5jZW9mIFNJUC5JbmNvbWluZ1Jlc3BvbnNlKSB7XG4gICAgICAgIC8qIFVuaWtlIHN0YXRlZCBpbiAxOC4xLjIsIGlmIGEgcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgKiBhbnkgdHJhbnNhY3Rpb24sIGl0IGlzIGRpc2NhcmRlZCBoZXJlIGFuZCBubyBwYXNzZWQgdG8gdGhlIGNvcmVcbiAgICAgICAgKiBpbiBvcmRlciB0byBiZSBkaXNjYXJkZWQgdGhlcmUuXG4gICAgICAgICovXG4gICAgICAgIHN3aXRjaChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgIGNhc2UgU0lQLkMuSU5WSVRFOlxuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0aGlzLnVhLnRyYW5zYWN0aW9ucy5pY3RbbWVzc2FnZS52aWFfYnJhbmNoXTtcbiAgICAgICAgICAgIGlmKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU0lQLkMuQUNLOlxuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlIDstKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy51YS50cmFuc2FjdGlvbnMubmljdFttZXNzYWdlLnZpYV9icmFuY2hdO1xuICAgICAgICAgICAgaWYodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQGV2ZW50XG4gICogQHBhcmFtIHtldmVudH0gZVxuICAqL1xuICBvbkVycm9yOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybignV2ViU29ja2V0IGNvbm5lY3Rpb24gZXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICogUmVjb25uZWN0aW9uIGF0dGVtcHQgbG9naWMuXG4gICogQHByaXZhdGVcbiAgKi9cbiAgcmVjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcztcblxuICAgIHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzICs9IDE7XG5cbiAgICBpZih0aGlzLnJlY29ubmVjdGlvbl9hdHRlbXB0cyA+IHRoaXMudWEuY29uZmlndXJhdGlvbi53c1NlcnZlck1heFJlY29ubmVjdGlvbikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignbWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgZm9yIFdlYlNvY2tldCAnICsgdGhpcy5zZXJ2ZXIud3NfdXJpKTtcbiAgICAgIHRoaXMudWEub25UcmFuc3BvcnRFcnJvcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVjb25uZWN0aW9uX2F0dGVtcHRzID09PSAxKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ0Nvbm5lY3Rpb24gdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIHNldmVyZWQsIGF0dGVtcHRpbmcgZmlyc3QgcmVjb25uZWN0Jyk7XG4gICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ3RyeWluZyB0byByZWNvbm5lY3QgdG8gV2ViU29ja2V0ICcgKyB0aGlzLnNlcnZlci53c191cmkgKyAnIChyZWNvbm5lY3Rpb24gYXR0ZW1wdCAnICsgdGhpcy5yZWNvbm5lY3Rpb25fYXR0ZW1wdHMgKyAnKScpO1xuXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gU0lQLlRpbWVycy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgICAgICB0cmFuc3BvcnQucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgfSwgdGhpcy51YS5jb25maWd1cmF0aW9uLndzU2VydmVyUmVjb25uZWN0aW9uVGltZW91dCAqIDEwMDApO1xuICAgIH1cbiAgfVxufTtcblxuVHJhbnNwb3J0LkMgPSBDO1xucmV0dXJuIFRyYW5zcG9ydDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaXAuanMvc3JjL1RyYW5zcG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==